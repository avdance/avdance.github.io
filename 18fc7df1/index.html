<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.1"><link rel="icon" type="image/png" sizes="32x32" href="/images/avdance32_32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/avdance16_16.ico"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"blog.avdancedu.com",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!0,pangu:!1,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!1,nav:null,activeClass:"valine"},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="随着浏览器的发展，JS（JavaScript) 越来越受到人们的欢迎。它不再像以前只能做单一的渲染页面这样的事情了，在Chrome等现代浏览器上，你甚至可以用JS来做音视频的处理，是不是觉得很神奇？ 不过今天我要讨论的并不是如何使用JS来做一些神奇的事儿，而是来重新认识一下JS中类的使用。对于这部分知识的理解，将为我们后面阅读Janus(一款WebRTC流媒体服务器)代码有着至关重要的作用。"><meta property="og:type" content="article"><meta property="og:title" content="js类的探究"><meta property="og:url" content="https://blog.avdancedu.com/18fc7df1/index.html"><meta property="og:site_name" content="音视跳动科技"><meta property="og:description" content="随着浏览器的发展，JS（JavaScript) 越来越受到人们的欢迎。它不再像以前只能做单一的渲染页面这样的事情了，在Chrome等现代浏览器上，你甚至可以用JS来做音视频的处理，是不是觉得很神奇？ 不过今天我要讨论的并不是如何使用JS来做一些神奇的事儿，而是来重新认识一下JS中类的使用。对于这部分知识的理解，将为我们后面阅读Janus(一款WebRTC流媒体服务器)代码有着至关重要的作用。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.avdancedu.com/image/article/js/javascript.png"><meta property="og:image" content="https://cdn.avdancedu.com/image/article/js/prototype.jpg"><meta property="og:image" content="https://cdn.avdancedu.com/image/article/js/js_obj.jpg"><meta property="og:image" content="https://cdn.avdancedu.com/image/article/js/js_extend.jpg"><meta property="article:published_time" content="2020-06-10T07:38:47.000Z"><meta property="article:modified_time" content="2020-06-28T16:49:16.690Z"><meta property="article:author" content="音视跳动"><meta property="article:tag" content="js"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.avdancedu.com/image/article/js/javascript.png"><link rel="canonical" href="https://blog.avdancedu.com/18fc7df1/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>js类的探究 | 音视跳动科技</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="音视跳动科技" type="application/atom+xml"></head><body itemscope itemtype="https://schema.org/WebPage"><div class="container"><div class="headband"></div><div id="needsharebutton-float"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div><header class="header" itemscope itemtype="https://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">音视跳动科技</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">传播最前沿的科技知识！</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i> 关于</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div> <a href="https://github.com/avdance" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="https://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.avdancedu.com/18fc7df1/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="image" content="/images/avdancelogo.jpg"><meta itemprop="name" content="音视跳动"><meta itemprop="description" content="传输最前沿的科技知识，学习音视频的圣地！ffmpeg, webrtc, H264, AAC"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="音视跳动科技"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> js类的探究</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-06-10 15:38:47" itemprop="dateCreated datePublished" datetime="2020-06-10T15:38:47+08:00">2020-06-10</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-06-29 00:49:16" itemprop="dateModified" datetime="2020-06-29T00:49:16+08:00">2020-06-29</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></span><span id="/18fc7df1/" class="post-meta-item leancloud_visitors" data-flag-title="js类的探究" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/18fc7df1/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/18fc7df1/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>6.2k</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img data-src="https://cdn.avdancedu.com/image/article/js/javascript.png" alt="javascript"></p><p>随着浏览器的发展，JS（JavaScript) 越来越受到人们的欢迎。它不再像以前只能做单一的渲染页面这样的事情了，在Chrome等现代浏览器上，你甚至可以用JS来做音视频的处理，是不是觉得很神奇？</p><p>不过今天我要讨论的并不是如何使用JS来做一些<strong>神奇</strong>的事儿，而是来重新认识一下JS中<strong>类</strong>的使用。对于这部分知识的理解，将为我们后面阅读Janus(一款WebRTC流媒体服务器)代码有着至关重要的作用。</p><a id="more"></a><h2 id="JS中的function"><a href="#JS中的function" class="headerlink" title="JS中的function"></a>JS中的function</h2><p>在ES5以前，JS中并没有<strong>class</strong>关键字，那时候JS是如何表示一个类的呢？说来也奇怪，它使用<strong>function</strong>来表示。</p><p>我在了解这部分知识的时候也是觉得不可思意！实际上我早在2003年的时候就学习并使用JS了，那时候JS还很简单。虽然后来很久没有再碰过它，但印象中<strong>function</strong>一直是用来定义一个函数的，现在怎么又用来定义<strong>类</strong>了呢？</p><p>后来看了一些资料才逐渐理清，原来现在的JS中<code>function</code>既可以用来定义函数，也可以用来定义类。有点类似于语文中的<strong>一语双关</strong>。</p><p>之所以<code>function</code>有双层含义，是因为JS最开始并不支持面向对象开发模式。但随着技术的发展，面向对象的开发模式越来越受到人们的欢迎，JS为了能跟上时代，所以也必须支持面向对象开发。</p><p>不过JS在转向面向对象语言时面临一种选择，即从原生语言上支持<code>class</code>，那JS解析器就要做大的调整，这可不是一时半会儿可以完成的。而如果在原有的基础上修改则要容易得多。</p><p>权衡利弊之后，JS<code>大神</code>们还是决定在现有的基础上修改是最省时少力的。于是就借用了<code>function</code>函数，把它看作是一个<strong>构造函数</strong>，这样就可以快速的将JS改造成面向对象的开发语言了。</p><p>以上就是JS中使用<code>function</code>定义类的大致由头！下面我们就来看看在ES5上该如何定义一个<strong>类</strong>。</p><h2 id="类及成员"><a href="#类及成员" class="headerlink" title="类及成员"></a>类及成员</h2><p>在JS中如何定义一个类呢？实际上它与其它面向对象语言(如Java)是很类似的，只不过在Java中定义类用的是<code>class</code>关键字，而在JS中用<code>function</code>代替而以。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function classname() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 中，类的成员按安全性可以分为<strong>公有</strong>和<strong>私有</strong>，JS中是否也有类似的概念呢？答案是肯定的，接下来我们就来看一下在JS类中如何定义公有成员和私有成员吧。</p><p>JS中公有成员和私有成员的定义都是隐式的，不像Java有明确的<code>public</code>和<code>private</code>关键字来指明它们的权限。在JS类中直接定义的函数或变量都是私有成员，在类成员或函数前面加<code>this</code>关键字的，则表式是公有成员。</p><p>我们来看个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function myclass ()&#123;</span><br><span class="line"></span><br><span class="line">    function test()&#123;</span><br><span class="line">        console.log(&quot;testA function&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; new myclass();</span><br><span class="line">obj.test();</span><br></pre></td></tr></table></figure><p>如果我们在浏览器执行上面的代码，在浏览器的<code>debugger</code>中你一定可以看到这样一条错误信息<code>“Uncaught TypeError: obj.testfunc is not a function”</code>，这说明通过<code>obj</code>对像是无法访问到<code>test()</code>函数的。</p><p>我们稍微调整一下这段代码，修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function myclass ()&#123;</span><br><span class="line"></span><br><span class="line">    this.test &#x3D; test() &#123; &#x2F;&#x2F;这里加了this 关键字</span><br><span class="line">        console.log(&quot;testA function&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; new myclass();</span><br><span class="line">obj.test();</span><br></pre></td></tr></table></figure><p>我们在<code>test</code>函数前加上<code>this.</code>，只做这一点点修改，这段代码就可以在浏览器上成功运行了。</p><p>由此我们可以知道，如果你想让外面访问对象中的成员（成员变量或成员方法），你就应该在这些成员前面加上<code>this</code>关键字。反过来讲，如果你不想让外面访问到对象中的成员，则不要在这些成员前面加<code>this</code>。</p><h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><p>在Java中除了有对象成员外，还可以有类成员，比如在使用单例模式时，我们都会定义一个静态的成员。在JS中如何做到这点呢？我们来看个具体例子吧。还是刚才那个代码，我们在其基础上稍做修改即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义类方法</span><br><span class="line">myclass.init &#x3D; function()&#123; </span><br><span class="line">    console.log(&quot;class method!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function myclass ()&#123;</span><br><span class="line"></span><br><span class="line">    this.test &#x3D; test() &#123; &#x2F;&#x2F;这里加了this 关键字</span><br><span class="line">        console.log(&quot;testA function&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用类方法</span><br><span class="line">myclass.init();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建对象</span><br><span class="line">var obj &#x3D; new myclass();</span><br><span class="line">obj.test();</span><br></pre></td></tr></table></figure><p>在这段代码中，加入了类方法的定义及调用类方法的代码。从上述代码中我们可以知道，在JS中类方法是在类之外定义的，而不像Java在是类内加<code>static</code>关键字。</p><h2 id="类的原型prototype"><a href="#类的原型prototype" class="headerlink" title="类的原型prototype"></a>类的原型prototype</h2><p>在JS中，每个类都有一个类属性<code>prototype</code>，用来指向类原型。或者你可以把它理解为指向<strong>类原型的地址</strong>。当我们想为这个类添加方法或成员变量的时候，就可以通过prototype来实现，只需修改prototype指向的内存地址的内容就可以达到添加成员的目的。</p><p>举个例子，假设我们定义了一个类如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function myjs()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前在这个类中没有写任何方法或成员变量，只是定义了一个空类。下面我想修改这个类，给这个类增加一些内容，该怎么做呢？实现的方法很简单，修改prototype即可，看下面的例子你就明白了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function myjs()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myjs.prototype.a  &#x3D; 5;</span><br><span class="line">myjs.prototype.test &#x3D; function() &#123;</span><br><span class="line">    console.log(&quot;this is a function of myjs object!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; new myjs();</span><br><span class="line">console.log(&quot;myjs.a &#x3D;&#x3D; &quot; + obj.a );</span><br><span class="line">obj.test();</span><br></pre></td></tr></table></figure><p>通过上面的代码，我们就给<code>myjs</code>类增加了两个成员，即一个变量<code>a</code>和一个方法<code>test</code>。当我们生成myjs对象时，生成的对象中就有我们之前添加的成员变量和成员方法了。</p><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>JS中没有专门用于类继承的语法，不过你可以通过上一节介绍的prototype来实现<code>类继承</code>。在我们正式讲解继承之前，我们先了解一下prototype在内存中是如何表示的。如下图所示：<br><img data-src="https://cdn.avdancedu.com/image/article/js/prototype.jpg" alt="prototype"></p><p>通过上图我们可以看到，使用<code>function</code>定义的类并非真实的<code>类</code>，更准确的说它应该是一个<code>构造函数</code>。而类属性<code>prototype</code>指向的才是类的真正地址。</p><p>可能很多同学会问JS是如何通过构造函数找到它所在的类的呢？其实这是C语言的一个小巧，其过程是JS调用浏览器，通过浏览器使用C语言中的<code>技巧</code>获取构造函数所在类的地址，这对于浏览器来当然是小菜一碟。</p><p>了解了<code>prototype</code>的物理意义后，接下来我们看看类生成的对象在内存中的情况，它与prototype之间的关系又是怎样的？如下图所示。<br><img data-src="https://cdn.avdancedu.com/image/article/js/js_obj.jpg" alt="对象在内存中"></p><p>通过上图我们可以看到，JS在创建对象时会为每个对象分配内存空间。更为重要的一点是，多个相同类型的<code>对象</code>会指向同一个prototype。</p><p>了解了上面的特性后，我们就可以利用<code>prototype</code>来实现类的继承了。如何来做呢？我们再来举个例子。</p><p>首先，我们定义一个基类，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function parent() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;给基类添加一个新的属性 a</span><br><span class="line">parent.prototype.a &#x3D; 1;</span><br></pre></td></tr></table></figure><p>然后，我们创建一个子类，并让子类的prototype指向父类，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function child() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">child.prototype &#x3D; new parent();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;再给子类添加一个属性 b</span><br><span class="line">child.prototype.b &#x3D; 2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建子类</span><br><span class="line">var obj_child &#x3D; new child();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;访问子类的属性</span><br><span class="line">console.log(&quot;a &#x3D; &quot; + obj_child.a);</span><br><span class="line">console.log(&quot;b &#x3D; &quot; + obj_child.b);</span><br></pre></td></tr></table></figure><p>执行上面的例子，我们通过浏览器的<code>debugger</code>就可以看到如下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 1</span><br><span class="line">b &#x3D; 2</span><br></pre></td></tr></table></figure><p>说明child子类确实是继承了parent类。我们再深扒一下，对于上面这段代码表示的继承关系在内存中的物理意义是什么呢？如下图所示：</p><p><img data-src="https://cdn.avdancedu.com/image/article/js/js_extend.jpg" alt="js继承"></p><p>在JS中，正常情况下每生成一个对象，该对象的 <code>__proto__</code> 都指向该对象的<strong>原始类的地址</strong>。如上图所示parent对象的<code>__proto__</code>指向parent.prototype，child对象的<code>__proto__</code>指向child.prototype。</p><p>为什么会这样呢？要理解其中的奥秘，我们必须要知道JS中 <code>new xxx</code> 做了哪些事儿。实际上，<code>new xxx</code> 做了四件事儿，我们以上图中的<code>new parent()</code>为例，它做的四件事儿如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line">obj.__proto__ &#x3D; parent.prototype; &#x2F;&#x2F;即parent</span><br><span class="line">parent.call(obj);                 &#x2F;&#x2F;调用parent的构造函数</span><br><span class="line">return obj;</span><br></pre></td></tr></table></figure><p>在这步中，第二步是最关键的，它表明了新对象的<code>__proto__</code>指向了哪里。这样我们就可以理解 <strong>“对象的 <code>__proto__</code> 都指向该对象的原始类的地址”</strong> 这句话了。</p><p>当我们理解了 <code>new xxx</code> 的真实含义之后，<code>child.prototype = new parent()</code> 这句代码的含义立马就清楚了，它的含义是改变 <code>child.prototype</code> 的指向， 让他重新指向<code>parent</code>对象。</p><p>由于生成parent对象时，它的<code>__proto__</code>指向了parent的<strong>原始类</strong>，因此child.prototype就与parent的prototype建立了连接。</p><p>在接下来创建<code>obj_child</code>对象时，由于child.prototype已经指向了parent对象，因此<code>obj_child.__proto__</code>也就指向了parent对象。此时通过 old_child 就可以访问到parent对象的内容了，从而也就达到了继承的目的。</p><h2 id="ES6-中的类"><a href="#ES6-中的类" class="headerlink" title="ES6 中的类"></a>ES6 中的类</h2><p>大家对于在JS中使用<code>function</code>方式定义类实在感到很厌烦，就不能与其它语言一样可以使用<code>class</code>来定义类吗？在ES6时代，JS终于可以做到这一点了。</p><p>现在我们来看看在JS中该如何定义类吧，例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class cls &#123;</span><br><span class="line">    constructor(arg)&#123;</span><br><span class="line">        this.a &#x3D; arg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    do()&#123;</span><br><span class="line">        console.log(&quot;a value &#x3D;&#x3D;&quot; + this.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var t &#x3D; new cls(&#39;hello&#39;);</span><br><span class="line">t.do();</span><br></pre></td></tr></table></figure><p>上面的代码是不是看着就舒服多了？但实际上，ES6中的<code>class</code>只是一个<code>语法糖</code>。啥意思呢？也就是说虽然语法上JS改成了与其它面向对象语言一致的用法，但在JS内部还是使用的<code>function</code>的机制来实现的。</p><h3 id="公有成员与私有成员"><a href="#公有成员与私有成员" class="headerlink" title="公有成员与私有成员"></a>公有成员与私有成员</h3><p>使用 ES6 中的 <code>class</code> 定义类时，类中的成员默认都是公有成员，外面都可以直接访问到。当然在class中也可以使用<code>#</code>来定义私有成员变量，但一般情况下我们很少用到。我们来看一下例子吧，在上面的代码中做一点修改即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class cls &#123;</span><br><span class="line">    #a;</span><br><span class="line">    constructor(arg)&#123;</span><br><span class="line">        this.#a &#x3D; arg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    do()&#123;</span><br><span class="line">        console.log(&quot;a value &#x3D;&#x3D;&quot; + this.#a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var t &#x3D; new cls(&#39;hello&#39;);</span><br><span class="line">console.log(&quot;#a&#x3D; &quot; + t.#a);</span><br><span class="line">t.do();</span><br></pre></td></tr></table></figure><p>我们在上面代码中增加了 <code>#a</code> 变量，因<code>#</code>表示的是私有成员，所以当我们创建对象 <code>t</code> 后，通过 <code>t.a</code> 是无法访问它的，此时只能通过cls类的成员方法<code>do()</code>才能访问 <code>#a</code>变量。</p><h3 id="类的继承-1"><a href="#类的继承-1" class="headerlink" title="类的继承"></a>类的继承</h3><p>接下来我们再来看看在 ES6 中如何实现<code>类的继承</code>。在ES5中要实现类继承必须使用<code>prototype</code>，如果你不从内存存储的角度去思考的话，就很难理解它是如何实现<code>类继承</code>的。而在 ES6 中，类的继承就就像我们使用其它语言中的类继承一样，让我们一目了然。</p><p>我们来举个例子，你一看就明白了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class parent &#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.a &#x3D; &#39;hello&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class child extends parent &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.b &#x3D; &#39;world&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var c &#x3D; new child();</span><br><span class="line"></span><br><span class="line">console.log(c.a + &quot; &quot; + c.b);</span><br></pre></td></tr></table></figure><p>上面的代码定义了两个类，一个父类<code>parent</code>;一个子类<code>child</code>。当我们创建 <code>child</code> 对象 <code>c</code>时，首先会触发 child的构造函数。在child构造函数中，它首先调用 <code>super()</code>方法，而该方法会调用<code>parent</code> 类的构造函数，从而将parent类中的<code>a</code>属性进行初始化。之后又回到child构造函数中对<code>b</code>属性进行初始化，至此所有的初始化工作完成，最终<code>c</code>对象被创建出来。</p><p>当c对象创建好后，我们就可以直接访问它里边的 <code>a</code> 和 <code>b</code> 属性了，以上就是ES6中类继承的过程。其过程与其它面向对象语言完成一致，所以大家在使用它时会觉得非常自然。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上我对JS中 ES5 和 ES6 标准中的<code>类</code>做的一些浅显的探究，在ES5 中类是通过<code>function</code>创建了，由于JS最开始并不支持面向对象开发，所以在ES5中使用JS实现面向对象开发的方式让人觉得很<code>诡异</code>。我在理解这部分知识时，也颇费了一翻周折。不过如果你对内存管理比较熟悉的话，从内存管理的角度去理解 ES5 中的类与继承就比较容易了。</p><p>对于 ES6 来说，类的定义与类的继承几乎完全照搬了 Java 的语法，所以我们在学习和使用它时就非常方便了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="noopener">阮一峰</a></p></div><div class="reward-container"><div></div> <button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'> 打赏</button><div id="qr" style="display:none"><div style="display:inline-block"> <img src="https://cdn.avdancedu.com/image/next/wechat.jpeg" alt="音视跳动 微信支付"><p>微信支付</p></div><div style="display:inline-block"> <img src="https://cdn.avdancedu.com/image/next/alipay.jpeg" alt="音视跳动 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> 音视跳动-李超 [avdance@163.com]</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://blog.avdancedu.com/18fc7df1/" title="js类的探究">https://blog.avdancedu.com/18fc7df1/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><p>欢迎关注我的其它发布渠道</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="https://cdn.avdancedu.com/image/next/WeChat.jpeg"><span class="icon"><i class="fa fa-wechat"></i></span> <span class="label">WeChat</span></a></div><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/js/" rel="tag"><i class="fa fa-tag"></i> js</a></div><div class="post-nav"><div class="post-nav-item"><a href="/f3ccc53/" rel="prev" title="hexo中如何画图"><i class="fa fa-chevron-left"></i> hexo中如何画图</a></div><div class="post-nav-item"> <a href="/5a9f427c/" rel="next" title="mediasoup 课程常见问题">mediasoup 课程常见问题<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#JS中的function"><span class="nav-number">1.</span> <span class="nav-text">JS中的function</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类及成员"><span class="nav-number">2.</span> <span class="nav-text">类及成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类方法"><span class="nav-number">3.</span> <span class="nav-text">类方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的原型prototype"><span class="nav-number">4.</span> <span class="nav-text">类的原型prototype</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的继承"><span class="nav-number">5.</span> <span class="nav-text">类的继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES6-中的类"><span class="nav-number">6.</span> <span class="nav-text">ES6 中的类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#公有成员与私有成员"><span class="nav-number">6.1.</span> <span class="nav-text">公有成员与私有成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类的继承-1"><span class="nav-number">6.2.</span> <span class="nav-text">类的继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">7.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">8.</span> <span class="nav-text">参考</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="https://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="音视跳动" src="/images/avdancelogo.jpg"><p class="site-author-name" itemprop="name">音视跳动</p><div class="site-description" itemprop="description">传输最前沿的科技知识，学习音视频的圣地！ffmpeg, webrtc, H264, AAC</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">34</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">26</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/avdance" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;avdance" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/garrylea/posts" title="ZhiHu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;garrylea&#x2F;posts" rel="noopener" target="_blank"><i class="fa fa-fw fa-zhihu"></i> ZhiHu</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://www.beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备19056322号-1</a> <img src="/images/beianico.png" style="display:inline-block"><a href="https://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11011102001366" rel="noopener" target="_blank">京公网安备11011102001366号</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2021</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">李超</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span title="站点总字数">180k</span></div><script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"Cu6h7B3RnNt3uEMrRWpVlIU6-gzGzoHsz","app_key":"5dKv9XFD2w3gjJnb0xnWIIWz","server_url":"https://leancloud.cn","security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        //if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script><script>AV.initialize("Cu6h7B3RnNt3uEMrRWpVlIU6-gzGzoHsz","5dKv9XFD2w3gjJnb0xnWIIWz")</script><script>function showTime(e){var t=new AV.Query(e),c=[],u=$(".leancloud_visitors");u.each(function(){c.push($(this).attr("id").trim())}),t.containedIn("url",c),t.find().done(function(e){var t=".leancloud-visitors-count";if(0!==e.length){for(var n=0;n<e.length;n++){var o=e[n],i=o.get("url"),s=o.get("time"),r=document.getElementById(i);$(r).find(t).text(s)}for(n=0;n<c.length;n++){i=c[n],r=document.getElementById(i);var l=$(r).find(t);""==l.text()&&l.text(0)}}else u.find(t).text(0)}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(i){var e=$(".leancloud_visitors"),s=e.attr("id").trim(),r=e.attr("data-flag-title").trim(),t=new AV.Query(i);t.equalTo("url",s),t.find({success:function(e){if(0<e.length){var t=e[0];t.fetchWhenSave(!0),t.increment("time"),t.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var n=new i,o=new AV.ACL;o.setPublicReadAccess(!0),o.setPublicWriteAccess(!0),n.setACL(o),n.set("title",r),n.set("url",s),n.set("time",1),n.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):1<$(".post-title-link").length&&showTime(e)})</script><link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.min.css"><script src="/lib/needsharebutton/needsharebutton.min.js"></script><script>flOptions={iconStyle:"box",boxForm:"horizontal",position:"topRight",networks:"Weibo,Wechat,QQZone"},new needShareButton("#needsharebutton-float",flOptions)</script><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('/lib/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Cu6h7B3RnNt3uEMrRWpVlIU6-gzGzoHsz',
      appKey     : '5dKv9XFD2w3gjJnb0xnWIIWz',
      placeholder: "畅所欲言？",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script></body></html>