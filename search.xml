<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《WebRTC音视频实时互动技术--原理、实战与源码分析》勘误表</title>
      <link href="/f2403a12/"/>
      <url>/f2403a12/</url>
      
        <content type="html"><![CDATA[<h2 id="勘误一"><a href="#勘误一" class="headerlink" title="勘误一"></a>勘误一</h2><p>P103，6.4.2小节倒数第二段修改如下：<br><img data-src="https://cdn.avdancedu.com/image/article/webrtc_book_kw/turn_protocal.png" alt=""></p><p>“因为主机 A 拿到了主机 B 的 Relay 类型的 Candidate，即 RelayB，所以主机 A 可以直接将音视频数据发向 RelayB。TurnServer 从 RelayB 接收到数据后，会将数据 打包成 TURN 消息，经 3478 端口发往主机 B。主机 B 收数据后，再利用 TurnClient 模块将数据从 TURN 消息中取出，交给其它模块做进一步处理; 同理，主机 B 与主机 A 的操作流程是一样的。TurnServer 从 RelayA 收到数据后，将其打包成 TURN 消息， 也要经过 3478 端口转发给主机 A。”</p><h2 id="勘误二"><a href="#勘误二" class="headerlink" title="勘误二"></a>勘误二</h2><p>P98，表6.2各NAT之间可穿越表：<br><img data-src="https://cdn.avdancedu.com/image/article/webrtc_book_kw/NAT_table.png" alt=""></p><a id="more"></a><h2 id="勘误三"><a href="#勘误三" class="headerlink" title="勘误三"></a>勘误三</h2><p>P168，图9.10有误，正确的图如下所示：<br><img data-src="https://cdn.avdancedu.com/image/article/webrtc_book_kw/onebyeheader2.png" alt=""></p><h2 id="勘误四"><a href="#勘误四" class="headerlink" title="勘误四"></a>勘误四</h2><p>P175，10.1 节的第一段修改为如下：</p><p>“在 WebRTC 中包含多种拥塞控制算法，有 GCC、BBR和 PCC。GCC 根据其实现又可细分为基于发送端的拥塞控制算法 Transport-CC4和基于<strong>接收端</strong>的拥塞控制算法 Goog-REMB。”</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的新书《WebRTC音视频实时互动技术--原理、实战与源码分析》终于出版了</title>
      <link href="/bc71cb9a/"/>
      <url>/bc71cb9a/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/webrtc_qos/webrtc_book.png" alt=""></p><p>近年来，在音视频领域WebRTC越来越受到大家的追棒，它就像音视频技术的一顶“王冠”，上面嵌了大大小小、各种各样的“宝石”，如回音消除、降噪、自动增益、NetEQ、网络拥塞控制……不胜枚举！几乎所有的实时直播客户端都或多或少的使用了WebRTC的代码或借鉴了WebRTC的思想。</p><a id="more"></a><h2 id="WebRTC服务质量"><a href="#WebRTC服务质量" class="headerlink" title="WebRTC服务质量"></a>WebRTC服务质量</h2><p>为什么WebRTC会受到如此追棒呢？我想，究其原因是它有非常好的服务质量（网络服务质量、音视频服务质量）。</p><p>在众多的服务质量中，网络服务质量是最为关键的。你可以想像一下，如果网络是“畅通无阻”的：有无限的带宽，不丢包、不延时，那一切都变得美好了。但现实中，不可能每个用户都有如此好的网络，更多的是网络不佳，带宽受限。而让那些网络不佳、带宽受限的用户也能享受较好的服务，则是WebRTC一直孜孜不倦追求的目标。</p><p>为了达到这个目标，WebRTC发明了一种网控拥塞控制算法，称为GCC。该算法最厉害的地方是可以根据网络的丢包情况和延时趋势准确的判断出用户带宽的大小，并根据带宽的大小来控制发包的速度，从而避免网络拥塞的发生。</p><p>这项技术是十分关键的。大多数情况下，用户的带宽是动态变化的，如果我们不能实时的、有效的判断出带宽的大小，那么很有可能会因为发送音视频码流过大，导致网络拥塞，最终引起网络瘫痪。举个典型的例子，像长城宽带这种共享网络，假如你购买的是 100M 带宽，但实际使用时，分到的带宽并不是 100M，它的波动是非常大的。在早上人少的时候，带宽可以接近 100M；但晚上人多时，可能还 2M都达不到。如果没有拥塞控制算法，不能动态的判断出带宽的大小，我们发送大码流的时候，后果就可想而知了。</p><p>当然，能够准确的评估出带宽，只是“万里长征”的第一步，后面还有很多事情要做呢，如：如何进行发送码流的控制？只控制发送速度就可以了吗？如果不对“源”（产生音频与视频数据的地方）进行控制，就会导致内存爆长，从而引起系统崩溃。</p><p>此外，传输的实时性也是非常关键的。此时又涉及到传输协议的选择了，我们在传输音视频数据时，是应该选择TCP还是UDP？在极端网络情况下为什么要选择UDP？这些都是值得深入探讨的问题。</p><p>当传输协议选好后，端与端之间连接通路的选择对传输的实时性也起着至关重要的作用。如果通信的双方在同一个局域网内，那么它们应该首先选择局域网这条通路，而不是将包发向外网绕一圈再回来；如果不在同一个局域网内，则应该优先选择P2P直连；只有在直连不通的情况下，才应该考虑通过中继服务器进行数据中转，从而达到数据实时传输的目的。</p><p>总之，为了达到更好的服务质量，WebRTC想到了各种办法，可以说无所不用其极。这里我对其方法做了一下总结，分成五大类，如下图所示：</p><p><img data-src="https://cdn.avdancedu.com/image/article/webrtc_qos/webrtc_qos.png" alt=""></p><h2 id="我的新书"><a href="#我的新书" class="headerlink" title="我的新书"></a>我的新书</h2><p>实际上，上面这些内容，都在我的书《WebRTC音视频实时互动技术–原理、实战与源码分析》中做了详细介绍。</p><p>本书不仅对WebRTC的网络传输做了细致、大量的分析，而且还向你详细介绍了如何通过WebRTC实现Web端与Android和iOS端的互联互通；并且还在本书的最后三章对WebRTC的源码进行了剖析，以使你不但可以知道如何使用WebRTC实现音视频通信，还能让你了解其中的原理，并知道WebRTC具体是如何做的。</p><p>总体来说，本书是一本WebRTC入门到进阶的书籍，尤其适合对于WebRTC有一定了解，想进阶的同学来说，非常适合学习本书的内容。以下是本书的目录:</p><p><img data-src="https://cdn.avdancedu.com/image/article/webrtc_qos/webrtc_dir1.png" alt=""><br><img data-src="https://cdn.avdancedu.com/image/article/webrtc_qos/webrtc_dir2.png" alt=""><br><img data-src="https://cdn.avdancedu.com/image/article/webrtc_qos/webrtc_dir3.png" alt=""><br><img data-src="https://cdn.avdancedu.com/image/article/webrtc_qos/webrtc_dir4.png" alt=""></p><h2 id="购买地址"><a href="#购买地址" class="headerlink" title="购买地址"></a>购买地址</h2><p><a href="https://item.jd.com/10033954503352.html" target="_blank" rel="noopener">机械工业出版社(华章)</a></p><h2 id="沟通群"><a href="#沟通群" class="headerlink" title="沟通群"></a>沟通群</h2><p>对于图中的任何疑问可以到微信群中提问。</p><p><img data-src="https://cdn.avdancedu.com/image/article/webrtc_qos/webrtc_group.jpeg" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Go的性能竟如何优秀？Go、C和RUST性能对比</title>
      <link href="/1ed22639/"/>
      <url>/1ed22639/</url>
      
        <content type="html"><![CDATA[<p>最近几年Go、RUST等新语言不断推陈出新，令人目不暇接。据说Go与RUST开发出的程序性能非常高，但对于我这种C/C++老鸟来说，对此并不感冒，“再快还能比C快？”这句话一直萦绕在我的心头。</p><p>但出于好奇，每次听到有人说Go性能多好多好时，难免都会追问一句“有没有与C进行过对比测试？”，这句并不是想“兑”谁，而是想确认一下网上的传言是否为真。</p><p>不幸的是，每当我问这句话时，从来没有得到一个明确答复，也搞不清是他们得出的“Go性能好”是道听途说，还是自己真实的测试结果。</p><p>近来时间充裕，一时兴起，心想不如做个简单的Go、C/C++、RUST的性能对比测试吧，验证一下Go的性能到底如何。</p><a id="more"></a><h2 id="简单的测试用例"><a href="#简单的测试用例" class="headerlink" title="简单的测试用例"></a>简单的测试用例</h2><p>由于我一直专注在音视频实时通信领域，因此对网络传输的性能特别关心，所以这次测试只验证一下不同语言在传输UDP包时的性能。</p><p>为了减少其它因素的影响，测试条件限制如下：</p><ul><li>在同一台机子上进行不同语言性能的测试，防止因硬件的不同影响测试结果</li><li>服务端只接收不回复，防止服务器干扰测试结果</li><li>客户端只发送不接收，每次只发送<code>Hello</code>几个字符</li><li>客户端循环发送 1000 0000次，看它的总时长是多少</li></ul><p>下面是不同语言编写的测试程序。</p><h3 id="C客户端代码"><a href="#C客户端代码" class="headerlink" title="C客户端代码"></a>C客户端代码</h3><p>下面是使用<code>C</code>语言实现的客户端代码的主要逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    gettimeofday(&amp;tv0, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> lastime = tv0.tv_sec * <span class="number">1000000000</span> + tv0.tv_usec; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"total: %lu, sec:%lu, nao:%u\n"</span>, lastime, tv0.tv_sec, tv0.tv_usec);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//循环 1000 0000 次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>; a&lt; <span class="number">10000000</span>; a++)&#123;</span><br><span class="line">        n = sendto(sock, </span><br><span class="line">                        buff_send, </span><br><span class="line">                        <span class="built_in">strlen</span>(buff_send), </span><br><span class="line">                        <span class="number">0</span>, (struct sockaddr *) &amp;addr, </span><br><span class="line">                        <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;tv1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> curtime = tv1.tv_sec * <span class="number">1000000000</span> + tv1.tv_usec; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"total:%lu, sec:%lu, nao:%u\n"</span>, curtime, tv1.tv_sec, tv1.tv_usec);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>从上述代码中可以看到，在<code>for</code>循环执行了 1000 0000 次，每次都调用 <code>sendto</code> 发送UDP数据。</p><h3 id="Go客户端代码"><a href="#Go客户端代码" class="headerlink" title="Go客户端代码"></a>Go客户端代码</h3><p>Go语言实现的逻辑与C客户端逻辑是类似的，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">var</span> lastime <span class="keyword">int64</span> = time.Now().UnixNano()</span><br><span class="line">    fmt.Printf(<span class="string">"lastime: %d\n"</span>, lastime)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> a:=<span class="number">0</span>; a &lt; <span class="number">10000000</span>; a++ &#123;</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        _, err = conn.Write([]<span class="keyword">byte</span>(<span class="string">"Hello"</span>))    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> curtime <span class="keyword">int64</span> = time.Now().UnixNano()</span><br><span class="line">    fmt.Printf(<span class="string">"curtime: %d"</span>, curtime)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Go的代码非常简单，它与C的区别是其使用Write来发送数据。</p><h3 id="RUST客户端代码"><a href="#RUST客户端代码" class="headerlink" title="RUST客户端代码"></a>RUST客户端代码</h3><p>RUST语言实现的逻辑也是类似的，代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">let</span> start = Instant::now();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> n = start.elapsed().as_nanos();</span><br><span class="line">    std::<span class="built_in">println!</span>(<span class="string">" elapsed: &#123;&#125;"</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//loop &#123;</span></span><br><span class="line">    <span class="keyword">for</span> _i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">100001</span> &#123;</span><br><span class="line">        socket.send_to(data.as_bytes(), <span class="string">"127.0.0.1:9998"</span>)?;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = start.elapsed().as_nanos();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"elapsed : &#123;&#125;"</span>, n);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><table><thead><tr><th align="left">系统</th><th align="left">硬件</th><th align="left">C</th><th align="left">Go</th><th align="left">RUST</th></tr></thead><tbody><tr><td align="left">Mac</td><td align="left">2.7 GHz Intel Core i5<br>8 GB DDR3</td><td align="left">150秒</td><td align="left">85秒</td><td align="left">150 秒</td></tr><tr><td align="left">Linux</td><td align="left">2.7GHz Inter 8 Core i7 <br> 8G</td><td align="left">17-18秒</td><td align="left">21-22秒</td><td align="left">22 秒</td></tr></tbody></table><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>刚看到这个结果时，我真是难以至信，Go和RUST的性能竟然与C如此接近。</p><p>通过上面的测试我们可以得出以下结论：</p><ul><li>新语言 Go 与 RUST 在性能上确实不错，基本上与 C 是接近的，应用层到系统接口之间的层级比较薄</li><li>不同的操作系统表现不一样，但通常情况下Go都是在Linux系统下运行，所以应该以Linux系统的测试为准</li><li>Go、RUST相较C/C++而言，开发效率高很多，如果性能差不多的情况下，采用Go或RUST做服务器开发更有优势</li></ul><p><strong>但这次只是一个简单的测试，只能说在发送UDP时，Go、RUST与C性能差别不大，但并不代表在整体性能上Go和RUST已经赶上C/C++性能了。如果想更好的了解Go、RUST与C/C++的差异，应该做更详尽的测试验证。</strong></p><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>代码地址：<a href="https://github.com/andancedu/go_rust_c.git" target="_blank" rel="noopener">https://github.com/andancedu/go_rust_c.git</a></p><h2 id="我的课程"><a href="#我的课程" class="headerlink" title="我的课程"></a>我的课程</h2><p>-<a href="https://coding.imooc.com/class/415.html" target="_blank" rel="noopener">音视频系统入门</a></p><p>-<a href="https://coding.imooc.com/class/279.html" target="_blank" rel="noopener">ffmpeg精讲</a></p><p>-<a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">WebRTC入门与实战</a></p><p>-<a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">WebRTC高并发流媒体服务器</a></p><p>-<a href="https://time.geekbang.org/column/article/111337" target="_blank" rel="noopener">从0开始构造直播系统</a></p><p>-<a href="https://coding.imooc.com/class/496.html" target="_blank" rel="noopener">OpenCV入门与实战</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>音频3A问题经验分享</title>
      <link href="/5756c48d/"/>
      <url>/5756c48d/</url>
      
        <content type="html"><![CDATA[<p>一直以来音频的3A（回音消除、降噪、自动增益）问题都是音视频实时通信中特别关键，也特别难以解决的问题。尤其是回音消除问题，更是难上加难，它就好比你向水中倒了一些墨汁，现在又想将它从水中提取出来一样困难。</p><p>对于做音视频 PaaS (提供API接口服务）的公司而言，只有将3A问题处理好，才能在音视频实时通信市场上占有一席之地，否则就没法与声网、腾讯等这些老牌或巨头公司进行竞争。正是由于3A 问题是做音视频公司必须要解决好的问题，所以它们对能够解决这类问题的人才都求贤若渴，对于想进入音视频行业的同学来说，如果你能具有3A问题的解决能力，那你一定会成为各音视频大厂挣抢的“香饽饽”。</p><p>为了让大家学到更多的干货，这次我特意邀请到拍乐云合伙人&amp;音频专家 Ark，请他为大家详细介绍在商业应用中都会遇到哪些3A问题，遇到这类问题时该如何解决，对于初入门的同学又该如何学习音频技术。相信通过这次分享，一定会让大家会收获满满。</p><p>感兴趣的小伙伴请加入讨论群, 分享时间为2021年6月30 19:45。</p><p><img data-src="https://cdn.avdancedu.com/image/article/3A/dakashuo.png" alt="音频3A经验分享群"></p><a id="more"></a><h2 id="本次分享的大体题纲如下："><a href="#本次分享的大体题纲如下：" class="headerlink" title="本次分享的大体题纲如下："></a>本次分享的大体题纲如下：</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul><li>音频的一些基本知识，音量（响度），分贝，频率、振幅与音量的关系，为什么音量是负值？</li><li>增益是指什么？它与音量大小的区别是什么？如何进行自动增益？<h3 id="降噪相关"><a href="#降噪相关" class="headerlink" title="降噪相关"></a>降噪相关</h3></li><li>什么是噪音，算法是如何判断出噪音的？</li><li>噪音是有颜色的，这是什么意思？</li><li>降噪的难点是什么？什么样的噪音不好降？</li><li>我们是否应该优先使用硬件降噪？移动端与PC端有什么区别吗？</li><li>什么是舒适噪音？为什么要增加舒适噪音？<h3 id="回音相关"><a href="#回音相关" class="headerlink" title="回音相关"></a>回音相关</h3></li><li>回音消除的难点是什么？</li><li>是否可以简要的介绍一下回音产生的一个大体原理？</li><li>机端的回音消除是否比PC端的回音更好消除一些？其中的原理是否可以比大家介绍一下？</li><li>WebRTC在回音消除方法做了哪些工作，最新的AEC3 与以前的回音消除算法有什么显著的差别？<h3 id="学习相关"><a href="#学习相关" class="headerlink" title="学习相关"></a>学习相关</h3></li><li>在解决实际3A问题时，一定要用到数学吗？</li><li>未来的技术方向</li><li>学习音频的基本路径是什么？</li><li>能否给推荐几本好书？</li></ul><h2 id="分享嘉宾"><a href="#分享嘉宾" class="headerlink" title="分享嘉宾"></a>分享嘉宾</h2><p>Ark，拍乐云合伙人&amp;音频专家。中科大硕士毕业，多年音频开发经验，5年WebEx音频专家工作经验，精通音频3A算法，深入理解实时通信音频框架，主导设计了多套音频处理框架，对于音频算法、移动端设备适配、大屏远场算法优化、智能手表音频优化等都非常了解。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>在Windows下使用VS编译OpenCV库</title>
      <link href="/d6343897/"/>
      <url>/d6343897/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近发现有很多同学在学习OpenCV时，不知道该如何在Windows下编译OpenCV源码，这里我整理了一份Windows编译OpenCV的具体步聚，希望可以帮助到大家。</p><p>Windows下编译OpenCV分为四步，即：</p><ul><li>一、下载安装必要的工具</li><li>二、下载OpenCV源码</li><li>三、生成编译脚本</li><li>四、使用VS工程编译OpenCV</li></ul><a id="more"></a><h2 id="下载必要的工具"><a href="#下载必要的工具" class="headerlink" title="下载必要的工具"></a>下载必要的工具</h2><ol><li>安装python3和numpy库，<a href="https://www.python.org/ftp/python/3.9.2/python-3.9.2-amd64.exe" target="_blank" rel="noopener">下载地址：https://www.python.org/ftp/python/3.9.2/python-3.9.2-amd64.exe</a></li><li>安装 VS, 下载社区版即可，<a href="https://visualstudio.microsoft.com/zh-hans/downloads/" target="_blank" rel="noopener">下载地址： https://visualstudio.microsoft.com/zh-hans/downloads/</a></li><li>安装 cmake，<a href="https://github.com/Kitware/CMake/releases/download/v3.20.0-rc1/cmake-3.20.0-rc1-windows-x86_64.msi" target="_blank" rel="noopener">下载地址：https://github.com/Kitware/CMake/releases/download/v3.20.0-rc1/cmake-3.20.0-rc1-windows-x86_64.msi</a></li><li>下载IPPICV，<a href="https://github.com/opencv/opencv_3rdparty.git" target="_blank" rel="noopener">下载地址：https://github.com/opencv/opencv_3rdparty.git</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;opencv&#x2F;opencv_3rdparty.git</span><br></pre></td></tr></table></figure></li></ol><h2 id="下载opencv源码"><a href="#下载opencv源码" class="headerlink" title="下载opencv源码"></a>下载opencv源码</h2><ol><li><p>下载opencv源码, 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;opencv&#x2F;opencv.git</span><br></pre></td></tr></table></figure></li><li><p>下载opencv-contrib源码, 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;opencv&#x2F;opencv_contrib.git</span><br></pre></td></tr></table></figure></li></ol><h2 id="生成编译脚本"><a href="#生成编译脚本" class="headerlink" title="生成编译脚本"></a>生成编译脚本</h2><ol><li>在存放opencv源码目录中创建build目录</li><li>运行cmake</li><li>选择opencv源码目录</li><li>选择编译目录</li><li>选择CPU架构</li><li>增加opencv-contrib选项, OPENCV_EXTRA_MODULES_PATH=../opencv_contrib/modules</li><li>检查编译选项，并<ol><li>勾选 opencv_world</li><li>勾选 ffmpeg</li><li>勾选 IPPICV，这步容易出错，如果你访问不了外网的话一般会出错。可以偿试手工下载IPPICV，进行设置。</li></ol></li><li>生成编译脚本</li></ol><h2 id="使用VS编译OpenCV"><a href="#使用VS编译OpenCV" class="headerlink" title="使用VS编译OpenCV"></a>使用VS编译OpenCV</h2><ol><li>选择输出版本类型</li><li>进行编译</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在上述步骤中，第三步<strong>生成编译脚本</strong>是最容易出错的，其中第7步是导致出错的最大原因，所以在生成编译脚本时一定要仔细检查这几项是否都是OK的。</p><h2 id="我的课程"><a href="#我的课程" class="headerlink" title="我的课程"></a>我的课程</h2><p>-<a href="https://coding.imooc.com/class/496.html" target="_blank" rel="noopener">OpenCV入门与实战</a></p><p>-<a href="https://coding.imooc.com/class/415.html" target="_blank" rel="noopener">音视频系统入门</a></p><p>-<a href="https://coding.imooc.com/class/279.html" target="_blank" rel="noopener">ffmpeg精讲</a></p><p>-<a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">WebRTC入门与实战</a></p><p>-<a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">WebRTC高并发流媒体服务器</a></p><p>-<a href="https://time.geekbang.org/column/article/111337" target="_blank" rel="noopener">从0开始构造直播系统</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《WebRTC实时互动技术原理实战与源码分析》一书的源码</title>
      <link href="/a0a831a3/"/>
      <url>/a0a831a3/</url>
      
        <content type="html"><![CDATA[<h1 id="源码下截地址"><a href="#源码下截地址" class="headerlink" title="源码下截地址"></a>源码下截地址</h1><p><a href="https://avdancedu.com/download/client.tar.gz" target="_blank" rel="noopener">客户端源码下载</a><br><a href="https://avdancedu.com/download/server.tar.gz" target="_blank" rel="noopener">服务端源码下载</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出C++的function</title>
      <link href="/dabab813/"/>
      <url>/dabab813/</url>
      
        <content type="html"><![CDATA[<p>今天我们来聊聊C++的function。std::function是从C++11开始支持的特性，它起什么作用?又有什么好处呢？</p><a id="more"></a><h2 id="C语言中的函数指针"><a href="#C语言中的函数指针" class="headerlink" title="C语言中的函数指针"></a>C语言中的函数指针</h2><p>对C语言熟悉的同学应该都知道，C语言中有一种高级技巧叫作函数指针，我们可以让函数指针指向参数类型相同、返回值类型也相同的函数。通过函数指针我们也可以实现C++中的多态。我们来看个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*func)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, print1 \n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, print2 \n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    func fp = print1;</span><br><span class="line">    fp();</span><br><span class="line"></span><br><span class="line">    fp = print2;</span><br><span class="line">    fp();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中定义了一个函数指针<code>func</code>，它可以指向无输入参数，返回值为整型的函数。因此在main函数中，我们可以用fp(这是func类型的指针）分别指向print1和print2并调用它们。</p><p>其运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello, print1</span><br><span class="line">hello, print2</span><br></pre></td></tr></table></figure><h2 id="function的作用"><a href="#function的作用" class="headerlink" title="function的作用"></a>function的作用</h2><p>从上面的C代码中我们可以看到C函数指针的作用，那在C++中是否也类似这样的功能呢？没错function就是完成这个任务的。但std::function比C的函数指针功能更强大些或者说更适合C++中使用。</p><p>下面我们来看一下如何在C++中使用std::function实现指向不同的函数吧。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello, print1"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello, print2"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::function&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">func</span><span class="params">(&amp;print1)</span></span>;</span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    func = &amp;print2;</span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码与C函数指针一样定义了两个全局函数print1和print2。在main函数中又定义了std::function 对象 func，然后将print1和print2分别赋值给func，这样就可以达到与C语言中指针同样的功能了。</p><p>其运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello, print1</span><br><span class="line">hello, print2</span><br></pre></td></tr></table></figure><p>可以看到std::function的结果与上面C函数指针的结果是一致的，因此std::function就是C++中用来代替C函数指针的。但如果std::function只是实现上面的功能也没啥好奇怪的对吧？实际上std::function还有一个特别有意思的用法，你可以将一个重载了<strong>()</strong>操作符的对象赋值给它，这样就可以像调用函数一样使用该对象了。下面咱们就对上面的代码做下简单修改，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"This is A Object"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    A a;</span><br><span class="line">    func = a;</span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，使用<code>struct</code>定义了一个结构体，而在该结构体中重载了<strong>()</strong>操作符，因此只要你将A的类对象赋值给func，它就可以像函数一样使用了。其结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">This is A Object</span><br></pre></td></tr></table></figure><h2 id="function的实现原理"><a href="#function的实现原理" class="headerlink" title="function的实现原理"></a>function的实现原理</h2><p>是不是觉得function做的事儿还挺神奇的？它是如何实现的呢？下面我们就来扒一扒它是如何实现的。</p><p>从实现上来说，有两种办法可以实现std::function：一种是通过类的多态，即通过虚表来达到多态；另一种方法是通过C语言的函数指针来实现。今天我们只介绍通过类多态的方式来实现function，对于通过函数指针实现的方式你可以自己去研究一下。</p><p>现在我们由浅入深的来分解一下function。通过观察我们可以发现function是一个包装类，它可以接收普通函数、<strong>函数类对象</strong>(也就是实现了（）操作符的类对象）等。它是如何做到的呢？</p><p>最简单的方式就是通过类模板。我们都知道function的类模板参数是可变的，但我们为了简单，所以只实现有一个参数的function类模板。这也符合我们的目标，只是扒一下实现原理，并不是想自己去实现它。</p><p>OK，下面我们来看看该如何定义这个类模板吧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> Arg0&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span>&lt;R(Arg0)&gt; &#123;</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(Arg0 arg0)</span></span>&#123;</span><br><span class="line">           <span class="keyword">return</span> ...;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个最简单的，只有一个参数的类模板。它是 <strong>function&lt;int(int)&gt;</strong> 或 <strong>function&lt;String(int)&gt;</strong> 等格式的类模板。这样我们在外型上与标准库中的std::function类似了。</p><p>接下来我们需要思考一下，如何让我们自己实现的function可以调用不同的函数呢？从其行为上可以推理出其内部应该有一个指针，而且这个指针具有多态性。想想C++中的多态是如何实现的？通过继承和虚表对吧。所以在function内部应该有一个基类指针，所有传入到function中的函数、类函数对象等都应该是继承于该类的子类成员。除此之外，还要在<strong>()</strong>操作符前加<code>virtual</code>关键字，让它创建虚表。</p><p>了解了上面的原理后，下面我们就在自己的function中增加基类及其类的指针。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> Arg0&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span>&lt;R(Arg0)&gt; <span class="title">function</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="class"><span class="keyword">class</span> __<span class="title">callbase</span> &#123;</span></span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                <span class="function"><span class="keyword">virtual</span> R <span class="title">operator</span><span class="params">()</span><span class="params">(Arg0 arg0)</span> </span>= <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">virtual</span> ~__callbase() &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        __callbase *base_;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(Arg0 arg0)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (*__callbase)(arg0); <span class="comment">//这里调用基类对象的()操作符</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面我们就将多态中的基类实现好了，在上面的代码中最关键是的<code>operator()</code>中增加了<strong>virtual</strong>关键字，这样该函数就被放到了vtable中，后面就可以在子类中实现该方法了。下面我们来实现子类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span>&lt;R(Arg0)&gt; <span class="title">function</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> __<span class="title">callable</span>:</span> <span class="keyword">public</span> __callbase &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                callable(F functor)</span><br><span class="line">                    : functor(functor)&#123;&#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">virtual</span> R <span class="title">operator</span><span class="params">()</span><span class="params">(Arg0 arg0)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> functor(arg0);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span>:</span><br><span class="line">                F functor;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">        myfunction(F f): base_(<span class="keyword">new</span> __callable&lt;F&gt;(f))&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~myfunction()&#123;</span><br><span class="line">            <span class="keyword">if</span>(base_) &#123;</span><br><span class="line">                <span class="keyword">delete</span> base_;</span><br><span class="line">                base_ = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在子类的实现中，核心点是增加指向赋值给function类的函数指针或函数类对象，也就是上面<code>__callable</code>类中的<strong>F functor</strong> 成员。该成员的类型是通过模板<code>template&lt;typename F&gt;</code>推导出来的。如果我们在创建function时传入的是函数，那么functor就是一个函数指针，如果我们传入的是函数类对象，则functor就是类对象。</p><p>另外你可以发现，我分别在myfunction类的构造函数和<code>__callable</code>类前定义了模板<code>F</code>，这样当我们在main函数中创建myfunction对象时，通过类型推导就可以获到F的具体类型了。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">myfunction <span class="title">myfunc</span><span class="params">(<span class="built_in">print</span>)</span></span>; <span class="comment">//通过这句可以获得F类型为函数指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了functor成员后，还需要在构造<code>__callable</code>时给functor赋值，也就是让functor指向具体的函数或函数类对象。之后重载<strong>()</strong>操作符就可以直接调用具体的函数或函数类对象了。</p><p>通过以上讲解我想你应该已经知道标准库中的function实现的基本原理了。当然我们这里实现的比较简陋，真正的实现还要考虑很多性能的问题，所以实现的要比这个复杂得多。另外标准库中的实现是通过函数指针来实现的而非通过C++的多态。</p><p>不过我们今天实现的的myfunction虽然与标准库有很多不同，但原理都是类似的，对于我们理解function已经足够了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在本文中我首先向你介绍了std::function的作用以及如何使用它，之后又苞丁解牛的实现了一个最简陋的function，主要的目的是加深你对function的理解。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">C++高阶知识：深入分析移动构造函数及其原理</a><br><a href="https://avdancedu.com/360c1c76" target="_blank" rel="noopener">聊聊C++中的完美转发</a><br><a href="https://avdancedu.com/9683d88/" target="_blank" rel="noopener">细说智能指针</a><br><a href="https://avdancedu/670ef31f/" target="_blank" rel="noopener">聊聊C++中的类型转换</a><br><a href="https://avdancedu.com/5e7916e3/" target="_blank" rel="noopener">重学C/C++中的const</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊C++中的完美转发</title>
      <link href="/360c1c76/"/>
      <url>/360c1c76/</url>
      
        <content type="html"><![CDATA[<p>之前我已经向你介绍了<a href="http://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">C++中的std::move</a>，它的作用是无论你传给它的是左值还是右值，通过std::move之后都变成了右值。而今天我们要介绍的std::forward则与之不同，它的作用是什么呢？</p><a id="more"></a><h2 id="forward的作用"><a href="#forward的作用" class="headerlink" title="forward的作用"></a>forward的作用</h2><p>std::forward被称为<strong>完美转发</strong>，它的作用是保持原来的<code>值</code>属性不变。啥意思呢？通俗的讲就是，如果原来的值是左值，经std::forward处理后该值还是左值；如果原来的值是右值，经std::forward处理后它还是右值。</p><p>看看下面的例子，你应该就清楚上面这句话的含义了:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T &amp; t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lvalue"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T &amp;&amp; t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rvalue"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(v);</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">std</span>::forward&lt;T&gt;(v));</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">std</span>::<span class="built_in">move</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    testForward(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"======================"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    testFoward(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，定义了两个模板函数，一个接收左值，另一个接收右值。在<code>testForward</code>函数中向模板函数<code>print</code>传入不同的参数，这样我们就可以观察出forward与move的区别了。</p><p>上面代码执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lvalue</span><br><span class="line">rvalue</span><br><span class="line">rvalue</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">lvalue</span><br><span class="line">lvalue</span><br><span class="line">rvalue</span><br></pre></td></tr></table></figure><p>从上面第一组的结果我们可以看到，传入的1虽然是右值，但经过函数传参之后它变成了左值（在内存中分配了空间）；而第二行由于使用了std::forward函数，所以不会改变它的右值属性，因此会调用参数为右值引用的print模板函数；第三行，因为std::move会将传入的参数强制转成右值，所以结果一定是右值。</p><p>再来看看第二组结果。因为x变量是左值，所以第一行一定是左值；第二行使用forward处理，它依然会让其保持左值，所以第二也是左值；最后一行使用move函数，因此一定是右值。</p><p>通过上面的例子我想你应该已经清楚forward的作用是什么了吧？</p><h2 id="forward实现原理"><a href="#forward实现原理" class="headerlink" title="forward实现原理"></a>forward实现原理</h2><p>要分析forward实现原理，我们首先来看一下forward代码实现。由于我们之前已经有了<a href="http://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">分析std::move</a>的基础，所以再来看forward代码应该不会太困难。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>forward实现了两个模板函数，一个接收左值，另一个接收右值。在上面有代码中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type</span><br></pre></td></tr></table></figure><p>的含义我们在<a href="http://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">分析std::move</a>时已经向你做了说细的说明，其作用就是获得去掉引用后的参数类型。所以在上面的两上模板函数中，第一个是左值引用模板函数，第二个是右值引用模板函数。</p><p>紧接着forward模板函数对传入的参数进行强制转换，转换的目标类型符合引用折叠规则，因此左值参数最终转换后仍为左值，右值参数最终转成右值。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们首先通一个小例子向你介绍了std::forward的作用为“完美转发”，也就是不改变原值的属性。接着我带你分析了std::forward的原码实现，如果你看过我之前对std::move的分析文章，相信你在阅读std:forward的代码实现时不会遇到什么困难。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">C++高阶知识：深入分析移动构造函数及其原理</a><br><a href="https://avdancedu.com/9683d88/" target="_blank" rel="noopener">细说智能指针</a><br><a href="https://avdancedu/670ef31f/" target="_blank" rel="noopener">聊聊C++中的类型转换</a><br><a href="https://avdancedu.com/5e7916e3/" target="_blank" rel="noopener">重学C/C++中的const</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[转]Mac配置中文man手册</title>
      <link href="/a77533/"/>
      <url>/a77533/</url>
      
        <content type="html"><![CDATA[<p>转自： <a href="http://www.jackaiup.com/index/detail?id=10234" target="_blank" rel="noopener">http://www.jackaiup.com/index/detail?id=10234</a></p><p>man手册对于我们在Mac或Linux系统下开发起着至关重要的作用，今天我们就来看一下如何在Mac系统下安装Man手册。</p><a id="more"></a><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li>安装软件依赖</li><li>编译安装man手册</li><li>修改配置文件</li><li>解决乱码问题</li></ul><h2 id="软件依赖"><a href="#软件依赖" class="headerlink" title="软件依赖"></a>软件依赖</h2><ul><li>autotools (autoconf, automake)</li><li>python3</li><li>opencc 1.x</li></ul><p>可以通过homebrew自行安装:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew install autotools</span><br><span class="line">brew install python3</span><br><span class="line">brew install opencc</span><br></pre></td></tr></table></figure><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><blockquote><p>git clone  <a href="https://github.com/man-pages-zh/manpages-zh" target="_blank" rel="noopener">https://github.com/man-pages-zh/manpages-zh</a>    #下载文件<br>cd manpages-zh<br>autoreconf –install –force     #构建configure文件<br>./configure<br>make<br>make install                     #需要超级用户权限</p></blockquote><h2 id="添加手册路径"><a href="#添加手册路径" class="headerlink" title="添加手册路径"></a>添加手册路径</h2><p>打开 man 手册配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;man.conf</span><br></pre></td></tr></table></figure><p>修改配置文件，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line">MANPATH &#x2F;usr&#x2F;local&#x2F;share&#x2F;man              #line 44</span><br><span class="line">MANPATH &#x2F;usr&#x2F;local&#x2F;share&#x2F;man&#x2F;zh_CN        #添加中文手册路径</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">:wq</span><br></pre></td></tr></table></figure><p>可以通过下面的命令查看是否中文文档已经加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man -aw</span><br></pre></td></tr></table></figure><p>如果出现下面的信息表示已加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;share&#x2F;man:&#x2F;usr&#x2F;share&#x2F;man:&#x2F;usr&#x2F;local&#x2F;share&#x2F;man&#x2F;zh_CN         #已经加载</span><br></pre></td></tr></table></figure><h2 id="查看中文文档"><a href="#查看中文文档" class="headerlink" title="查看中文文档"></a>查看中文文档</h2><p>执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man -aw ls            &lt;&#x3D; 查看有几个中文文档</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;share&#x2F;man&#x2F;man1&#x2F;ls.1                 &lt;&#x3D; 默认文档</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;share&#x2F;man&#x2F;zh_CN&#x2F;man1&#x2F;ls.1     &lt;&#x3D; 中文文档</span><br></pre></td></tr></table></figure><p>查看文档内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man -a ls             &lt;&#x3D; 查看文档内容</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">LS(1)                     BSD General Commands Manual                    LS(1)</span><br><span class="line">NAME</span><br><span class="line">     ls — list directory contents</span><br><span class="line">SYNOPSIS</span><br><span class="line">     ls [-ABCFGHLOPRSTUW@abcdefghiklmnopqrstuwx1] [file ...]</span><br><span class="line">DESCRIPTION</span><br><span class="line">     For each operand that names a file of a type other than directory, ls displays its name as</span><br><span class="line">     well as any requested, associated information.  For each operand that names a file of type</span><br><span class="line">     directory, ls displays the names of files contained within that directory, as well as any</span><br><span class="line">     requested, associated information.</span><br><span class="line">     If no operands are given, the contents of the current directory are displayed.  If more than</span><br><span class="line">     one operand is given, non-directory operands are displayed first; directory and non-direc‐</span><br><span class="line">     tory operands are sorted separately and in lexicographical order.</span><br><span class="line">     The following options are available:</span><br><span class="line">     -@      Display extended attribute keys and sizes in long (-l) output.</span><br><span class="line">     -1      (The numeric digit “one”.)  Force output to be one entry per line.  This is the</span><br><span class="line">     ...</span><br><span class="line">    按【q】进入中文文档</span><br><span class="line"></span><br><span class="line">LS(1)                                General Commands Manual                                LS(1)</span><br><span class="line">NAME</span><br><span class="line">       ls, dir, vdir - 列目录内容</span><br><span class="line">提要</span><br><span class="line">       ls [选项] [文件名...]</span><br><span class="line">       POSIX 标准选项: [-CFRacdilqrtu1]</span><br><span class="line">GNU 选项 (短格式):</span><br><span class="line">       [-1abcdfgiklmnopqrstuxABCDFGLNQRSUX]  [-w  cols]  [-T  cols]  [-I  pattern]  [--full-time]</span><br><span class="line">       [--format&#x3D;&#123;long,verbose,commas,across,vertical,single-column&#125;]</span><br><span class="line">       [--sort&#x3D;&#123;none,time,size,extension&#125;]               [--time&#x3D;&#123;atime,access,use,ctime,status&#125;]</span><br><span class="line">       [--color[&#x3D;&#123;none,auto,always&#125;]] [--help] [--version] [--]</span><br><span class="line">描述（ DESCRIPTION ）</span><br><span class="line">       程序ls先列出非目录的文件项，然后是每一个目录中的“可显示”文件。如果</span><br><span class="line">       没有选项之外的参数【译注：即文件名部分为空】出现，缺省为   &quot;.&quot;   （当前目录）。  选项“  -d</span><br><span class="line">       ”使得目录与非目录项同样对待。除非“ -a ” 选项出现，文 件名以“.”开始的文件不属“可显示”文件。</span><br><span class="line">       以当前目录为准，每一组文件（包括非目录文件项，以及每一内含文件的目录）分</span><br><span class="line">       别按文件名比较顺序排序。如果“-l”选项存在，每组文件前显示一摘要行:</span><br><span class="line">       ...</span><br><span class="line">【注】默认进入英文文档，按【q】可进入中文文档，再次按【q】则退出文档</span><br></pre></td></tr></table></figure><h2 id="解决乱码"><a href="#解决乱码" class="headerlink" title="解决乱码"></a>解决乱码</h2><p>如果系统的groff版本太低，文档可能出现乱码，可以将groff更新到最新版本（1.22.3，可能的话请使用尚未发布的 1.22.4）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install groff</span><br></pre></td></tr></table></figure><p>安装完成后，配置man.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;man.conf</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">#修改NROFF配置如下（将UTF8编码的MAN页面通过转码而被groff识别）</span><br><span class="line">#line 95</span><br><span class="line"></span><br><span class="line">NROFF preconv -e utf8 | &#x2F;usr&#x2F;local&#x2F;bin&#x2F;groff -Wall -mtty-char -Tutf8 -mandoc -c</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">#修改PAGER配置如下（这样可以避免MAN手册页面中的ANSI Escape字符序列干扰（用于控制显示粗体等格式））</span><br><span class="line">#line 106</span><br><span class="line"></span><br><span class="line">PAGER &#x2F;usr&#x2F;bin&#x2F;less -isR</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">:wq</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> man </category>
          
      </categories>
      
      
        <tags>
            
            <tag> man </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg命令详解</title>
      <link href="/92d94a35/"/>
      <url>/92d94a35/</url>
      
        <content type="html"><![CDATA[<p><img data-src="http://upload-images.jianshu.io/upload_images/5956443-29b1eff4f8ce0e61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1600" alt="ffmpegX.png"></p><p>FFMPEG是特别强大的专门用于处理音视频的开源库。你既可以使用它的API对音视频进行处理，也可以使用它提供的工具，如 ffmpeg, ffplay, ffprobe，来编辑你的音视频文件。</p><p>本文将简要介绍一下 FFMPEG 库的基本目录结构及其功能，然后详细介绍一下我们在日常工作中，如何使用 ffmpeg 提供的工具来处理音视频文件。</p><a id="more"></a><h1 id="FFMPEG-目录及作用"><a href="#FFMPEG-目录及作用" class="headerlink" title="FFMPEG 目录及作用"></a>FFMPEG 目录及作用</h1><ul><li>libavcodec： 提供了一系列编码器的实现。</li><li>libavformat： 实现在流协议，容器格式及其本IO访问。</li><li>libavutil： 包括了hash器，解码器和各利工具函数。</li><li>libavfilter： 提供了各种音视频过滤器。</li><li>libavdevice： 提供了访问捕获设备和回放设备的接口。</li><li>libswresample： 实现了混音和重采样。</li><li>libswscale： 实现了色彩转换和缩放工能。</li></ul><h1 id="FFMPEG基本概念"><a href="#FFMPEG基本概念" class="headerlink" title="FFMPEG基本概念"></a>FFMPEG基本概念</h1><p>在讲解 FFMPEG 命令之前，我们先要介绍一些音视频格式的基要概念。</p><ul><li>音／视频流</li></ul><blockquote><p>在音视频领域，我们把一路音／视频称为一路<strong>流</strong>。如我们小时候经常使用VCD看港片，在里边可以选择粤语或国语声音，其实就是CD视频文件中存放了两路音频流，用户可以选择其中一路进行播放。</p></blockquote><ul><li>容器</li></ul><blockquote><p>我们一般把 MP4､ FLV、MOV等文件格式称之为<strong>容器</strong>。也就是在这些常用格式文件中，可以存放多路音视频文件。以 MP4 为例，就可以存放一路视频流，多路音频流，多路字幕流。</p></blockquote><ul><li>channel</li></ul><blockquote><p>channel是音频中的概念，称之为声道。在一路音频流中，可以有单声道，双声道或立体声。</p></blockquote><h1 id="FFMPEG-命令"><a href="#FFMPEG-命令" class="headerlink" title="FFMPEG 命令"></a>FFMPEG 命令</h1><p>我们按使用目的可以将 FFMPEG 命令分成以下几类：</p><ul><li>基本信息查询命令</li><li>录制</li><li>分解/复用</li><li>处理原始数据</li><li>滤镜</li><li>切割与合并</li><li>图／视互转</li><li>直播相关</li></ul><p>除了 FFMPEG 的基本信息查询命令外，其它命令都按下图所示的流程处理音视频。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> _______              ______________</span><br><span class="line">|       |            |              |</span><br><span class="line">| input |  demuxer   | encoded data |   decoder</span><br><span class="line">| file  | ---------&gt; | packets      | -----+</span><br><span class="line">|_______|            |______________|      |</span><br><span class="line">                                           v</span><br><span class="line">                                       _________</span><br><span class="line">                                      |         |</span><br><span class="line">                                      | decoded |</span><br><span class="line">                                      | frames  |</span><br><span class="line">                                      |_________|</span><br><span class="line"> ________             ______________       |</span><br><span class="line">|        |           |              |      |</span><br><span class="line">| output | &lt;-------- | encoded data | &lt;----+</span><br><span class="line">| file   |   muxer   | packets      |   encoder</span><br><span class="line">|________|           |______________|</span><br></pre></td></tr></table></figure><p>ffmpeg调用libavformat库（包含demuxers）来读取输入文件并获取包含编码数据的数据包。 当有多个输入文件时，ffmpeg会尝试通过跟踪任何活动输入流上的最低时间戳来使其保持同步。</p><p>然后将编码的数据包传送给解码器（除非为数据流选择了流拷贝，请参阅进一步描述）。 解码器产生未压缩的帧（原始视频/ PCM音频/ …），可以通过滤波进一步处理（见下一节）。 在过滤之后，帧被传递到编码器，编码器并输出编码的数据包。 最后，这些传递给复用器，将编码的数据包写入输出文件。</p><p>默认情况下，ffmpeg只包含输入文件中每种类型（视频，音频，字幕）的一个流，并将其添加到每个输出文件中。 它根据以下标准挑选每一个的“最佳”：对于视频，它是具有最高分辨率的流，对于音频，它是具有最多channel的流，对于字幕，是第一个字幕流。 在相同类型的几个流相等的情况下，选择具有最低索引的流。</p><p>您可以通过使用-vn / -an / -sn / -dn选项来禁用某些默认设置。 要进行全面的手动控制，请使用-map选项，该选项禁用刚描述的默认设置。</p><p>下面我们就来详细介绍一下这些命令。</p><h2 id="基本信息查询命令"><a href="#基本信息查询命令" class="headerlink" title="基本信息查询命令"></a>基本信息查询命令</h2><p>FFMPEG 可以使用下面的参数进行基本信息查询。例如，想查询一下现在使用的 FFMPEG 都支持哪些 filter，就可以用 <code>ffmpeg -filters</code> 来查询。详细参数说明如下：</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-version</td><td align="left">显示版本。</td></tr><tr><td align="left">-formats</td><td align="left">显示可用的格式（包括设备）。</td></tr><tr><td align="left">-demuxers</td><td align="left">显示可用的demuxers。</td></tr><tr><td align="left">-muxers</td><td align="left">显示可用的muxers。</td></tr><tr><td align="left">-devices</td><td align="left">显示可用的设备。</td></tr><tr><td align="left">-codecs</td><td align="left">显示libavcodec已知的所有编解码器。</td></tr><tr><td align="left">-decoders</td><td align="left">显示可用的解码器。</td></tr><tr><td align="left">-encoders</td><td align="left">显示所有可用的编码器。</td></tr><tr><td align="left">-bsfs</td><td align="left">显示可用的比特流filter。</td></tr><tr><td align="left">-protocols</td><td align="left">显示可用的协议。</td></tr><tr><td align="left">-filters</td><td align="left">显示可用的libavfilter过滤器。</td></tr><tr><td align="left">-pix_fmts</td><td align="left">显示可用的像素格式。</td></tr><tr><td align="left">-sample_fmts</td><td align="left">显示可用的采样格式。</td></tr><tr><td align="left">-layouts</td><td align="left">显示channel名称和标准channel布局。</td></tr><tr><td align="left">-colors</td><td align="left">显示识别的颜色名称。</td></tr></tbody></table><p>接下来介绍的是 FFMPEG 处理音视频时使用的命令格式与参数。</p><h2 id="命令基本格式及参数"><a href="#命令基本格式及参数" class="headerlink" title="命令基本格式及参数"></a>命令基本格式及参数</h2><p>下面是 FFMPEG 的基本命令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg [global_options] &#123;[input_file_options] -i input_url&#125; ...</span><br><span class="line"> &#123;[output_file_options] output_url&#125; ...</span><br></pre></td></tr></table></figure><p>ffmpeg 通过 -i 选项读取输任意数量的输入“文件”（可以是常规文件，管道，网络流，抓取设备等，并写入任意数量的输出“文件”。</p><p>原则上，每个输入/输出“文件”都可以包含任意数量的不同类型的视频流（视频/音频/字幕/附件/数据）。 流的数量和/或类型是由容器格式来限制。 选择从哪个输入进入到哪个输出将自动完成或使用 -map 选项。</p><p>要引用选项中的输入文件，您必须使用它们的索引（从0开始）。 例如。 第一个输入文件是0，第二个输入文件是1，等等。类似地，文件内的流被它们的索引引用。 例如。 2：3是指第三个输入文件中的第四个流。</p><p>上面就是 FFMPEG 处理音视频的常用命令，下面是一些常用参数：</p><h3 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h3><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-f fmt（输入/输出）</td><td align="left">强制输入或输出文件格式。 格式通常是自动检测输入文件，并从输出文件的文件扩展名中猜测出来，所以在大多数情况下这个选项是不需要的。</td></tr><tr><td align="left">-i url（输入）</td><td align="left">输入文件的网址</td></tr><tr><td align="left">-y（全局参数）</td><td align="left">覆盖输出文件而不询问。</td></tr><tr><td align="left">-n（全局参数）</td><td align="left">不要覆盖输出文件，如果指定的输出文件已经存在，请立即退出。</td></tr><tr><td align="left">-c [：stream_specifier] codec（输入/输出，每个流）</td><td align="left">选择一个编码器（当在输出文件之前使用）或解码器（当在输入文件之前使用时）用于一个或多个流。codec 是解码器/编码器的名称或 copy（仅输出）以指示该流不被重新编码。如：ffmpeg -i INPUT -map 0 -c:v libx264 -c:a copy OUTPUT</td></tr><tr><td align="left">-codec [：stream_specifier]编解码器（输入/输出，每个流）</td><td align="left">同 -c</td></tr><tr><td align="left">-t duration（输入/输出）</td><td align="left">当用作输入选项（在-i之前）时，限制从输入文件读取的数据的持续时间。当用作输出选项时（在输出url之前），在持续时间到达持续时间之后停止输出。</td></tr><tr><td align="left">-ss位置（输入/输出）</td><td align="left">当用作输入选项时（在-i之前），在这个输入文件中寻找位置。 请注意，在大多数格式中，不可能精确搜索，因此ffmpeg将在位置之前寻找最近的搜索点。 当转码和-accurate_seek被启用时（默认），搜索点和位置之间的这个额外的分段将被解码和丢弃。 当进行流式复制或使用-noaccurate_seek时，它将被保留。当用作输出选项（在输出url之前）时，解码但丢弃输入，直到时间戳到达位置。</td></tr><tr><td align="left">-frames [：stream_specifier] framecount（output，per-stream）</td><td align="left">停止在帧计数帧之后写入流。</td></tr><tr><td align="left">-filter [：stream_specifier] filtergraph（output，per-stream）</td><td align="left">创建由filtergraph指定的过滤器图，并使用它来过滤流。filtergraph是应用于流的filtergraph的描述，并且必须具有相同类型的流的单个输入和单个输出。在过滤器图形中，输入与标签中的标签相关联，标签中的输出与标签相关联。有关filtergraph语法的更多信息，请参阅ffmpeg-filters手册。</td></tr></tbody></table><h3 id="视频参数"><a href="#视频参数" class="headerlink" title="视频参数"></a>视频参数</h3><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-vframes num（输出）</td><td align="left">设置要输出的视频帧的数量。对于-frames：v，这是一个过时的别名，您应该使用它。</td></tr><tr><td align="left">-r [：stream_specifier] fps（输入/输出，每个流）</td><td align="left">设置帧率（Hz值，分数或缩写）。作为输入选项，忽略存储在文件中的任何时间戳，根据速率生成新的时间戳。这与用于-framerate选项不同（它在FFmpeg的旧版本中使用的是相同的）。如果有疑问，请使用-framerate而不是输入选项-r。作为输出选项，复制或丢弃输入帧以实现恒定输出帧频fps。</td></tr><tr><td align="left">-s [：stream_specifier]大小（输入/输出，每个流）</td><td align="left">设置窗口大小。作为输入选项，这是video_size专用选项的快捷方式，由某些分帧器识别，其帧尺寸未被存储在文件中。作为输出选项，这会将缩放视频过滤器插入到相应过滤器图形的末尾。请直接使用比例过滤器将其插入到开头或其他地方。格式是’wxh’（默认 - 与源相同）。</td></tr><tr><td align="left">-aspect [：stream_specifier] 宽高比（输出，每个流）</td><td align="left">设置方面指定的视频显示宽高比。aspect可以是浮点数字符串，也可以是num：den形式的字符串，其中num和den是宽高比的分子和分母。例如“4：3”，“16：9”，“1.3333”和“1.7777”是有效的参数值。如果与-vcodec副本一起使用，则会影响存储在容器级别的宽高比，但不会影响存储在编码帧中的宽高比（如果存在）。</td></tr><tr><td align="left">-vn（输出）</td><td align="left">禁用视频录制。</td></tr><tr><td align="left">-vcodec编解码器（输出）</td><td align="left">设置视频编解码器。这是-codec：v的别名。</td></tr><tr><td align="left">-vf filtergraph（输出）</td><td align="left">创建由filtergraph指定的过滤器图，并使用它来过滤流。</td></tr></tbody></table><h3 id="音频参数"><a href="#音频参数" class="headerlink" title="音频参数"></a>音频参数</h3><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-aframes（输出）</td><td align="left">设置要输出的音频帧的数量。这是-frames：a的一个过时的别名。</td></tr><tr><td align="left">-ar [：stream_specifier] freq（输入/输出，每个流）</td><td align="left">设置音频采样频率。对于输出流，它默认设置为相应输入流的频率。对于输入流，此选项仅适用于音频捕获设备和原始分路器，并映射到相应的分路器选件。</td></tr><tr><td align="left">-ac [：stream_specifier]通道（输入/输出，每个流）</td><td align="left">设置音频通道的数量。对于输出流，它默认设置为输入音频通道的数量。对于输入流，此选项仅适用于音频捕获设备和原始分路器，并映射到相应的分路器选件。</td></tr><tr><td align="left">-an（输出）</td><td align="left">禁用录音。</td></tr><tr><td align="left">-acodec编解码器（输入/输出）</td><td align="left">设置音频编解码器。这是-codec的别名：a。</td></tr><tr><td align="left">-sample_fmt [：stream_specifier] sample_fmt（输出，每个流）</td><td align="left">设置音频采样格式。使用-sample_fmts获取支持的样本格式列表。</td></tr><tr><td align="left">-af filtergraph（输出）</td><td align="left">创建由filtergraph指定的过滤器图，并使用它来过滤流。</td></tr></tbody></table><p>了解了这些基本信息后，接下来我们看看 FFMPEG 具体都能干些什么吧。</p><h2 id="录制"><a href="#录制" class="headerlink" title="录制"></a>录制</h2><p>首先通过下面的命令查看一下 mac 上都有哪些设备。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f avfoundation -list_devices true -i &quot;&quot;</span><br></pre></td></tr></table></figure><p><strong>录屏</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f avfoundation -i 1 -r 30 out.yuv</span><br></pre></td></tr></table></figure><ul><li>-f 指定使用 avfoundation 采集数据。</li><li>-i 指定从哪儿采集数据，它是一个文件索引号。在我的MAC上，1代表桌面（可以通过上面的命令查询设备索引号）。</li><li>-r 指定帧率。按ffmpeg官方文档说-r与-framerate作用相同，但实际测试时发现不同。-framerate 用于限制输入，而-r用于限制输出。</li></ul><blockquote><p>注意，桌面的输入对帧率没有要求，所以不用限制桌面的帧率。其实限制了也没用。</p></blockquote><p><strong>录屏+声音</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -f avfoundation -i 1:0  -r 29.97 -c:v libx264 -crf 0 -c:a libfdk_aac -profile:a aac_he_v2 -b:a 32k  out.flv</span><br></pre></td></tr></table></figure><ul><li>-i 1:0 冒号前面的 “1” 代表的屏幕索引号。冒号后面的”0”代表的声音索相号。</li><li>-c:v 与参数 -vcodec 一样，表示视频编码器。c 是 codec 的缩写，v 是video的缩写。</li><li>-crf 是 x264 的参数。 0 表式无损压缩。</li><li>-c:a 与参数 -acodec 一样，表示音频编码器。</li><li>-profile 是 fdk_aac 的参数。 aac_he_v2 表式使用 AAC_HE v2 压缩数据。</li><li>-b:a 指定音频码率。 b 是 bitrate的缩写, a是 audio的缩与。</li></ul><p><strong>Linux下录屏</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f x11grab -s 640*480 -r 20 -i :0.0 test.mp4</span><br></pre></td></tr></table></figure><p><strong>录视频</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -framerate 30 -f avfoundation -i 0 out.mp4</span><br></pre></td></tr></table></figure><ul><li>-framerate 限制视频的采集帧率。这个必须要根据提示要求进行设置，如果不设置就会报错。</li><li>-f 指定使用 avfoundation 采集数据。</li><li>-i 指定视频设备的索引号。</li></ul><p><strong>视频+音频</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -framerate 30 -f avfoundation -i 0:0 out.mp4</span><br></pre></td></tr></table></figure><p><strong>录音</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f avfoundation -i :0 out.wav</span><br></pre></td></tr></table></figure><p><strong>录制音频裸数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -f avfoundation -i :0 -ar 44100 -f s16le out.pcm</span><br></pre></td></tr></table></figure><p><strong>在Windows下录制播放的声音</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -f dshow -i audio&#x3D;&quot;立体声混音 (Realtek High Definition Audio)&quot; -ar 48000  -acodec aac -bsf:a aac_adtstoasc -f flv temp.flv</span><br></pre></td></tr></table></figure><h2 id="分解与复用"><a href="#分解与复用" class="headerlink" title="分解与复用"></a>分解与复用</h2><p>流拷贝是通过将 copy 参数提供给-codec选项来选择流的模式。它使得ffmpeg省略了指定流的解码和编码步骤，所以它只能进行多路分解和多路复用。 这对于更改容器格式或修改容器级元数据很有用。 在这种情况下，上图将简化为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> _______              ______________            ________</span><br><span class="line">|       |            |              |          |        |</span><br><span class="line">| input |  demuxer   | encoded data |  muxer   | output |</span><br><span class="line">| file  | ---------&gt; | packets      | -------&gt; | file   |</span><br><span class="line">|_______|            |______________|          |________|</span><br></pre></td></tr></table></figure><p>由于没有解码或编码，速度非常快，没有质量损失。 但是，由于许多因素，在某些情况下可能无法正常工作。 应用过滤器显然也是不可能的，因为过滤器处理未压缩的数据。</p><p><strong>抽取音频流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -acodec copy -vn out.aac</span><br></pre></td></tr></table></figure><ul><li>acodec: 指定音频编码器，copy 指明只拷贝，不做编解码。</li><li>vn: v 代表视频，n 代表 no 也就是无视频的意思。</li></ul><p><strong>抽取视频流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -vcodec copy -an out.h264</span><br></pre></td></tr></table></figure><ul><li>vcodec: 指定视频编码器，copy 指明只拷贝，不做编解码。</li><li>an: a 代表视频，n 代表 no 也就是无音频的意思。</li></ul><p><strong>转格式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -vcodec copy -acodec copy out.flv</span><br></pre></td></tr></table></figure><p>上面的命令表式的是音频、视频都直接 copy，只是将 mp4 的封装格式转成了flv。</p><p><strong>音视频合并</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.h264 -i out.aac -vcodec copy -acodec copy out.mp4</span><br></pre></td></tr></table></figure><h2 id="处理原始数据"><a href="#处理原始数据" class="headerlink" title="处理原始数据"></a>处理原始数据</h2><p><strong>提取YUV数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -an -c:v rawvideo -pix_fmt yuv420p out.yuv</span><br><span class="line">ffplay -s wxh out.yuv</span><br></pre></td></tr></table></figure><ul><li>-c:v rawvideo 指定将视频转成原始数据</li><li>-pix_fmt yuv420p 指定转换格式为yuv420p</li></ul><p><strong>YUV转H264</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f rawvideo -pix_fmt yuv420p -s 320x240 -r 30 -i out.yuv -c:v libx264 -f rawvideo out.h264</span><br></pre></td></tr></table></figure><p><strong>提取PCM数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -vn -ar 44100 -ac 2 -f s16le out.pcm</span><br><span class="line">ffplay -ar 44100 -ac 2 -f s16le -i out.pcm</span><br></pre></td></tr></table></figure><p><strong>PCM转WAV</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f s16be -ar 8000 -ac 2 -acodec pcm_s16be -i input.raw output.wav</span><br></pre></td></tr></table></figure><h2 id="滤镜"><a href="#滤镜" class="headerlink" title="滤镜"></a>滤镜</h2><p>在编码之前，ffmpeg可以使用libavfilter库中的过滤器处理原始音频和视频帧。 几个链式过滤器形成一个过滤器图形。 ffmpeg区分两种类型的过滤器图形：简单和复杂。</p><h3 id="简单滤镜"><a href="#简单滤镜" class="headerlink" title="简单滤镜"></a>简单滤镜</h3><p>简单的过滤器图是那些只有一个输入和输出，都是相同的类型。 在上面的图中，它们可以通过在解码和编码之间插入一个额外的步骤来表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> _________                        ______________</span><br><span class="line">|         |                      |              |</span><br><span class="line">| decoded |                      | encoded data |</span><br><span class="line">| frames  |\                   _ | packets      |</span><br><span class="line">|_________| \                  &#x2F;||______________|</span><br><span class="line">             \   __________   &#x2F;</span><br><span class="line">  simple     _\||          | &#x2F;  encoder</span><br><span class="line">  filtergraph   | filtered |&#x2F;</span><br><span class="line">                | frames   |</span><br><span class="line">                |__________|</span><br></pre></td></tr></table></figure><p>简单的filtergraphs配置了per-stream-filter选项（分别为视频和音频使用-vf和-af别名）。 一个简单的视频filtergraph可以看起来像这样的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> _______        _____________        _______        ________</span><br><span class="line">|       |      |             |      |       |      |        |</span><br><span class="line">| input | ---&gt; | deinterlace | ---&gt; | scale | ---&gt; | output |</span><br><span class="line">|_______|      |_____________|      |_______|      |________|</span><br></pre></td></tr></table></figure><p>请注意，某些滤镜会更改帧属性，但不会改变帧内容。 例如。 上例中的fps过滤器会改变帧数，但不会触及帧内容。 另一个例子是setpts过滤器，它只设置时间戳，否则不改变帧。</p><h3 id="复杂滤镜"><a href="#复杂滤镜" class="headerlink" title="复杂滤镜"></a>复杂滤镜</h3><p>复杂的过滤器图是那些不能简单描述为应用于一个流的线性处理链的过滤器图。 例如，当图形有多个输入和/或输出，或者当输出流类型与输入不同时，就是这种情况。 他们可以用下图来表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> _________</span><br><span class="line">|         |</span><br><span class="line">| input 0 |\                    __________</span><br><span class="line">|_________| \                  |          |</span><br><span class="line">             \   _________    &#x2F;| output 0 |</span><br><span class="line">              \ |         |  &#x2F; |__________|</span><br><span class="line"> _________     \| complex | &#x2F;</span><br><span class="line">|         |     |         |&#x2F;</span><br><span class="line">| input 1 |----&gt;| filter  |\</span><br><span class="line">|_________|     |         | \   __________</span><br><span class="line">               &#x2F;| graph   |  \ |          |</span><br><span class="line">              &#x2F; |         |   \| output 1 |</span><br><span class="line"> _________   &#x2F;  |_________|    |__________|</span><br><span class="line">|         | &#x2F;</span><br><span class="line">| input 2 |&#x2F;</span><br><span class="line">|_________|</span><br></pre></td></tr></table></figure><p>复杂的过滤器图使用-filter_complex选项进行配置。 请注意，此选项是全局性的，因为复杂的过滤器图形本质上不能与单个流或文件明确关联。</p><p>-lavfi选项等同于-filter_complex。</p><p>一个复杂的过滤器图的一个简单的例子是覆盖过滤器，它有两个视频输入和一个视频输出，包含一个视频叠加在另一个上面。 它的音频对应是amix滤波器。</p><p><strong>添加水印</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4  -vf &quot;movie&#x3D;logo.png,scale&#x3D;64:48[watermask];[in][watermask] overlay&#x3D;30:10 [out]&quot; water.mp4</span><br></pre></td></tr></table></figure><ul><li>-vf中的 movie 指定logo位置。scale 指定 logo 大小。overlay 指定 logo 摆放的位置。</li></ul><p><strong>删除水印</strong><br>先通过 ffplay 找到要删除 LOGO 的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffplay -i test.flv -vf delogo&#x3D;x&#x3D;806:y&#x3D;20:w&#x3D;70:h&#x3D;80:show&#x3D;1</span><br></pre></td></tr></table></figure><p>使用 delogo 滤镜删除 LOGO</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.flv -vf delogo&#x3D;x&#x3D;806:y&#x3D;20:w&#x3D;70:h&#x3D;80 output.flv</span><br></pre></td></tr></table></figure><p><strong>视频缩小一倍</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -vf scale&#x3D;iw&#x2F;2:-1 scale.mp4</span><br></pre></td></tr></table></figure><ul><li>-vf scale 指定使用简单过滤器 scale，iw/2:-1 中的 iw 指定按整型取视频的宽度。 -1 表示高度随宽度一起变化。</li></ul><p><strong>视频裁剪</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i VR.mov  -vf crop&#x3D;in_w-200:in_h-200 -c:v libx264 -c:a copy -video_size 1280x720 vr_new.mp4</span><br></pre></td></tr></table></figure><p>crop 格式：crop=out_w:out_h:x:y</p><ul><li>out_w: 输出的宽度。可以使用 in_w 表式输入视频的宽度。</li><li>out_h: 输出的高度。可以使用 in_h 表式输入视频的高度。</li><li>x : X坐标</li><li>y : Y坐标</li></ul><blockquote><p>如果 x和y 设置为 0,说明从左上角开始裁剪。如果不写是从中心点裁剪。</p></blockquote><p><strong>倍速播放</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -filter_complex &quot;[0:v]setpts&#x3D;0.5*PTS[v];[0:a]atempo&#x3D;2.0[a]&quot; -map &quot;[v]&quot; -map &quot;[a]&quot; speed2.0.mp4</span><br></pre></td></tr></table></figure><ul><li>-filter_complex 复杂滤镜，[0:v]表示第一个（文件索引号是0）文件的视频作为输入。setpts=0.5*PTS表示每帧视频的pts时间戳都乘0.5 ，也就是差少一半。[v]表示输出的别名。音频同理就不详述了。</li><li>map 可用于处理复杂输出，如可以将指定的多路流输出到一个输出文件，也可以指定输出到多个文件。”[v]” 复杂滤镜输出的别名作为输出文件的一路流。上面 map的用法是将复杂滤镜输出的视频和音频输出到指定文件中。</li></ul><p><strong>对称视频</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -i out.mp4 -filter_complex &quot;[0:v]pad&#x3D;w&#x3D;2*iw[a];[0:v]hflip[b];[a][b]overlay&#x3D;x&#x3D;w&quot; duicheng.mp4</span><br></pre></td></tr></table></figure><ul><li>hflip 水平翻转</li></ul><p>如果要修改为垂直翻转可以用vflip。</p><p><strong>画中画</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -i out1.mp4 -filter_complex &quot;[1:v]scale&#x3D;w&#x3D;176:h&#x3D;144:force_original_aspect_ratio&#x3D;decrease[ckout];[0:v][ckout]overlay&#x3D;x&#x3D;W-w-10:y&#x3D;0[out]&quot; -map &quot;[out]&quot; -movflags faststart new.mp4</span><br></pre></td></tr></table></figure><p><strong>录制画中画</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -f avfoundation -i &quot;1&quot; -framerate 30 -f avfoundation -i &quot;0:0&quot;</span><br><span class="line">-r 30 -c:v libx264 -preset ultrafast</span><br><span class="line">-c:a libfdk_aac -profile:a aac_he_v2 -ar 44100 -ac 2</span><br><span class="line">-filter_complex &quot;[1:v]scale&#x3D;w&#x3D;176:h&#x3D;144:force_original_aspect_ratio&#x3D;decrease[a];[0:v][a]overlay&#x3D;x&#x3D;W-w-10:y&#x3D;0[out]&quot;</span><br><span class="line">-map &quot;[out]&quot; -movflags faststart -map 1:a b.mp4</span><br></pre></td></tr></table></figure><p><strong>多路视频拼接</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -f avfoundation -i &quot;1&quot; -framerate 30 -f avfoundation   -i &quot;0:0&quot; -r 30 -c:v libx264 -preset ultrafast -c:a libfdk_aac -profile:a aac_he_v2 -ar 44100 -ac 2 -filter_complex &quot;[0:v]scale&#x3D;320:240[a];[a]pad&#x3D;640:240[b];[b][1:v]overlay&#x3D;320:0[out]&quot; -map &quot;[out]&quot; -movflags faststart  -map 1:a  c.mp4</span><br></pre></td></tr></table></figure><p><strong>滤镜加水印</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i killer.mp4 -filter_complex &quot;movie&#x3D;.&#x2F;logo&#x2F;daka.png,scale&#x3D;64:48[w];[0:v]curves&#x3D;vintage[o];[o][w]overlay&#x3D;30:10[out]&quot; -map &quot;[out]&quot; -map 0:a test1.mp4</span><br></pre></td></tr></table></figure><p><strong>多张图片合成一张</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i killer.mp4 -vf &quot;select&#x3D;not(mod(n\,250)),scale&#x3D;320:240,tile&#x3D;2x3&quot; -an  out%3d.png</span><br></pre></td></tr></table></figure><h2 id="一些比较有意思的滤镜"><a href="#一些比较有意思的滤镜" class="headerlink" title="一些比较有意思的滤镜"></a>一些比较有意思的滤镜</h2><ul><li><p>镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crop&#x3D;iw&#x2F;2:ih:0:0,split[left][tmp];[tmp]hflip[right];</span><br></pre></td></tr></table></figure></li><li><p>复古</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curves&#x3D;vintage;</span><br></pre></td></tr></table></figure></li><li><p>光晕</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vignette&#x3D;PI&#x2F;4</span><br></pre></td></tr></table></figure></li><li><p>变暗</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colorlevels&#x3D;rimin&#x3D;0.058:gimin&#x3D;0.058:bimin&#x3D;0.058</span><br></pre></td></tr></table></figure></li><li><p>增加对比度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fftfilt&#x3D;dc_Y&#x3D;0:weight_Y&#x3D;&#39;exp(-4 * ((Y+X)&#x2F;(W+H)))</span><br></pre></td></tr></table></figure></li><li><p>降噪</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hqdn3d&#x3D;luma_spatial&#x3D;15.0</span><br></pre></td></tr></table></figure></li><li><p>强对比度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curves&#x3D;strong_contrast</span><br></pre></td></tr></table></figure></li><li><p>变亮</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curves&#x3D;lighter</span><br></pre></td></tr></table></figure></li><li><p>锐化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fftfilt&#x3D;dc_Y&#x3D;0:weight_Y&#x3D;&#39;1+squish(1-(Y+X)&#x2F;100)&#39;</span><br></pre></td></tr></table></figure></li><li><p>低通滤波</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fftfilt&#x3D;dc_Y&#x3D;0:weight_Y&#x3D;&#39;squish((Y+X)&#x2F;100-1)&#39;</span><br></pre></td></tr></table></figure></li><li><p>高通滤波</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fftfilt&#x3D;dc_Y&#x3D;128:weight_Y&#x3D;&#39;squish(1-(Y+X)&#x2F;100)&#39;</span><br></pre></td></tr></table></figure></li><li><p>复古</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curves&#x3D;vintage</span><br></pre></td></tr></table></figure></li><li><p>边缘检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edgedetect</span><br></pre></td></tr></table></figure></li><li><p>底片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">negate</span><br></pre></td></tr></table></figure></li><li><p>彩色底片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curves &#x3D; ‘none’‘color_negative’</span><br></pre></td></tr></table></figure></li></ul><h2 id="音视频的拼接与裁剪"><a href="#音视频的拼接与裁剪" class="headerlink" title="音视频的拼接与裁剪"></a>音视频的拼接与裁剪</h2><p><strong>裁剪</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -ss 00:00:00 -t 10 out1.mp4</span><br></pre></td></tr></table></figure><ul><li>-ss 指定裁剪的开始时间，精确到秒</li><li>-t 被裁剪后的时长。</li></ul><p><strong>视频合并</strong></p><p>首先创建一个 inputs.txt 文件，文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file &#39;1.flv&#39;</span><br><span class="line">file &#39;2.flv&#39;</span><br><span class="line">file &#39;3.flv&#39;</span><br></pre></td></tr></table></figure><p>然后执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f concat -i inputs.txt -c copy output.flv</span><br></pre></td></tr></table></figure><p><strong>音频合并</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i text.mp3 -i silenceall.mp3 -filter_complex &#39;[0:0] [1:0] concat&#x3D;n&#x3D;2:v&#x3D;0:a&#x3D;1 [a]&#39; -map [a] test.mp3</span><br></pre></td></tr></table></figure><p><strong>音频混音</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.mp4 -i test.mp3 -filter_complex &quot;[0:a] [1:a]amerge&#x3D;inputs&#x3D;2[aout]&quot; -map &quot;[aout]&quot; -ac 2 mix_amerge.aac</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i INPUT1 -i INPUT2 -i INPUT3 -filter_complex &#39;amix&#x3D;inputs&#x3D;3:duration&#x3D;first:dropout_transition&#x3D;3&#39; OUTPUT</span><br></pre></td></tr></table></figure><ul><li>inputs: The number of inputs. If unspecified, it defaults to 2.//输入的数量，如果没有指明，默认为2.</li><li>duration: How to determine the end-of-stream.//决定了流的结束</li><li>longest: The duration of the longest input. (default)//最长输入的持续时间</li><li>shortest: The duration of the shortest input.//最短输入的持续时间</li><li>first: The duration of the first input.//第一个输入的持续时间</li><li>dropout_transition: The transition time, in seconds, for volume renormalization when an input stream ends. The default value is 2 seconds.//输入流结束时（音频）容量重整化的转换时间（以秒为单位）。 默认值为2秒。</li></ul><blockquote><p>注： amerge 与amix 的区别<br>amerge terminates with the shortest input (always) and amix terminates with the longest input, by default. So the former will always truncate when streams are of different length.</p></blockquote><p><strong>hls切片</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -c:v libx264 -c:a libfdk_aac -strict -2 -f hls  out.m3u8</span><br></pre></td></tr></table></figure><ul><li>-strict -2 指明音频使有AAC。</li><li>-f hls 转成 m3u8 格式。</li></ul><p><strong>将ts文件按时间切片</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -i somefile.ts  -f segment -segment_time 3  -c copy out%03d.ts</span><br></pre></td></tr></table></figure><h2 id="视频图片互转"><a href="#视频图片互转" class="headerlink" title="视频图片互转"></a>视频图片互转</h2><p><strong>视频转JPEG</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.flv -r 1 -f image2 image-%3d.jpeg</span><br></pre></td></tr></table></figure><p><strong>视频转gif</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -ss 00:00:00 -t 10 out.gif</span><br></pre></td></tr></table></figure><p><strong>图片转视频</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -f image2 -i image-%3d.jpeg images.mp4</span><br></pre></td></tr></table></figure><p><strong>一张图片转成5秒视频</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -loop 1 -i .&#x2F;xxx.jpeg -pix_fmt yuv420p -c:v libx264 -preset veryfast -r 25 -t 5 b.mp4</span><br></pre></td></tr></table></figure><h2 id="直播相关"><a href="#直播相关" class="headerlink" title="直播相关"></a>直播相关</h2><p><strong>推流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i out.mp4 -c copy -f flv rtmp:&#x2F;&#x2F;server&#x2F;live&#x2F;streamName</span><br></pre></td></tr></table></figure><ul><li>re的含义 ，Read input at native frame rate. Mainly used to simulate a grab device, or live input stream (e.g. when reading from a file). Should not be used with actual grab devices or live input streams (where it can cause packet loss). By default ffmpeg attempts to read the input(s) as fast as possible. This option will slow down the reading of the input(s) to the native frame rate of the input(s). It is useful for real-time output (e.g. live streaming).</li></ul><p><strong>推rtsp流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i input -f rtsp -muxdelay 0.1 rtsp:&#x2F;&#x2F;server&#x2F;live.sdp</span><br></pre></td></tr></table></figure><p><strong>循环推流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -stream_loop 1 -i out.mp4  -c copy -f flv rtmp:&#x2F;&#x2F;server&#x2F;live&#x2F;streamName</span><br></pre></td></tr></table></figure><p><strong>拉流保存</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i rtmp:&#x2F;&#x2F;server&#x2F;live&#x2F;streamName -c copy dump.flv</span><br></pre></td></tr></table></figure><p><strong>转流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i rtmp:&#x2F;&#x2F;server&#x2F;live&#x2F;originalStream -c:a copy -c:v copy -f flv rtmp:&#x2F;&#x2F;server&#x2F;live&#x2F;h264Stream</span><br></pre></td></tr></table></figure><p><strong>实时推流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -framerate 15 -f avfoundation -i &quot;1&quot; -s 1280x720 -c:v libx264  -f  flv rtmp:&#x2F;&#x2F;localhost:1935&#x2F;live&#x2F;room</span><br></pre></td></tr></table></figure><h2 id="ffplay"><a href="#ffplay" class="headerlink" title="ffplay"></a>ffplay</h2><p><strong>播放YUV 数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffplay -pix_fmt nv12 -s 192x144 1.yuv</span><br></pre></td></tr></table></figure><p><strong>播放YUV中的 Y平面</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffplay -pix_fmt nv21 -s 640x480 -vf extractplanes&#x3D;&#39;y&#39; 1.yuv</span><br></pre></td></tr></table></figure><h2 id="查看多媒体文件详细信息"><a href="#查看多媒体文件详细信息" class="headerlink" title="查看多媒体文件详细信息"></a>查看多媒体文件详细信息</h2><p><strong>输出每路流最详细的信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffprobe -print_format json -show_streams 多媒体文件</span><br></pre></td></tr></table></figure><p><strong>输出帧信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffprobe -show_frames  多媒体文件</span><br></pre></td></tr></table></figure><p><strong>输出包信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffprobe -show_packets 多媒体文件</span><br></pre></td></tr></table></figure><h2 id="我的ffmpeg视频课地址"><a href="#我的ffmpeg视频课地址" class="headerlink" title="我的ffmpeg视频课地址"></a>我的ffmpeg视频课地址</h2><p><a href="http://www.imooc.com/u/4873493/courses?sort=publish" target="_blank" rel="noopener">课程主页地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 音视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入剖析WebRTC之事件机制Slot</title>
      <link href="/a35f406b/"/>
      <url>/a35f406b/</url>
      
        <content type="html"><![CDATA[<p>我最早了解到 sigslot 大概是在 2007年 左右，当时在QT中大量使用了 sigslot 的概念。 现在 WebRTC 中也大量使用了 sigslot 这种机制来处理底层的事件。它对我们阅读WebRTC代码至关重要。本篇文章就详细介绍一下 sigslot。</p><a id="more"></a><h2 id="Sigslot作用"><a href="#Sigslot作用" class="headerlink" title="Sigslot作用"></a>Sigslot作用</h2><p>Sigslot 的作用一句话表式就是为了<strong>解耦</strong>。例如，有两个类 A 和 B，如果 B 使用 A, 就必须在 B 类中写入与 A 类有关的代码。看下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B(A&amp; a)&#123;</span><br><span class="line">m_a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcB</span><span class="params">()</span></span>&#123;</span><br><span class="line">m_a.funcA(); <span class="comment">//这里调用了A类的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">A m_a; <span class="comment">//引用 A 类型成员变量。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">A a;</span><br><span class="line"><span class="function">B <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">b.funcB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<strong>弊端</strong>是 B 中必须要声名使用 A。如果我们的项目特别复杂，这样的使用方式在后期维护时很容易让我们掉入“陷阱”。有没有一种通用的办法可以做到在 B 中不用使用 A 也可以调用 A 中的方法呢？答案就是使用 <strong>sigslot</strong>。我们看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> sigslot::has_slot&lt;&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">funcA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    sigslot::signal0&lt;&gt; sender;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在运行时才将 a 和 b 绑定到一起</span></span><br><span class="line">b.sender.<span class="built_in">connect</span>(&amp;a, &amp;A::funcA);</span><br><span class="line">b.sender();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以看到 B 中没有一行与 A 相关的代码。只在 main 函数中（也就是在运行时）才知道 A 与 B 有关联关系。是不是觉得很神奇呢？下面我们就看一下它的实现原理。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>sigslot的原理其实非常简单，它就是一个变化的观察者模式。观察者模式如下所示：</p><p><img data-src="http://upload-images.jianshu.io/upload_images/5956443-cd6a57418c8ff9fc.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""></p><p>观察者模式，首先让 Observer(“观察者”)对象 注册到 Subject(“被观察者”) 对象中。当 Subject 状态发生变化时，遍历所有注册到自己的 Observer 对象，并调用它们的 notify方法。</p><p>sigslot与观察者模式类似，它使用signal(“信号”)和slot(“槽”)，区别在于 signal 主动连接自己感兴趣的类及其方法，将它们保存到自己的列表中。当发射信号时，它遍历所有的连接，调用 slot（“槽”） 方法。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>下面我们看一下 WebRTC 中是如何使用 sigslot 的。</p><ul><li>首先，定义 slot(“槽”)，也就是事件处理函数。在WebRTC中定义槽必须继承 has_slots&lt;&gt;。如下图所示：</li></ul><p><img data-src="http://upload-images.jianshu.io/upload_images/5956443-9db34af78eb1e4ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""></p><ul><li><p>其次，定义 signal (“信号”) ，也就是发送的信号。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sigslot::signal1&lt;AsyncSocket*,</span><br><span class="line">           sigslot::multi_threaded_local&gt; SignalWriteEvent;</span><br></pre></td></tr></table></figure></li><li><p>然后，将 signal 与 slot 连接到一起。在这里就是将 AsyncUDPSocket和 OnWriteEvent方法与signal绑定到一起。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">socket_-&gt;SignalWriteEvent.<span class="built_in">connect</span>(<span class="keyword">this</span>,</span><br><span class="line">&amp;AsyncUDPSocket::OnWriteEvent);</span><br></pre></td></tr></table></figure></li><li><p>最后，发送信号。在 WebRTC中根据参数的不同定义了许多 signal，如 signal1 说明带一个参数，signal2说明带两个参数。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SignalWriteEvent(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><p>下面是对 sigslog 的类关系图及关键代码与其详细注释。</p><p><img data-src="http://upload-images.jianshu.io/upload_images/5956443-e2f8002c19fa7338.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// On our copy of sigslot.h, we set single threading as default.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSLOT_DEFAULT_MT_POLICY single_threaded</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(SIGSLOT_PURE_ISO) ||                   \</span></span><br><span class="line">    (!defined(WEBRTC_WIN) &amp;&amp; !defined(__GNUG__) &amp;&amp; \</span><br><span class="line">     !defined(SIGSLOT_USE_POSIX_THREADS))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SIGSLOT_SINGLE_THREADED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(WEBRTC_WIN)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SIGSLOT_HAS_WIN32_THREADS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(WIN32_LEAN_AND_MEAN)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"webrtc/rtc_base/win32.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__GNUG__) || defined(SIGSLOT_USE_POSIX_THREADS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SIGSLOT_HAS_POSIX_THREADS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SIGSLOT_SINGLE_THREADED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SIGSLOT_DEFAULT_MT_POLICY</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SIGSLOT_SINGLE_THREADED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSLOT_DEFAULT_MT_POLICY single_threaded</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSLOT_DEFAULT_MT_POLICY multi_threaded_local</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> change this namespace to rtc?</span></span><br><span class="line"><span class="keyword">namespace</span> sigslot &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//这面这大段代码是为了实现智能锁使用的。</span></span><br><span class="line"><span class="comment">//它会根据不同的平台初始化不同的互斥量，并调用不同的锁函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是 Window 平台</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SIGSLOT_HAS_WIN32_THREADS</span></span><br><span class="line"><span class="comment">// The multi threading policies only get compiled in if they are enabled.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是全局线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">multi_threaded_global</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  multi_threaded_global() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> isinitialised = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isinitialised) &#123;</span><br><span class="line">      InitializeCriticalSection(get_critsec());</span><br><span class="line">      isinitialised = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; EnterCriticalSection(get_critsec()); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; LeaveCriticalSection(get_critsec()); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function">CRITICAL_SECTION* <span class="title">get_critsec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> CRITICAL_SECTION g_critsec;</span><br><span class="line">    <span class="keyword">return</span> &amp;g_critsec;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是本地线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">multi_threaded_local</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  multi_threaded_local() &#123; InitializeCriticalSection(&amp;m_critsec); &#125;</span><br><span class="line"></span><br><span class="line">  multi_threaded_local(<span class="keyword">const</span> multi_threaded_local&amp;) &#123;</span><br><span class="line">    InitializeCriticalSection(&amp;m_critsec);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~multi_threaded_local() &#123; DeleteCriticalSection(&amp;m_critsec); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; EnterCriticalSection(&amp;m_critsec); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; LeaveCriticalSection(&amp;m_critsec); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  CRITICAL_SECTION m_critsec;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// _SIGSLOT_HAS_WIN32_THREADS</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//非window平台</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SIGSLOT_HAS_POSIX_THREADS</span></span><br><span class="line"><span class="comment">// The multi threading policies only get compiled in if they are enabled.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是全局线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">multi_threaded_global</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; pthread_mutex_lock(get_mutex()); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; pthread_mutex_unlock(get_mutex()); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span>* <span class="title">get_mutex</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是本地线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">multi_threaded_local</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  multi_threaded_local() &#123; pthread_mutex_init(&amp;m_mutex, <span class="literal">nullptr</span>); &#125;</span><br><span class="line">  multi_threaded_local(<span class="keyword">const</span> multi_threaded_local&amp;) &#123;</span><br><span class="line">    pthread_mutex_init(&amp;m_mutex, <span class="literal">nullptr</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ~multi_threaded_local() &#123; pthread_mutex_destroy(&amp;m_mutex); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; pthread_mutex_lock(&amp;m_mutex); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; pthread_mutex_unlock(&amp;m_mutex); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">pthread_mutex_t</span> m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// _SIGSLOT_HAS_POSIX_THREADS</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据不同的策略调用不同的锁。</span></span><br><span class="line"><span class="comment">//这里的策略就是不同的平台</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">mt_policy</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">lock_block</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  mt_policy* m_mutex;</span><br><span class="line"></span><br><span class="line">  lock_block(mt_policy* mtx) : m_mutex(mtx) &#123; m_mutex-&gt;lock(); &#125;</span><br><span class="line"></span><br><span class="line">  ~lock_block() &#123; m_mutex-&gt;unlock(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">signal_base_interface</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">has_slots_interface</span> &#123;</span></span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">signal_connect</span><span class="params">(_signal_base_interface* sender)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">signal_disconnect</span><span class="params">(_signal_base_interface* sender)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">disconnect_all</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">signal_base_interface</span> &#123;</span></span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">slot_disconnect</span><span class="params">(has_slots_interface* pslot)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">slot_duplicate</span><span class="params">(<span class="keyword">const</span> has_slots_interface* poldslot,</span></span></span><br><span class="line"><span class="function"><span class="params">                      has_slots_interface* pnewslot)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该类是一个特别重要的类</span></span><br><span class="line"><span class="comment">// signal与slot绑定之前，必须先将槽对象与槽方法组成 connection</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">opaque_connection</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">emit_t</span>)</span><span class="params">(<span class="keyword">const</span> _opaque_connection*)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//联合结构体，用于函数转换</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> FromT, <span class="keyword">typename</span> ToT&gt;</span><br><span class="line">  <span class="keyword">union</span> union_caster &#123;</span><br><span class="line">    FromT from;</span><br><span class="line">    ToT to;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//信号发射函数指针</span></span><br><span class="line">  <span class="keyword">emit_t</span> pemit;</span><br><span class="line">  <span class="comment">//存放“槽”对象</span></span><br><span class="line">  has_slots_interface* pdest;</span><br><span class="line">  <span class="comment">// Pointers to member functions may be up to 16 bytes for virtual classes,</span></span><br><span class="line">  <span class="comment">// so make sure we have enough space to store it.</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> pmethod[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  <span class="comment">//在构造connect时，要传入槽对象和槽类方法指针</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> DestT, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  _opaque_connection(DestT* pd, <span class="keyword">void</span> (DestT::*pm)(Args...)) : pdest(pd) &#123;</span><br><span class="line">    <span class="comment">//定义成员函数指针，与C语言中的函数指针是类似的</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(DestT::*<span class="keyword">pm_t</span>)</span><span class="params">(Args...)</span></span>;</span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(<span class="keyword">pm_t</span>) &lt;= <span class="keyword">sizeof</span>(pmethod),</span><br><span class="line">                  <span class="string">"Size of slot function pointer too large."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">memcpy</span>(pmethod, &amp;pm, <span class="keyword">sizeof</span>(<span class="keyword">pm_t</span>));</span><br><span class="line"></span><br><span class="line"> <span class="comment">//定义了一个函数指针</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">em_t</span>)</span><span class="params">(<span class="keyword">const</span> _opaque_connection* self, Args...)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过下面的方法，将 pemit 函数变理指向了 emitter 函数。</span></span><br><span class="line">    union_caster&lt;<span class="keyword">em_t</span>, <span class="keyword">emit_t</span>&gt; caster2;</span><br><span class="line">    <span class="comment">//注意 emitter后面的是模版参数，不是函数参数，这里不要弄混了。</span></span><br><span class="line">    caster2.from = &amp;_opaque_connection::emitter&lt;DestT, Args...&gt;;</span><br><span class="line">    pemit = caster2.to;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回"槽"对象</span></span><br><span class="line">  <span class="function">has_slots_interface* <span class="title">getdest</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pdest; &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">//因为在构造函数里已经将 pemit 设置为 emitter 了，</span></span><br><span class="line">  <span class="comment">//所以下面的代码就是调用 emitter 函数。为里只不过做了一次函数指针类型转换。</span></span><br><span class="line">  <span class="comment">//也就是说调用 connect 的 emit 方法，实际调的是 emitter。</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">emit</span><span class="params">(Args... args)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">em_t</span>)</span><span class="params">(<span class="keyword">const</span> _opaque_connection*, Args...)</span></span>;</span><br><span class="line">    union_caster&lt;<span class="keyword">emit_t</span>, <span class="keyword">em_t</span>&gt; caster;</span><br><span class="line">    caster.from = pemit;</span><br><span class="line">    (caster.to)(<span class="keyword">this</span>, args...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> DestT, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">emitter</span><span class="params">(<span class="keyword">const</span> _opaque_connection* self, Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//pm_t是一个成员函数指针，它指向的是传进来的成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(DestT::*<span class="keyword">pm_t</span>)</span><span class="params">(Args...)</span></span>;</span><br><span class="line">    <span class="keyword">pm_t</span> pm;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">memcpy</span>(&amp;pm, self-&gt;pmethod, <span class="keyword">sizeof</span>(<span class="keyword">pm_t</span>));</span><br><span class="line">    <span class="comment">//调用成员方法</span></span><br><span class="line">    (<span class="keyword">static_cast</span>&lt;DestT*&gt;(self-&gt;pdest)-&gt;*(pm))(args...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//signal_with_thread_policy类的父类。</span></span><br><span class="line"><span class="comment">//该类最主要的作用是存有一个conn list。</span></span><br><span class="line"><span class="comment">//在 signal_with_thread_policy中的connect方法就是对该成员变量的操作。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">mt_policy</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> _<span class="title">signal_base</span> :</span> <span class="keyword">public</span> _signal_base_interface, <span class="keyword">public</span> mt_policy &#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;_opaque_connection&gt; connections_list;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">//在 _signal_base 中定义了一个connection list，用于绑定的 slots.</span></span><br><span class="line">  connections_list m_connected_slots;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该类是"槽"的实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">mt_policy</span> = <span class="title">SIGSLOT_DEFAULT_MT_POLICY</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">has_slots</span> :</span> <span class="keyword">public</span> has_slots_interface, <span class="keyword">public</span> mt_policy &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;_signal_base_interface*&gt; sender_set;</span><br><span class="line">  <span class="keyword">typedef</span> sender_set::const_iterator const_iterator;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  has_slots()</span><br><span class="line">      : has_slots_interface(&amp;has_slots::do_signal_connect,</span><br><span class="line">                            &amp;has_slots::do_signal_disconnect,</span><br><span class="line">                            &amp;has_slots::do_disconnect_all) &#123;&#125;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  has_slots&amp; <span class="keyword">operator</span>=(has_slots <span class="keyword">const</span>&amp;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//静态函数，用于与signal绑定，由父类调用</span></span><br><span class="line">  <span class="comment">//它是在构造函数时传给父类的</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_signal_connect</span><span class="params">(has_slots_interface* p,</span></span></span><br><span class="line"><span class="function"><span class="params">                                _signal_base_interface* sender)</span> </span>&#123;</span><br><span class="line">    has_slots* <span class="keyword">const</span> self = <span class="keyword">static_cast</span>&lt;has_slots*&gt;(p);</span><br><span class="line">    <span class="function">lock_block&lt;mt_policy&gt; <span class="title">lock</span><span class="params">(self)</span></span>;</span><br><span class="line">    self-&gt;m_senders.insert(sender);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//静态函数，用于解绑signal，由父类调用</span></span><br><span class="line">  <span class="comment">//它是在构造函数时传给父类的</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_signal_disconnect</span><span class="params">(has_slots_interface* p,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   _signal_base_interface* sender)</span> </span>&#123;</span><br><span class="line">    has_slots* <span class="keyword">const</span> self = <span class="keyword">static_cast</span>&lt;has_slots*&gt;(p);</span><br><span class="line">    <span class="function">lock_block&lt;mt_policy&gt; <span class="title">lock</span><span class="params">(self)</span></span>;</span><br><span class="line">    self-&gt;m_senders.erase(sender);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//该集合中存放的是与slog绑定的 signal</span></span><br><span class="line">  sender_set m_senders;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该类是信号的具体实现</span></span><br><span class="line"><span class="comment">//为了保证信号可以在不同的平台是线程安全的，所以这里使用了策略模式</span></span><br><span class="line"><span class="comment">//mt_policy参数表式的是，不同的平台使用不同的策略</span></span><br><span class="line"><span class="comment">//该类中有两个重要的函数，一个是connect用于与槽进行绑定；另一个是 emit用于发射信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">mt_policy</span>, <span class="title">typename</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">signal_with_thread_policy</span> :</span> <span class="keyword">public</span> _signal_base&lt;mt_policy&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">desttype</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">connect</span>(<span class="title">desttype</span>* <span class="title">pclass</span>, <span class="title">void</span> (<span class="title">desttype</span>:</span>:*pmemfun)(Args...)) &#123;</span><br><span class="line">    <span class="comment">//这是一个智能锁，当函数结束时，自动释放锁。</span></span><br><span class="line">    <span class="function">lock_block&lt;mt_policy&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="comment">//先将对象与"槽"组成一个conn,然后存放到 signal的 conn list里</span></span><br><span class="line">    <span class="comment">//当发射信号时，调用 conn list中的每个conn的 emit方法。</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_connected_slots.push_back(_opaque_connection(pclass, pmemfun));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在槽对象中也要保存 signal 对象。</span></span><br><span class="line">    pclass-&gt;signal_connect(<span class="keyword">static_cast</span>&lt;_signal_base_interface*&gt;(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//遍历所有的连接，并调用 conn 的emit方法。最终调用的是绑定"槽"的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">emit</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="function">lock_block&lt;mt_policy&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_current_iterator = <span class="keyword">this</span>-&gt;m_connected_slots.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;m_current_iterator != <span class="keyword">this</span>-&gt;m_connected_slots.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      _opaque_connection <span class="keyword">const</span>&amp; conn = *<span class="keyword">this</span>-&gt;m_current_iterator;</span><br><span class="line">      ++(<span class="keyword">this</span>-&gt;m_current_iterator);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//调 conn 的 emit 方法，最终会调用绑定的 "槽" 方法。</span></span><br><span class="line">      conn.emit&lt;Args...&gt;(args...);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//重载（）操作符，这样就从直接调用emit方法变成隐含调用emit方法。</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args... args)</span> </span>&#123; emit(args...); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的对不同参数信号的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">using</span> signal = signal_with_thread_policy&lt;SIGSLOT_DEFAULT_MT_POLICY, Args...&gt;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> mt_policy = SIGSLOT_DEFAULT_MT_POLICY&gt;</span><br><span class="line"><span class="keyword">using</span> signal0 = signal_with_thread_policy&lt;mt_policy&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A1, <span class="keyword">typename</span> mt_policy = SIGSLOT_DEFAULT_MT_POLICY&gt;</span><br><span class="line"><span class="keyword">using</span> signal1 = signal_with_thread_policy&lt;mt_policy, A1&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A1,</span><br><span class="line">          <span class="keyword">typename</span> A2,</span><br><span class="line">          <span class="keyword">typename</span> mt_policy = SIGSLOT_DEFAULT_MT_POLICY&gt;</span><br><span class="line"><span class="keyword">using</span> signal2 = signal_with_thread_policy&lt;mt_policy, A1, A2&gt;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace sigslot</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文通过 sigslot作用、实现原理、如何使用以及详细的代码注释四个部分剖析了 WebRTC 中的 sigslot。sigslot是 WebRTC中非常底性的基础代码，它对 WebRTC 事件机制起着关键性的作用。熟悉sigslot，对我们阅读 WebRTC 代码会有非常大的帮助。</p><p>希望本文能对你有所帮助。谢谢！</p>]]></content>
      
      
      <categories>
          
          <category> WebRTC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> slot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊C++中的类型转换</title>
      <link href="/670ef31f/"/>
      <url>/670ef31f/</url>
      
        <content type="html"><![CDATA[<p>在C语言中我们经常要做类型转换，例如malloc函数分配内存时需要从<code>void *</code>转换成你指定的类型指针。如下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* block = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure><p>上面的代码是将<code>void*</code>转换成<code>int*</code>，这种转换方式在C语言中称为<code>强制转换</code>。它的好处是简洁，灵活；缺点是需要人来决定转换后类型是否正确，因此对开发人员的要求是很高的。</p><a id="more"></a><h2 id="C-的四种类型转换"><a href="#C-的四种类型转换" class="headerlink" title="C++的四种类型转换"></a>C++的四种类型转换</h2><p>C++觉得C的强制转换方式不是很友好，尤其是没法通过编译器或运行时检测工具来提供帮助，光靠人的能力来判断是很不靠谱的事儿。</p><p>而且相对于C来说，分析C++程序的运行轨迹要比分析C复杂得多。因此C++提出了四种新的类型转换方法，这四种类型转换方法分别是：<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>以及<code>reinterpret_cast</code>。</p><p>下面我们就来对这四种类型转换方法做下详细讨论。</p><h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>static_cast主要用于不同类型变量之间的转换及左值转右值等。比如说double转int就需要用static_cast转换。我们来举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不同类型之间的转换</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">10.1</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">//左值转右值</span></span><br><span class="line"><span class="keyword">int</span> lv = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp; rv = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&amp;&amp;&gt;(lv);</span><br></pre></td></tr></table></figure><blockquote><p>这里需要注意的是：int 转 double是隐式转换，右值转左值也是隐性转换，所以对这两种情况是不需要用static_cast进行显示转换的。</p></blockquote><p>上面我们说的是普通类型的转换。而对于类对象来说，static_cast不能直接将一种类对象转成另一种类对象。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    b = <span class="keyword">static_cast</span>&lt;B&gt;(a); <span class="comment">//不允许static_cast将一个对象转成另一个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像上面这种用static_cast将A类型的对象转成B类型对象是不允许的。但你可以利用static_cast将基类指针/引用转成子类指针/引用。如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">A ca;</span><br><span class="line">B &amp; crb = <span class="keyword">static_cast</span>&lt;B&amp;&gt;(ca);</span><br><span class="line">...</span><br><span class="line">A * pa = <span class="keyword">new</span> A();</span><br><span class="line">B * cpb = <span class="keyword">static_cast</span>&lt;B*&gt;(pa);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但这里有个前提条件，即只有有父子关系的类之间才可以做如上转换，否则编译失败。还有，虽然以上两种使用static_cast的方式都可以编译通过，但用户自己要防止越界访问的问题。</p><p>static_cast除了上面讨论的几种情况外，还有一点需要牢记，即<strong>static_cast不允许不同类型之间指针/引用的转换(有父子关系的类对象除外)</strong>。看个具体的例子：：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">double</span> *pd  = <span class="keyword">new</span> <span class="keyword">double</span>();</span><br><span class="line"><span class="keyword">int</span> * pi = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(pd); <span class="comment">//报错</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面的代码在编译时会报错，因为它不允许不同类型之间的指针或引用转换。对于有父子关系的类对象之间之所以可以转换是因为static_cast把它们当做同一类型看待了。</p><p>所以总结来说，static_cast主要用于不同类型变量之间的转换，指针和引用的转换不能用static_cast，而应该用reinterpret_cast。</p><h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><p>reinterpret_cast类似于C语言中不同类型指针间的类型转换，最接近于C的强制转换。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">double</span> *pd  = <span class="keyword">new</span> <span class="keyword">double</span>();</span><br><span class="line"><span class="keyword">int</span> * pi = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(pd);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面的代码是将<code>double*</code> 转成 <code>int*</code>。如果你使用static_cast做这种转换转换是不允许的，但改用reinterpret_cast就一切正常。 当然，如果你用reinterpret_cast做static_cast善长的变量类型转换也会报错。从上面的描述我们应该知道reinterpret_cast与static_cast之间的区别了。</p><p>如果我们像下面这样用reinterpret_cast去做类型变量的转换，编译器会报错：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">10.1</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>&gt;(d);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这样的转换是绝对不允许的。</p><p>reinterpret_cast还有一个特点，它可以将指针转成长整型，也可以将长整型转成指针。如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> ll = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">long</span>&gt;(&amp;a);</span><br><span class="line"><span class="keyword">double</span> *dd = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">double</span>*&gt;(ll);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面是将一个<code>int*</code>转成long型，又将long型转成<code>double*</code>，这些都是reinterpret_cast善长做的转换。</p><p>reinterpret_cast对于对象指针/引用的转换与普通类型的指针/引用转换是一样的。因此不同类型的对象指针/引用可以随意转换，但转换后是否会引起问题它不关心，这要由开发人员自己保证。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A * pa = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">B b;</span><br><span class="line">B &amp; rb = B();</span><br><span class="line"></span><br><span class="line">C * cc = <span class="keyword">reinterpret_cast</span>&lt;C*&gt;(pa);</span><br><span class="line">C &amp; rcc = <span class="keyword">reinterpret_cast</span>&lt;C&amp;&gt;(rb);</span><br></pre></td></tr></table></figure><p>总结一下，reinterpret_cast是对指针/引用的转换，其中必须至少有一个是指针或引用，否则它会报错。</p><h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p>这个比较简单，它的作用是去掉<strong>指针/引用</strong>中的const限制。这里要注意的是被转换的一定是指针/引用的const，而常数的const是不能去掉的。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b  = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&gt;(a);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面的代码是想通过const_cast将常数的const去掉？这是决对不可以的！！！编译器一定会报错。</p><p>而如果是加了const的指针/引用就没问题了，我们再来一个列子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pca = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> * pa = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(pca);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>将一个const 指针转换成非const指针正是const_cast做的事儿。</p><p>我们再来想一种case，是否可以将一种类型的const指针转换成另一种类型的非const指针呢？如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pca = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">double</span> * pa = <span class="keyword">const_cast</span>&lt;<span class="keyword">double</span>*&gt;(pca);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这样也是不允许的。对于const_cast来说，它只能将同一类型的const 指针/引用 转成非const指针/引用。</p><p>所以我们这里总结一下，const_cast是一个专门去掉同一类型的const限制的类型转换方法。它不如static_cast和reinterpret_cast应用的广泛。</p><h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p>这个转换方法限制比较多，一、它只能处理类对象；二、它只能处理指针；三、它只能用于将子对象转换成父对象这样的操作。我们来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">A * a;</span><br><span class="line">B * b =<span class="keyword">new</span> B();</span><br><span class="line">a = <span class="keyword">dynamic_cast</span>&lt;A*&gt;(b);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>只有上面这一种情况可以编译成功，其它情况都会失败！</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>下面我们总结一下这四种类型转换方法。四种转换方法中，用的比较多的是static_cast和reinterpret_cast这两种转换方法。</p><p>static_cast主要用于普通类型变量的转换，如double到int的转换，或左值转右值。当然它也可以在父对象与子对象之间进行指针转换。</p><p>reinterpret_cast主要用于不同类型指针/引用间的转换。也可以将指针/引用转成长整型或将长整型转成指针类型。但不可以像static_cast一样在两个不同的类型变量间转换。也就是说reinterpret_cast在转换时必须有一个是指针/引用。</p><p>const_cast就比较简单了，它只能将同一类型的const指针转成同一类型的非const指针。</p><p>dynamic_cast只能用于有父子关系的类对象之间的转换，而且只能用于将子对象转换成父对象。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">C++高阶知识：深入分析移动构造函数及其原理</a><br><a href="https://avdancedu.com/9683d88/" target="_blank" rel="noopener">细说智能指针</a><br><a href="https://avdancedu.com/5e7916e3/" target="_blank" rel="noopener">重学C/C++中的const</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类型转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++高阶知识：深入分析移动构造函数及其原理</title>
      <link href="/a39d51f9/"/>
      <url>/a39d51f9/</url>
      
        <content type="html"><![CDATA[<p>移动构造函数是C++11中新增加的一种构造函数，其作用是提高程序性能。今天我们就细扒一下它的工作原理，看看它是怎么提高性能的。</p><a id="more"></a><h2 id="移动构造函数的由来"><a href="#移动构造函数的由来" class="headerlink" title="移动构造函数的由来"></a>移动构造函数的由来</h2><p>在讲解移动构造函数之间，我们先来了解一下在没有移动构造函数之前哪里有性能瓶颈吧。我们来举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        A()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A construct..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            ptr_ = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        A(<span class="keyword">const</span> A &amp; a)&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A copy construct ..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            ptr_ = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line">            <span class="built_in">memcpy</span>(ptr_, a.ptr_, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~A()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A deconstruct ..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(ptr_)&#123;</span><br><span class="line">                <span class="keyword">delete</span> ptr_;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A &amp; a) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" A operator= ...."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> * <span class="title">getVal</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ptr_;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> *ptr_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;A&gt; vec;</span><br><span class="line">    vec.push_back(A());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//clang++ -g -o testmove test_move.cpp</span></span><br></pre></td></tr></table></figure><p>上面这段代码很简单对吧，就是定义了一个普通的类A。在main函数中创建一个vector，然后用A类创建一个对象，并把它放入到vector中。这样的程序在C++中是很常见，但就是这样很常见的代码确有非常大的性能问题。为什么呢？因为在将A对象放入vector时，在vector内部又创建了一个A对象，并调用了其拷贝构造函数进行了深拷贝。</p><p>我们看一下上面代码运行的结果就一目了然了，其结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A construct...          &#x2F;&#x2F;main中创建的A对象</span><br><span class="line">A copy construct ...    &#x2F;&#x2F;vector内部创建的A对象</span><br><span class="line">A deconstruct ...       &#x2F;&#x2F;vector内部创建的A对象被析构</span><br><span class="line">A deconstruct ...       &#x2F;&#x2F;main中创建的A对象析构</span><br></pre></td></tr></table></figure><p>上面的运行结果印证了我们之前的讨论，在vector内部确实又创建了一个A对象。如果在A对象中分配的是一个比较大的空间，且vector中要存放大量的A对象时（如 100000个)，就会不断的做分配/释放堆空间的操作，这会造成多在的性能消耗呀！</p><p>有什么办法可以解决这个问题呢？这就要用到我们今天要讲的移动构造函数了。</p><h2 id="移动构造函数的使用"><a href="#移动构造函数的使用" class="headerlink" title="移动构造函数的使用"></a>移动构造函数的使用</h2><p>从C++11开始，类中不光可以有构造函数、拷贝构造函数，还增加了一种新的构造函数即移动构造函数。移动构造函数起什么作用呢？就像它的名子一样，它可以实现指针的移动，即可以将一个对象中的指针成员转移给另一个对象。指针成员转移后，原对象中的指针成员一般要被设置为NULL，防止其再被使用。</p><p>还是以我们上面的代码为例，如果我们有了移动构造函数，那么在将A对象push到vector时，vector内部虽然还是会再分A对象，但在进行数据的拷贝时就不是深拷贝了，而变成了浅拷贝，这样就大大提高了程序的执行效率。</p><p>如何为A增加移动构造函数呢？我们来看一下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        A(A &amp;&amp; a)&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A move construct ..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            ptr_ = a.ptr_;</span><br><span class="line">            a.ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 A 类中增加上面代码即可，上面的代码看起来与普通构造函数好像没什么两样，但你细心观察可以发现该构造函数的参数是 <code>A &amp;&amp; a</code>。咦！<code>&amp;&amp;</code>这在以前还真没见过对吧。它表示的是C++中的右值，也就是只有创建A对象时传入的是右值才会执行该构造函数。</p><p>对于右值后面我们还会做详细介绍，现在我们只要知道要想让这个函数起作用，就必须传给它一个右值就可以了。如么问题来了，我们这个例子中如何传递给它一个右值呢？这就要用到 std::move 函数了。</p><p>std::move可以将任何一值变成右值，所以我们不管3721，在创建A对象时直接调用std::move”造”个右值给它就好了。于是我们修改main代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;A&gt; vec;</span><br><span class="line">    vec.push_back(<span class="built_in">std</span>::<span class="built_in">move</span>(A()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经这样修后，我们运行一下程序看现在它的结果是什么样子吧。结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A construct...          &#x2F;&#x2F;main中创建A对象</span><br><span class="line">A move construct ...    &#x2F;&#x2F;vector内部通过移动构造函数创建A对象，减少了对堆空间的频繁操作</span><br><span class="line">A deconstruct ...       &#x2F;&#x2F;释放vector中的A对象</span><br><span class="line">A deconstruct ...       &#x2F;&#x2F;释放main中创建的A对象</span><br></pre></td></tr></table></figure><p>从上面的结果我们可以看出我们新增加的移动构造函数确实被调用了，这样就大大减了频繁对堆空间的分配/释放操作，从而提高了程序的执行效率。这里需要注意的是，在移动构造函数操作之后原A对象的指针地址已经指向NULL了，因此此时就不能再通过其访问之前的堆空间了。</p><h2 id="C-的左值与右值"><a href="#C-的左值与右值" class="headerlink" title="C++的左值与右值"></a>C++的左值与右值</h2><p>右值是C++从C继承来的概念，最初是指=号右边的值。但现在C++中的右值已经与它最初的概念完全不一样了。在C++中右值指的的临时值或常量，更准确的说法是保存在CPU寄存器中的值为右值，而保存在内存中的值为左值。</p><p>可能有很多同学对计算机系统的底层不太了解，我们这里做一个简单的介绍。计算机是由CPU、内存、主板、总线、各种硬件等组成的，这个大家应该都清楚。而CPU又是由逻辑处理器，算术单元、寄存器等组成的。我们的程序运行时并不是直接从内存中取令运行的，因为内存相对于CPU来说太慢了。一般情况下都是先将一部分指令读到CPU的指令寄存器，CPU再从指令寄存器中取指令然后一条一条的执行。对于数据也是一样，先将数据从内存中读到数据寄存器，然后CPU从数据寄存器读数据。以Intel的CPU为例，它就包括了 EAX、EBX、ECX、EDX…多个通用寄存器，这样就可以让CPU更高效的工作。</p><p>比如说一个常数5，我们在使用它时不会在内存中为其分配一个空间，而是直接把它放到寄存器中，所以它在C++中就是一个右值。再比如说我们定义了一个变量 a，它在内存中会分配空间，因此它在C++中就是左值。那么<code>a+5</code>是左值还是右值呢？当然是右值对吧，因为a+5的结果存放在寄存器中，它并没有在内存中分配新空间，所以它是右值。</p><p>通过上面的描述你就应该对 C++ 中的左值和右值比较清楚了。我们来看个例子吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> &amp;&amp; a = <span class="number">5</span>;  <span class="comment">// 正确，5会被直接存放在寄存器中，所以它是右值</span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;&amp; c = b;  <span class="comment">// 错误，b在内存中有空间，所以是右值；右值不能赋值给左值</span></span><br><span class="line">    <span class="keyword">int</span> &amp;&amp; d = b + <span class="number">5</span>; <span class="comment">// 正确，虽然 b 在内存中，但 b+5 的结果放在寄存器中，它没有在内存中分配空间，因此是右值 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C++中使用<code>&amp;&amp;</code>表示右值引用，在上面的例子中，我首先将常数5赋值给右值引用a，因为常数5是右值，所以这条语句可以编译成功；紧接着我定义了变量b，因为它是左值，所以当将b赋值给右直引用c时，编译器会报错；最后一行将<code>b+5</code>赋值给右值引用d，由于<code>b+5</code>不会在内存中占用空间所以这也是右值，因此最后一句编译也没有任何问题。</p><p>接下来我们看一个有意思的情况，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">int</span> &amp;&amp; e = a;</span><br><span class="line">..</span><br></pre></td></tr></table></figure><p>这种情况是否是合法的呢？实际上当你这么做的时候编译器会报错，因为a是左值而e必须接收右值。那有没有办法将一个左值转成右值呢？这个问题我们前面其实已经回答过了，通过std::move就可以解决这个问题。我们来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">int</span> &amp;&amp; e = <span class="built_in">std</span>::<span class="built_in">move</span>(a);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>之前我们直接将a赋值给e是肯定不行的，但上面的操作编译器就不会报错了，因为通过std::move可以将一个左值转成右值。但这里有一点需要特别注意：<strong>e虽然接收的必须是右值，但它本身是左值。换句话说e是一种特殊的变量，它是只能接收右值的变量。我们再从左值的本质来看，e也是占内存空间的，所以它肯定是左值。</strong></p><h2 id="std-move的实现"><a href="#std-move的实现" class="headerlink" title="std::move的实现"></a>std::move的实现</h2><p>上面我们已经看到了std::move的神奇之处，你可能很好奇std::move是如何做到的呢？实际上std::move就是一个类型转换器，将左值转换成右值而以。我们来看一下它的实现吧！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> static_case&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::move的实现还是挺简单的就这么几行代码，但要理解这几行代码可不容易。下面我们就来对它做下详细分析。</p><h3 id="通用引用"><a href="#通用引用" class="headerlink" title="通用引用"></a>通用引用</h3><p>首先我们来看一下move的输入参数，move的输入参数类型称为通用引用类型。什么是通用引用呢？就是它既可以接收左值也可以接收右值。我们来看一下例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"the value is "</span>&lt;&lt; param &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> &amp;&amp; b = <span class="number">5</span>;   <span class="comment">//通用引用，可以接收右值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> &amp;&amp; c = a;    <span class="comment">//错误，右值引用，不能接收左值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> &amp;&amp; d = a;   <span class="comment">//通用引用，可以接收左值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;&amp; e = a; <span class="comment">//错误，加了const就不再是通用引用了</span></span><br><span class="line"></span><br><span class="line">    func(a);         <span class="comment">//通用引用，可以接收左值</span></span><br><span class="line">    func(<span class="number">10</span>);        <span class="comment">//通用引用，可以接收右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中有两种类型的通用引用: 一种是auto，另一种是通过模板定义的T&amp;&amp;。实际上auto就是模板中的T，它们是等价的。下面我们就对这段代码做下详细解读。</p><p>代码中的 a 是个左值，因为它在内存中会分配空间，这应该没什么异义；b 是通过引用。为什么呢？因为通用引用有两个条件：一，必须是T&amp;&amp;的形式，由于auto等价于T，所以auto &amp;&amp; 符合这个要求；二，T类型要可以推导，也就是说它必须是个模板，而auto是模板的一种变型，因此b是通用引用。通用引用即可以接收左值，也可以接收右值，所以b=5是正确的；c不是通用引用，因为它不符合T&amp;&amp;的形式。所经第三行代码是错误的，右值引用只能接收右值；d是通用引用，所以给它赋值a是正确的；e不是通用引用，它多了一个const已不符合T&amp;&amp; 的形式，所以给它左值肯定会出错；最后两个函数调用的形参符合 T&amp;&amp;，又因是模板可以进行类型推导，所以是通用引用，因此给它传左值和右值它都能正确接收。</p><h3 id="模板的类型推导"><a href="#模板的类型推导" class="headerlink" title="模板的类型推导"></a>模板的类型推导</h3><p>通用引用好强大呀！它既可以接收左值又可以接收右值，它是如何做到的呢？这就要讲讲模板的类型推导了。</p><p>模板的类型推导规则还是蛮复杂的，这里我们只简要说明一下，有兴趣的同学可以查一下C++11的规范。我们还是举个具体的例子吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br><span class="line"></span><br><span class="line">f(expr);</span><br></pre></td></tr></table></figure><p>上面这个例子是函数模板的通用例子，其中T是根据f函数的参数推到出来的，而ParamType则是根据 T 推导出来的。T与ParamType有可能相等，也可能不等，因为ParamType是可以加修饰的。我们看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;         <span class="comment">// x是int</span></span><br><span class="line">    <span class="keyword">int</span> &amp; rr = x;       <span class="comment">// rr是 int &amp;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> cx = x;   <span class="comment">// cx是const int</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;  <span class="comment">// rx是const int &amp;</span></span><br><span class="line">    <span class="keyword">int</span> *pp = &amp;x;       <span class="comment">// pp是int *</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面是传值的模板，由于传入参数的值不影响原值，所以参数类型退化为原始类型</span></span><br><span class="line">    f(x);               <span class="comment">// T是int</span></span><br><span class="line">    f(cx);              <span class="comment">// T是int</span></span><br><span class="line">    f(rx);              <span class="comment">// T是int</span></span><br><span class="line">    f(rr);              <span class="comment">// T是int</span></span><br><span class="line">    f(pp);              <span class="comment">// T是int*，指针比较特殊，直接使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面是传引用模板, 如果输入参数类型有引用，则去掉引用;如果没有引用，则输入参数类型就是T的类型</span></span><br><span class="line">    func(x);            <span class="comment">// T为int</span></span><br><span class="line">    func(cx);           <span class="comment">// T为const int</span></span><br><span class="line">    func(rx);           <span class="comment">// T为const int</span></span><br><span class="line">    func(rr);           <span class="comment">// T为int</span></span><br><span class="line">    func(pp);           <span class="comment">// T是int*，指针比较特殊，直接使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面是通用引用模板，与引用模板规则一致</span></span><br><span class="line">    function(x);        <span class="comment">// T为int&amp;</span></span><br><span class="line">    function(<span class="number">5</span>);        <span class="comment">// T为int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中可以将类型推导分成两大类：其中类型不是引用也不是指针的模板为一类; 引用和指针模板为另一类。</p><p>对于第一类其推导时根据的原则是，函数参数传值不影响原值，所以无论你实际传入的参数是普通变量、常量还是引用，它最终都退化为不带任何修修饰的原始类型。如上面的例子中，<code>const int &amp;</code>类型传进去后，退化为int型了。</p><p>第二类为模板类型为引用（包括左值引用和右值引用）或指针模板。这一类在类型推导时根据的原则是去除对等数量的引用符号，其它关键字照般。还是我们上面的例子，<code>func(x)</code>中x的类型为 <code>int&amp;</code>，它与<code>T&amp;</code>放在一起可以知道T为int。另一个例子<code>function(x)</code>，其中x为<code>int&amp;</code>它与T&amp;&amp; 放在一起可知T为<code>int&amp;</code>。</p><p>根据推导原则，我们可以知道通用引用最终的结果是什么了，左值与通用引用放在一推导出来的T仍为左值，而右值与通用引用放在一起推导出来的T仍然为右值。</p><h3 id="move-的返回类型"><a href="#move-的返回类型" class="headerlink" title="move 的返回类型"></a>move 的返回类型</h3><p>实际上上面通过模板推导出的T与move的返回类型息息相关的，要讲明白这一点我们先要把move的返回类型弄明白。下面我们就来讨论一下move的返回类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;</span><br></pre></td></tr></table></figure><p>move的返回类型非常奇特，我们在开发时很少会这样写，它表示的是什么意思呢？</p><p>这就要提到C++的另外一个知识点，即类型成员。你应该知道C++的类成员有成员函数、成员变量、静态成员三种类型，但从C++11之后又增加了一种成员称为类型成员。类型成员与静态成员一样，它们都属于类而不属于对象，访问它时也与访问静态成员一样用<code>::</code>访问。</p><p>了解了这点，我们再看move的返类型是不是也不难理解了呢？它表达的意思是返回remove_reference类的type类型成员。而该类是一个模板类，所以在它前面要加typename关键字。</p><p>remove_reference看着很陌生，接下来我们再分析一下remove_reference类，看它又起什么作用吧。其实，通过它的名子你应该也能猜个大概了，就是通过模板去除引用。我们来看一下它的实现吧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;  <span class="comment">//定义T的类型别名为type</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&gt; //左值引用</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&amp;&gt; //右值引用</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是remove_reference类的代码，在C++中struct与class基本是相同的，不同点是class默认成员是private，而struct默认是public，所以使用struct代码会写的更简洁一些。</p><p>通过上面的代码我们可以知道，经过remove_reference处理后，T的引用被剔除了。假设前面我们通过move的类型自动推导得到T为int&amp;&amp;，那么再次经过模板推导remove_reference的type成员，这样就可以得出type的类型为int了。</p><p>remove_reference利用模板的自动推导获取到了实参去引用后的类型。现在我们再回过来看move函数的时候是不是就一目了解了呢？之前无法理解的5行代码现然变成了这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int &amp;&amp; move(int&amp;&amp; &amp;&amp; t)&#123;</span><br><span class="line">    return static_case&lt;int&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line">int &amp;&amp; move(int&amp; &amp;&amp; t)&#123;</span><br><span class="line">    return static_case&lt;int&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经上面转换后，我们看这个代码就清晰多了，从中我们可以看到move实际上就是做了一个类型的强制转换。如果你是左值引用就强制转换成右值引用。</p><h3 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h3><p>上面的代码我们看起来是简单了很多，但其参数<code>int&amp; &amp;&amp;</code>和<code>int &amp;&amp; &amp;&amp;</code>还是让人觉得很别扭。因为C++编译器根本就不支持这两种类型。咦！这是怎么回事儿呢？</p><p>到这里我们就要讲到最后一个知识点引用折叠了。在C++中根本就不存 <code>int&amp; &amp;&amp;</code>、<code>int &amp;&amp; &amp;&amp;</code>这样的语法，但在编译器内部是能将它们识别出来的。换句话说，编译器内部能识别这种格式，但它没有给我们提供相应的接口(语法）。</p><p>实际上，当编译器遇到这类形式的时候它会使用引用折叠技术，将它们变成我们熟悉的格式。其规则如下：</p><ul><li><code>int &amp; &amp;</code> 折叠为 <code>int&amp;</code></li><li><code>int &amp; &amp;&amp;</code> 折叠为 <code>int&amp;</code></li><li><code>int &amp;&amp; &amp;</code> 折叠为 <code>int&amp;</code></li><li><code>int &amp;&amp; &amp;&amp;</code> 折叠为 <code>int &amp;&amp;</code></li></ul><p>总结一句话就是左值引用总是折叠为左值引用，右值引用总是折叠为右值引用。</p><p>经过这一系列的操作之后，对于一个具体的参数类型<code>int &amp; a</code>，std::move就变成了下面的样子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> &amp;&amp; <span class="title">move</span><span class="params">(<span class="keyword">int</span>&amp; t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> static_case&lt;<span class="keyword">int</span>&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一下我们就清楚它在做什么事儿了哈！</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上就是C++高阶知识移动构造函数及其原理的分析。在本文中我首先向你介绍了拷贝构造函数在某些场景下会引起程序性能严重下降，然后讲解了如何使用移动构造函数和std::move函数改善性能。在文章的最后，我带你深入剖析了std::move是如何实现的，最终我们发现它原来就是实现了一个自适应类型的强制类型转换的功能。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/9683d88/" target="_blank" rel="noopener">细说智能指针</a><br><a href="https://avdancedu.com/5e7916e3/" target="_blank" rel="noopener">重学C/C++中的const</a><br><a href="https://avdancedu.com/670ef31f/" target="_blank" rel="noopener">聊聊C++中的类型转换</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动构造函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>细说智能指针</title>
      <link href="/9683d88/"/>
      <url>/9683d88/</url>
      
        <content type="html"><![CDATA[<p>今天我们来聊聊C++的智能指针。C++从1983年诞生到现在已经有30多年历史了，为什么到现在还能如此流行呢(排名第四，2020年6月<a href="https://hellogithub.com/report/tiobe/" target="_blank" rel="noopener">HelloGitHub榜单</a>)？因为它具有很多其它语言所不具备的优势，比如说执行速度快，控制力更强等。同样的，有更多的同学会选择用Java(排名第二)等语言，这是因为它相对C++来说，它更简单，易上手，不用担心内存泄漏！</p><p>确实，<strong>内存泄漏</strong>在很长的一段时间里是影响人们学习C++的一个最重要的原因。不过C++也在不断进步中，智能指针的出现就大大降低了内存泄漏发生的风险。</p><p>下面我们就来细聊一下C++智能指针的方方面面，通过本文让你真正掌握C++智能指针。</p><a id="more"></a><h2 id="内存泄漏的产生"><a href="#内存泄漏的产生" class="headerlink" title="内存泄漏的产生"></a>内存泄漏的产生</h2><p>在C++中内存的分配与释放都是手工操作的(分配内存用<code>new</code>，释放内存用<code>delete</code>)，这种方式本身就很容易产生内存泄漏。因为人们在开发过程中需要内存时很自然的就用new分配一块，但这块内存什么时候释放就说不好了，有可能用完马上就释放，也有可能要等待一个周期才能释放等等。而且随着时间的推移，代码越来越大，需要被释放的内存被遗忘的可能性也就更大。</p><p>我来看一下具体的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *pVal = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line">    *pVal = <span class="number">10</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(*pVal == <span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;      <span class="comment">//这里会产生内存泄漏</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">delete</span> pVal;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，使用new在堆空间分配了一个整型大小的空间，在函数结束时通过delete将分配的内存释放。但当<code>pVal==10</code>时，函数没有释放内存就直接退出了，此时就产生了内存泄漏。</p><p>有的同学可能会说，谁会写出这么蠢的代码呢？实际上这样的代码在C++项目中经常出现，很多老手有时都犯这样的错误。你之所以可以一眼就看出上面代码的问题，是因为我将代码简化了。在真实的场景中，由于代码量比较大，你就没那么容易一眼看出问题了。</p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>上面我们已经看到了，通过new/delete这种方式申请/释放内存存在着很大弊端，有没有什么方法可以在使用时申请内存，在不需要的时自动释放它呢？当然有，<strong>这就是智能指针</strong>。</p><p>下面我们来看看智能指针是怎么做到的吧。实际上，智能指针最朴素的想法是利用类的<code>析构函数</code>和<code>函数栈</code>的自动释放机制来自动管理指针，即用户只要按需分配堆空间，堆空间的释放由智能指针帮你完成。</p><p>在解释这个原理之前，我们先来补充两个基本知识，一是构造函数与析构函数；另一个是堆空间与栈空间。首先来看构造函数与析构函数。</p><h3 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3><p>类对象的构造与析构是C++最基本的概念了，当创建对象时其构造函数会被调用，销毁对象时其析构函数会被调用。我们来举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MyClass()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"construct func"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~MyClass()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"deconstruct func"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"create MyClass object ..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    MyClass *myclass = <span class="keyword">new</span> MyClass();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"release MyClass object ..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> myclass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译命令 clang++ -g -o myclass test_class.cpp</span></span><br></pre></td></tr></table></figure><p>我们将上面的代码编译执行后，会得到下面的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create MyClass object ...</span><br><span class="line">construct func</span><br><span class="line">release MyClass object ...</span><br><span class="line">deconstruct func</span><br></pre></td></tr></table></figure><p>通过其结果就可以证明我们上面的结论了，即<strong>创建对象时其构造函数会被调用；销毁对像时其析构函数会被调用</strong>。</p><p>下面我们再来看看堆空间与栈空间。</p><h3 id="堆空间与栈空间"><a href="#堆空间与栈空间" class="headerlink" title="堆空间与栈空间"></a>堆空间与栈空间</h3><p>我们以Linux为例，在Linux系统上每个进程都有自己的虚似地址空间，如果你的系统是32位的，那它可以访问的内存空间是：2^32，也就是4G大小。</p><p>在这么大的空间中，内存被分成了几块：内核块、代码块、BSS块、堆空间，栈空间等。</p><ul><li>内核块，由Linux内核使用，应用层不可以访问。</li><li>代码块，用户的二进制应用程序，只读。</li><li>BSS块，全局量，全局常量等。</li><li>堆空间，用new分配的动态空间，可以分配大块内存。</li><li>栈空间，用于函数调用，分配临时变量等。其空间大小有限，<strong>当函数执行完成后其内存会自动回收</strong>。</li></ul><p>其中栈空间有个特点，当函数执行完后，它所用到的栈空间会被自动释放，而这正是智能指针所需要的。当它与构造函数/析构函数结合到一起时就可以实现智能指针了。下面我们来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">AutoPtr</span><span class="params">(T *ptr = <span class="literal">nullptr</span>)</span></span>&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"set new object"</span> &lt;&lt; ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            _ptr = ptr;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~AutoPtr()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"delete object"</span> &lt;&lt; _ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(_ptr != nulptr)</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T * _ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MyClass()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"construct MyClass func"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~MyClass()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"deconstruct MyClass func"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">AutoPtr&lt;MyClass&gt; <span class="title">myclass</span><span class="params">(<span class="keyword">new</span> MyClass())</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译命令 clang++ -g -o autoptr test_autoptr.cpp</span></span><br></pre></td></tr></table></figure><p>上面例子执行的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">construct MyClass func</span><br><span class="line">set new object, 0x7f8e25c028c0</span><br><span class="line">delete object, 0x7f8e25c028c0</span><br><span class="line">deconstruct MyClass func</span><br></pre></td></tr></table></figure><p>在上面main函数中创建了一个智能指针<code>AutoPtr&lt;MyClass&gt; myclass</code>，其在堆空间分配了一个MyClass对象交由智能指针管理，即<code>myclass(new MyClass())</code>。当main函数结束时，它会调用智能指针的析构函数，析构函数中执行了<code>delete</code>操作，最终将之前new出来的myclass对象释放掉了。</p><p>通过这个例子我们可以知道，有了智能指针我们就不用再担心内存泄漏了。对于C++开发同学来说像不像中了大奖一样高兴？不过上面的AutoPtr还称不上真正的智能指针，因为它只实现了智能指针最基本的一部分功能，我们还需要对它不断完善才行。</p><h2 id="AutoPtr智能指针"><a href="#AutoPtr智能指针" class="headerlink" title="AutoPtr智能指针"></a>AutoPtr智能指针</h2><p>上面实现的智能指针有什么问题呢？最大的问题就是它不能像真正的指针一样操作，比如说不能执行<code>xxx-&gt;xxx()</code>、<code>*xxx</code>等操作。下面我们就为AutoPtr重载这两个操作符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改AutoPtr，增加 -&gt; 和 * 操作符</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    T* <span class="keyword">operator</span> -&gt; ()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    T&amp; <span class="keyword">operator</span> * ()&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;(<span class="keyword">this</span>-&gt;_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改MyClass类，增加print方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加测试例子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">AutoPtr&lt;MyClass&gt; <span class="title">myclass</span><span class="params">(<span class="keyword">new</span> MyClass())</span></span>;</span><br><span class="line">    myclass-&gt;<span class="built_in">print</span>();</span><br><span class="line">    (*myclass).<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该程序，我们可以得到下面的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">construct MyClass func</span><br><span class="line">set new object,0x7f94f44028c0</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line">delete object，0x7f94f44028c0</span><br><span class="line">deconstruct MyClass func</span><br></pre></td></tr></table></figure><p>通过上面的例子我们可以看到AutoPtr确实像一个真正的指针了，既可以通过<code>-&gt;</code>调用MyClass方法，又可以通过<code>*</code>调用MyClass方法。</p><h2 id="AutoPtr缺陷"><a href="#AutoPtr缺陷" class="headerlink" title="AutoPtr缺陷"></a>AutoPtr缺陷</h2><p>虽然上面的AutoPtr实现看着很不错，不过它有非常致命的问题。当两个AutoPtr指针指向同一块堆空间时，在释放资源时会引起crash。咱们看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加测试例子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">AutoPtr&lt;MyClass&gt; <span class="title">myclass</span><span class="params">(<span class="keyword">new</span> MyClass())</span></span>;</span><br><span class="line">    AutoPtr&lt;MyClass&gt; newPtr = myclass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你在main函数中让两个AutoPtr指向同一块堆空间时就会引起crash。之所以会出现这个问题，是因为堆空间被释放了两次。上面程序的执行结果就可以推出这个结论：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">construct MyClass func</span><br><span class="line">set new object,0x7fdecfc028c0</span><br><span class="line"></span><br><span class="line">delete object，0x7fdecfc028c0     &#x2F;&#x2F;释放第二个对象</span><br><span class="line">deconstruct MyClass func</span><br><span class="line"></span><br><span class="line">delete object，0x7fdecfc028c0     &#x2F;&#x2F;释放第一个对象</span><br><span class="line">deconstruct MyClass func</span><br><span class="line">malloc: *** error for object 0x7fdecfc028c0: pointer being freed was not allocated &#x2F;&#x2F;0x7fdecfc028c0这个空间已经被释放过一次了</span><br></pre></td></tr></table></figure><p>通过上面的运行结果我们可以知道，创建myclass智能指针时它指向了<code>new MyClass</code>所分配的空间。紧接着，程序使用默认<code>=</code>运算符将myclass中的全部内容赋值给newPtr。此时newPtr的<code>_ptr</code>成员会与myclass的<code>_ptr</code>成员指向同一块堆空间(由于使用了默认<code>=</code>运算符，所以过程没有显示出来)。</p><p>当main函数结束时，它会按次序依次调用newPtr的析构函数和myclass的析构函数，所以我们可以看到有两次”delete object，0x7fdecfc028c0”。在C++中，如果对同一地址释放多次就会引起crash，所以我们在显示结果的最后一行看到了”pointer being freed was not allocated” 这条信息表示的就是重复释放了。</p><p>因此我们必须对 AutoPtr 继续改进，防止出现重复释放的情况。如何才能防止重复释放呢？</p><h2 id="谁来独享所有权？"><a href="#谁来独享所有权？" class="headerlink" title="谁来独享所有权？"></a>谁来独享所有权？</h2><p>我们可以想到的最简单的办法是当有多个智能指针指向同一块堆空间时，只能有一个智能指针拥有所有权。什么意思呢？就是这块堆空间的释放只能由其中的一个来完成。</p><h3 id="允许共享，独占所有权"><a href="#允许共享，独占所有权" class="headerlink" title="允许共享，独占所有权"></a>允许共享，独占所有权</h3><p>怎么才能让众多智能指针中的一个拥有所有权呢？简单的办法是在AutoPtr上加个owner就好了。我们将上面的代码修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    explicit AutoPtr(T *ptr = nullptr):_ptr(ptr), _owner(true)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr(AutoPtr&lt;T&gt; &amp; autoptr):_ptr(autoptr._ptr), _owner(<span class="literal">false</span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~AutoPtr()&#123;</span><br><span class="line">        <span class="keyword">if</span>(_owner &amp;&amp; _ptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr&amp; <span class="keyword">operator</span>=(AutoPtr&lt;T&gt; &amp; autoptr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;autoptr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(_ptr)&#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_ptr = autoptr._ptr;</span><br><span class="line">            _owner = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _ptr;</span><br><span class="line">    <span class="keyword">bool</span> _owner;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>经上面修改后，<code>new MyClass</code>分配的空间就有了具体的owner，所以再执行之前的测试程序就不会crash了。结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">construct MyClass func</span><br><span class="line">set new object,0x7fb9acc028c0</span><br><span class="line">copy construct, 0x7fb9acc028c0</span><br><span class="line">delete object，0x7fb9acc028c0   &#x2F;&#x2F; 调用newPtr 析构</span><br><span class="line">delete object，0x7fb9acc028c0   &#x2F;&#x2F; 调用 myclass 析构</span><br><span class="line">deconstruct MyClass func        &#x2F;&#x2F; 由于myclass是owner，所以才会真正的释放堆空间</span><br></pre></td></tr></table></figure><p>通过上面的修改问题似乎已经得到了解决，但实际的情况是后创建的智能指针更应该是owner，所以我们再做下微调：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    explicit AutoPtr(T *ptr = nullptr):_ptr(ptr), _owner(true)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr(AutoPtr&lt;T&gt; &amp; autoptr):_ptr(autoptr._ptr), _owner(<span class="literal">true</span>)&#123;</span><br><span class="line">        autoptr._owner = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr&amp; <span class="keyword">operator</span>=(AutoPtr&lt;T&gt; &amp; autoptr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;autoptr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(_ptr)&#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_ptr = autoptr._ptr;</span><br><span class="line">            _owner = <span class="literal">true</span>;</span><br><span class="line">            autoptr._owner = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>经上面修改后，后创建的AutoPtr就取代之前的智能指针成为owner了。我们来看一下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">construct MyClass func</span><br><span class="line">set new object,0x7fe67b4028c0</span><br><span class="line">copy construct, 0x7fe67b4028c0</span><br><span class="line">delete object，0x7fe67b4028c0       &#x2F;&#x2F; 调用newPtr析构函数</span><br><span class="line">deconstruct MyClass func            &#x2F;&#x2F; 堆空间被释放掉了</span><br><span class="line">delete object，0x7fe67b4028c0       &#x2F;&#x2F; 调用myclass析构函数</span><br></pre></td></tr></table></figure><p>通过上面最后三行的输出结果我们可以看出，释放空间的顺序发生了变化，说明owner已经变为最近创建的智能指针newPtr了。</p><p>调整后的AutoPtr还有没有问题呢？当然还有，我们再来看一下例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">T* <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">AutoPtr&lt;<span class="keyword">int</span>&gt; <span class="title">oldPtr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">AutoPtr&lt;<span class="keyword">int</span>&gt; <span class="title">newPtr</span><span class="params">(oldPtr)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里出现了野指针</span></span><br><span class="line">        *(oldPtr.<span class="built_in">get</span>())= <span class="number">-100</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"the value is "</span> &lt;&lt; *(oldPtr.<span class="built_in">get</span>()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我在AutoPtr中增加了一个get方法以便获得智能指针所指的堆空间</p></blockquote><p>在上面的代码中，将newPtr放到一个花括号里，这样它就有了自己的栈空间。当跳出花括号后，newPtr就完成了它的使命，然后它会将持有的资源全部释放掉。由于newPtr从oldPtr获得了<code>new int(100)</code>这块堆空间的控制权，所以当newPtr生命周期结束后，堆空间也被回收了。</p><p>但在newPtr被释放掉之后，oldPtr却还能通过get方法访问原来的堆空间，它还能将<code>-100</code>写入了被释放的堆空间。<strong>这是非常可怕的事情，因为oldPtr通过get方法拿到的已经是野指针了。</strong></p><p>因此，多智能指针共享堆空间并用owner控制最终资源释放的方法并不是特别好的智能指针方案。</p><h3 id="不允许共享，独占所有权"><a href="#不允许共享，独占所有权" class="headerlink" title="不允许共享，独占所有权"></a>不允许共享，独占所有权</h3><p>既然多智能指针共享堆空间存在着这样或那样的问题，那干脆不让他们共享得了。比如下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">AutoPtr</span><span class="params">(T * ptr=<span class="literal">nullptr</span>)</span>: _<span class="title">ptr</span><span class="params">(ptr)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr(AutoPtr&lt;T&gt; &amp; autoptr): _ptr(autoptr._ptr)&#123;</span><br><span class="line">        autoptr._ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~AutoPtr()&#123;</span><br><span class="line">        <span class="keyword">if</span>(_ptr)&#123;</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr&lt;T&gt; &amp; <span class="keyword">operator</span>=(AutoPtr&lt;T&gt; &amp; autoptr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;autoptr) &#123;</span><br><span class="line">            <span class="keyword">if</span>(_ptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            _ptr = autoptr._ptr;</span><br><span class="line">            autoptr._ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">AutoPtr&lt;<span class="keyword">int</span>&gt; <span class="title">oldPtr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line">    AutoPtr&lt;<span class="keyword">int</span>&gt; newPtr = oldPtr; <span class="comment">//oldPtr已经不指向堆空间了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中我们不允许多个AutoPtr之间共享同一块堆空间，当将一个AutoPtr赋值给另一个AutoPtr时，让原来的AutoPtr指向空地址（nullptr)，新的AutoPtr指向堆空间。上面代码执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set new object,0x7fe905502760</span><br><span class="line">copy construct, 0x7fe905502760          &#x2F;&#x2F;newPtr 指向堆空间</span><br><span class="line">delete object，0x7fe905502760           &#x2F;&#x2F;newPtr 析构</span><br><span class="line">really,delete object，0x7fe90550276     &#x2F;&#x2F;newPtr 指向的堆空间被释放</span><br><span class="line">delete object，0x0                      &#x2F;&#x2F;oldPtr 析构，此时可以看到它指向的地址为nullptr</span><br></pre></td></tr></table></figure><p>通过结果可以证明我们上面修改的代码已经阻止了多个AutoPtr共享同一块堆空间的可能。</p><p>然而上面的实现打破了我们对传统指针的认知，这会给你带来很多麻烦。尤其是多人合作时，如果大家对AutoPtr没有一致的认识，特别容易出现问题。因为既然是指针，那它就应该允许多个指针指向同一块堆空间。因此，当不有了解AutoPtr的同学使用它时，很可能还会认为多个AutoPtr是指向同一块堆空间的，这样当他通过老的AutoPtr向堆空间写数据时就会产生crash。比如像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">*(oldptr.get()) &#x3D; 10;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set new object,0x7fd93bc028c0</span><br><span class="line">copy construct, 0x7fd93bc028c0</span><br><span class="line">[1]    39662 segmentation fault  .&#x2F;autoptr  &#x2F;&#x2F;这里crash了</span><br></pre></td></tr></table></figure><p>上面的AutoPtr就是C++98规范中的auto_ptr的实现，由于该实现总是存在这样或那样的问题，因此现在auto_ptr已经被废弃掉了。</p><h2 id="scoped-ptr"><a href="#scoped-ptr" class="headerlink" title="scoped_ptr"></a>scoped_ptr</h2><p>我们已经看到上面的AutoPtr有各种弊端，引起这些弊端的最主要的原因是AutoPtr具有控制权的传递性，也就是说它允许从一个AutoPtr赋值给另一个AutoPtr。</p><p>为了彻底解决AutoPtr上面所述的问题，就出现了scoped_ptr。scoped_ptr最早是在C++的boost库中出现的，其出现的原因是从C++98之后C++标准一直没有更新智能指针的规范。因此C++大牛们纷纷发布了自己私有标准，而scoped_ptr就是其中之一。</p><p>scoped_ptr的核心思想是什么呢？既然auto_ptr的所有问题都是因为传递性引起的，所以阻止其传递性就可以解决这个问题了。因此scoped_ptr的实现也特别简单，它将其拷贝构造函数及赋值操作符全部隐藏起来，这样就不会有auto_ptr的问题了。</p><p>下面我们来看一下它的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScopedPtr</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ScopedPtr(T * ptr = <span class="literal">nullptr</span>): _ptr(ptr)&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T* <span class="keyword">operator</span>-&gt;()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T&amp; <span class="keyword">operator</span>*()&#123;</span><br><span class="line">            <span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_ptr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">T* <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~ScopedPtr()&#123;</span><br><span class="line">            <span class="keyword">if</span>(_ptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        ScopedPtr(ScopedPtr&lt;T&gt; &amp; scopedptr)&#123;&#125;</span><br><span class="line">        ScopedPtr&lt;T&gt; &amp; <span class="keyword">operator</span>=(ScopedPtr&lt;T&gt; &amp; scopedptr)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T *_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">ScopedPtr&lt;<span class="keyword">int</span>&gt; <span class="title">myPtr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line">    ScopedPtr&lt;<span class="keyword">int</span>&gt; newPtr = myPtr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//clang++ -g -o scopedptr test_scopedptr.cpp</span></span><br></pre></td></tr></table></figure><p>当我们编译上面的代码时，会报下面的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test_scopedptr.cpp:32:29: error: calling a protected constructor of class &#39;ScopedPtr&lt;int&gt;&#39;</span><br><span class="line">    ScopedPtr&lt;int&gt; newPtr &#x3D; myPtr;</span><br><span class="line">                            ^</span><br><span class="line">test_scopedptr.cpp:23:9: note: declared protected here</span><br><span class="line">        ScopedPtr(ScopedPtr&lt;T&gt; &amp; scopedptr)&#123;&#125;</span><br><span class="line">        ^</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure><p>上面的错误正是我们想要的结果。只要你对ScopedPtr进行赋值，在编译时就不让其编译通过，这样就不会再产生AutoPtr的问题了。</p><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>我们上面所讲的scoped_ptr并非是官方的标准，它是C++大牛们自己实现的版本。到了C++11之后官方版本来了，其被命名为unique_ptr。实际上unique_ptr与scoped_ptr功能几乎是一模一样，不过它们之间也有一些细微差别。</p><p>差别是什么呢？就是unique_ptr可以对右值进行转移，<code>对右值转移</code>这是啥意思呢？说明白了就是提供了一种特殊方法可以将unique_ptr赋值给另一个unique_ptr，被转移后的unique_ptr也就不能再处理之前管理的指针了。</p><p>我们还是来看一个具体的例子你就清楚了，只要给我们之前的ScopedPtr加上一个移动构造函数和移动赋值运算符就实现unique_ptrr的转移功能了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class ScopedPtr&#123;</span><br><span class="line">    ...</span><br><span class="line">    ScopedPtr(ScopedPtr&lt;T&gt;&amp;&amp; scopedptr) noexcept : _ptr(scopedptr._ptr)&#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;move construct...&quot; &lt;&lt; std::endl;</span><br><span class="line">        scopedptr._ptr &#x3D;  nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ScopedPtr&amp; operator&#x3D;(ScopedPtr&lt;T&gt; &amp;&amp; scopedptr) noexcept &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;move assignment...&quot; &lt;&lt; std::endl;</span><br><span class="line">        if(this !&#x3D; &amp;scopedptr)&#123;</span><br><span class="line">            _ptr &#x3D; scopedptr._ptr;</span><br><span class="line">           scopedptr._ptr &#x3D; nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[])&#123;</span><br><span class="line">    ScopedPtr&lt;int&gt; myPtr(new int(100));</span><br><span class="line">    &#x2F;&#x2F;ScopedPtr&lt;int&gt; newPtr &#x3D; myPtr;            &#x2F;&#x2F;拷贝构造函数已经不能用了</span><br><span class="line">    ScopedPtr&lt;int&gt; newPtr &#x3D; std::move(myPtr);   &#x2F;&#x2F;可以使用移动拷贝构造函数进行转移</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;clang++ -std&#x3D;c++11 -g -o scopedptr test_scopedptr.cpp</span><br></pre></td></tr></table></figure><p>上面main函数中的第二行调用的是拷贝构造函数，由于该函数是不是public属性，所以调用该行时会失败。而第三行会调用移动构造函数，因为我们已经实现了移动构造函数，所以该行可以编译成功。在运行时，当myPtr移动给newPtr后，myPtr也就失去了对原指针的控制权，这在代码中也有体现就是将 scopedptr的<code>_ptr</code>域设置为nullptr了。</p><p>上面就是C++11标准中的unique_ptr的实现，这样一分析下来也是蛮简单的对吧。</p><p>另外，对于移动构造函数，std::move这些概念我在另一篇文章<a href="https://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">《C++高阶知识：深入分析移动构造函数及其原理》</a>中有详细的介绍，对这块知识不了解的同学可以去看一下。</p><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>虽然unique_ptr已经很好用了，但有时候我们还是需要多个智能指针管理同一块堆内存空间。之前在讲AutoPtr时我们已经介绍了多个智能指针管理同一块内存空间会引起很多问题，有没有更好的方式来解决这些问题呢？</p><p>其中引用计数法是个不错的解决方案，实现起来也比较简单。其基本原理是当有多个智能指针指对同一块堆空间进行管理时，每增加一个智能指针引用计数就增1，每减少一个智能指针引用计数就减少。当引用计数减为0时，就将管理的堆空间释放掉。</p><p>我们还是看一个具体例子吧，其实现是在unique_ptr的基础之上实现的，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScopedPtr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        ScopedPtr(T *ptr = <span class="literal">nullptr</span>): _ptr(ptr), _ref_count(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>))&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ScopedPtr(ScopedPtr&lt;T&gt; &amp; scopedptr): _ptr(scopedptr._ptr), _ref_count(scopedptr._ref_count)&#123;</span><br><span class="line">            ++（*_ref_count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ScopedPtr &amp; <span class="keyword">operator</span>=(ScopedPtr&lt;T&gt; &amp; scopedptr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;scopedptr)&#123;</span><br><span class="line">                _release();</span><br><span class="line">                _ptr(scopedptr._ptr);</span><br><span class="line">                _ref_conut(scopedptr._ptr);</span><br><span class="line">                ++(*_ref_count);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~ScopedPtr()&#123;</span><br><span class="line">            _release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span>* <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> *_ref_count; </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="keyword">void</span> _release() &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"deconstruct...: count="</span> &lt;&lt; ((*_ref_count) <span class="number">-1</span>)  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(--(*_ref_count) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">                <span class="keyword">delete</span> _ref_count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">int</span> *_ref_count;   <span class="comment">//引用计数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">ScopedPtr&lt;<span class="keyword">int</span>&gt; <span class="title">myPtr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line">    ScopedPtr&lt;<span class="keyword">int</span>&gt; pT2 = myPtr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//clang++ -std=c++11 -g -o sharedptr test_sharedptr.cpp</span></span><br></pre></td></tr></table></figure><p>通过上面的修改，我们就可以将unique_ptr修改成shared_ptr了，测试结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">default construct ...</span><br><span class="line">copy construct ...: count&#x3D;2</span><br><span class="line">deconstruct...: count&#x3D;1</span><br><span class="line">deconstruct...: count&#x3D;0</span><br></pre></td></tr></table></figure><p>从结果中我们可以看到创建myPtr时引用计数为 1，将myPtr赋值给pT2时引用计算为2。当main程序结束后首先释放pT2，其引用计数减1。再释放myPtr，引用计数减为0，当引用计数为0时，释放堆空间。</p><p>这样的智能指针还是非常棒的，我们再也不怕内存泄漏了！！！</p><p>等等，我们好像高兴的太早了，当出现循环指向时还是会出现内存泄漏。我们来看一下例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ScopeddPtr&lt;Node&gt; _prev;</span><br><span class="line">    ScopeddPtr&lt;Node&gt; _next;</span><br><span class="line"></span><br><span class="line">    ~Node()</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"delete :"</span> &lt;&lt;<span class="keyword">this</span>&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ScopedPtr&lt;Node&gt; <span class="title">cur</span><span class="params">(<span class="keyword">new</span>(Node))</span></span>;</span><br><span class="line"><span class="function">ScopedPtr&lt;Node&gt; <span class="title">next</span><span class="params">(<span class="keyword">new</span>(Node))</span></span>;</span><br><span class="line">cur-&gt;_next = next;</span><br><span class="line">next-&gt;_prev = cur;</span><br></pre></td></tr></table></figure><p>上面这段代码就会出现内存泄漏，我们来分析一下。</p><p>首先第一行会创建三个Node类型的智能指针，分别是 <code>cur-&gt;_prev</code>、<code>cur-&gt;_next</code> 、<code>cur</code> 此时它们各自的引用计数都是 1；第二行也会创建三个Nodet智能指针，分别是<code>next-&gt;_prev</code>、<code>next-&gt;_next</code>及<code>next</code>; 第三行完成之后，<code>cur-&gt;_next</code>和<code>next</code>的引用计数都为 2；第四行完成后，<code>next-&gt;_prev</code>和<code>cur</code>的引用计数也变成了2；</p><p>当main程序结束时，next和cur分别调用它们的析构函数，因此<code>next</code>和<code>cur-&gt;_next</code>的引用计数变为1，<code>cur</code>和<code>next_prev</code>的引用计数也变成了1，但由于没有减至0，所以资源永会不会被释放掉。这就是产生内存泄露的原因。</p><p>真是辛辛苦苦好几年，一下回到解放前。使用引用计数还是会产生内存泄漏，我们仿佛又回到了起点。</p><p>不过别着急，C++11又给我们提供了新的解决方案，如何解决这个问题呢？</p><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>weak_ptr就是专门为了解决这个问题而出现的。实际上weak_ptr不能单独称为一个智能指针，它必须与shared_ptr一起使用，起到辅助share_ptr的作用。我们来看看它是如何解决上述问题的吧。</p><p>首先引入weak_ptr后，weak_ptr也要有自己的引用计数，因此我们需要修改之前的ScopedPtr，将它的计数成员变成一个类型，包括它自己的计数和weak_ptr的计数，它看起来像下面的样子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Counter():s(<span class="number">0</span>),w(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> s; <span class="comment">//存放share_ptr引用计数</span></span><br><span class="line">        <span class="keyword">int</span> w; <span class="comment">//存放weak_ptr引用计数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来我们来修改一下ScopedPtr，由于这次修改比较大，所以我给它重新起一个名子，叫作SharedPtr吧，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">WeakPtr</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SharedPtr &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        SharedPtr(T * ptr = <span class="literal">nullptr</span>):_ptr(ptr)&#123;</span><br><span class="line">            _cnt = <span class="keyword">new</span> Counter();</span><br><span class="line">           <span class="keyword">if</span>(_ptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                 _cnt-&gt;s = <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~SharedPtr()&#123;</span><br><span class="line">            _release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SharedPtr(SharedPtr&lt;T&gt; &amp; sharedptr): _ptr(sharedptr._ptr), _cnt(sharedptr._cnt)&#123;</span><br><span class="line">            _cnt-&gt;s++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SharedPtr(WeakPtr&lt;T&gt; &amp; weakptr): _ptr(weakptr._ptr), _cnt(weakptr._cnt)&#123;</span><br><span class="line">            _cnt-&gt;s++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SharedPtr &amp; <span class="keyword">operator</span>=(SharedPtr&lt;T&gt; &amp; sharedptr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> != &amp; sharedptr)&#123;</span><br><span class="line">                _release();</span><br><span class="line">                _ptr = sharedptr._ptr;</span><br><span class="line">                _cnt = sharedptr._cnt;</span><br><span class="line">                _cnt-&gt;s++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T&amp; <span class="keyword">operator</span> *()&#123;</span><br><span class="line">            <span class="keyword">return</span> *_ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T* <span class="keyword">operator</span> -&gt;()&#123;</span><br><span class="line">            <span class="keyword">return</span> _ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//friend class WeakPtr&lt;T&gt;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">       <span class="keyword">void</span> _release()&#123;</span><br><span class="line">            _cnt-&gt;s--;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"release "</span>&lt;&lt;_cnt-&gt;s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(_cnt-&gt;s &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">                <span class="keyword">if</span>(_cnt-&gt;w &lt;<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">delete</span> _cnt;</span><br><span class="line">                    _cnt=<span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T * _ptr;</span><br><span class="line">        Counter * _cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakPtr</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        WeakPtr():_ptr(<span class="literal">nullptr</span>), _cnt(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        ~WeakPtr()&#123;</span><br><span class="line">            _release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WeakPtr(WeakPtr&lt;T&gt; &amp; weakptr):_ptr(weakptr._ptr), _cnt(weakptr._cnt)&#123;</span><br><span class="line">            _cnt-&gt;w++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WeakPtr(SharedPtr&lt;T&gt; &amp; sharedptr):_ptr(sharedptr._ptr), _cnt(sharedptr._cnt)&#123;</span><br><span class="line">            _cnt-&gt;w++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WeakPtr &amp; <span class="keyword">operator</span>=(WeakPtr&lt;T&gt; &amp; weakptr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;weakptr)&#123;</span><br><span class="line">                _release();</span><br><span class="line">                _ptr = weakptr._ptr;</span><br><span class="line">                _cnt = weakptr._cnt;</span><br><span class="line">                _cnt-&gt;w++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WeakPtr &amp; <span class="keyword">operator</span>=(SharedPtr&lt;T&gt; &amp; sharedptr)&#123;</span><br><span class="line">            _release();</span><br><span class="line">            _ptr = sharedptr._ptr;</span><br><span class="line">            _cnt = sharedptr._cnt;</span><br><span class="line">            _cnt-&gt;w++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">SharedPtr&lt;T&gt; <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> SharedPtr&lt;T&gt;(*<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">expired</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(_cnt &amp;&amp; _cnt-&gt;s &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"empty "</span>&lt;&lt;_cnt-&gt;s&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//friend class SharedPtr&lt;T&gt;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="keyword">void</span> _release()&#123;</span><br><span class="line">            <span class="keyword">if</span>(_cnt)&#123;</span><br><span class="line">                _cnt-&gt;w--;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"weakptr release"</span>&lt;&lt;_cnt-&gt;w&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">if</span>(_cnt-&gt;w &lt; <span class="number">1</span> &amp;&amp; _cnt-&gt;s &lt;<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">//delete cnt;</span></span><br><span class="line">                        _cnt=<span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T * _ptr;</span><br><span class="line">        Counter * _cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    WeakPtr&lt;Node&gt; _prev;</span><br><span class="line">    WeakPtr&lt;Node&gt; _next;</span><br><span class="line"></span><br><span class="line">    ~Node()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"delete :"</span> &lt;&lt;<span class="keyword">this</span>&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">SharedPtr&lt;Node&gt; <span class="title">cur</span><span class="params">(<span class="keyword">new</span>(Node))</span></span>;</span><br><span class="line">    <span class="function">SharedPtr&lt;Node&gt; <span class="title">next</span><span class="params">(<span class="keyword">new</span>(Node))</span></span>;</span><br><span class="line">    cur-&gt;_next = next;</span><br><span class="line">    next-&gt;_prev = cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//clang++ -std=c++11 -g -o weakptr test_weakptr.cpp</span></span><br></pre></td></tr></table></figure><p>以上就是WeakPtr的实现以及SharedPtr的改造，从中我们可以看到，SharedPtr与我们之前的ScopedPtr区别并不是很大，主要做了三点有修改：一、以前只有一个计数器，然在变成了两个，一个是SharedPtr本身的计数，另一个是WeakPtr的计数；二是增加了一个参数为WeakPtr引用的拷贝构造函数;三、<code>_ptr</code>和<code>_cnt</code>的释放都是在SharedPtr中完成的，WeakPtr不做具体的释放工作。</p><p>WeakPtr是新增加的弱指针，它是配合SharedPtr使用的，自己并不能单独使用。WeakPtr也包含<code>_ptr</code>和<code>_cnt</code>两个成员，但它更多是是引用，对它们没有创建和释放权。另外在WeakPtr中会对Counter对象的w字段操作，也就是说多个WeakPtr指向同一个堆空间时，它仅操作Counter中的w字段。</p><p>因此，对于我们之前的SharedPtr形成环后导致的内存泄漏可以通过WeakPtr对其进行改造，这样内存泄漏的问题就迎刃而解了。</p><p>上面修改后的代码我们再来分析一遍。首先第一行会创建两个WeakPtr指针 <code>cur-&gt;_prev</code>、<code>cur-&gt;_next</code> 和一个SharedPtr智能指针<code>cur</code>。此时它们各自的引用计数都是 1；第二行同样也会创建二个WeakPtr指针<code>next-&gt;_prev</code>、<code>next-&gt;_next</code>和一个SharedPtr智能指针<code>next</code>; 第三行完成之后，<code>cur-&gt;_next</code>的_cnt-&gt;w为1，<code>next</code>的_cnt-&gt;s为1；第四行完成后，<code>next-&gt;_prev</code>的_cnt-&gt;w为1，<code>cur</code>的_cnt-&gt;s引用计数也为1；</p><p>当main程序结束时，next和cur分别调用它们的析构函数，因此<code>next</code>引用计数为0，释入Node对象，在Node中又会释放_prev和_next。next释放完成后开始释放<code>cur</code>，同里cur所持有的资源也一并释放。因此就不会再有内存泄漏了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文的篇幅有点长，不过每一部分都是不可或缺的。在本文中向你详细讲解了 auto_ptr、scoped_ptr、unique_ptr、shared_ptr以及与之配套的 weak_ptr的衍化过程。通过这样一个过程让你知道了这几个智能指针的作用是什么，应该用在地方，以及该如何使用。</p><p>相信通过本文你会对C++中的智能指针有了深刻的理解。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">C++高阶知识：深入分析移动构造函数及其原理</a><br>[重学C/C++中的const][<a href="https://avdancedu.com/5e7916e3/]" target="_blank" rel="noopener">https://avdancedu.com/5e7916e3/]</a><br><a href="http://localhost:4000/670ef31f/" target="_blank" rel="noopener">聊聊C++中的类型转换</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智能指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学C/C++中的const</title>
      <link href="/5e7916e3/"/>
      <url>/5e7916e3/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/const/const.jpg" alt=""></p><p>使用<code>C/C++</code>语言的同学应该对<code>const</code>都比较了解，但对于初学者来说，<code>const</code>确是一个难肯的骨头，理解起来困难重重。今天我就带你重新学习一下C/C++的中的<code>const</code>。</p><a id="more"></a><h2 id="const-与-define-的区别"><a href="#const-与-define-的区别" class="headerlink" title="const 与 #define 的区别"></a>const 与 #define 的区别</h2><p>在<code>C/C++</code>中定义常量通常使用<code>const</code>关键字，当然你也可以使有宏<code>#define</code>来定义。这两种方式定义常量如下所示：</p><ul><li>const 定义常量  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int PI &#x3D; 3.14;</span><br></pre></td></tr></table></figure></li><li>宏定义常量  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define PI &#x3D; 3.14</span><br></pre></td></tr></table></figure></li></ul><p>这两种定义常量的方式有什么区别呢？</p><p>要回答这个问题，我们需要了解一点编译原理的知识。编译器在编译我们写好C/C++程序时，其编译器过程为：<strong>预编译-&gt;编译-&gt;链接</strong>。<code>C/C++</code>中宏的替换就是在预编译阶段完成的，也就是说在预编译阶段将C/C++中的所有用到的宏都用宏定义中的值替换掉。</p><p>而<code>const</code> 定义的常量则与宏定义的常量不同，它是在编译阶段进行检测，而且还可以对其类型进行检测。因此我们可以总结出使用<code>const</code>定义的常量与宏定义的常量有如下区别:</p><ul><li>宏是在预编译时进行宏展开，而const是在编译时检测，所以两者操作的时期不同</li><li>由于宏在预编译时被操作，所以无法进行类型检测；而const则可以进行类型检测</li><li>因在编译阶段可以形成符号表，所以const定义的常量可以通过调试器进行调试；而宏在展开后就消失了，所以无法通过调试器进行调试</li></ul><p>以上就是<code>const</code>与<code>宏</code>的最主要的区别。所以一般情况下我们都建议使用const来定义常量。</p><h2 id="const常量与const常量指针"><a href="#const常量与const常量指针" class="headerlink" title="const常量与const常量指针"></a>const常量与const常量指针</h2><p>上面我们已经列举过const如何定义常量，这里就不再赘述了。现在咱们来看一下const常量指针，它该如何定义呢?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int * ptr; &#x2F;&#x2F;const常量指针</span><br></pre></td></tr></table></figure><p>上面就是const常量指针的定义，也挺好理解的对吧。我们将const常量和const常量指针放在一起看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int i;    &#x2F;&#x2F;const常量</span><br><span class="line">const int* ptr; &#x2F;&#x2F;const常量指针</span><br></pre></td></tr></table></figure><p>将他们放在一起比较着看，你就更容易理解const常量指针了，无非就是将const常量中的类型变成指针而已。</p><h2 id="const常量指针的作用"><a href="#const常量指针的作用" class="headerlink" title="const常量指针的作用"></a>const常量指针的作用</h2><p><strong>那么常量指针的作用是什么呢？</strong>，我们来看个例子你就清楚了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const int i &#x3D; 100;     &#x2F;&#x2F; 定义一个常量</span><br><span class="line">i &#x3D; 100;               &#x2F;&#x2F; 不允许修改常量</span><br><span class="line"></span><br><span class="line">int *p &#x3D; &amp;i;           &#x2F;&#x2F; 老的编译器是被允许的，这实际存在安全问题</span><br><span class="line">                       &#x2F;&#x2F; 为了解决这个问题，新的编译器报错，非常量指针不允许指向常量地址</span><br><span class="line"></span><br><span class="line">const int * ptr &#x3D; &amp;i;  &#x2F;&#x2F; 常量指针指向常量地址</span><br><span class="line">*ptr &#x3D; 100;            &#x2F;&#x2F; 不允许修改常量的内容</span><br></pre></td></tr></table></figure><p>按照常量的定义，常量定义好后其内容就不允许再修改了，因此对于上面代码中的前两行相信你不会有什么异义。</p><p>但在较老的编译器上，存在一个漏洞，它允许你用普通指针指向常量地址。这样你就可以通过该指针修改常量的内容了，这是非常大的安全漏洞。为了消除这个安全隐患，在新的编译器上已经不允许普通指针指向const常量了。</p><p>为什么在老编译器上指针可以指向常量地址并修改其内容呢？究其原因是因为const定义的常量实际是在内存的可读写空间，只是由于编译器限制你才不能修改它。而老的编译器却没有这方面的限制，所以才会出现通过普通指针修改常量的可能。</p><p>我们再来看代码的最后两行。使用const常量指针指向常量地址，此时你无论用新编译器还是老编译器，都无法通过该指针修改常量的内容。所以代码的最后一行当你修改常量内容时就会报错。</p><p>通过上面的讲解，你应该对常量指针的概念比较清楚了。常量指针不能修改常量内容，但能不能让常量指针指向另外一个常量的地址呢？比如下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const int i &#x3D; 100;</span><br><span class="line">const int n &#x3D; 1000;</span><br><span class="line"></span><br><span class="line">const int * ptr &#x3D; &amp;i;   &#x2F;&#x2F;常量指针先指向 i 常量的地址</span><br><span class="line">ptr &#x3D; &amp;n;               &#x2F;&#x2F;又修改为指向 n 常量的地址</span><br></pre></td></tr></table></figure><p>这样做当然是可以的，因为常量指针限制的是不能修改常量内容，但并没有限制它指向哪个常量。</p><h2 id="const变形"><a href="#const变形" class="headerlink" title="const变形"></a>const变形</h2><p>上面我们已经清楚了const常量指针是什么，它起了什么作用。但它还有一点你不知道，就是它会变型。我们来看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int * ptr;</span><br><span class="line">int const * ptr;</span><br></pre></td></tr></table></figure><p>上面这两行代码很像是不是？第二行代码将 const 放到了 int 类型之后，它表达的是什么意思呢？<strong>其实两行表示的是同一个意思，都是常量指针</strong>。只是有的人喜欢将const写在最前面，有的人喜欢将const 写在类型后面罢了。这里有一个记忆的小巧门，我们只要记住const是在 <code>*</code> 左边它就表示的是常量指针就OK了，</p><h2 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h2><p>上面的内容清楚之后，我们再来一个复杂的<strong>指针常量</strong>。看到这个词相信很多同学立马晕了，上面是常量指针，这又来个指针常量是这是说绕口令吗？先别急，我们先来看个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int * const ptr;</span><br></pre></td></tr></table></figure><p>上面这行代码是不是与前面的很相似？一模一样? 如果你这样认为说明你没有仔细观察。之前的常量指针const是在<code>*</code>号左边，这次的const跑到<code>*</code>号右边了。</p><p>它表示的是什么意思呢？</p><p>前面我已经说了，对于常量指针来说，你是不能修改它所指向的内容的，因为内容是常量，但它可以让它指向不同的常量地址。新需求来了，有没有可能让指针指向一个地址就不动了呢？或者换个思考的角度，既然const可以定义常量，能不能定义一个指针常量呢？<strong>这就是指针常量的由来</strong>。</p><p>C/C++编译器的作者考虑的一下这个需求，觉得这个需求是合理的，决定实现它。但怎么才能表示指针常量呢？于是就有了 <code>const int * const ptr</code> 这个写法，const 放在<code>*</code>后面表达对ptr的限制。</p><p>了解了指针变量的由来，下面我们来看一下它的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 100;</span><br><span class="line">int n &#x3D; 1000;</span><br><span class="line"></span><br><span class="line">int * const ptr &#x3D;  &amp;i; &#x2F;&#x2F; 正确，初始指向某个变量</span><br><span class="line">ptr &#x3D; &amp;n;              &#x2F;&#x2F; 错误，ptr是常量，不能再发生变化</span><br><span class="line"></span><br><span class="line">*ptr &#x3D; 20;             &#x2F;&#x2F; 正确，因为我们没有对指针指向的内容做限制</span><br></pre></td></tr></table></figure><p>上面代码中定义了两个变量 i 和 n，ptr是针指常量，因此它只能在初始化时指向某个变量的地址，之后它就不能更改变指向其它地址了，因为它是<strong>常量</strong>。<strong>但需要注意的是ptr指向的内容是可以被修改的</strong>。</p><h2 id="指向常量的指针常量"><a href="#指向常量的指针常量" class="headerlink" title="指向常量的指针常量"></a>指向常量的指针常量</h2><p>看这个标题就觉得好复杂啊！没错我们又要升级难度了。先看个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int * const ptr1;</span><br><span class="line">int const * const ptr2;</span><br></pre></td></tr></table></figure><p>天呐，一条语句中出列了两个const，如果我们没有基础的话，这两行代码简直无法理解。不过，有了上面的基础我们再来看这两句还是能猜出它要干什么的对吧？</p><p>这两条语句的含义是一样的，表示的是ptr1/ptr2指向的地址不能再改变，而且它指向的地址里的内容也不能再改变。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在本文中我向你详细介绍了C/C++中的<code>const</code>的含义和用法，总结一下包括以下几种：</p><ul><li>定义常量, 内容不能改变，<code>const int a;</code></li><li>定义常量指针，指向的内容不能改变，<code>const int * ptr;</code> 或 <code>int const * ptr;</code></li><li>定义指针常量，指针不能改变，但指向的内容可以改变。<code>int * const ptr</code></li><li>定义指向常量的针指常量，指针不能改变，内容也不能改变。<code>const int * const ptr</code> 或 <code>int const * const ptr</code></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">C++高阶知识：深入分析移动构造函数及其原理</a><br><a href="https://avdancedu.com/9683d88/" target="_blank" rel="noopener">细说智能指针</a><br><a href="https://avdancedu/670ef31f/" target="_blank" rel="noopener">聊聊C++中的类型转换</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> const </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分析WebRTC，重学Windows开发</title>
      <link href="/2fb1b8c6/"/>
      <url>/2fb1b8c6/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/windows/win95.jpg" alt=""></p><p>N多年没有写过 Window 程序了。为了研究 WebRTC 源码，这两天重新学习一下。还记得上大学的时候看过 《Windows95 程式设计》台湾版，对那本书印象极为深刻。一是当时国内确实没有一本写的那么深入的书籍，二是那本书翻译的特别好，让人一看就特别明白。10多年过多了，当时的情景还记忆犹新，也可见那本书写的有多好了。</p><a id="more"></a><p>Windows开发有很多知识点，窗口啊，句柄啊，消息啊，重绘啊，baba …..，但一个 Windows 程序的核心就是一个消息处理机制。</p><h2 id="Windows程序运行的基本原理"><a href="#Windows程序运行的基本原理" class="headerlink" title="Windows程序运行的基本原理"></a>Windows程序运行的基本原理</h2><p>Windows程序是消息为驱动的，所以它的核心就是消息的传递与处理。如鼠标消息、键盘消息，Timer消息，窗口的创建与消毁等等。那么，Windows程序是在哪儿处理消息呢？是否掌握了它，就控制了Windows程序的核心呢？答案是肯定的，它就是 WndProc 函数。所有的消息都要经过这个函数处理。</p><p>Windows 程序有两种消息，一种是队列消息，它通过 DispatchMessage 函数分发给 WndProc 函数，像鼠标消息、键盘消息，Timer消息都是这类消息。另一种是非队列消息，它是系统函数直接发送给 WndProc 函数的，像窗口的创建与消毁消息，WM_COMMON消息等等都是非队列消息。</p><h2 id="最简单的-Windows-程序"><a href="#最简单的-Windows-程序" class="headerlink" title="最简单的 Windows 程序"></a>最简单的 Windows 程序</h2><p>一个最简单的 Windows 程序都包括哪些内容呢？下面我们详细介绍一下：</p><h3 id="WinMain-函数"><a href="#WinMain-函数" class="headerlink" title="WinMain 函数"></a>WinMain 函数</h3><p>我们都知道无论是Windows程序，还是Linux程序，也无论是C/C++，还是 Java语言，它们都有一个 main 函数。更准确点说应该叫“程序入口点”。</p><p>我们写程序时，一般都以 main 开头，编译器在编译该程序时，会将 main 函数地址写入到可执行文件的文件头中，这就是“程序入口点”了。</p><p>在执行程序时，操作系统首先通过程序加载器将要运行的程序加载到内存中，然后重新计算符号地址表。一切准备就绪后，才跳到程序入口点，将一条条指令送入CPU流水线开始执行程序。这就是程序的运行的基本流程。</p><p>因此，我们可以知道每个程序都有一个入口点。但是否一定以 main 开头呢? 其实，只要编译器能识别出入口点就可以，不必非要以 main 为标志。对于 Windows 程序就是这样，它就不使用 main作为入口点，而是换成了 WinMain 作为程序入口点。格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int CALLBACK WinMain(</span><br><span class="line">   _In_  HINSTANCE hInstance,</span><br><span class="line">   _In_  HINSTANCE hPrevInstance,</span><br><span class="line">   _In_  LPSTR lpCmdLine,</span><br><span class="line">   _In_  int nCmdShow</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="实现消息中心函数-WndProc"><a href="#实现消息中心函数-WndProc" class="headerlink" title="实现消息中心函数 WndProc()"></a>实现消息中心函数 WndProc()</h3><p>前面我已经介绍了 WndProc 是 Windows 程序的消息中心，所有的消息都要在这个函数中处理。如 窗口创建时发送的 WM_CREATE 消息，如果我们不处理它，Windows 操作系统就不会显示创建的窗口。</p><p>但 Windows 中有那么多消息，我们每个都处理岂不是要累死人？所以 Windows 很贴心的提供了一个API，就是 DefWindowProc 函数。该函数对所有的 Windows 消息都做了默认处理，如果我们很懒的话，可以将所有消息都交由它就好了。</p><p>有没有坐过山车的感脚？开始觉得很苦闷，突然又拨云见日了。嘿嘿！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK WndProc(</span><br><span class="line">        _In_  HWND hwnd,</span><br><span class="line">        _In_  UINT uMsg,</span><br><span class="line">        _In_  WPARAM wParam,</span><br><span class="line">        _In_  LPARAM lParam</span><br><span class="line">) &#123;</span><br><span class="line">return DefWindowProc(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册窗口类"><a href="#注册窗口类" class="headerlink" title="注册窗口类"></a>注册窗口类</h3><p>我们在创建窗口之前要注册一个窗口类，它是干啥用的呢？就是告诉操作系统，我要创建个什么样子的窗口，是啥背景色，鼠标是啥样子的，程序叫啥名子等等。</p><p>有了这个窗口类，我们就可以创建不同样式的窗口了，这样是不是觉得很方便呢？当然，一般情况下我们都使用默认样式！</p><p>这个窗口类除了设置样式外，其实它<strong>更重要的作用</strong>是指定 WndProc 函数，也就是为 Window 程序指定 “消息处理中心”。消息中心是谁，完全是由 RegisterClass 说了算，它说消息处理中心是 WndProc 就是 WndProc，它说 ABC 那就是 ABC。</p><p>一般我们调用注册窗口的代码都长的像下面这样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 类名</span><br><span class="line">WCHAR* cls_Name &#x3D; L&quot;My Class&quot;;</span><br><span class="line">&#x2F;&#x2F; 设计窗口类</span><br><span class="line">WNDCLASS wc &#x3D; &#123; &#125;;</span><br><span class="line">wc.hbrBackground &#x3D; (HBRUSH)COLOR_WINDOW;</span><br><span class="line">wc.lpfnWndProc &#x3D; WndProc;</span><br><span class="line">wc.lpszClassName &#x3D; cls_Name;</span><br><span class="line">wc.hInstance &#x3D; hInstance;</span><br><span class="line">&#x2F;&#x2F; 注册窗口类</span><br><span class="line">RegisterClass(&amp;wc);</span><br></pre></td></tr></table></figure><h3 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h3><p>创建窗口就比较简单了，高多少，宽多少，透明的还是非透明的，可显示还是不可显示，标题栏上要写啥字等等，这些都是由<code>创建窗口</code>说了算。形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建窗口</span><br><span class="line">      HWND hwnd &#x3D; CreateWindow(</span><br><span class="line">      cls_Name,           &#x2F;&#x2F;类名，要和刚才注册的一致</span><br><span class="line">      L&quot;我的应用程序&quot;,  &#x2F;&#x2F;窗口标题文字</span><br><span class="line">      WS_OVERLAPPEDWINDOW, &#x2F;&#x2F;窗口外观样式</span><br><span class="line">      38,                 &#x2F;&#x2F;窗口相对于父级的X坐标</span><br><span class="line">      20,                 &#x2F;&#x2F;窗口相对于父级的Y坐标</span><br><span class="line">      480,                &#x2F;&#x2F;窗口的宽度</span><br><span class="line">      250,                &#x2F;&#x2F;窗口的高度</span><br><span class="line">      NULL,               &#x2F;&#x2F;没有父窗口，为NULL</span><br><span class="line">      NULL,               &#x2F;&#x2F;没有菜单，为NULL</span><br><span class="line">      hInstance,          &#x2F;&#x2F;当前应用程序的实例句柄</span><br><span class="line">      NULL);              &#x2F;&#x2F;没有附加数据，为NULL</span><br></pre></td></tr></table></figure><h3 id="显示窗口"><a href="#显示窗口" class="headerlink" title="显示窗口"></a>显示窗口</h3><p>窗口创建完了，还要主动调<code>ShowWindows</code>函数让窗口显示出来，否则它是不会出来干活的。形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 显示窗口</span><br><span class="line">ShowWindow(hwnd, SW_SHOW);</span><br></pre></td></tr></table></figure><h3 id="循环处理，检索与分发消息"><a href="#循环处理，检索与分发消息" class="headerlink" title="循环处理，检索与分发消息"></a>循环处理，检索与分发消息</h3><p>这部分工作是在 WinMain 函数中要做的事儿。在 WinMain 中写一个循环，不停的从系统消息队列中取消息。</p><p>如果此时没有消息，则该线被程阻塞，并将CPU资源释放；如果有消息，需要判断是不是退出消息？如果不是，使用 DispatchMessage 将该消息分配出去。如果是退出消息，则退出消息循环，程序结束。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void WinMan(...)&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 消息循环</span><br><span class="line">MSG msg;</span><br><span class="line">while(GetMessage(&amp;msg, NULL, 0, 0))</span><br><span class="line">&#123;</span><br><span class="line">    TranslateMessage(&amp;msg);</span><br><span class="line">    DispatchMessage(&amp;msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是一个最简单的窗口 Window 程序。了解了上面这些知识，大家是不是觉得即使不用 MFC 也可以写出一个很不错的 Windows 程序呢？</p><h2 id="重要函数详细介绍"><a href="#重要函数详细介绍" class="headerlink" title="重要函数详细介绍"></a>重要函数详细介绍</h2><h3 id="WinMain"><a href="#WinMain" class="headerlink" title="WinMain"></a>WinMain</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int CALLBACK WinMain(</span><br><span class="line">  _In_ HINSTANCE hInstance, &#x2F;&#x2F;句柄</span><br><span class="line">  _In_ HINSTANCE hPrevInstance, &#x2F;&#x2F;总是 NULL</span><br><span class="line">  _In_ LPSTR     lpCmdLine, &#x2F;&#x2F;在命令行启动程序时的命令</span><br><span class="line">  _In_ int       nCmdShow &#x2F;&#x2F;程序启动时的显示方式</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>hInstance：句柄，就是一个内存地址，在该地址上有该程序的基本信息。</li><li>hPrevInstance：总是NULL，没啥用。</li><li>lpCmdLine： 用命令行启动时的命令，有兴趣的可以自己打印出来。</li><li>nCmdShow：程序启动时的显示方式，是隐藏，还是显示，是最大化，还是最小化显示。</li></ul><h3 id="注册窗口"><a href="#注册窗口" class="headerlink" title="注册窗口"></a>注册窗口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagWNDCLASS &#123;</span><br><span class="line">  UINT      style;</span><br><span class="line">  WNDPROC   lpfnWndProc;</span><br><span class="line">  int       cbClsExtra;</span><br><span class="line">  int       cbWndExtra;</span><br><span class="line">  HINSTANCE hInstance;</span><br><span class="line">  HICON     hIcon;</span><br><span class="line">  HCURSOR   hCursor;</span><br><span class="line">  HBRUSH    hbrBackground;</span><br><span class="line">  LPCTSTR   lpszMenuName;</span><br><span class="line">  LPCTSTR   lpszClassName;</span><br><span class="line">&#125; WNDCLASS, *PWNDCLASS;</span><br><span class="line"></span><br><span class="line">ATOM WINAPI RegisterClass(</span><br><span class="line">  _In_ const WNDCLASS *lpWndClass</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>style ：设置窗口样式。可以不设置。</li><li>lpfnWndProc ：这个字段特别重要，设置消息处理函数，它是消息的中心。</li><li>cbClsExtra ：不用设置。</li><li>cbWndExtra ：不用设置。</li><li>hInstance ：窗口句柄，与WinMain中的一样。</li><li>hIcon ：窗口图标。如果是NULL，使用默认图标。</li><li>hCursor ：设置光标样式。可以不设置</li><li>hbrBackground ：设置窗口背景色。</li><li>lpszMenuName：菜单名。如果为NULL说明没有菜单。</li><li>lpszClassName：这个参数要提供，长度不超过 256。</li></ul><h3 id="创建窗口-1"><a href="#创建窗口-1" class="headerlink" title="创建窗口"></a>创建窗口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HWND WINAPI CreateWindow(</span><br><span class="line">  _In_opt_ LPCTSTR   lpClassName,</span><br><span class="line">  _In_opt_ LPCTSTR   lpWindowName,</span><br><span class="line">  _In_     DWORD     dwStyle,</span><br><span class="line">  _In_     int       x,</span><br><span class="line">  _In_     int       y,</span><br><span class="line">  _In_     int       nWidth,</span><br><span class="line">  _In_     int       nHeight,</span><br><span class="line">  _In_opt_ HWND      hWndParent,</span><br><span class="line">  _In_opt_ HMENU     hMenu,</span><br><span class="line">  _In_opt_ HINSTANCE hInstance,</span><br><span class="line">  _In_opt_ LPVOID    lpParam</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>lpClassName ： 与注册的类名子一致。</li><li>lpWindowName ：窗口标题栏名子。</li><li>dwStyle ：窗口外观样式。</li><li>x ：窗口起始位置 x。</li><li>y ：窗口起始位置 y。</li><li>nWidth ：窗口宽度。</li><li>nHeight ：窗口高度。</li><li>hWndParent ：父窗口，没有的话设置为NULL</li><li>hMenu ：窗口菜单，没有设置为NULL</li><li>hInstance ： 窗口句柄。</li><li>lpParam ：符加数据，没有设置为 NULL</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过上面的介绍，我想你首先知道了Windows程序是由消息驱动的，真正负责消息处理的函数是 WinProc，它是在调用 RegisterClass 时指定的。通过 RegisterClass 我们还可以给窗口指定样式，并最终由 CreateWindow 创建出来。同时我们还可以总结出，通过 6 大步既可以创建出一个最简单的 Windows程序，这6步分别是：</p><ul><li>设置入口点，WinMain。</li><li>创建 WinProc 函数。</li><li>注册窗口类。</li><li>创建窗口。</li><li>显示窗口。</li><li>循环处理，检索与分发消息</li></ul><p>至此，一个Windows程序窗口已经展现在你面前了。 希望本文能对你有所帮助!</p><p> 谢谢！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/garrylea/SimpleWindow" target="_blank" rel="noopener">github地址</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>janus的线程模型</title>
      <link href="/8f43ddc9/"/>
      <url>/8f43ddc9/</url>
      
        <content type="html"><![CDATA[<p>我们要想把一个系统搞清楚，首先要把它的线程模型弄明白。比如它是单线程的还是多线程的？如果它是单线程的，那逻辑就比较简单了，像mediasoup就是单进程多实例的模型；如果是多线程的，那它的线程是如何分配的？每个线程的作用是什么？我们必须把这些都要弄清楚才行，否则我们就无法将这个系统彻底搞明白。</p><a id="more"></a><p>在分析 <code>janus</code> 的时候，我们也应尊循上面的原则。因此在分析<code>janus</code>之前，我们先来问几个问题，<code>janus</code>是多线程的模式吗？如果是多线程模式，那它一共有几个线程呢？ 这些线程又分别起什么作用？</p><p>如果我们将上面的问题回答好了，我想我们基本上就将<code>janus</code>的线程模型搞清楚了，搞清了它的线程模型也就撑握了<code>janus</code>的系统大体脉络。</p><h1 id="janus是多线程模式吗？"><a href="#janus是多线程模式吗？" class="headerlink" title="janus是多线程模式吗？"></a>janus是多线程模式吗？</h1><p>其实这个问题非常好回答，通过查看<code>janus</code>的主文件janus.c我们就能知道答案了。在janus.c中我们可以发现下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">GThread *watchdog &#x3D; g_thread_try_new(&quot;timeout watchdog&quot;, &amp;janus_sessions_watchdog, watchdog_loop, &amp;error);</span><br><span class="line">...</span><br><span class="line">GThread *requests_thread &#x3D; g_thread_try_new(&quot;sessions requests&quot;, &amp;janus_transport_requests, NULL, &amp;error);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>janus</code>是基于Linux 的GLIB库开发出来的，因此所有对系统的调用都是使用的GLIB库的API。而<code>g_thread_try_new</code>函数正中GLIB中用来创建线程的，在<code>g_thread_try_new</code>的底层真正调用的是<code>pthread</code>的相关API。</p><p><strong>通这上面的分析，我们可以知道janus是多线程的模式。</strong></p><h1 id="janus一共有几个线程？"><a href="#janus一共有几个线程？" class="headerlink" title="janus一共有几个线程？"></a>janus一共有几个线程？</h1><p>除了我们上面介绍的两个线程外，<code>janus</code>还使用了线程池的概念。在<code>janus</code>的初始化阶段就将线程池创建出来了。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">tasks &#x3D; g_thread_pool_new(janus_transport_task, NULL, -1, FALSE, &amp;error);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>查看<code>g_thread_pool_new</code>API的帮助文档，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GThreadPool *</span><br><span class="line">g_thread_pool_new (GFunc func,</span><br><span class="line">                   gpointer user_data,</span><br><span class="line">                   gint max_threads,</span><br><span class="line">                   gboolean exclusive,</span><br><span class="line">                   GError **error);</span><br></pre></td></tr></table></figure><p>通过这个定义我们可以知道<code>janus</code>创建的线程池时并没有对线程数进制控制。也就是说它可以开出系统可以支持的最大限度的线程个数。<strong>会在高并发时出现性能问题呢？这个还要等我们后面的深入分析才能清楚，目前来说这行代码还是有风险的。</strong></p><p>下面我们总结一下，通过对janus.c文件的分析，我们现在可以知道<code>janus</code>的线程模型是由两个专用线程<code>watchdog</code>、<code>request</code>和一个通用任务线程池构成的。如下图所示：</p><p><img data-src="https://cdn.avdancedu.com/image/article/janus_thread/janus_thread.jpg" alt="janus线程模型"></p><p>了解了<code>janus</code>的线程模型后，下面我们来看一下 <code>janus</code> 每个线程的作用吧。</p><h1 id="每个线程的作用"><a href="#每个线程的作用" class="headerlink" title="每个线程的作用"></a>每个线程的作用</h1><p>通过阅读代码，我们可以了解到这几个线程的主要作用是什么，下面我们来一一介绍一下。</p><p><strong>首先是主线程</strong>，这个线程的主要作用就是初始化的工作。主要包括以下几方面的工作：</p><ul><li>从配置文件中读配置信息，然后根据配置信息进行初始化工作</li><li>启动其它线程</li><li>动态加载plugin</li></ul><p><strong>WatchDog 线程</strong>，通过名子我们基本上就可以清楚它的作用了。它是监控线程，它每隔２秒做一次扫描，查看transport的session是否过期了。如果过期了，则给对应的transport发通知让transport结束处理。需要注意的是，这里的 trasnport代表的是不同协议的接入口，如RabbitMQ、MQTT、HTTP等。</p><p><strong>Request线程</strong>，用于处理接口请求。一般将接口请求分为两大类，文本类请求和命令类请求。如果是文本类请求的，则会启动新线程（从线程池中获取）进行处理；如果是命令的类的，则可以直接处理。当然对于命令类型的Request可能处理上会比较复杂，有可能会分成多个阶段处理，而在每个不同的阶段又会生成新的Request。</p><p><strong>最后一个就是线程池了</strong>，线程池的作用上面我已经介绍了，就是在处理Request时会从线程池中分配线程，然后执行Request任务，任务完成后再回收到线程池里。　</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过上面的描述我们可以看到<code>janus</code>的线程模型并不复杂，它启动了两个专门的线程，一个用于处理transport的session是否过期；另一个用于处理Request请求，当收到Request请求后，它又会把请求交给新的线程做延时处理。</p><p>以上我们就将 <code>janus</code> 的线程模型分析完了，读到这里我相信你已经对<code>janus</code>的线程模型有了一个大体的了解了。当然你仍然会很许多疑惑，这只能对照着<code>janus</code>的代码分析才能让你体会的更深刻！</p><p>谢谢！</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门》</a></li><li><a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级高并发WebRTC流媒体服务器设计与开发》</a></li><li><a href="https://time.geekbang.org/column/intro/207" target="_blank" rel="noopener">《从0打造音视频直播系统》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> WebRTC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解janus中的plugin管理</title>
      <link href="/26c3d930/"/>
      <url>/26c3d930/</url>
      
        <content type="html"><![CDATA[<p><code>janus</code>中的<code>plugin</code>是其非常重要的一部分内容，今天我们就来对这块内容做一下分析，看看<code>janus</code>是如何实现<code>plugin</code>的，以及它的工作原理是怎样的。</p><a id="more"></a><h2 id="janus的架构模型"><a href="#janus的架构模型" class="headerlink" title="janus的架构模型"></a>janus的架构模型</h2><p><code>janus</code>的最大特色就是可以以插件的方式对业务模块进行管理。比如当你想实现新业务时，按照<code>janus Plugin</code>的要求写一个<code>plugin</code>，然后将它放到指定目录下，这样<code>janus</code>在启动时就可以将它加载到内存中。</p><p>下面这张图是janus的整体架构图：</p><p><img data-src="https://cdn.avdancedu.com/image/article/janus_plugin/janus_plugin.png" alt="janus架构图"></p><p>从上面这张图我们可以看到，<code>janus</code>在设计时被分成了两层，即<code>核心层</code>和<code>插件层</code>。核心层主要用于资源的分配（如线程的启动与分配）、底层事件处理、各种WebRTC协议的实现及处理等；插件层用于业务处理，各种传输类型命令的处理等。</p><p>从中我们可以知道，这样的架构设计及管理方式特别适合变化比较快的业务模型。因为我们可以随时生成一个新的janus插件，并将它加载到内存中。</p><p>OK，了解了<code>janus</code>的架构，我们再来看看janus是如何实现插件管理的吧。</p><h2 id="Linux-系统下动态库的动态加载"><a href="#Linux-系统下动态库的动态加载" class="headerlink" title="Linux 系统下动态库的动态加载"></a>Linux 系统下动态库的动态加载</h2><p>要想真正理解janus的插件管理，我们首先要知道Linux系统是如何动态加载库的，这是我们理解 janus 插件管理的基础。</p><p>在Linux系统中，动态加载库其实很容易，只要用两个API 就可以了，即 <strong>dlopen</strong> 和 <strong>dlsym</strong> 。它们的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  path: 被加载到内存中的动态库路径</span><br><span class="line"> *  mode: RTLD_LAZY，用时加载；RTLD_NOW，立即加载；</span><br><span class="line"> *  return: handle，即被加载的动态库的内存地址</span><br><span class="line"> *&#x2F;</span><br><span class="line">void* dlopen(const char* path, int mode);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * handle: dlopen 的返回值</span><br><span class="line"> * symbol: 指向动态库中的符号，如函数，变量等</span><br><span class="line"> * return: 返回在内存中的符号地址</span><br><span class="line"> *&#x2F;</span><br><span class="line">void* dlsym(void* handle, const char* symbol);</span><br></pre></td></tr></table></figure><p>其中，<strong>dlopen</strong> 用于将动态库加载到内存中；<strong>dlsym</strong> 用于查找被加载到内存中的动态库的函数或变量的地址。</p><p>接下来我们就使用这两个API 来演示一下如何在 Linux 系统下动态加载库。</p><p>要想做这个演示，首先我们要写一个动态库。这个动态库特别简单，就一个函数 <strong>add()</strong> ， 用于加法运算。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;源码</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int add(int a, int b)&#123;</span><br><span class="line">  return a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;编译</span><br><span class="line">gcc -shared -o add.so add.c</span><br></pre></td></tr></table></figure><p>通过上面的操作我们就有了一个add.so的动态库。接下来我们再来看看如何使用 <strong>dlopen</strong> 及 <strong>dlsym</strong> 将上面生成的库动态库加载到内存中，并调用它的 <strong>add()</strong> 方法吧。具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line"></span><br><span class="line">typedef int(*FUNC)(int,int);</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])&#123;</span><br><span class="line">  void* handler &#x3D; dlopen(&quot;.&#x2F;add.so&quot;, RTLD_NOW);</span><br><span class="line">  if(!handler)&#123;</span><br><span class="line">    printf(&quot;Failed to load so!\n&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  FUNC func &#x3D; (FUNC)dlsym(handler, &quot;add&quot;);</span><br><span class="line">  int r &#x3D; func(10, 20);</span><br><span class="line">  printf(&quot;the result is : %d\n&quot;, r);</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;编译</span><br><span class="line">gcc -g -o loadso mytest.c</span><br></pre></td></tr></table></figure><p>上面的这段代码是不是很简单？短短的几行代码就向你展示了在 Linux/Mac 系统下动态加载并调用动态库中方法的具体步骤。有了上面的知识，我们再来看janus的实现就很容易理解它是如何做的了。</p><h2 id="janus-加载Plugin"><a href="#janus-加载Plugin" class="headerlink" title="janus 加载Plugin"></a>janus 加载Plugin</h2><p>janus实现加载插件的代码量很大，但核心代码就那么几行，只要我们将核心代码抽取出来，我们就会发现其实它与我们上面讲的代码几乎是一模一样的。下面我们来看看janus 是如何动态加载库的吧。</p><p>为了方便janus专门创建了一个目录用于存放插件。在janus启动时它会遍历该目录，并将目录中的插件一个个动态加载到内存中。经整理后的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((pluginent = readdir(dir))) &#123;</span><br><span class="line">  ......</span><br><span class="line">  g_snprintf(pluginpath, <span class="number">1024</span>, <span class="string">"%s/%s"</span>, path, pluginent-&gt;d_name);</span><br><span class="line">  <span class="keyword">void</span> *plugin = dlopen(pluginpath, RTLD_NOW |   RTLD_GLOBAL);</span><br><span class="line">  ......</span><br><span class="line">  create_p *create = (create_p*) dlsym(plugin, <span class="string">"create"</span>);</span><br><span class="line">  ......</span><br><span class="line">  janus_plugin *janus_plugin = create();</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这段核心代码是不是与我们上面 <strong>Linux 系统下动态库的动态加载</strong> 一节介绍的几乎是一样的？所以我们只要把基础知识撑握好了，再看一些复杂的实现时也就不会感觉很难了。</p><p>从上面的代码中我们还可以看到，janus 中的每个插件都实现了create 函数。该函数会返回一个包含多个函数的结构体。这些函数是我们实现janus插件必须要实现的，它们包括:</p><ul><li><code>init()</code>: 该函数是插件的初始化函数，像读取配置文件等操作都应该在这个函数中实现。</li><li><code>destroy()</code>: 插件被关闭的时候被调用</li><li><code>get_api_compatibility()</code>: 该方法只需要返回janus的API版本即可，用于控制不同janus版本是否兼容</li><li><code>get_version()</code>: 返回版本号(例如 3)</li><li><code>get_version_string()</code>: 返回字符串格式的版本号(例如, “v1.0.1”)</li><li><code>get_description()</code>: 返回插件的详细信息</li><li><code>get_name()</code>: 返回插件的短名子</li><li><code>get_package()</code>:返回插件的唯一包标识 (例如., “janus.plugin.myplugin”);</li><li><code>create_session()</code>: 在你和客户端之间创建一个session</li><li><code>handle_message()</code>: 处理对方发送给你的消息</li><li><code>handle_admin_message()</code>: 来自Admin API的消息</li><li><code>setup_media()</code>: 创建socket，建立与客户端<code>peerConnection</code>之间的连接</li><li><code>incoming_rtp()</code>: 接收客户端发过来的<code>rtp</code>包</li><li><code>incoming_rtcp()</code>: 接收客户端发过来的<code>rtcp</code>消息</li><li><code>incoming_data()</code>: 接收客户端通过<code>SCTP DataChannel</code>发过来的数据</li><li><code>data_ready()</code>: 检查数据是否可以通过<code>SCTP DataChannel</code>发送了</li><li><code>slow_link()</code>: 客户端发过来很多<code>NACK</code>，说是此时网络质量变差了</li><li><code>hangup_media()</code>: 客户端关闭了<code>PeerConnection</code></li><li><code>query_session()</code>: 查询在你与客户端之间的<code>session</code>信息</li><li><code>destroy_session()</code>: 销毁<code>session</code></li></ul><p>对于一个插件来讲，上面的方法中除了 <code>incoming_rtp</code> 、<code>incoming_rtcp</code>、<code>incoming_data</code> 可以不实现外，其它的方法都必须实现。只有这样当插件被<code>janus</code>核心层加载之后，才可以被顺利的调用。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我重点向你介绍了<code>janus</code>是如何使用和管理<code>plugin</code>的，同时向你简要的介绍了<code>janus</code>的架构模型以及要实现一个<code>janus</code>插件要实现哪些函数。</p><p>当然，我们这里只是对<code>plugin</code>做了一个大体的讲解，很多细节这里并没有讲到，我会在后面的文档中做更详细的介绍 。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门》</a></li><li><a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级高并发WebRTC流媒体服务器设计与开发》</a></li><li><a href="https://time.geekbang.org/column/intro/207" target="_blank" rel="noopener">《从0打造音视频直播系统》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> WebRTC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> plugin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>janus深入分析系列文章</title>
      <link href="/aafa6b93/"/>
      <url>/aafa6b93/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/janus_deep/janus_deep.jpg" alt=""></p><p>说到WebRTC流媒体服务器就不得不提<code>janus</code>，它是WebRTC众多流媒体服务器中的重要一员，其以优越的性能、丰富的功能、灵活的配置而著称。由于工作的原因，最近这段时间一直在分析<code>janus</code>，陆续整理出了我对janus的一些分析，希望这些文章对你了解<code>janus</code>能有所帮助。</p><a id="more"></a><h2 id="janus系列文章"><a href="#janus系列文章" class="headerlink" title="janus系列文章"></a>janus系列文章</h2><p>下面的这些文章是按照<strong>认知</strong>、<strong>使用</strong>、<strong>逐步深入</strong>的顺序做了编排，这种阅读顺序应该会使你更容易理解<code>janus</code>的整个运行机制。</p><ul><li><a href="http://avdancedu.com/947c722a/" target="_blank" rel="noopener">WebRTC流媒体服务器比较</a></li><li><a href="https://avdancedu.com/ed54b3d4/" target="_blank" rel="noopener">音视频会议系统-janus的编译与布署</a></li><li><a href="https://avdancedu.com/fdfe2594/" target="_blank" rel="noopener">janus各文件及目录的作用</a></li><li><a href="https://avdancedu.com/8f43ddc9/" target="_blank" rel="noopener">janus的线程模型</a></li><li><a href="https://avdancedu.com/26c3d930/" target="_blank" rel="noopener">深入理解janus的插件管理</a></li><li><a href="https://avdancedu.com/bb906872/" target="_blank" rel="noopener">janus的videoroom插件信令实现</a></li><li><a href="https://avdancedu.com/d7281c13/" target="_blank" rel="noopener">janus.js源码分析</a></li><li><a href="https://avdancedu.com/5ae5ee2f/" target="_blank" rel="noopener">janus.js的使用</a></li></ul><p>更深入的文章还在不断整理中，会陆续加到这个系列文章中来。如果你感兴趣也可以将你的分析心得放到这里，与大家一起分享。</p><p>另外，也欢迎大家一起讨论，文中有描述的不清楚的地方也希望大家指正批评！ </p><p>谢谢！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://coding.imooc.com/class/415.html" target="_blank" rel="noopener">音视频系统入门</a></li><li><a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">WebRTC入门与实战</a></li><li><a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">百万级WebRTC流媒体服务器设计与开发</a></li><li><a href="https://time.geekbang.org/column/article/132863" target="_blank" rel="noopener">从0开始打造音视频直播系统</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> WebRTC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> janus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>janus各文件及目录的作用</title>
      <link href="/fdfe2594/"/>
      <url>/fdfe2594/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/janus_file/janus_arch.jpg" alt="janus架构图"></p><p>在<a href="https://avdancedu.com/ed54b3d4/" target="_blank" rel="noopener">《音视频会议系统-janus的安装与布署》</a>一文中我已经向你介绍了如何布署<code>janus</code>，今天我们再来了解一下<code>janus</code>的源码，看看<code>janus</code>包括哪些文件以及它们所起的作用是什么。</p><a id="more"></a><h2 id="下载-janus-源码"><a href="#下载-janus-源码" class="headerlink" title="下载 janus 源码"></a>下载 janus 源码</h2><p><code>janus</code>源码可以在<a href="https://github.com/meetecho/janus-gateway" target="_blank" rel="noopener">这里</a>找到，执行下面命令就可将其下载下来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;meetecho&#x2F;janus-gateway.git</span><br><span class="line">cd janus-gateway</span><br></pre></td></tr></table></figure><h2 id="janus各源码文件的作用"><a href="#janus各源码文件的作用" class="headerlink" title="janus各源码文件的作用"></a>janus各源码文件的作用</h2><p>下载好<code>janus</code>源码后，你可以看到<code>janus</code>目录下有很多文件，这里我列出了比较重要的几个文件，下面来说明一下它们起所的作用是什么。目录列表如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">events           # 主要用于各种事件消息的分析</span><br><span class="line">plugins          # 各种业务插件，所有的业务应用都在这里实现</span><br><span class="line">transports       # 用于处理各种网络信令，HTTP、WebSocket、MQTT等</span><br><span class="line">docs             <span class="meta"># janus的文档，它是通过 Doxygen 生成的，janus的文档还是很全面的</span></span><br><span class="line">html             # Web端的Demo都放在这里</span><br><span class="line">rtcp.h           # RTCP 是RTP的控制协议</span><br><span class="line">rtcp.c           # RTCP 协议的具体实现</span><br><span class="line">rtp.c            # RTP协议的实现，它用于传输音视频数据</span><br><span class="line">rtp.h            # RTP 协议的头文件</span><br><span class="line">rtpsrtp.h        # SRTP 协议</span><br><span class="line">sctp.c           # SCTP 协议的实现</span><br><span class="line">sctp.h           # SCTP 协议的头文件</span><br><span class="line">sdp.c            # SDP 协议的实现</span><br><span class="line">sdp.h            # SDP 协议的头文件</span><br><span class="line">sdp-utils.c      # 处理 SDP 的常用工具</span><br><span class="line">sdp-utils.h</span><br><span class="line">test             # 测试文件所在目录</span><br><span class="line">record.c         <span class="meta"># janus的录制功能在该文件中实现</span></span><br><span class="line">record.h</span><br><span class="line">ice.c            <span class="meta"># janus 使用 libnice 实现 ICE 功能，该文件是对libnice库的封装</span></span><br><span class="line">ice.h</span><br><span class="line">janus.c          # 该文件是janus的主框架程序，里边做了很多事儿</span><br><span class="line">janus.h</span><br><span class="line"><span class="built_in">log</span>.c            # 日志</span><br><span class="line"><span class="built_in">log</span>.h</span><br><span class="line">dtls-bio.c       # DTLS 中 BIO 的实现</span><br><span class="line">dtls-bio.h</span><br><span class="line">dtls.c           # DTLS 协议实现</span><br><span class="line">dtls.h</span><br><span class="line">events.c         # 配合events插件与janus core连接用的</span><br><span class="line">events.h</span><br></pre></td></tr></table></figure><p>对于上面的文件我们可能将它们分成几大类：</p><ul><li>业务插件，<code>plugins</code>目录下的所有文件都属于该类，其主要作用是实现不同的业务逻辑的服务端，如<code>echotest</code>、<code>videoroom</code>、<code>videocall</code>等。</li><li>事件分析，<code>events</code>目录下的所有文件以及<code>events.c|h</code>，其作用是收集事件消息，做分析使用。这个功能只能高级用户才会用，对于一般用户来说可以不关注它。</li><li>协议，包括 <code>rtp.c|h</code>、<code>rtcp.c|h</code>、<code>rtpsrtp.h</code>、<code>stcp.c|h</code>、<code>sdp.c|h</code>、<code>dtls.c|h</code>、<code>dtls-bio.c|h</code>，这些都是用于处理不同协议的，每个文件都比较独利。</li><li>日志，包括 <code>log.c|h</code>，这个应该一眼就可以看出来。</li><li>浏览器Demo，<code>html</code>目录中的所有文件，主要包括一些demo程序，如videoroom、echotest等。</li><li>信令传输，<code>transports</code>目录下的文件属于该类，作用是接收不同传输协议发送过来的消息，并使用同样的协议将响应消息返回。</li><li>数据传输，<code>ice.c|h</code>，它是对<code>libnice</code>库的封装，用于媒体数据的传输。</li><li>janus核心，<code>janus.c|h</code>，这是<code>janus</code>中最核心的文件，程序的启动，插件的加载，数据的流转都是通过它来实现的。</li></ul><p>在上面几个类别中， <strong>janus核心</strong>、<strong>数据传输</strong>、<strong>信令传输</strong>、<strong>业务插件</strong>、<strong>浏览器Demo</strong> 中的代码是比较重要的，所以是你在阅读代码时需要重点看的内容。由于<strong>信令传输</strong>、<strong>业务插件</strong>、<strong>浏览器Demo</strong>都是目录，里边还包括了很多文件，所以下面我们再来看看这三个目录中都包括了那些文件。</p><h3 id="信令传输"><a href="#信令传输" class="headerlink" title="信令传输"></a>信令传输</h3><p>进入到 <code>transports</code> 目录，你会它有以下几个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">transport.h             # 定义了&#96;信令传输&#96;插件的接口</span><br><span class="line">transport.c             # 定义了几个通用的释放资源的函数</span><br><span class="line">janus_http.c            # HTTP 接口，默认使用的接口</span><br><span class="line">janus_mqtt.c            # MQTT 接口，编译时需要明确指定才会编入janus</span><br><span class="line">janus_pfunix.c          # UNIX 接口</span><br><span class="line">janus_nanomsg.c         # NanoMSG 接口</span><br><span class="line">janus_rabbitmq.c        # RabbitMQ 接口</span><br><span class="line">janus_websockets.c      # Websocket 接口</span><br></pre></td></tr></table></figure><p><code>janus</code>支持的信令接口方式还是蛮全的，这是它的一大优势。用户可以选择自己喜欢的接入方式进行接入。通过上面的描述你应该很容易判断出每个文件的作用，你对那个感兴趣就可以专门看那个文件。默认情况下<code>janus</code>使用的是HTTP接口，因此该接口也是最成熟的。</p><h3 id="业务插件"><a href="#业务插件" class="headerlink" title="业务插件"></a>业务插件</h3><p><code>janus</code>支持很多业务插件，这对于很多用户来说也是一个非常棒的特点，我们来看一下它都支持那些插件吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">plugin.h                # 定义了业务插件的接口</span><br><span class="line">plugin.c                # 实现了一些公用的释放资源的函数</span><br><span class="line">janus_echotest.c        # 回显业务插件</span><br><span class="line">janus_videocall.c       # 1:1视频通讯业务插件</span><br><span class="line">janus_videoroom.c       # 会议业务插件</span><br><span class="line">janus_textroom.c        # 文本聊天室插件</span><br><span class="line">janus_streaming.c       # 传输直接流插件，可以播放视频文件，或其它的RTP数据流</span><br><span class="line">streams</span><br><span class="line">janus_recordplay.c      # 录制回放业务插件</span><br><span class="line">recordings</span><br><span class="line">janus_sip.c             # sip 业务插件，主要用于与电话业务的互通</span><br><span class="line">janus_nosip.c           # 包含sip信令业务插件，用它可以中转RTP数据</span><br><span class="line">janus_audiobridge.c     # 音频会议插件</span><br><span class="line">janus_voicemail.c       # 语言信箱业务插件</span><br><span class="line">janus_lua.c             # lua 语言开发插件</span><br><span class="line">janus_lua_extra.h</span><br><span class="line">janus_lua_extra.c</span><br><span class="line">janus_lua_data.h</span><br><span class="line">lua</span><br><span class="line">janus_duktape.c         # duktape语言插件</span><br><span class="line">janus_duktape_extra.h</span><br><span class="line">janus_duktape_extra.c</span><br><span class="line">janus_duktape_data.h</span><br><span class="line">duktape</span><br><span class="line">duktape-deps</span><br></pre></td></tr></table></figure><p>通过上面的文件列表，我们看到<code>janus</code>支持的插件可真不少，有会议视会议的、1：1通话的、SIP、RTP、流…等等。这些插件几乎含盖的所有的业务场景。对于用户来话，要以根据自己的需求选择上面的业务插件进行修改即可完成自己的业务了。</p><p>最后我们再来看看客户端 Demo。</p><h3 id="HTML-Demo"><a href="#HTML-Demo" class="headerlink" title="HTML Demo"></a>HTML Demo</h3><p>在<code>janus</code>的html目录中有很多文件，其中大部分文件是与上面<code>业务插件</code>中的内容是对应的。也就是说一个业务插件对应一个HTML Demo。所以这块的内容大家自己看一下就可以了。我就不在这里一一列出来了。</p><p>通过上面的描述，我们大体上可以知道<code>janus</code>的实现并不是特别复杂。它实现了RTP/RTCP、SRTP、SCTP、DTLS/DTLS-BIO、SDP 等 WebRTC 必要的协议，而对于数据的传输则是使用<code>libnice</code> 库，并通过<code>ice.c|h</code>对libnice 做了一层封装。</p><p>除此之外，它所有的业务层都是以<code>plugin</code>的方式实现的，这对于后面的业务拓展有很大的优势。当我们要实现一个新业务时，只要按照 plugin 的规则进行开发就好了，非常简单。</p><p>另外，janus是用纯C实现的，并且使用了Linux社区丰常优秀的库<code>glib</code>(注意不是glibc)，这个库的性能非常好，对于在Linux 下开发的同学来说对它应该十分熟悉。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过本文，你应该对<code>janus</code>的源码有了一个大体功能的了解。由于<code>WebRTC</code>使用了很多的协议（如 RTP/RTCP、DTLS、SDP等），因此作为服务端的<code>janus</code>也必须实现这些协议，这样才能与<code>WebRTC</code>进行通信。</p><p>对于<code>janus</code>使用的这些协议可能很多同学会觉得一脸懵B，不知道其中的原理和作用，如果你对这块感兴趣的话，可以去看我的网课<a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门》</a>，在课程里我对这些协议都做了详细介绍。</p><p>如果你有一定基础的话，现在应该知道<code>janus</code>的实现并不是特别复杂，但它的架构设计还是很值得借鉴的，尤其是<code>plugin</code>的设计方案。</p><p>今天我只是对<code>janus</code>做个初步分析，后面会对它的一些性能做下详细分析，静请期待！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门》</a></li><li><a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级高并发WebRTC流媒体服务器设计与开发》</a></li><li><a href="https://time.geekbang.org/column/intro/207" target="_blank" rel="noopener">《从0打造音视频直播系统》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> WebRTC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> janus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音视频会议系统-janus的编译与布署</title>
      <link href="/ed54b3d4/"/>
      <url>/ed54b3d4/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/janus_deploy/janus.jpg" alt=""></p><p>说到WebRTC流媒体服务器就不得不提janus。说实话我以前对这款流媒体服务器并没有进行特别深入的研究，不过2019年10月我有幸作为声网RTC大会 Workshop 分会场的主讲嘉宾及串场人与janus的创始人<strong>Lorenzo Miniero</strong>有了一次深入交流，从中了解到janus的强大，因此决定有时间一定要对janus做下深入分析。</p><a id="more"></a><p><img data-src="https://cdn.avdancedu.com/image/article/janus_deploy/agora.jpg" alt="声网RTC大会"></p><p>正好前段时间忙完了手头的一些工作，终于可以有时间来对janus做详细研究了，而本篇则是对janus分析的第一篇文章。</p><p>下面我们就来看一下如何在一台 Ubuntu 系统下安装布署 janus。</p><h1 id="janus的布署方法"><a href="#janus的布署方法" class="headerlink" title="janus的布署方法"></a>janus的布署方法</h1><p>不得不说janus提供的文档还是非常全面的，如果你英文比较好的话，完全可以按它的文档进行操作。但对于一些新手来说，通过阅读本文可以让你快速的在本机搭建出janus Demo，所以本文对你仍然是非常有意义的。</p><h2 id="布署环境"><a href="#布署环境" class="headerlink" title="布署环境"></a>布署环境</h2><p>janus的官方文档建议你把它安装在Linux系统上，可以是 Ubuntu、CentOS等。当然你也可以在MacOS上安装它，而文档中明确说明它不支持Ｗindows系统，因此千万不要再在Windows上浪费时间了。</p><p>对于我来说，我一直比较倾向于使用Ubuntu系统，最主要的原因是安装依赖包比较方便。如果你是Linux新手，我更是强烈推建你使用Ubuntu，这样可以让你更快速入门Linux。而CentOS安装依赖包则会麻烦得多，虽然它也提供yum（类似Ubuntu中的apt）工具，但有很多库都必须通过源码编译的方式安装，这样很繁琐。</p><p>今天我们就使用<strong>Ubuntu系统</strong>作为janus的布署环境，而且这个环境是一台<strong>本地主机</strong>，而不是云主机，这样可以大大减少很多不必要的麻烦。</p><h2 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h2><p>在我们正式布署janus之前，需要先在Ubuntu系统上安装上必要的依赖包。在Ubuntu上安装依赖包非常方便，只要执行下面的命令就好了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libmicrohttpd-dev libjansson-dev \</span><br><span class="line">       libssl-dev libsofia-sip-ua-dev libglib2.0-dev libopus-dev \</span><br><span class="line">       libogg-dev libcurl4-openssl-dev liblua5.3-ev libconfig-dev\</span><br><span class="line">       pkg-config gengetopt libtool automake libscrtp-dev \</span><br><span class="line">               libwebsockets-dev  librabbitmq-dev libnanomsg-dev libnice-dev \</span><br><span class="line">               gtk-doc-tools doxygen graphviz</span><br></pre></td></tr></table></figure><p>除了以上这些可以通过 apt工具安装的依赖包外，还有一个依赖库是必须通过源码安装的，它就是libsrtp库。</p><p>libsrtp库的主要作用是对数据进行加密。之所以要通过源码安装，是因为在apt源上的libsrtp库没有将ssl库编译上，而janus又需要使ssl库对数据做最终的加密，所以我们只能使用源码的方式安装了。具体操作步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;cisco&#x2F;libsrtp&#x2F;archive&#x2F;v2.2.0.tar.gz</span><br><span class="line">tar xfv v2.2.0.tar.gz</span><br><span class="line">cd libsrtp-2.2.0</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr --enable-openssl</span><br><span class="line">make shared_library &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><h2 id="编译安装janus"><a href="#编译安装janus" class="headerlink" title="编译安装janus"></a>编译安装janus</h2><p>布署环境搭建好之后，编译安装janus还是非常简单的，就按下面的三步执行就好了：</p><ul><li>下载 janus 源码</li><li>执行 ./configure 生成 Makefile 文件</li><li>执行 make -j 4 &amp; sudo make install</li></ul><p>首先我们来看看如何下载janus的源码，操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;meetecho&#x2F;janus-gateway.git</span><br><span class="line">cd janus-gateway</span><br></pre></td></tr></table></figure><p>源码下载好后，执行./configure就可以生成Makefile文件了。但需要注意的是，在执行./configure之前，先要执行autogen.sh脚本，这样才能生成./configure文件。具体操作步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;autogen.sh</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;janus</span><br></pre></td></tr></table></figure><p>当./configure执行完成后，Makefile文件就生成了，紧接着我们要开始编译安装 janus 了。按下面的执行步骤操作就好了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j 4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>通过上面的步骤，我们就将janus编译好并成功安装了。</p><h1 id="启动janus"><a href="#启动janus" class="headerlink" title="启动janus"></a>启动janus</h1><p>安装好janus 后，启动它非常容易，但在启动之前，我们还要为它准备好配置文件。</p><p>janus在启动时会分析配置文件，然后按照配置文件中的信息启动加载对应的模块。该如何构建配置文件呢？对于初学janus的新手来说，看到janus有一堆的参数，在构造配置文件时可能就有点懵了。</p><p>不过janus已经为我们想好了解决方案，就是从它的配置文件模板中拷贝一份作为janus的配置文件。其中最简单的就是将 janus.jcfg.sample作为配置文件即可。具体操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;installdir&gt;&#x2F;etc&#x2F;janus&#x2F;</span><br><span class="line">cp janus.jcfg.sample janus.jcfg</span><br></pre></td></tr></table></figure><p>有了janus配置文件之后，我们就可以直接启动janus了，执行如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;janus</span><br></pre></td></tr></table></figure><p>OK，到目前为止，我们就已经将janus启动好了。此时，如果有用户连接janus的话，你就可以从终端上看到对应的连接信息。</p><p>上面的启动方式非常适合于我们观察和调试janus，但如果你想让它像服务器一样一直运行，则需要让janus到Linux系统的后台运行。这该如何实现呢？其实操作也很简单，只要执行下面的命令就好了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;janus &amp;</span><br></pre></td></tr></table></figure><h1 id="janus-Demo的布署"><a href="#janus-Demo的布署" class="headerlink" title="janus Demo的布署"></a>janus Demo的布署</h1><p>通过上面的步骤我们已经将janus网关布署好了，但此时janus Demo还无法使用，我们还必须搭建一台WebServer，将janus Demo 客户端发布出来才行。</p><p>关于WebServer的搭建方法我这里就不做详细介绍了，大家应该在网上都可以找到方法，比如使用 nginx、nodejs、Apache、Tomcat等都是可以的。</p><p>当WebServer搭建好后，将/usr/local/janus/share/janus/demo目录中的内容全部拷贝到WebServer的发布目录下即可，这样我们就大功告成了！</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过上面的描述，我们就将如何搭建janus Demo的步骤向你做了详细的介绍，让你知道了如何在Ubuntu下搭建janus服务，又该如何将janus Demo布署好。总结起来就是以下三步：</p><ul><li>安装依赖包</li><li>编译安装janus</li><li>布署WebServer，并将 janus Demo 代码放到 WebServer发布目录下</li></ul><p>需要注意的是，我这里提供的方法只适用于本机，如果你想在云服务器上布署 janus的话，还有其它一些工作要做。对于这一点，我在这里就不做详细论述了，有兴趣的同学可以去参考我在慕课网的课程。</p><p>谢谢！</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级高并发WebRTC流媒体服务器设计与开发》</a></li><li><a href="https://time.geekbang.org/column/intro/207" target="_blank" rel="noopener">《从0打造音视频直播系统》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> WebRTC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> janus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>janus.js的使用</title>
      <link href="/5ae5ee2f/"/>
      <url>/5ae5ee2f/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/janus_jscall/jscall.jpg" alt=""></p><p>之前我在<a href="https://avdancedu.com/d7281c13/" target="_blank" rel="noopener">《janus前端核心库源码分析》</a>一文中已经向你详细分析了<code>janus.js</code>文件的实现，但对于大多同学来说，知道如何使用它才是最重要的。那具体我们该如何使用它呢？janus中的<code>videoroomtest.js</code>是一个不错的例子，今天就来分析一下<code>videoroomtest.js</code>，看看它是是如何使用<code>janus.js</code>的。</p><a id="more"></a><p>通过分析<code>videoroomtest.js</code>文件，你会发现使用<code>janus.js</code>的步骤很简单，只要下面三步即可：</p><ul><li>初始化<code>janus.js</code></li><li>创建<code>Janus</code>对象</li><li>attach 音视频流</li></ul><p>下面我就按上面的顺序向你逐一介绍<code>videoroomtest.js</code>是如何使用<code>janus.js</code>的。</p><h2 id="janus的初始化"><a href="#janus的初始化" class="headerlink" title="janus的初始化"></a>janus的初始化</h2><p>我们使用<code>janus.js</code>之前，第一步就是调用<code>Janus</code>的<code>类</code>方法<code>init</code>来初始化<code>janus.js</code>。方法的原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Janus.init &#x3D; function(options)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>init</code>方法需要一个<code>JSON</code>格式的输入参数，它包括两个<code>域</code>: <code>debug</code>和一个回调函数<code>callback</code>。这样当<code>init</code>执行完成后，就可以通过<code>callback</code>将结果返回到应用层了。<code>videoroomtest.js</code>调用<code>Janus.init</code>的代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Janus.init(</span><br><span class="line">            &#123;</span><br><span class="line">                debug: &quot;all&quot;,</span><br><span class="line">                callback: function()&#123;...&#125;</span><br><span class="line">            &#125;</span><br><span class="line">          );</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面的代码非常简单，关键的一点是我们要知道传入的参数是<code>JSON</code> 格式的，它有两个域<code>debug</code>和<code>callback</code>即可。知道如何调用了，接下来我们再来看看<code>init</code>函数的实现。</p><p><code>janus.js</code>的<code>init</code>方法实现了什么功能呢？我们把<code>Janus.init</code>方法中的主干逻辑抽取出来，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Janus.init &#x3D; function(options) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if(Janus.initDone) &#123;</span><br><span class="line">        options.callback();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ...</span><br><span class="line">        Janus.initDone &#x3D; true;</span><br><span class="line">        options.callback();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中的<code>initDone</code>表示的是之前是否初始化过<code>janus.js</code>？而<code>options</code>是<code>init</code>方法的输入参数，通过它可以回调应用层。通过上面的代码我们可以知道<code>init</code>方法的功能其实蛮简单的，就是将<code>initDone</code>置位，并回调应用层。</p><p>接下来我们看一下<code>init</code>回调应用层后，在应用层又做了什么事儿。 输入参数<code>options</code>的<code>callback</code>方法在<code>videoroomtest.js</code>中是一个<code>匿名函数</code>，其主干逻辑代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">callback: function() &#123;</span><br><span class="line">    $(&#39;#start&#39;).one(&#39;click&#39;, function() &#123; ... &#125; )</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>正如你上面看到的，<code>callback</code>函数只有一行关键代码，即给<code>start</code> 键钮绑定了一个<code>click</code>方法。当用户点击<code>start</code>时执行该方法。那么应用层在<code>start</code>方法中又做了哪些事儿呢？</p><h2 id="创建Janus对象"><a href="#创建Janus对象" class="headerlink" title="创建Janus对象"></a>创建Janus对象</h2><p>下面的代码就是<code>start</code>方法的主逻辑，从中我们可以知道<code>start</code>方法中完成了使用<code>janus.js</code>的第二个关键步骤，即创建<code>Janus</code>对象。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if(!Janus.isWebrtcSupported()) &#123;</span><br><span class="line">    ...</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">janus &#x3D; new Janus(</span><br><span class="line">                    &#123;</span><br><span class="line">                        server: server,</span><br><span class="line">                        success: function() &#123; ... &#125;,</span><br><span class="line">                        error: function(error) &#123; ... &#125;,</span><br><span class="line">                        destroyed: function() &#123; ... &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                 );</span><br></pre></td></tr></table></figure><p>在该方法中首先判断<code>浏览器</code>是否支持<code>WebRTC</code>，如果不支持则直接退出，否则创建<code>Janus</code>对象。在创建<code>Janus</code>对象时，需要给它传入了一个<code>JSON</code>格式的参数，该<code>JSON</code>对象包括以下几个<code>域</code>：</p><ul><li>server，Janus服务器地址</li><li>success，连接成功后执行的回调函数</li><li>error，连接失败后执行的回调函数</li><li>destroyed，连接销毁时的回调函数</li></ul><p>在上述几个<code>域</code>中，最关键的是<code>success</code>回调函数。它的含义是当Janus对象创建成功后，回调该函数到应用层。但对于这个回调函的详细介绍我们先<code>暂时</code>放一放，现在我们先来看看创建<code>Janus</code>对象时都做了哪些事儿，然后再来分析<code>success</code>回调函数。</p><p>Janus类的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function Janus(gatewayCallbacks) &#123;</span><br><span class="line">    ...</span><br><span class="line">    createSession(gatewayCallbacks);</span><br><span class="line">    ...</span><br><span class="line">    this.attach &#x3D; function(callbacks) &#123; createHandle(callbacks); &#125;;</span><br><span class="line">    function handleEvent(json, skipTimeout) &#123; ... &#125;;</span><br><span class="line">    function keepAlive() &#123;&#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建Session</span><br><span class="line">    function createSession(callbacks) &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F;与服务器相连</span><br><span class="line">        Janus.httpAPICall(server,</span><br><span class="line">                          &#123;</span><br><span class="line">                            ...</span><br><span class="line">                            &#x2F;&#x2F;处理服务器发过来的消息</span><br><span class="line">                            success: handleEvent(...)&#123; ... &#125;;</span><br><span class="line">                            ...</span><br><span class="line">                          &#125;);</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;绑定媒体流</span><br><span class="line">    function createHandle(callbacks) &#123;...&#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以知道，在创建<code>Janus</code>对象时它会调用<code>createSession</code>函数。而在<code>createSession</code>函数内部会通过<code>Janus</code>的<code>类</code>方法<code>httpAPICall</code>与服务端建立<code>HTTP</code>连接。连接建立成功后，会回调<code>success</code>函数，也就是类中的<code>handleEvent</code>方法。</p><p><code>handleEvent</code>的功能我在<a href="https://avdancedu.com/d7281c13/" target="_blank" rel="noopener">《janus前端核心库源码分析》</a>一文中已经介绍过，它用于处理服务端发来的消息，并根据不同的消息类型做不同的逻辑处理。</p><p>现在我们可以总结一下创建<code>Janus</code>对象所做的事儿啦，其实就两件事儿：一与<code>janus</code>服务器建立连接(HTTP/WebSocket/…)；二处理<code>janus</code>服务器发来的各种消息。</p><p>接下来我们再来讨论一下<code>Janus</code>对象创建成功后，回调<code>success</code>干了些什么吧！</p><h2 id="attach-绑定媒体流"><a href="#attach-绑定媒体流" class="headerlink" title="attach 绑定媒体流"></a>attach 绑定媒体流</h2><p>正如上面所说，<code>Janus</code>创建成功后会回调输入参数中的<code>success</code>函数。这个函数<code>特别重要</code>，下面我们来看看在该函数中实现了什么逻辑吧。</p><p>实际上，<code>success</code> 回调函数做的事儿也很简单，只是调用了 <code>janus.attach</code> 方法，<strong>而attach正是我们使用janus.js的第三步</strong>。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">success: function() &#123;</span><br><span class="line">    janus.attach(</span><br><span class="line">                    &#123;</span><br><span class="line">                        plugin: &quot;janus.plugin.videoroom&quot;,</span><br><span class="line">                        opaqueId: opaqueId,</span><br><span class="line">                        success: function(pluginHandle) &#123; ... &#125;,</span><br><span class="line">                        error: function(error) &#123; ... &#125;,</span><br><span class="line">                        consentDialog: function(on) &#123; ... &#125;,</span><br><span class="line">                        iceState: function(state) &#123; ... &#125;,</span><br><span class="line">                        mediaState: function(medium, on) &#123; ... &#125;,</span><br><span class="line">                        webrtcState: function(on) &#123; ... &#125;,</span><br><span class="line">                        onmessage: function(msg, jsep) &#123; ... &#125;,</span><br><span class="line">                        onlocalstream: function(stream) &#123; ... &#125;,</span><br><span class="line">                        onremotestream: function(stream) &#123; ... &#125;,</span><br><span class="line">                        oncleanup: function() &#123; ... &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，该方法的作用在<a href="https://avdancedu.com/d7281c13/" target="_blank" rel="noopener">《janus前端核心库源码分析》</a>一文中也已经做过介绍，该方法可以让浏览器与服务端的<code>videoroom插件</code>绑定，以便获取媒体流。</p><blockquote><p>这里<code>绑定</code>的真实含义是建立WEBRTC连接。</p></blockquote><p>在调用<code>attach</code>方法时，也要传一个<code>JSON</code>格式的对象。在该对像包含了很多属性，这些属性的含义如下：</p><ul><li>plugin，要绑定的<code>janus</code>插件，这里要绑定插件为<code>janus.plugin.videoroom</code>。</li><li>opaqueId，一个随机值，插件的唯一ID。</li><li>success，<code>attach</code>方法执行成功后的回调函数。</li><li>error，<code>attach</code>方法执行失败后的回调函数。</li><li>consentDialog,</li><li>iceState，可以通过该函数更新ICE状态。在<code>videoroomtest.js</code>中没有做任何处理。</li><li>mediaState，可以通过该函数更新媒体状态。该方法也没有做任你可事儿。</li><li>webrtcState，更改WebRTC状态的回调函数。</li><li>onmessage，收到事件消自己的回调函数。</li><li>onlocalstream，收到本地流时的回调函数。</li><li>onremotestream，收到远端流时的回调函数。</li><li>oncleanup，销毁时的回调函数。</li></ul><p>在上面属性中，比较关键的是<code>success</code>、<code>webrtceState</code>、<code>onmessage</code>、<code>onlocalstream</code>和<code>onremotestream</code> 。这几个属性都是回调函数，在不同的情况下<code>janus.js</code>会调不同的回调函数。下面我们就对这几个回调函数做一下详细分析。</p><h3 id="success回调函数"><a href="#success回调函数" class="headerlink" title="success回调函数"></a>success回调函数</h3><p>当调用<code>attach</code>方法成功与<code>janus</code>服务器<code>插件</code>绑定之后，<code>janus.js</code>会回调<code>success</code>函数。代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">this.attach &#x3D; function(callbacks) &#123; createHandle(callbacks); &#125;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">function createHandle(callbacks) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Janus.httpAPICall( server + &quot;&#x2F;&quot; + sessionId,</span><br><span class="line">                       &#123;</span><br><span class="line">                            verb: &#39;POST&#39;,</span><br><span class="line">                            withCredentials: withCredentials,</span><br><span class="line">                            body: request,</span><br><span class="line">                            success: function() &#123;</span><br><span class="line">                                var pluginHandle &#x3D; &#123; ... &#125;;</span><br><span class="line">                                callbacks.success(pluginHandle);</span><br><span class="line">                            &#125;,</span><br><span class="line">                            error: function() &#123; ... &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                     );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面代码的执行过程如下，<code>janus.js</code>向<code>janus</code>服务器发送<code>attach</code>请求，服务器收到<code>attach</code>请求后进行处理，然后根据处理结果返回<code>success</code>或<code>error</code>。如果浏览器收到的是服务器返回的<code>success</code>响应，那么就会回调<code>success</code>函数。</p><p>接下来我们看一下<code>success</code>回调到应用层<code>videoroomtest.js</code>后做了哪些事儿吧! 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">janus.attach(</span><br><span class="line">                &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    success: function(pluginHandle) &#123;</span><br><span class="line">                                ...</span><br><span class="line">                                sfutest &#x3D; pluginHandle;</span><br><span class="line">                                ...</span><br><span class="line">                             &#125;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>从上面的代码中我们可以看到，应用层<code>success</code>的逻辑非常简单，只是将<code>janus.js</code>层创建的<code>pluginHanle</code>保存起来以备后用，剩下的其它的一些代码是与界面相关的，我们这里就不介绍了。</p><h3 id="onmessage"><a href="#onmessage" class="headerlink" title="onmessage"></a>onmessage</h3><p><code>onmessagee</code>实现的是对<code>janus</code>服务端返回事件的处理逻辑。我们依然还是先看看在<code>janus.js</code>中是如何调用该函数的。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function handleEvent(json, skipTimeout) &#123;</span><br><span class="line">    ...</span><br><span class="line">    else if(json[&quot;janus&quot;] &#x3D;&#x3D;&#x3D; &quot;event&quot;) &#123;</span><br><span class="line">        ...</span><br><span class="line">        var sender &#x3D; json[&quot;sender&quot;];</span><br><span class="line">        var pluginHandle &#x3D; pluginHandles[sender];</span><br><span class="line">        ...</span><br><span class="line">        var plugindata &#x3D; json[&quot;plugindata&quot;];</span><br><span class="line">        ...</span><br><span class="line">        var jsep &#x3D; json[&quot;jsep&quot;];</span><br><span class="line">        var callback &#x3D; pluginHandle.onmessage;</span><br><span class="line">        if(callback) &#123;</span><br><span class="line">            callback(data, jsep);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是<code>janus.js</code>中的<code>handleEvent</code>函数的主逻辑，当<code>janus.js</code>收到janus服务端发来的<code>event</code>事件后，从中取出必要的信息，然后调用<code>pluginHandle.onmessage</code>方法回调应用层。</p><p>应用层的<code>onmessage</code>函数<code>非常重要</code>，可以说它是应用层最<code>核心的代码</code>。它根据从janus服务端收到的不同消息类型做不同的逻辑处理，其主逻辑框架如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">onmessage: function(msg, jsep) &#123;</span><br><span class="line">            var event &#x3D; msg[&quot;videoroom&quot;];</span><br><span class="line">            if(event) &#123;</span><br><span class="line">                if(event &#x3D;&#x3D;&#x3D; &quot;joined&quot;) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    publishOwnFeed(true);</span><br><span class="line">                    ...</span><br><span class="line">                &#125; else if(event &#x3D;&#x3D;&#x3D; &quot;destroyed&quot;) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125; else if(event &#x3D;&#x3D;&#x3D; &quot;event&quot;) &#123;</span><br><span class="line">                    if(msg[&quot;publishers&quot;]) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125; else if(msg[&quot;leaving&quot;]) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125; else if(msg[&quot;unpublished&quot;]) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;else if(msg[&quot;error&quot;]) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(jsep) &#123;</span><br><span class="line">                ...</span><br><span class="line">                sfutest.handleRemoteJsep(&#123; jsep: jsep &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以看到，消息包括以下3种：</p><ul><li>joined，表示作为<code>发布者</code>加入成功</li><li>destroyed, 表示用户成功<code>销毁</code>房间</li><li>event，子事件，<code>event</code>又有四个子事件：<ul><li>publishers，发布者列表</li><li>leaving，有用户离开了</li><li>unpublished，用户取消发布流</li><li>error，出错</li></ul></li></ul><p>在<code>onmessage</code>函数中会对3种事件消息做处理，下面我们分别对这几个事件消息做一下分析。</p><h4 id="joined-事件"><a href="#joined-事件" class="headerlink" title="joined 事件"></a>joined 事件</h4><p><code>joined</code>消息的含义我在<a href="https://avdancedu.com/bb906872/" target="_blank" rel="noopener">《janus的videoroom插件》</a>一文中已经向你做过介绍了，即当你作为<code>发布者</code>加入到房间里时，如果成功则会收到<code>joined</code>事件消息。</p><p>此时你可以从该消息中取出<code>publishers</code>列表，该列表中的每一个<code>publisher</code>都是会中的一个<code>发布者</code>(或称为一路流）。由于<code>发布者</code>也是房间的<code>订阅者</code>，所以你应该订阅每个<code>发布者</code>的媒体流，因此你要与列表中的每个<code>publisher</code>进行一次<code>媒体协商</code>，并进行<code>attach</code>。这样就可以接收<code>发布者</code>的媒体流啦。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if(event &#x3D;&#x3D;&#x3D; &quot;joined&quot;) &#123;</span><br><span class="line">    ...</span><br><span class="line">    publishOwnFeed(true); &#x2F;&#x2F;创建 Offer</span><br><span class="line">    if(msg[&quot;publishers&quot;]) &#123;</span><br><span class="line">        var list &#x3D; msg[&quot;publishers&quot;];</span><br><span class="line">        for(var f in list) &#123;</span><br><span class="line">            var id &#x3D; list[f][&quot;id&quot;];</span><br><span class="line">            var display &#x3D; list[f][&quot;display&quot;];</span><br><span class="line">            var audio &#x3D; list[f][&quot;audio_codec&quot;];</span><br><span class="line">            var video &#x3D; list[f][&quot;video_codec&quot;];</span><br><span class="line">            newRemoteFeed(id, display, audio, video); &#x2F;&#x2F;attach插件，并向插件发送 join 消息</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>从代码中我们可以看到，因为它是一个<code>发布者</code>所以它首先执行<code>publishOwnFeed(true)</code>创建<code>Offer</code>与janus服务端作媒体协商。之后遍历<code>publishers</code>列表，取出每个<code>publisher</code>执行<code>newRemoteFeed</code>方法，在该方法中又会调用<code>attach</code>方法获取其它<code>发布者</code>的媒体流。</p><h4 id="publishers-事件"><a href="#publishers-事件" class="headerlink" title="publishers 事件"></a>publishers 事件</h4><p>当有<code>发布者</code>加入到房间后，房间内的所有<code>订阅者</code>都会收到<code>publishers</code>事件消息。浏览器收到该消息后，应该对消息中的每个未绑定的<code>publisher</code>都进行<code>attach</code>操作，这样就可以接收<code>发布者</code>的媒体流了。 其主逻辑代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if(msg[&quot;publishers&quot;]) &#123;</span><br><span class="line">    var list &#x3D; msg[&quot;publishers&quot;];</span><br><span class="line">    for(var f in list) &#123;</span><br><span class="line">        var id &#x3D; list[f][&quot;id&quot;];</span><br><span class="line">        var display &#x3D; list[f][&quot;display&quot;];</span><br><span class="line">        var audio &#x3D; list[f][&quot;audio_codec&quot;];</span><br><span class="line">        var video &#x3D; list[f][&quot;video_codec&quot;];</span><br><span class="line">        newRemoteFeed(id, display, audio, video);&#x2F;&#x2F;attach插件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这段代码与<code>joined</code>消息的处理逻辑几乎是一样的，只不过<code>订阅者</code>此时不需要与janus服务器进行媒体协商，所以它没有调用<code>publishOwnFeed</code>方法，其它的逻辑都是一样的了。</p><h4 id="leaving-unpublished-事件"><a href="#leaving-unpublished-事件" class="headerlink" title="leaving/unpublished 事件"></a>leaving/unpublished 事件</h4><p>当一个<code>发布者</code>取消发布时，janus会向房间内的其它用户发送<code>unpublished</code>消息。另外，当有用户离开房间时，janus会给房间内的其它人发送<code>leaving</code>消息。另外，如果离开的用户是一个<code>发布者</code>的话，它同时也会发<code>unpublished</code>消息，所以这里我们将两个消息放在一起讨论。</p><p>这两个消息处理的核心逻辑如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">var remoteFeed &#x3D; null;</span><br><span class="line">for(var i&#x3D;1; i&lt;6; i++) &#123;</span><br><span class="line">    if(feeds[i] &amp;&amp; feeds[i].rfid &#x3D;&#x3D; unpublished) &#123;</span><br><span class="line">        remoteFeed &#x3D; feeds[i];</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(remoteFeed !&#x3D; null) &#123;</span><br><span class="line">    ...</span><br><span class="line">    feeds[remoteFeed.rfindex] &#x3D; null;</span><br><span class="line">    remoteFeed.detach();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面这段代码有点不太好理解，我这里解释一下你就清楚了。首先我们来看看循环中的固定数字<code>6</code>，表示什么含义呢？实际上我在<a href="https://avdancedu.com/bb906872/" target="_blank" rel="noopener">《janus的videoroom插件》</a>一文中有解释过，在janus中一个房间内最多可以支持<code>6</code>路流，这个<code>6</code>表过的正是这个意思。所以当收到<code>leaving</code>和<code>unpublished</code>消息时，客户端会遍历全局变量<code>feeds</code>(保存所有订阅的流），如果在<code>feeds</code>中找到了该流，则需要与该流进行<code>detach</code>操作。</p><p>现在我们再读这段代码时是不是就理解它要表达的意思了呢？</p><h3 id="onlocalstream-消息"><a href="#onlocalstream-消息" class="headerlink" title="onlocalstream 消息"></a>onlocalstream 消息</h3><p>当收到<code>onlocalstream</code>消息时，说明本地流已经准备就绪了，此时我们需要让本地流的视频在浏览器里显示出来。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">onlocalstream: function(stream) &#123;</span><br><span class="line">    mystream &#x3D; stream;</span><br><span class="line">    ...</span><br><span class="line">    Janus.attachMediaStream($(&#39;#myvideo&#39;).get(0), stream);</span><br><span class="line">    $(&quot;#myvideo&quot;).get(0).muted &#x3D; &quot;muted&quot;;</span><br><span class="line">    ...</span><br><span class="line">    var videoTracks &#x3D; stream.getVideoTracks();&#125;</span><br><span class="line">    &#x2F;&#x2F;显示video标签</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这段代码的含议非常简单了，就是获取本地址，然后从<code>HTML</code>中拿到一个<code>video</code>标签，最后将<code>video</code>与本地流绑定到一起，这样就可以看到捕获的本地视频了。</p><h3 id="onremotestream-消息"><a href="#onremotestream-消息" class="headerlink" title="onremotestream 消息"></a>onremotestream 消息</h3><p><code>onremotestream</code>消息与<code>onlocalstream</code>是类似的，只不过它表示的是远端的视频流。当收到远端的视频流时，我们也同样在本地创建一个<code>video</code>，然后将远端视频流与<code>video</code>绑定即可。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我向你详细介绍了janus中的<code>videoroom</code>是如何使用<code>janus.js</code>文件的，其总的步骤是先调用<code>Janus.init</code>方法进行初始化；然后创建<code>Janus</code>对象，即与janus服务器建立连接，并接收来自服务器端的消息; 最后调用<code>attach</code>与业务服务器绑定，再根据消息进行推流或拉流。</p><p>总的来看，使用<code>janus.js</code>库大大减轻了我们开发<code>webrtc</code>应用程序的工作量，提高了工作效率。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/bb906872/" target="_blank" rel="noopener">《janus的videoroom插件》</a><br><a href="https://avdancedu.com/d7281c13/" target="_blank" rel="noopener">《janus前端核心库源码分析》</a></p>]]></content>
      
      
      <categories>
          
          <category> WebRTC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> janus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音视频学习路线图</title>
      <link href="/12dc77f9/"/>
      <url>/12dc77f9/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/av_path/av_learn_path.jpg" alt=""></p><p>这是我制订的一个<a href="https://coding.imooc.com/learningpath/route?pathId=39" target="_blank" rel="noopener">音视频学习线路图</a>，希望对学习音视频的同学能所有帮助!</p><p>从2018年制作第一门音视频课<a href="https://coding.imooc.com/class/279.html" target="_blank" rel="noopener">《ffmpeg精讲》</a>开始，到今年3月我已经陆续录制了4门与音视频相关的课程和一个专栏，分别是<a href="https://coding.imooc.com/class/415.html" target="_blank" rel="noopener">《音视频系统入门》</a>、<a href="https://coding.imooc.com/class/279.html" target="_blank" rel="noopener">《ffmpeg精讲》</a>、<a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门与实战》</a>、<a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级WebRTC流媒体服务器》</a>以及<a href="https://time.geekbang.org/column/article/107916" target="_blank" rel="noopener">《从0开始打造音视频直播系统》</a>，他们基本覆盖了音视频从入门到高阶的所有内容。</p><a id="more"></a><p>如果你对音视频感兴趣的话，可以根据自己的情况选择自己感兴趣的课程学习，当然也可以按照下面的路线图进行学习，</p><p>首先是<a href="https://coding.imooc.com/class/415.html" target="_blank" rel="noopener">《音视频系统入门》</a>，这门课是学习音视频至关重要的课程，是所有其它课程的基础。如果你之前对音视频没有任何概念，或者基础不牢的话，建议先从这门课开始学起。这门课讲解了最基本的音视频知识，如音频三要素、PCM、AAC编码、YUV、H264编码原理、音视频数据采集、FLV/RTMP、可商用的RTMP流媒体服务器等知识。课程中包括了大量实战，而且是手把手带你一行一行代码写起，特别适合于新入门的同学。这门课的知识是每个搞音视频研发的同学必须 100% 撑握的内容，很多音视频面试题也是考的这部分内容。</p><p>学完<a href="https://coding.imooc.com/class/415.html" target="_blank" rel="noopener">《音视频系统入门》</a>之后，你可以继续学习高阶的<a href="https://coding.imooc.com/class/279.html" target="_blank" rel="noopener">《ffmpeg精讲》</a>，这门课详细讲解了ffmpeg的运行机制，重点讲解了音视频同步，音视频线程的协作等。并通过这些知识实现了一个播放器内核。如果你的工作是做音视频编辑(如音视频的裁剪、音视拆分合并等）、音视频的编解码、音视频播放器研发的工作，那这门课就特别适合你。</p><p>当然，如果你想做实时互动直播（如音视频会议、在线教育）产品，那么WebRTC是你必须要学习的内容。WebRTC现在越来越强大，强大到你通过浏览器编写几行代码就可能实现1对1的实时通信。因此你可以选择学习<a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门与实战》</a> 和<a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级WebRTC流媒体服务器》</a>。 这两门课一门是讲解客户端的一门是讲解服务端的。</p><p><a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门与实战》</a>讲解了WebRTC的工作原理，如如何采集音视频，媒体协商，以及理底层的ICE、P2P、DTLS-SRTP、RTP/RTCP、STUN等，但其侧重点还是教你如何使用WebRTC库实现实时通信。在这门课中实现了浏览器端、Android、iOS三个端。并且三个端之间都可以彼此进行 1对1 的实时通信。</p><p>另一门课<a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级WebRTC流媒体服务器》</a>是讲解WebRTC流媒体服务器的高阶课程，这门课里面详细讲解了如何在Linux上开发高并发流媒体服务器，讲解了信号处理、多进程/多线程、select/poll/epoll/libevent/libev异步事件处理机制等，并重点对性能最好的WebRTC流媒体服务器<code>mediasoup</code>做了深入剖析。相信学完这门课后你去应聘相关的工作时，技术上已经不会有任何问题了。甚至是各大厂争抢的人才。</p><p>上面的视频课都是针对于某一方面做的重点讲解，但如果你想对整个音视频技术做全面了解，并且对更愿意阅读文字的话，阅读我的专栏 <a href="https://time.geekbang.org/column/article/107916" target="_blank" rel="noopener">《从0开始打造音视频直播系统》</a>是个不错的选择。专栏中我对上面所有的内容做了概括性的讲解，如 WebRTC的使用、WebRTC流媒体服务器的分析、传统RTMP直播技术以及各种播放器都做了讲解。如果你对音视频各方面知识都有了一定的了解，建议你再读一下这个专栏，它会对你的音视频知识做一个系统的梳理，从而让你对音视频的认知更上一个台阶。</p><p><img data-src="https://cdn.avdancedu.com/image/article/av_path/path.jpg" alt="音视频知识图谱"></p>]]></content>
      
      
      <categories>
          
          <category> 音视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>janus的videoroom插件</title>
      <link href="/bb906872/"/>
      <url>/bb906872/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/videoroom/videoroom.jpg" alt="videoroom"></p><p>在Janus的众多插件中，大家最感兴趣的恐怕就是<code>VideoRoom</code>插件了。因为它实现的是一个音视频会议的场景，这正是大多数同学所需要的。而且在Janus众多的插件中<code>VideoRoom</code>应该也是最复杂的一个，如果你们撑握了它，再去看其它插件的实现就容易多了。</p><p>在<code>VideoRoom</code>中，包括了很多API，这些API是我们打开<code>VideoRoom</code>的一把钥匙，所以本文的重点就是讲解这些API。我相信当你把这些API都撑握之后，再去看<code>VideoRoom</code>插件的代码时就会更加游刃有余了。</p><a id="more"></a><h2 id="VideoRoom插件"><a href="#VideoRoom插件" class="headerlink" title="VideoRoom插件"></a>VideoRoom插件</h2><p><code>VideoRoom</code>是Janus的一个插件，实现了一个SFU（Selective Forwarding Unit）型的音视频会议。如果你从数据转发的角度看，也可以把它认为是一个音视频<code>路由器</code>。</p><p><code>VideoRoom</code>实现的音视频会议是基于<code>发布/订阅</code>模式。每个<code>参与方</code>都可以发布自己的实时音视频流，因此它可以实现几种不同的场景，比如泛娱乐化直播或多人的实时互动产品(如音视频会议、在线教育小班课等）。</p><p>考虑到此插件允许一个<code>参与方</code>可以打开多个WebRTC <code>PeerConnection</code>（如每个<code>参与方</code>可以有1个用于推流的<code>PeerConnection</code>和N个拉流的<code>PeerConnection</code>），所以每个<code>参与方</code>需要为订阅不同的流<code>attach</code>到<code>VideoRoom</code>插件几次(每<code>attach</code>一次就会生成一个<code>Handle</code>，每个<code>Handle</code>就是一个上下文)。</p><p>因此，对于每个<code>参与方</code>至少要有一个<code>Handle</code>用于管理与插件的关系（如加入一个房间，离开一个房间，静音/取消静音，发布，接收事件）。</p><p>每当<code>参与方</code>需要订阅另一个参与方发布的音视频流时，它需要创建一个新的<code>Handle</code>。新创建的<code>Handle</code>在逻辑上属于<strong>“从”</strong><code>Handle</code>，它不能像<strong>“主”</strong><code>Handle</code>一样可以做取消房间静音这样的操作。因此，<strong>从</strong><code>Handle</code>唯一目的是提供一个上下文，在该上下文中创建一个<code>recvonly</code>类型的<code>PeerConnection</code>来订阅发布者的音视频流。</p><p>通过上面的描述我们可以知道，主Handle用于管理，而从Handle用于订阅音视频流。</p><blockquote><p>注意，现在<code>WebRTC</code>已经实现了SSRC复用（Unified Plan），这意味着你可以使用相同的<code>Janus Handle</code> 和<code>PeerConnection</code>同时接收多路音视频流。</p></blockquote><p>VideoRoom插件功能非常强大，也很灵活，它有很多的配置项，你可以通过<code>conf/janus.plugin.videoroom.jcfg</code>来修改它们。当然Janus也支持动态API修改配置，如通过API创建房间等。</p><p>要增加更多房间或修改现有房间信息，你可以向Janus发送下面格式的请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">room- &lt;唯一的房间ID&gt;：&#123;</span><br><span class="line">        description &#x3D; 房间的描述信息</span><br><span class="line">        is_private &#x3D; true | false（是否是私有房间? 如果创建的是私有房间，则无法通过list指令进行查看）</span><br><span class="line">        secret &#x3D; &lt;可选项，操作房间所需的密码，如果设置了，则像做销毁房间这样的操作时你要带上它才行&gt;</span><br><span class="line">        PIN &#x3D; &lt;可选项，加入会议房间的密码&gt;</span><br><span class="line">        require_pvtid &#x3D; true | false（是否订阅音视频流时，需要提供一个与发布者相关的有效private_id， 默认为false）</span><br><span class="line">        publishers &#x3D;  &lt;房间内发布者的最大数&gt;（例如，一个视频会议可以有6个发布者，而广播只有一个，默认&#x3D; 3）</span><br><span class="line">        bitrate &#x3D; &lt;房间里发布者发送数据的最大比特率&gt;（例如128000）</span><br><span class="line">        fir_freq &#x3D; &lt;向发布者发送FIR指令的频率&gt;（0 &#x3D;禁用）</span><br><span class="line">        audiocodec &#x3D; opus | g722 | pcmu | pcma | isac32 | isac16（发布者可以使用的音频编解码器列表，默认为opus。编码器按优先顺序以逗号分隔）</span><br><span class="line">        videocodec &#x3D; vp8 | vp9 | h264 | av1 | h265（发布者可以使用的视频编解码器列表，默认为vp8。可以按优先级顺序用逗号分隔，例如，vp9，vp8，h264）</span><br><span class="line">        vp9_profile &#x3D; VP9首选的profile(&quot;2&quot; 表示 &quot;profile-id &#x3D; 2&quot; ）</span><br><span class="line">        h264_profile &#x3D; H.264首选的profile（&quot;42e01f&quot; 表示 &quot;profile-level-id &#x3D; 42e01f&quot; ）</span><br><span class="line">        opus_fec &#x3D; true | false（是否使用带内FEC；仅适用于Opus，默认为false）</span><br><span class="line">        video_svc &#x3D; true | false（是否启用SVC支持；仅适用于VP9，默认为false）</span><br><span class="line">        audiolevel_ext &#x3D; true | false（对于发布者是否使用RTP扩展ssrc-audio-level？默认为 true）</span><br><span class="line">        audiolevel_event &#x3D; true | false（是否将audiolevel事件发送给其他用户）</span><br><span class="line">        audio_active_packets &#x3D; 100（音频保活包个数，默认值&#x3D; 100，2秒）</span><br><span class="line">        audio_level_average &#x3D; 25（音频音量级别的平均值，127 &#x3D;静音，0 &#x3D;&#39;太大声&#39;，默认&#x3D; 25）</span><br><span class="line">        videoorient_ext &#x3D; true | false（发布者是否使用RTP扩展video-orientation? 默认&#x3D; true）</span><br><span class="line">        playoutdelay_ext &#x3D; true | false（发布者是否使用RTP扩展playout-delay? 默认&#x3D; true）</span><br><span class="line">        transport_wide_cc_ext &#x3D; true | false（发布者是否使用RTP扩展 transport-wide-cc? 默认&#x3D; true）</span><br><span class="line">        record &#x3D; true | false（该房间是否启录制？默认&#x3D; false）</span><br><span class="line">        rec_dir &#x3D; &lt;启用录制后，录制文件存放的目录&gt;</span><br><span class="line">        lock_record &#x3D; true | false（是否锁定录制状态? 默认&#x3D; false）</span><br><span class="line">        notify_joining &#x3D; true | false（可选，当有新的参与方加入房音后，是否通知房间里的所有参与者?</span><br><span class="line">                                       Videoroom插件默认仅通知发布者，启用此功能可能会导致额外的通知传输。</span><br><span class="line">                                       该功能与require_pvtid一起启用时，对管理员管理仅收听的参与者特别有用。默认&#x3D; false）</span><br><span class="line">        require_e2ee &#x3D; true | false（是否启用端到端加密? 默认&#x3D; false）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Video-Room-可以使用的API"><a href="#Video-Room-可以使用的API" class="headerlink" title="Video Room 可以使用的API"></a>Video Room 可以使用的API</h2><p><code>VideoRoom</code> 插件支持很多API。这些API中，一些是同步请求，一些则是异步请求。但无论是同步还是异步请求，当遇到无效的JSON格式或无效的请求时，都使用同步进行错误响应。</p><p>接下来，我们首先看看都有那些同步请求API。<code>create</code>，<code>destroy</code>，<code>edit</code>，<code>exists</code>，<code>list</code>，<code>allowed</code>，<code>kick</code>和<code>listparticipants</code>是同步请求API。<code>create</code>允许您动态创建一个新的音视频房间；<code>edit</code>允许您动态编辑房间的属性（例如 修改PIN码）；<code>destroy</code>首先释放视频资源，然后踢除房间里的所有用户，最后销毁音视频房间；<code>exists</code>检查指定的音视频房间是否存在；<code>list</code>列出所有有效的音视频房间; <code>listparticipants</code>列出指定房间中所有激活的参与者及其详细信息。</p><p>异步请求API有：<code>join</code>，<code>joinandconfigure</code>，<code>configure</code>，<code>publish</code>，<code>unpublish</code>，<code>start</code>，<code>pause</code>，<code>switch</code>和<code>leave</code>。<code>join</code>允许你加入指定的音视频房间；<code>configure</code>可用于修改某些属性（例如，比特率范围）；<code>joinandconfigure</code>的含义是将前两个请求合并为一个请求（该请求仅适用于发布者）；<code>publish</code>发布媒体流给所有订阅者; <code>unpublish</code>正好与<code>publish</code>相反；<code>start</code>允许你开始接收订阅的媒体流；<code>pause</code>暂停发送媒体流；<code>switch</code>更改指定<code>PeerConnection</code>的媒体源（例如，你正在看A，现在改为看B），但无需为此创建新的Handle；<code>leave</code>离开视频房间。</p><p>下面咱们对上面提到的API做一下详细分析，首先看一下<code>create</code>API，它用于创建新的音视频房间，其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;create&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;可选，房间ID。如果不填，则由插件随机生成&gt;，</span><br><span class="line">        &quot;permanent&quot;：&lt;true | false，是否创建永久房间，默认&#x3D; false&gt;，</span><br><span class="line">        &quot;description&quot;：&quot;&lt;可选，房间的名称&gt;&quot;，</span><br><span class="line">        &quot;secret&quot;：&quot;&lt;可选，编辑&#x2F;销毁房间时用的密码&gt;&quot;，</span><br><span class="line">        &quot;pin&quot;：&quot;&lt;可选，加入房间的密码&gt;&quot;，</span><br><span class="line">        &quot;is_private&quot;：&lt;true | false，是否是私有房间？如果是私有房间则不会出现在房间列表中&gt;，</span><br><span class="line">        &quot;allowed&quot;：[可选，用户加入房间的token数组]，</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的说明已经非常清楚了，这里我就不做简赘述了。</p><p>如果<code>create</code>成功，则会返回<code>created</code>响应，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：“created&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;permanent&quot;：&lt;是否是创建的永久房间？是则为true，否则为false&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，如果你请求创建一个永久房间，但<code>permanet</code>返回的是false，很可能是因为权限的问题导致的。</p></blockquote><p>如果<code>create</code>请求失败，则返回错误信息，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;error_code&quot;：&lt;错误码，每个错误码的含义需要看插件实现代码中的宏定义&gt;，</span><br><span class="line">        &quot;error&quot;：&quot;&lt;错误描述字符串&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里需要注意的是，所有请求的错误响应格式都与上面一样。</p></blockquote><p>默认情况下，所有用户都可以创建房间，但你可以通过在<code>VideoRoom</code>插件的配置文件中增加<code>admin_key</code>项来限制此功能。此时，只有带了正确的<code>admin_key</code>值的<code>create</code>请求才能成功创建房间。你也可以选择将此功能扩展到RTP转发，只转发受信任的客户端的RTP包。</p><p>房间创建好后，您可以用<code>edit</code>API编辑其中的部分（但不是全部）属性。<code>edit</code>允许你修改房间描述，密码，PIN码以及是否为私有。但你将无法修改他的静态属性，例如房间ID，采样率，与扩展相关的内容等。如果你有兴趣更改ACL，还需要查看<code>allowed</code>是否允许。</p><p>一个<code>edit</code>请求格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;edit&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;secret&quot;：&quot;&lt;房间密码&gt;&quot;，</span><br><span class="line">        &quot;new_description&quot;：&quot;&lt;房间的新名称，可选&gt;&quot;，</span><br><span class="line">        &quot;new_secret&quot;：&quot;&lt;房间的新密码，可选&gt;&quot;，</span><br><span class="line">        &quot;new_pin&quot;：&quot;&lt;新PIN码，可选&gt;&quot;，</span><br><span class="line">        &quot;new_is_private&quot;：&lt;true | false，房间是否为私有房间?&gt;，</span><br><span class="line">        &quot;new_require_pvtid&quot;：&lt;true | false，房间是否要求订阅者提供private_id&gt;，</span><br><span class="line">        &quot;new_bitrate&quot;：&lt;比特率&gt;，</span><br><span class="line">        &quot;new_fir_freq&quot;：&lt;发送PLI请求关键帧的时间间隔&gt;，</span><br><span class="line">        &quot;new_publishers&quot;：&lt;房间里发布者的最大数&gt;，</span><br><span class="line">        &quot;new_lock_record&quot;：&lt;true | false，如否可以改变录制状态&gt;，</span><br><span class="line">        &quot;permanent&quot;：&lt;true | false，该房间是否是永久房间？默认&#x3D; false&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>edit</code>请求成功，刚收到<code>edited</code>响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;edited&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来看看<code>destroy</code>API，无论你是通过动态创建的还是静态创建的房间，均可使用<code>destroy</code>销毁它，其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;destroy&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;secret&quot;：&quot;&lt;房间密码&gt;&quot;，</span><br><span class="line">        &quot;permanent&quot;：&lt;true | false，是否是永久房间，默认&#x3D; false&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功销毁房间后将收到<code>destroyed</code>响应，其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;destroyed&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>销毁房间后，在房间内的所有参与者都会收到<code>destroyed</code>事件，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;destroyed&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Janus中还提供了<code>exists</code>API，来检查房间是否存在，该请求的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;exists&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求成功将收到success响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：“success&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        “exists&quot;：&lt;true | false 房间是否存在&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>allowed</code>API可以打开/关闭对令牌的检测，它还可以增加/删除允许的用户，其请求格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;allowed&quot;，</span><br><span class="line">        &quot;secret&quot;：&quot;&lt;房间密码，如果已配置，则是必需的&gt;&quot;，</span><br><span class="line">        &quot;action&quot;：&quot;enable | disable | add | remove&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;allowed&quot;：[</span><br><span class="line">                &#x2F;&#x2F;字符串数组</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功请求将返回success响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：“success&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        “allowed&quot;：[</span><br><span class="line">                &#x2F;&#x2F;更新后完整的令牌列表</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你是房间管理员（即你创建了该房间并可以加密访问），则你可以使用<code>kick</code>API踢除房间内的用户。</p><blockquote><p>注意，这只会将用户踢出房间，但并不能阻止他们重新加入。要禁止他们加入，你需要先从授权用户列表中删除他们（请参阅allowed请求），然后再将其踢掉。<code>kick</code>请求的格式如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;kick&quot;，</span><br><span class="line">        &quot;secret&quot;：&quot;&lt;房间密码&gt;&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;id&quot;：&lt;被踢用户ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求成功将收到success响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;success&quot;，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你还可以通过<code>list</code>API获取可用房间的列表（不包括配置或创建为私有的房间），其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：“list&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求成功将返回success响应，响应中会带有有效的房间列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：“成功&quot;，</span><br><span class="line">        &quot;rooms&quot;：[&#x2F;&#x2F;房间对象数组</span><br><span class="line">                &#123;&#x2F;&#x2F; 第一个房间</span><br><span class="line">                        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">                        &quot;description&quot;：&quot;&lt;房间名称&gt;&quot;，</span><br><span class="line">                        &quot;pin_required&quot;：&lt;true | false，是否需要输入PIN吗才能加入此房间&gt;，</span><br><span class="line">                        &quot;max_publishers&quot;：&lt;房间内发布者最大数量，&gt;</span><br><span class="line">                        &quot;bitrate&quot;：&lt;发布者使用的（通过REMB）比特率上限&gt;，</span><br><span class="line">                        &quot;bitrate_cap&quot;：&lt;true | false，上述上限是否可以动态更改?&gt;，</span><br><span class="line">                        &quot;fir_freq&quot;：&lt;发送PLI&#x2F;FIR请求关键帧的时间间隔&gt;，</span><br><span class="line">                        &quot;audiocodec&quot;：&quot;&lt;音频编解码器列表，每个编码器以逗号分隔&gt;&quot;，</span><br><span class="line">                        &quot;videocodec&quot;：&quot;&lt;视频编解码器列表，每个编码器以逗号分隔&gt;&quot;，</span><br><span class="line">                        &quot;record&quot;：&lt;true | false，是否打开了录制功能&gt;，</span><br><span class="line">                        &quot;record_dir&quot;：&quot;&lt;如果开启了录掉，.mjr文件保存的路径&gt;&quot;，</span><br><span class="line">                        &quot;lock_record&quot;：&lt;true | false，是否只能通过密码才能更改房间记录状态&gt;，</span><br><span class="line">                        &quot;num_participants&quot;：&lt;房间内参与人的个数&gt;</span><br><span class="line">                &#125;，</span><br><span class="line">                &#x2F;&#x2F;其他房间</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，你要获取特定房间中的参与者列表，可以使用<code>listparticipants</code>请求，其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;listparticipants&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求成功将返回一个<code>participants</code>响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;participants&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        “participants&quot;：[&#x2F;&#x2F;参与者对象的数组</span><br><span class="line">                &#123;&#x2F;&#x2F;参与者＃1</span><br><span class="line">                        &quot;id&quot;：&lt;用户ID&gt;，</span><br><span class="line">                        &quot;display&quot;：&quot;&lt;用户名；可选&gt;&quot;，</span><br><span class="line">                        &quot;publisher&quot;：&quot;&lt;true | false，用户是否是房间的发布者&gt;&quot;，</span><br><span class="line">                        &quot;talking&quot;：&lt;true | false，用户是否可以说话（仅当使用音频级别时）&gt;</span><br><span class="line">                &#125;，</span><br><span class="line">                &#x2F;&#x2F;其他参与者</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是Janus中的同步API。异步API都是与<code>参与者</code>有关，即<code>参与者</code>如何发布，订阅或管理他们正在发送或接收的媒体流。</p><h2 id="VideoRoom-发布者"><a href="#VideoRoom-发布者" class="headerlink" title="VideoRoom 发布者"></a>VideoRoom 发布者</h2><p>在VideoRoom中，<code>发布者</code>是指那些能够在房间中发布<code>媒体流</code>的参与者。</p><p>当你以<code>发布者</code>的身份加入到房间里时，您应该发送<code>join</code>请求，并且将ptype设置为<code>publisher</code>。请求的具体格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;join&quot;，</span><br><span class="line">        &quot;ptype&quot;：&quot;pbulisher&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;id&quot;：&lt;发布者ID；可选，如果缺少，将由插件选择&gt;，</span><br><span class="line">        &quot;display&quot;：&quot;&lt;发布者名称；可选&gt;&quot;，</span><br><span class="line">        &quot;token&quot;：&quot;&lt;邀请令牌，如果房间有ACL时需要该字段；可选&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>join</code>请求成功将收到<code>joined</code>事件，其中包含当前激活的<code>发布者</code>列表，以及任选的<code>参加者</code>列表。<code>joined</code>事件格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;joined&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;description&quot;：&lt;房间名，如果有的话&gt;，</span><br><span class="line">        &quot;id&quot;：&lt;用户ID&gt;，</span><br><span class="line">        &quot;private_id&quot;：&lt;与参与者相关联的不同唯一ID；打算是私人的&gt;，</span><br><span class="line">        “publishers&quot;：[</span><br><span class="line">                &#123;</span><br><span class="line">                        &quot;id&quot;：&lt;活动发布者＃1的唯一ID&gt;，</span><br><span class="line">                        &quot;display&quot;：&quot;&lt;发布者＃1的名称，如果有的话&gt;&quot;，</span><br><span class="line">                        &quot;audio_codec&quot;：&quot;&lt;发布者＃1使用的音频编解码器，如果有的话&gt;&quot;，</span><br><span class="line">                        &quot;video_codec&quot;：&quot;&lt;发布者＃1使用的视频编解码器，如果有的话&gt;&quot;，</span><br><span class="line">                        &quot;simulcast&quot;：&quot;&lt;如果发布者使用simulcast，则为true（仅VP8和H.264）&gt;&quot;，</span><br><span class="line">                        &quot;talking&quot;：&lt;true | false，发布者开启语音聊天（仅在使用音频级别的情况下）&gt;，</span><br><span class="line">                &#125;，</span><br><span class="line">                &#x2F;&#x2F;其他活跃的发布者</span><br><span class="line">        ]，</span><br><span class="line">        &quot;attendees&quot;：[&#x2F;&#x2F;仅当房间的notify_joining设置为TRUE时存在</span><br><span class="line">                &#123;</span><br><span class="line">                        &quot;id&quot;：&lt;与会者＃1的唯一ID&gt;，</span><br><span class="line">                        &quot;display&quot;：&quot;&lt;与会者＃1的名称，如果有的话&gt;&quot;</span><br><span class="line">                &#125;，</span><br><span class="line">                &#x2F;&#x2F;其他参加者</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，如果房间中当前没有人，则<code>发布者</code>列表为空。上面格式中的<code>private_id</code>属性只有在用户订阅时才起作用。</p></blockquote><p>对于房间里的订阅者来说，会收到<code>event</code>通知。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        “joining&quot;：&#123;</span><br><span class="line">                &quot;id&quot;：&lt;参与者ID&gt;，</span><br><span class="line">                &quot;display&quot;：&quot;&lt;参与者名称&gt;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想成为<code>发布者</code>，则发送<code>publish</code>请求。该请求必须跟着一个<code>JSEP SDP Offer</code>，用于协商新的<code>PeerConnection</code>。插件会将其与房间配置进行匹配（例如，确保房间中使用协商的编解码器），并使用<code>JSEP SDP answer</code>进行答复从而完成<code>PeerConnection</code>的设置。建立<code>PeerConnection</code>后，发布者立即处于活动状态，其他参与者就可以订阅它发布的流啦。</p><p><code>publish</code>请求格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;publish&quot;，</span><br><span class="line">        &quot;audio&quot;：&lt;true | false，是否应该转发音频；默认为true&gt;，</span><br><span class="line">        &quot;video&quot;：&lt;true | false，是否应该转发视频；默认为true&gt;，</span><br><span class="line">        &quot;data&quot;：&lt;true | false，是否应该转发数据；默认为true&gt;，</span><br><span class="line">        &quot;audiocodec&quot;：&quot;&lt;在协商协议中首选的音频编解码器；可选&gt;&quot;，</span><br><span class="line">        &quot;videocodec&quot;：&quot;&lt;在协商协议中首选的视频编解码器；可选&gt;&quot;，</span><br><span class="line">        &quot;bitrate&quot;：&lt;通过REMB返回的比特率上限；可选，如果存在则覆盖全局房间值&gt;，</span><br><span class="line">        &quot;record&quot;：&lt;true | false，是否应该记录此发布者；可选&gt;</span><br><span class="line">        &quot;filename&quot;：&quot;&lt;录制文件名；可选&gt;&quot;，</span><br><span class="line">        &quot;display&quot;：&quot;&lt;用户名称；可选&gt;&quot;，</span><br><span class="line">        &quot;audio_level_average&quot;：&quot;&lt;音频音量平均值，此设置覆盖房间的audio_level_average；可选&gt;&quot;，</span><br><span class="line">        &quot;audio_active_packets&quot;：&quot;&lt;音频保活包数，此设置覆盖房间audio_active_packets；可选&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此请求应该与发布者的<code>JSEP SDP Offer</code>一起提供，插件收到此消息后，将协商与之匹配的<code>JSEP SDP Answer</code>。如果成功，<code>configured</code>事件将被返回，其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;configured&quot;：“ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该事件将与准备好的<code>JSEP SDP Answer</code>一起发送给客户端。</p><p>你也可以用<code>configure</code>请求代替<code>publish</code>。两者的功能在<code>发布</code>上是等效的，但从语义的角度来看，<code>publish</code>是发布时要发送的正确消息。<code>configure</code>请求也可以用于更新发布者会话的某些属性，在这种情况下，就不能用<code>publish</code>请求了。</p><blockquote><p>需要注意的是，如果用户已经发送过<code>publish</code>了，再发送<code>publish</code>将导致失败。</p></blockquote><p>其实，您可以将<code>join</code>和<code>publish</code>两个API合并为一个API请求。比如你一开始以<code>参与者</code>的身份加入，随后变为<code>发布者</code>，这时你就可以将他们合并。你可以使用<code>joinandconfigure</code>请求来做到这一点，该请求将这两个请求（join与publish)结合在一起。如果成功，则响应一个<code>joined</code>事件，并且将<code>JSEP SDP Answer</code>一起发送出去。</p><p>一旦<code>PeerConnection</code>设置成功，且发布者处于激活状态，<code>event</code>就会被发向房间中的所有<code>参与者</code>。其格式如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        “publishers&quot;：[</span><br><span class="line">                &#123;</span><br><span class="line">                        &quot;id&quot;：&lt;新发布者的唯一ID&gt;，</span><br><span class="line">                        &quot;display&quot;：&quot;&lt;新发布者的名称，如果有的话&gt;&quot;，</span><br><span class="line">                        &quot;audio_codec&quot;：&quot;&lt;新布者使用的音频编解码器，如果有的话&gt;&quot;，</span><br><span class="line">                        &quot;video_codec&quot;：&quot;&lt;新发布使用的视频编解码器，如果有的话&gt;&quot;，</span><br><span class="line">                        &quot;simulcast&quot;：&quot;&lt;如果发布者使用simucast，则为true（仅VP8和H.264）&gt;&quot;，</span><br><span class="line">                        &quot;talking&quot;：&lt;true | false，发布者是否在讲话（仅在使用音频级别的情况下）&gt;，</span><br><span class="line">                &#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要停止发布并删除相关的<code>PeerConnection</code>，可以使用该<code>unpublish</code>请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：“unpublish&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当插件收到这条请求后，它会删除对应的<code>PeerConnection</code>，并将发布者从活动列表中删除。如果成功，响应如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        “unpublish&quot;：“ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>PeerConnection</code>删除后，插件还将向所有其他<code>参与者</code>通知该流不再可用的消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;unpublished&quot;：&lt;发布者的ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，不光收到<code>unpublish</code>消息会触发上面的事件通知，其实无论什么情况下，只要<code>发布者</code>提供的流消失了（例如，句柄已关闭或用户失去连接），都会发同样的<code>事件</code>。此外，你可以使用同一句柄的上下文多次执行<code>发布</code>或<code>取消发布</code>操作。</p></blockquote><p>正如我们上面讲过的，你可以使用<code>configure</code>请求调整发布者会话的某些属性。该请求的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;configure&quot;，</span><br><span class="line">        &quot;audio&quot;：&lt;true | false，取决于是否应该转发音频；默认为true&gt;，</span><br><span class="line">        &quot;video&quot;：&lt;true | false，取决于是否应该转发视频；默认为true&gt;，</span><br><span class="line">        &quot;data&quot;：&lt;true | false，取决于是否应该转发数据；默认为true&gt;，</span><br><span class="line">        &quot;bitrate&quot;：&lt;比特率上限；可选，如果存在则覆盖全局房间值（除非设置了bitrate_cap）&gt;，</span><br><span class="line">        &quot;keyframe&quot;：&lt;true | false，是否向发布者发送关键帧请求&gt;，</span><br><span class="line">        &quot;record&quot;：&lt;true | false，是否开启录制；可选&gt;</span><br><span class="line">        &quot;filename&quot;：&quot;&lt;如果开启了录制，指明录制路径&#x2F;文件；可选&gt;&quot;，</span><br><span class="line">        &quot;display&quot;：&quot;&lt;用户名称；可选&gt;&quot;，</span><br><span class="line">        &quot;audio_active_packets&quot;：&quot;&lt;音频保活包个数，audio_active_packets；可选&gt;&quot;，</span><br><span class="line">        &quot;audio_level_average&quot;：&quot;&lt;音频音量平均值，audio_level_average；可选&gt;&quot;，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>configure</code>基本上与<code>publish</code>的属性相同。这就是为什么两个请求都可以用来开始发布的原因。如果<code>configure</code>成功，则返回<code>configured</code>事件，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;configured&quot;：“ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当发送<code>configure</code>请求RTP扩展<code>ssrc-audio-level</code>时，如果<code>audiolevel_event</code>设置为true ，则可能会向所有发布者发送一些临时事件。这些事件将具有以下格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&lt;&quot;talking&quot;|&quot;stopped-talking&quot;，是否发布者开始或停止发言&gt;，</span><br><span class="line">        &quot;room&quot;：&lt;房间的唯一ID&gt;，</span><br><span class="line">        &quot;id&quot;：&lt;发布者的唯一ID&gt;，</span><br><span class="line">        &quot;audio-level-dBov-avg&quot;：&lt;音平音量的平均值，127 &#x3D;静音，0 &#x3D;&#39;太大声&#39;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VideoRoom</code>插件的主要目的是从WebRTC源(发布者)获取媒体，并将其转发到WebRTC目的地（订阅者），但实际上存在几种方案，可以将媒体转发给外部（不一定与WebRTC兼容）组件。例如，用于媒体处理，外部录制，转码，级联等等。<code>rtp_forward</code>顾名思义，就是将发布者发送的RTP包（普通或加密）实时转发到远程后端。</p><p>您可以使用<code>rtp_forward</code>请求为现有发布者添加新的RTP转发器，其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;rtp_forward&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;publisher_id&quot;：&lt;发布者ID&gt;，</span><br><span class="line">        &quot;host&quot;：&quot;&lt;将RTP和数据包转发到的host主机IP地址&gt;&quot;，</span><br><span class="line">        &quot;host_family&quot;：&quot;&lt;ipv4 | ipv6，使用IPv4还是IPv6；默认情况下，无论我们得到什么&gt;&quot;，</span><br><span class="line">        &quot;audio_port&quot;：&lt;音频RTP数据包转发到的端口&gt;，</span><br><span class="line">        &quot;audio_ssrc&quot;：&lt;音频SSRC，用于流式传输；可选&gt;</span><br><span class="line">        &quot;audio_pt&quot;：&lt;音频有效负载类型；可选&gt;</span><br><span class="line">        &quot;audio_rtcp_port&quot;：&lt;接收方接收音频RTCP反馈端口；可选，当前未用于音频&gt;，</span><br><span class="line">        &quot;video_port&quot;：&lt;将视频RTP数据包转发到的端口&gt;，</span><br><span class="line">        &quot;video_ssrc&quot;：&lt;视频 SSRC；可选&gt;</span><br><span class="line">        &quot;video_pt&quot;：&lt;视频有效载荷类型；可选&gt;</span><br><span class="line">        &quot;video_rtcp_port&quot;：&lt;接收方接收视频RTCP反馈端口；可选&gt;</span><br><span class="line">        &quot;video_port_2&quot;：&lt;如果simulcast，则视频第二个的RTP数据端口&gt;，</span><br><span class="line">        &quot;video_ssrc_2&quot;：&lt;如果simulcast，则视频第二个的SSRC；可选&gt;</span><br><span class="line">        &quot;video_pt_2&quot;：&lt;如果simulcast，则视频第二个的有效载荷类型；可选&gt;</span><br><span class="line">        &quot;video_port_3&quot;：&lt;如果simulcast，则视频第三个RTP数据包端口&gt;，</span><br><span class="line">        &quot;video_ssrc_3&quot;：&lt;如果simulcast，则视频第三个SSRC；可选&gt;</span><br><span class="line">        &quot;video_pt_3&quot;：&lt;如果simulcast，则视频第三个的有效载荷类型；可选&gt;</span><br><span class="line">        &quot;data_port&quot;：&lt;数据通道消息端口&gt;，</span><br><span class="line">        &quot;srtp_suite&quot;：&lt;身份验证标签的长度（32或80）；可选&gt;</span><br><span class="line">        &quot;srtp_crypto&quot;：&quot;&lt;用作加密的密钥（如SDES中的base64编码的密钥；可选&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，如上所述，如果您配置了admin_key属性，则在请求中也需要提供它，否则未授权的请求将被拒绝。默认情况下，没有对rtp_forward进行限制。</p></blockquote><p>如果请求成功则返回<code>rtp_forward</code>响应，其中格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;rtp_forward&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;publisher_id&quot;：&lt;发布者ID&gt;</span><br><span class="line">        &quot;rtp_stream&quot;：&#123;</span><br><span class="line">                &quot;host&quot;：&quot;&lt;接收流的主机IP，如果未解析，则与请求相同&gt;&quot;，</span><br><span class="line">                &quot;audio&quot;：&lt;音频RTP端口，与请求相同（如果已配置）&gt;，</span><br><span class="line">                &quot;audio_rtcp&quot;：&lt;音频RTCP端口，与请求相同（如果已配置）&gt;，</span><br><span class="line">                &quot;audio_stream_id&quot;：&lt;分配给音频RTP转发器的唯一数字ID，如果有的话，&gt;</span><br><span class="line">                &quot;video&quot;：&lt;视频RTP端口，与请求相同（如果已配置）&gt;，</span><br><span class="line">                &quot;video_rtcp&quot;：&lt;视频RTCP端口，如果配置，则与请求相同，&gt;</span><br><span class="line">                &quot;video_stream_id&quot;：&lt;分配给主视频RTP转发器的唯一数字ID，如果有的话，&gt;</span><br><span class="line">                &quot;video_2&quot;：&lt;第二个视频端口，与请求相同（如果已配置）&gt;，</span><br><span class="line">                &quot;video_stream_id_2&quot;：&lt;分配给第二层视频RTP转发器的唯一数字ID，如果有的话，&gt;</span><br><span class="line">                &quot;video_3&quot;：&lt;第三个视频端口，与请求相同（如果已配置）&gt;，</span><br><span class="line">                &quot;video_stream_id_3&quot;：&lt;分配给第三个视频RTP转发器的唯一数字ID，如果有，&gt;</span><br><span class="line">                &quot;data&quot;：&lt;数据端口，与请求相同（如果已配置）&gt;，</span><br><span class="line">                &quot;data_stream_id&quot;：&lt;分配给数据通道消息转发器的唯一数字ID（如果有）&gt;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要停止以前创建的RTP转发器，可以使用<code>stop_rtp_forward</code>请求，其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;stop_rtp_forward&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;publisher_id&quot;：&lt;发布者ID&gt;，</span><br><span class="line">        &quot;stream_id&quot;：&lt;RTP转发器ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求成功，则返回<code>stop_rtp_forward</code>响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;stop_rtp_forward&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;publisher_id&quot;：&lt;发布者ID，与请求相同，&gt;</span><br><span class="line">        &quot;stream_id&quot;：&lt;流ID，与请求相同&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要获取特定房间中所有转发器的列表，可以使用<code>listforwarders</code>请求，其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;listforwarders&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间的唯一数字ID&gt;，</span><br><span class="line">        &quot;secret&quot;：&quot;&lt;房间密码；如果已配置，则是必需的&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求成功，则返回forwarders响应，其中包括RTP转发器列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;forwarders&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间的唯一ID&gt;，</span><br><span class="line">        &quot;rtp_forwarders&quot;：[&#x2F;&#x2F;具有RTP转发器的发布者数组</span><br><span class="line">                &#123;&#x2F;&#x2F;发布者＃1</span><br><span class="line">                        &quot;publisher_id&quot;：&lt;发布者＃1的唯一数字ID&gt;，</span><br><span class="line">                        &quot;rtp_forwarders&quot;：[&#x2F;&#x2F; RTP转发器数组</span><br><span class="line">                                &#123;&#x2F;&#x2F; RTP转发器＃1</span><br><span class="line">                                        &quot;audio_stream_id&quot;：&lt;音频RTP转发器的唯一ID，如果有的话&gt;，</span><br><span class="line">                                        &quot;video_stream_id&quot;：&lt;视频RTP转发器的唯一ID，如果有的话&gt;，</span><br><span class="line">                                        &quot;data_stream_id&quot;：&lt;数据通道消息转发器的唯一ID（如果有）&gt;，</span><br><span class="line">                                        &quot;ip&quot;：&quot;&lt;接收端IP&gt;&quot;，</span><br><span class="line">                                        &quot;port&quot;：&lt;接收端端口&gt;，</span><br><span class="line">                                        &quot;rtcp_port&quot;：&lt;接收端RTCP端口，如果有的话&gt;，</span><br><span class="line">                                        &quot;ssrc&quot;：&lt;转发器正在使用的SSRC，如果有的话&gt;，</span><br><span class="line">                                        &quot;pt&quot;：&lt;转发器正在使用的有效负载类型&gt;，</span><br><span class="line">                                        &quot;substream&quot;：&lt;视频子流，如果有&gt;，</span><br><span class="line">                                        &quot;srtp&quot;：&lt;true | false，RTP流是否已加密&gt;</span><br><span class="line">                                &#125;，</span><br><span class="line">                                &#x2F;&#x2F;此发布者的其他转发器</span><br><span class="line">                        ]，</span><br><span class="line">                &#125;，</span><br><span class="line">                &#x2F;&#x2F;其他发布者</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在会议进行期间启用或禁用录制，您可以使用<code>enable_recording</code>请求，该请求的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;enable_recording&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;secret&quot;：&quot;&lt;房间密码；如果已配置，则是必需的&gt;&quot;</span><br><span class="line">        &quot;record&quot;：&lt;true | false，是否自动记录此会议室中的参与者&gt;，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，参与者通常也可以通过configure请求来更改自己的录制状态：这样做是为了获得最大的灵活性，您可能希望单独记录一些流，而不是全局或自动记录一些内容，到特定文件。就是说，如果你希望确保在启用全局录制后参与者不能停止其录制，或者在不应该录制该会议室的情况下启动它，那么您应该确保在创建会议室时使用lock_record属性，将其设置为true。这样，只有在提供了房间密码的情况下，才能更改录制状态，从而确保只有管理员才能执行此操作。</p></blockquote><p>最后，您可以使用<code>leave</code>请求离开会议室。如果您是会议室中的活动发布者，这也将隐式取消你的发布。该leave请求如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;leave&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果成功，响应将如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;leaving&quot;：&quot;ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他参与者将收到”leaving”事件，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;leaving：&lt;离开的参与者的唯一ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您是活跃的发布者，则其他用户也将收到相应的<code>unpublish</code>事件，以通知他们该流不再可用。如果您只是潜伏而不是发布者，则其他参与者将仅收到”leave”事件。</p><h2 id="VideoRoom-订阅者"><a href="#VideoRoom-订阅者" class="headerlink" title="VideoRoom 订阅者"></a>VideoRoom 订阅者</h2><p>订阅者在加入房间时，join请求的ptype属性应该设置为<code>subscriber</code>，并指定要订阅的确切的媒体流。该请求的确切语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;join&quot;，</span><br><span class="line">        &quot;ptype&quot;：&quot;subscriber&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;feed&quot;：&lt;发布者ID；强制性&gt;，</span><br><span class="line">        &quot;private_id&quot;：&lt;发起此请求的用户ID；可选的，除非房间配置要求&gt;</span><br><span class="line">        &quot;close_pc&quot;：&lt;true | false，发布者离开时是否应自动关闭PeerConnection；默认为true&gt;，</span><br><span class="line">        &quot;audio&quot;：&lt;true | false，是否转发音频；默认为true&gt;，</span><br><span class="line">        &quot;video&quot;：&lt;true | false，是否转发视频；默认为true&gt;，</span><br><span class="line">        &quot;data&quot;：&lt;true | false，是否转发数据；默认为true&gt;，</span><br><span class="line">        &quot;offer_audio&quot;：&lt;true | false; 是否应该协商音频；如果发布者的音频&gt;，默认为true</span><br><span class="line">        &quot;offer_video&quot;：&lt;true | false; 是否应该协商视频；如果发布者的视频&gt;，默认为true</span><br><span class="line">        &quot;offer_data&quot;：&lt;true | false; 是否应该协商数据通道；如果发布者的datachannels&gt;为默认值，则为true</span><br><span class="line">        &quot;substream&quot;：&lt;启用了simulcast情况下，要接收的子流（0-2）；可选&gt;</span><br><span class="line">        &quot;temporal&quot;：&lt;启用simulcast情况下，要接收的时间层（0-2）；可选&gt;</span><br><span class="line">        &quot;fallback&quot;：&lt;多少时间（在我们这里，默认为250000）没有接收到数据包将使我们下降到下面的子流&gt;，</span><br><span class="line">        &quot;spatial_layer&quot;：&lt;启用VP9-SVC时要接收的空间层（0-2）；可选&gt;</span><br><span class="line">        &quot;temporal_layer&quot;：&lt;启用VP9-SVC时要接收的时间层（0-2）；可选&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如您所见，只要指定好要订阅的发布者ID，并在需要时指定好<code>private_id</code>(订阅者ID)，其它的都可以不设置。不过请求中的<code>offer_audio</code>，<code>offer_video</code>和<code>offer_data</code>特别有意思，你可以通过它们订阅媒体的一个子集(音频\视频\数据）。</p><p>默认情况下，发送<code>join</code>请求时会导致插件层创建<code>SDP Offer</code>，用以协商发布者提供那些媒体。此外，如果发布者发布的是<code>simulcast</code>或<code>VP9 SVC</code>，那么你还可以订阅你感兴趣的子流，例如，获得最佳质量的中间质量。更有意思的是，你可以使用<code>configure</code>请求随时动态更改这些设置。</p><p>上面的请求如果成功，将生成一个新的<code>JSEP SDP Offer</code>，并伴随一个attached事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;attached&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;feed&quot;：&lt;发布者ID&gt;，</span><br><span class="line">        &quot;display&quot;：&quot;&lt;发布者的名称，如果有的话&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此阶段，为了完成<code>PeerConnection</code>的设置，订阅者应将<code>JSEP SDP Answer</code>发送回插件。此操作是通过<code>start</code>请求来完成的，在这种情况下，请求必须与<code>JSEP SDP Answer</code>相关联，但是不需要任何参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：“start&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果成功，此请求将返回一个started事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;started&quot;：&quot;ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成此操作后，所需要做的就是等待WebRTC <code>PeerConnection</code>建立成功。一旦<code>PeerConnection</code>建立成功，Streaming插件就可以开始向订阅的观众转发媒体了。</p><blockquote><p>注意，在需要重新协商（例如出于ICE重启目的）的情况下，您也可以使用我们刚经历的相同步骤（watch请求，然后插件创建<code>JSEP Offer</code>，最后客户端发送<code>start</code>请求和<code>JSEP Answer</code>）。</p></blockquote><p>作为<code>订阅者</code>，您可以发送<code>pause</code>临时暂停或发送<code>start</code>恢复整个媒体的传送（在这种情况下，不附带任何JSEP SDP Answer）。因为上下文中已经有了相关信息，所以不需要重新进行协商。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;pause&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;start&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，它们会分别导致paused和started事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;paused&quot;：&quot;ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;started&quot;：&quot;ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>configure</code>请求可以对<code>订阅</code>做更多深入操作。该请求允许<code>订阅者</code>动态更改与媒体订阅有关的某些属性，<code>configure</code>请求的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;configure&quot;，</span><br><span class="line">        &quot;audio&quot;：&lt;true | false，是否应该转发音频；可选&gt;</span><br><span class="line">        &quot;video&quot;：&lt;true | false，是否应该转发视频；可选&gt;</span><br><span class="line">        &quot;data&quot;：&lt;true | false，是否转发数据；可选&gt;</span><br><span class="line">        &quot;substream&quot;：&lt;启用simulcast情况下，要接收的子流（0-2）；可选&gt;</span><br><span class="line">        &quot;temporal&quot;：&lt;启用simulcast，要接收的时间层（0-2）；可选&gt;</span><br><span class="line">        &quot;fallback&quot;：&lt;多少时间（在我们这里，默认为250000）没有接收到数据包将使我们下降到下面的子流&gt;，</span><br><span class="line">        &quot;spatial_layer&quot;：&lt;启用VP9-SVC时要接收的空间层（0-2）；可选&gt;</span><br><span class="line">        &quot;temporal_layer&quot;：&lt;启用VP9-SVC时要接收的时间层（0-2）；可选&gt;</span><br><span class="line">        &quot;audio_level_average&quot;：&quot;&lt;如果提供，将覆盖此用户的房间audio_level_average；可选&gt;&quot;，</span><br><span class="line">        &quot;audio_active_packets&quot;：&quot;&lt;如果提供，将覆盖此用户的房间audio_active_packets；可选&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所看到的audio，video和data属性可以用作媒体级的暂停/恢复功能，而pause与start只是简单地暂停/恢复所有数据流。</p><p>下面来说说<code>switch</code>，switch 请求格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;switch&quot;，</span><br><span class="line">        &quot;feed&quot;：&lt;要切换到的新发布者的唯一ID；强制性&gt;，</span><br><span class="line">        &quot;audio&quot;：&lt;true | false，取决于是否应该中继音频；可选&gt;</span><br><span class="line">        &quot;video&quot;：&lt;true | false，取决于是否应该中继视频；可选&gt;</span><br><span class="line">        &quot;data&quot;：&lt;true | false，取决于是否应该中继数据通道消息；可选&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果成功，您将退订之前的发布者，然后订阅新的发布者。确认切换成功的事件如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;switched&quot;：&quot;ok&quot;，</span><br><span class="line">        &quot;room&quot;：&lt;房间ID&gt;，</span><br><span class="line">        &quot;id&quot;：&lt;新发布者的唯一ID&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，要停止订阅并删除相关的PeerConnection，可以使用该leave请求。由于上下文是隐式的，因此不需要其他参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;request&quot;：&quot;leave&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果成功，该插件将尝试拆除PeerConnection，并发送回一个left事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;videoroom&quot;：&quot;event&quot;，</span><br><span class="line">        &quot;left&quot;：&quot;ok&quot;，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>VideoRoom</code>插件是Janus的一个特别重要的插件，对于该插件的理解对于我们理解整个Janus有至关重要的意义。本文说细分析了<code>VideoRoom</code>插件中所有的信令，大体上我们可以将它们人成两在类，一类是房间管理信令，另一类是用户信令。</p><p>这些信令设计的非常巧妙，对我们研发自己的SFU会议系统是一个很好的借鉴。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/947c722a/" target="_blank" rel="noopener">多人实时互动之各WebRTC流媒体服务器比较</a><br><a href="https://avdancedu.com/d7281c13/" target="_blank" rel="noopener">janus前端核心库源码分析</a></p>]]></content>
      
      
      <categories>
          
          <category> WebRTC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> videoroom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebRTC常见问题</title>
      <link href="/af19ebea/"/>
      <url>/af19ebea/</url>
      
        <content type="html"><![CDATA[<h2 id="DTLS-SRTP-与-DTLS-的区别"><a href="#DTLS-SRTP-与-DTLS-的区别" class="headerlink" title="DTLS-SRTP 与 DTLS 的区别"></a>DTLS-SRTP 与 DTLS 的区别</h2><p>DTLS用于数据加密，它是从 TLS 发展而来。 TLS用于TCP，而DTLS用于UDP。<br>DTLS-SRTP 只用户握手，交换<code>fingerprint</code>和密钥，真正的加密由SRTP来完成。</p><h2 id="是否开启-DTLS-SRTP"><a href="#是否开启-DTLS-SRTP" class="headerlink" title="是否开启 DTLS-SRTP"></a>是否开启 DTLS-SRTP</h2><p>在创建PeerConnection时设置<code>DtlsSrtpKeyAgreement</code>参数可以关闭/打开 DTLS-SRTP<br><a href="https://groups.google.com/forum/#!topic/discuss-webrtc/t8XT0IxoHgw" target="_blank" rel="noopener">discuss-webrtc</a></p>]]></content>
      
      
      <categories>
          
          <category> WebRTC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebRTC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>janus前端核心库源码分析</title>
      <link href="/d7281c13/"/>
      <url>/d7281c13/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/janus_js/janus_logo.jpg" alt=""></p><p>Hello,大家好！今天我们继续来分析janus。相信现在大家应该对<a href="https://janus.conf.meetecho.com/" target="_blank" rel="noopener">janus</a> 都比较熟悉了，它是一套完整的音视频会议系统，包括了WebRTC流媒体服务器和客户端API两大部分。</p><p>其中，客户端又包括Android、iOS以及浏览器端。今天我们要分析的内容就是浏览器端中的<code>janus.js</code>文件。之所以要分析它，是因为它是浏览器端最关键的一个文件，了解了它我们基本上就将浏览器端的逻辑全部撑握了。</p><p>从大的方面说，<code>janus.js</code>主要完成两方面的事儿。一是封装了浏览器与janus流媒体服务器之间的业务接口，使得在浏览器端开发音视频会议系统变得特别简单；二是对WebRTC的API做了封装，这样用户不用再理会WebRTC底层API该何使用了。</p><p>总之一句话，就是大大的减了少JS用户使用janus的难度。</p><a id="more"></a><p>在阅读本文之前你应该已经熟悉了JavaScript语法，且对浏览器下调用WebRTC的API十分精通，否则你应该先去补齐相关知识再来阅读本文。 这里有一些参考资料仅供参考：<a href="https://avdancedu.com/18fc7df1/" target="_blank" rel="noopener">《js类的探究》</a>，在这篇文章中有介绍ES5与ES6之间的区别。<a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门与实战课程》</a>，该课程详细讲解了在浏览器下该如何使用WebRTC。</p><p>下面我们开始<code>janus.js</code>源码分析。</p><h2 id="核心类Janus"><a href="#核心类Janus" class="headerlink" title="核心类Janus"></a>核心类Janus</h2><p>对于<code>janus</code>源码的目录结构我已经在之前的文章中向你介绍过了，如果你还没看过，可以到<a href="https://avdancedu.com/fdfe2594/" target="_blank" rel="noopener">这里</a>看一下。通过目录结构我们可以知道，<code>janus.js</code>就在<code>janus</code>源码的<code>html</code>目录下。</p><p>大体浏览一下<code>janus.js</code>你会发现，整个文件有3000多行代码，但只有一个<code>类</code>，即<code>Janus</code>类。该类中实现了很多方法，然而核心代码量并不大，经抽丝拨茧，你会发现下面几个方法是比较关键的。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">function Janus(gatewayCallbacks) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建一个Session，私有方法</span><br><span class="line">    function createSession(callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;消毁Session，私有方法</span><br><span class="line">    function destroySession(callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;用于处理Janus信令</span><br><span class="line">    function eventHandler()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;信令事件处理函数，私有方法</span><br><span class="line">    function handleEvent(json, skipTimeout);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;发送消息，私有方法</span><br><span class="line">    function sendMessage(handleId, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建插件处理函数，私有方法</span><br><span class="line">    function createHandle(callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;消毁插件处理方法</span><br><span class="line">    function destroyHandle(handleId, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;发送candidate，私有方法</span><br><span class="line">    function sendTrickleCandidate(handleId, candidate);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建PC</span><br><span class="line">    function streamsDone(handleId, jsep, media, callbacks, stream);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;准备WebRTC</span><br><span class="line">    function prepareWebrtc(handleId, offer, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;接收远端的SDP，并设备远端描述符</span><br><span class="line">    function prepareWebrtcPeer(handleId, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建Offer</span><br><span class="line">    function createOffer(handleId, media, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建answer</span><br><span class="line">    function createAnswer(handleId, media, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;发送SDP</span><br><span class="line">    function sendSDP(handleId, callbacks);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对上面的这些方法，我们可以按类别将其划分成以下几类：</p><ul><li><p>Session相关</p><ul><li>createSession</li><li>destorySession</li></ul></li><li><p>信令处理</p><ul><li>handleEvent</li><li>eventHandler</li><li>sendMessage</li></ul></li><li><p>Plugin相关</p><ul><li>createHandle</li><li>destoryHandle</li></ul></li><li><p>WebRTC相关</p><ul><li>prepareWebrtc</li><li>prepareWebrtcPeer</li><li>createOffer</li><li>createAnswer</li><li>sendSDP</li><li>streamDone</li></ul></li></ul><p>接下来，我们就对这几个函数做下详细介绍，整体的介绍思路是：首先介绍一下它的主要功能是什么，然后再讨论一下它是怎么实现的。</p><h2 id="Session-相关"><a href="#Session-相关" class="headerlink" title="Session 相关"></a>Session 相关</h2><p>首先我们来看看 <code>Session</code> 的作用是什么。<code>Session</code>表示的是一个客户端与<code>janus</code>服务器之间建立的一个<code>信令通道</code>。janus客户端与服务器之间就是通过这个<code>信令通道</code>传输信令的。</p><p>Session是如何创建的呢？下面我们就来看一下<code>createSession</code>函数的处理逻辑。在<code>createSession</code>中，首先创建了一个JSON对象<code>request</code>，该对象中包括了以下几个信息：</p><ul><li>janus，代表一个信令，<code>create</code>表示要创建一个<code>session</code>。</li><li>token，唯一标识，用于鉴权。</li><li>apisecret，API调用码密，用于安全访问。</li></ul><p><code>request</code>对象构建好后，<code>createSession</code>函数会根据server地址的类型(如ws://、http://）判断是使用 websocket 接口还是使用 HTTP RESTFUL接口。判断逻辑如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if(!server &amp;&amp; Janus.isArray(servers)) &#123;</span><br><span class="line">    &#x2F;&#x2F; We still need to find a working server from the list we were given</span><br><span class="line">    server &#x3D; servers[serversIndex];</span><br><span class="line">    if(server.indexOf(&quot;ws&quot;) &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">        websockets &#x3D; true;</span><br><span class="line">        Janus.log(&quot;Server #&quot; + (serversIndex+1) + &quot;: trying WebSockets to contact Janus (&quot; + server + &quot;)&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        websockets &#x3D; false;</span><br><span class="line">        Janus.log(&quot;Server #&quot; + (serversIndex+1) + &quot;: trying REST API to contact Janus (&quot; + server + &quot;)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果<code>createSession</code>判断server使用的是<code>websocket</code>接口，它就会走到<code>websocket</code>的处理逻辑分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(websockets)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个分支中，首先通过<code>Janus.newWebSocket</code>方法与server（janus服务器）建立连接。然后向websocket注册侦听事件，当websocket接收到不同的事件后就跳到对应事件的处理函数中执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">ws &#x3D; Janus.newWebSocket(server, &#39;janus-protocol&#39;);</span><br><span class="line">wsHandlers &#x3D; &#123;</span><br><span class="line">    &#39;error&#39;: ...,</span><br><span class="line">    &#39;open&#39;: ...,</span><br><span class="line">    &#39;message&#39;: ...,</span><br><span class="line">    &#39;close&#39;: ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(var eventName in wsHandlers) &#123;</span><br><span class="line">    ws.addEventListener(eventName, wsHandlers[eventName]);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在上代码中，注册到 websocket 中的 open 和 message 事件特别重要。websocket收到<code>open</code>事件说明与janus服务器之间已经成功建立了连接，此时我们就可以将之前准备好的 <code>request</code> 发送出去了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">transactions[transaction] &#x3D; function()...;</span><br><span class="line">ws.send(JSON.stringify(request));</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>当websocket连接创建好后，<code>janus.js</code>首先在transctons中创建一个新的<code>transaction</code>，然后将之前准备好的request发送给服务器。</p><blockquote><p>这里需要注意的是transaction，它表示一个事务或称之为上下文，当一件事儿由多个步骤多阶段组合完成时，我们一般都使用这种设计方案。</p></blockquote><p>服务端收到消息后进行逻辑处理，之后通过上面建立的连接将处理结果返回给<code>janus.js</code>，此时就会触发我们上面注册的<code>message</code>事件。在message事件中，对所有接收到的服务端的消息都由<code>handleEvent</code>函数进行处理。对于该函数我们后面还会做详细介绍，这里就不过多讲解了。</p><p>至此，<code>createSession</code> 函数的主要作用我们就分析完了，而<code>destorySession</code>是<code>createSession</code>的反函数，用于销毁<code>createSession</code>创建的资源，大家自己去看代码就好了，我这里不再做过多描述了。</p><p>接下来我们来看一下<code>janus.js</code>是如何处理从服务端接收到的信令的。</p><h2 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h2><p>上面讲解<code>Session</code>的创建时，我已经向你介绍了janus默认提供了两种传输信令的接口，即<code>websocket</code>处<code>http</code>。janus会根所用户访问地址的协议头来自动判断使用那种协议进行信令的传输。</p><p>对于服务端来讲，这两种接口的实现是在<code>janus</code>源码目录下的 <code>transports</code> 目录下，对应的实现文件为janus_websockets.c和janus_http.c文件，通过文件名我们也可以知道他们分别是websocket和http接口的实现了。</p><blockquote><p>当然janus不光支持这两种接口，它还支持好几种接口，但需要你手工配置。如果你不进行任何配置的话，它默认只支持这两种接口。</p></blockquote><p>下面是<code>janus</code>信令处理的简化架构图，我们通过这张图先从整体上了解一下janus是如何处理信令的。</p><p><img data-src="https://cdn.avdancedu.com/image/article/janus_js/janus_command.jpg" alt=""></p><p>上图将janus分成了两大部分，服务端和客户端。我们分别来介绍一下，首先来看看服务端的处理过程。</p><h3 id="服务端接收消息"><a href="#服务端接收消息" class="headerlink" title="服务端接收消息"></a>服务端接收消息</h3><p>通过上图我们可以看到，janus服务端的信令处理是由<code>transports</code>完成的，<code>transports</code>中包括很多插件，图中展示的<code>websocket</code>和<code>http</code>就是其中的两个。</p><p>这两个<code>transport</code>插件是在janus服务启动时加载起来的。以websocket插件为例，当该插件被加载后，websocket服务随即开启。此时，<code>janus.js</code>(JS客户端）就可以向该websocket服务发送消息了，同时<code>janus.js</code>也可以通过websocket连接接收来自服务端的信息。</p><p>当在服务端通过<code>websocket</code>收到消息后，最终会调用janus_websockets.c中的<code>janus_websockets_common_callback</code>方法将收到的消息传给janus core。janus core 收到消息后再根据消息类型做相应的处理。关于这块的逻辑我们先暂时放一放，待以有时间了我再说细介绍。</p><p>接下来我们再看客户端<code>janus.js</code>是如何处理的。</p><h3 id="客户端接收消息"><a href="#客户端接收消息" class="headerlink" title="客户端接收消息"></a>客户端接收消息</h3><p>客户端是如何处理消息的呢？我们还是从<code>Session</code>创建之后讲起。在<code>创建Session</code>一节中我已经介绍了，janus在websocket上侦听了<code>message</code>事件，每当websocket收到服务端发来的消息时，就会触发该事件。</p><p><code>janus.js</code>对该事件的处理方法是也比较简单，不管三七二十一直接将event中带来的数据交收<code>handleEvent</code>处理。<code>handleEvent</code>又是如何做的呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function handleEvent(json, skipTimeout) &#123;</span><br><span class="line">  ...</span><br><span class="line">  if(json[&quot;janus&quot;] &#x3D;&#x3D;&#x3D; &quot;keepalive&quot;) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; else if(json[&quot;janus&quot;] &#x3D;&#x3D;&#x3D; &quot;ack&quot;) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; else if(json[&quot;janus&quot;] &#x3D;&#x3D;&#x3D; &quot;success&quot;) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; else if(...</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>handleEvent</code>处理逻辑就如上面所示，对消息类型做判断，根据不同的类型做不同的处理。它能处理的消息包括以下几种:</p><ul><li>keepalive，心跳消息。</li><li>ack，确认消息。也就是说之前客户端发送了一个信令给服务端，服务端收到之后给客户端回了一个<code>ack</code>，确认服务端已经收到该消息了。</li><li>success，消息处理成功。该消息与 ack 消息是类似的，当服务器完成了客户端的命令后会返回该消息。</li><li>trickle，收集<code>候选者</code>用的消息。里边存放着 candidate，janus.js收到该消息后，需要将Candidate解析出来。</li><li>webrtcup，表示一个peer上线了，此时要找到以应的业务插件（plugin）做业务处理。</li><li>hangup，用户挂断，找到对应的plugin，进行挂断操作。</li><li>detached，某个插件要求与Janus Core之间断开连接。</li><li>media，开始或停信媒体流。</li><li>slowlink，限流？</li><li>error，错误消息</li><li>event，插件发磅的事件消息。</li><li>timeout，超时。</li></ul><p>对于janus.js来讲，上面这些消息有些是不需要再做处理的，有些是需要修改状态的，还有一些是与业务插件有关的，需要交由<code>pluginHandle</code>做进一步处理。 关于<code>pluginHandle</code>后面我们再做介绍。</p><p>以上就是janus客户端对从服务端接收到的消息的处理过程。当然在你阅读代码时还会看到<code>eventHandler</code>函数，这个函数是对handleEvent函数简单的封装，用在http接口上。由于websocket接口是长连接，所以直接使用的handleEvent函数，我们清楚这两个函数的联系与区别就OK了。</p><h3 id="客户端发送消息"><a href="#客户端发送消息" class="headerlink" title="客户端发送消息"></a>客户端发送消息</h3><p>上面我们主要介绍了从服务端来的消息janus是如何处理的，那客户端是如何发送消息的呢？</p><p>在<code>janus.js</code>中为上层应用封装了一个发送消息的方法，即<code>config.send()</code>。这个函数实际调用的是janus的<code>sendMessage</code>方法。我们来看一下它的大体实现吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function sendMessage(handleId, callbacks) &#123;</span><br><span class="line">    ...</span><br><span class="line">    var pluginHandle &#x3D; pluginHandles[handleId];</span><br><span class="line">    ...</span><br><span class="line">    var message &#x3D; callbacks.message;</span><br><span class="line">    ...</span><br><span class="line">    if(pluginHandle.token)</span><br><span class="line">        request[&quot;token&quot;] &#x3D; pluginHandle.token;</span><br><span class="line">    ...</span><br><span class="line">    var request &#x3D; &#123; &quot;janus&quot;: &quot;message&quot;, &quot;body&quot;: message, &quot;transaction&quot;: transaction &#125;;</span><br><span class="line">    ...</span><br><span class="line">    if(websockets)&#123;</span><br><span class="line">        ws.send(JSON.stringify(request));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以发现，在<code>sendMessage</code>中主要是构造<code>request</code>对象，然后将构造好的<code>request</code>消息通过<code>websocket</code>发送出去。</p><p>消息发送给janus服务器，服务器处理好后又会给客户端返回消息。消息返回到客户端后，后会触发websocket的<code>message</code>事件，这样就又回到了我们上面介绍的<code>handleEvent</code>处理函数。</p><h2 id="Plugin相关"><a href="#Plugin相关" class="headerlink" title="Plugin相关"></a>Plugin相关</h2><p>在<code>janus.js</code>中，<code>Plugin</code>相关函数的主要作用是，在客户端创建一个<code>pluginHandle</code>对象，并让该对象与janus服务端的某个插件关联。</p><p>所谓的关联就是在<code>pluginHandle</code>对象中保存着可以访问janus服务端插件的信息。该对象中存放着很多的信息，如session、plugin、webrtc等信息。下面我抽取了一些比较关键的信息，我们来详细分析一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">session : that,</span><br><span class="line">plugin : plugin,</span><br><span class="line">...</span><br><span class="line">token : handleToken,</span><br><span class="line">detached : false,</span><br><span class="line">webrtcStuff : &#123;</span><br><span class="line">    ...</span><br><span class="line">    mySdp : null,</span><br><span class="line">    mediaConstraints : null,</span><br><span class="line">    pc : null,</span><br><span class="line">    trickle : true,</span><br><span class="line">    iceDone : false,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面的字段就是<code>pluginHandle</code>对象的一些重要信息，在这些信息中包括了两在部分，基础信息部分和WebRTC信息部分。</p><p>首先我们看一下基础信息。session中保存的是<code>janus</code>核心类对象；plugin指明我们要与服务端那个个插件建立联接，例如<code>vidoeroom</code>插件；token用于安全访问；detached表明是否已经与服务端对应的<code>plugin</code>建立了联系。</p><p>接下来<code>webrtcStuff</code>域是与webrtc相关的参数。mySdp中保存的是本地SDP信息；mediaConstrains存放用于采集音视频数据的限制参数；pc表示PeerConnection；trickle指明在使用WebRTC时是否使用<code>trickle</code>机制；iceDone表明是否ICE建立成功了。</p><p>该对象中的内容是由<code>createHandle</code>函数创建和填充的，下面我们就来看一下<code>createHandle</code>函数做了哪些事儿？</p><p>在该函数中，它首先构造<code>request</code>对象，该对象包括以下几个信息：</p><ul><li>janus，表示信令类型， 在<code>createHandle</code>函数中，该域填的内容为<code>attach</code>，表示与某个<code>plugin</code> 进行绑定。</li><li>plugin，指明要绑定的具体<code>plugin</code>。<code>janus.plugin.videoroom</code></li><li>opaque_id，一个唯一的ID。</li><li>transaction，表示一个事务ID。</li><li>token，用于与服务器连接的合法标识</li><li>apisecret，API密码。</li><li>sessionID，session的唯一标识。</li></ul><p><code>request</code>对象创建好后，通过websocket发送给服务端，这样就在客户端与服务端的plugin插件建立了联接。</p><p>除了创建<code>request</code>对象外，该函数还创建了一个transaction对象，并将它存放在 <code>transactions</code> 数组中(<code>transactions[transaction]</code>)。</p><p>实际上 <code>transaction</code> 是一个函数，该函数中会创建一个<code>pluginHandle</code>对象，<code>pluginHandle</code>创建好后，也会被保存起来放到<code>pluginHandles</code>里以备后面使用。</p><p>除了<code>createHandle</code>函数之外，在janus.js中还有<code>destoryHandle</code>函数，它是<code>createHandle</code>的反函数，用于做释放操作。</p><p>以上就是janus.js中处理Plugin相关的函数。</p><h2 id="Webrtc相关"><a href="#Webrtc相关" class="headerlink" title="Webrtc相关"></a>Webrtc相关</h2><p>在<code>janus.js</code>中WebRTC相关的方法是最多的，也是最为重要的。其中尤以<code>prepareWebRTC</code>最为重要。下面我们就来详细介绍一下这个函数。</p><p>这个函数的作用是什么呢？说来起它还是蛮复杂的，我们来一项一项来介绍。一、它要过浏览器采集音视频数据，以便可以将数据上传给远端；二要与按照WebRTC的规规范进行媒体协商；三协商成功后要与远端建立连接；最后把采集的数据压缩编码后传到远端；</p><p>这个函数代码量非常大，我抽取了函数中重要的逻辑，这样更有利于我们撑握整个函数的流程脉络。代码整理如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if(isAudioSendEnabled(media) || isVideoSendEnabled(media)) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;media为空，或者media.video不为屏幕，说明现在想采集视频数据</span><br><span class="line">    if(!media || media.video !&#x3D;&#x3D; &#39;screen&#39;) &#123;</span><br><span class="line">        &#x2F;&#x2F;遍历每个设备</span><br><span class="line">        navigator.mediaDevices.enumerateDevices().then( function(devices) &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;如果是音频输入设备</span><br><span class="line">            var audioExist &#x3D; devices.some(function(device) &#123;</span><br><span class="line">                                return device.kind &#x3D;&#x3D;&#x3D; &#39;audioinput&#39;;</span><br><span class="line">                            &#125;),</span><br><span class="line">            &#x2F;&#x2F;如果是视频输入设置</span><br><span class="line">            videoExist &#x3D; isScreenSendEnabled(media) || devices.some(function(device) &#123;</span><br><span class="line">                                return device.kind &#x3D;&#x3D;&#x3D; &#39;videoinput&#39;;</span><br><span class="line">                            &#125;);</span><br><span class="line">           ...</span><br><span class="line">           &#x2F;&#x2F;设置采集数据的限制条件</span><br><span class="line">           var gumConstraints &#x3D; &#123;</span><br><span class="line">              audio: (audioExist &amp;&amp; !media.keepAudio) ? audioSupport : false,</span><br><span class="line">              video: (videoExist &amp;&amp; !media.keepVideo) ? videoSupport : false</span><br><span class="line">           &#125;;</span><br><span class="line"></span><br><span class="line">           ...</span><br><span class="line">           &#x2F;&#x2F;采集数据</span><br><span class="line">           navigator.mediaDevices.getUserMedia(gumConstraints)</span><br><span class="line">             .then(function(stream) &#123;</span><br><span class="line">               ...</span><br><span class="line">               &#x2F;&#x2F;</span><br><span class="line">               streamsDone(handleId, jsep, media, callbacks, stream);</span><br><span class="line">             &#125;).catch(function(error) &#123;...&#125;);</span><br><span class="line"></span><br><span class="line">        &#125;).catch(...);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码的梳理我们可以看到<code>prepareWebrtc</code>函数首先遍历所有设备，找出可用的设备，之外调用`getUserMedia函数去采集音视频数据。之后像媒体协商、Candidate的收集都在 streamDone 函数中完成。</p><p>接下来我们继续分析<code>streamsDone</code> 函数。下面是<code>streamsDone</code>函数的主要脉络代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function streamsDone(handleId, jsep, media, callbacks, stream) &#123;</span><br><span class="line">    ...</span><br><span class="line">    var config &#x3D; pluginHandle.webrtcStuff;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;创建PeerConnection</span><br><span class="line">    f(!config.pc) &#123;</span><br><span class="line">        var pc_config &#x3D; &#123;&quot;iceServers&quot;: iceServers, &quot;iceTransportPolicy&quot;: iceTransportPolicy, &quot;bundlePolicy&quot;: bundlePolicy&#125;;</span><br><span class="line">        ...</span><br><span class="line">        var pc_constraints &#x3D; &#123;</span><br><span class="line">            &quot;optional&quot;: [&#123;&quot;DtlsSrtpKeyAgreement&quot;: true&#125;]</span><br><span class="line">        &#125;;</span><br><span class="line">        ...</span><br><span class="line">        config.pc &#x3D; new RTCPeerConnection(pc_config, pc_constraints);</span><br><span class="line">        config.pc.oniceconnectionstatechange &#x3D; ...;</span><br><span class="line">        config.pc.onicecandidate &#x3D; ...;</span><br><span class="line">        config.pc.ontrack &#x3D; ...;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将本地track添加到流中</span><br><span class="line">    if(addTracks &amp;&amp; stream) &#123;</span><br><span class="line">        ...</span><br><span class="line">        config.pc.addTrack(track, stream);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建offer进行媒体协商</span><br><span class="line">    if(!jsep) &#123;</span><br><span class="line">        createOffer(handleId, media, callbacks);</span><br><span class="line">    &#125;else&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该函数中首先会根据限制条件创建一个<code>PeerConnection</code>。PeerConnection简称PC，它是浏览器下使用WebRTC的核心，想了解这块知识的同学可以看一下我的课程<a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门与实战》</a>，这里我就不过多讲解这部分内容了。</p><p>PC创建好后，需要将之前从<code>prepareWebrtc</code>中获取的本地音视频轨添加到PC中，为媒体协商做好准备。最后调用createOffer函数生成媒体协商中的<code>Offer</code>SDP与远端交换从成完成媒体协商。</p><p>现在你应该了解<code>streamsDone</code>函数的作用了吧？同时也应该清楚<code>prepareWebrtc</code>函数是干什么的了。</p><p>当我们将<code>prepareWebrtc</code>函数的功能搞清楚之后，对于其它的WebRTC相关API就比较容易理解了，由于篇幅的原因我就不在这里一一做介绍了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上面我对janus.js文件做了全面的剖析，通过本文你应该知道<code>janus.js</code>的API可以分成四大类，分别是Session相关，信令相关，Plugin相关以及WebRTC相关的API。同时你也应该清楚，janus中的Session表示的是客户端与服务端之间的网络连接；客户端与服务器之间的信令是如何交互的，以及包括了哪些信令；<code>pluginHandle</code>的作用是用来保存访问远端插件的信息用的，同时它也保存了操作WebRTC相关的信息；而WebRTC相关的API是janus.js中最关键，最为复杂的。尤其是<code>prepareWebrtc</code>函数是最核心的API。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://avdancedu.com/18fc7df1/" target="_blank" rel="noopener">《js类的探究》</a>文中介绍了ES5与ES6之间的区别</li><li><a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门与实战课程》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> WebRTC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> janus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音视频已强势崛起，我们该如何快速入门音视频技术？</title>
      <link href="/811929dc/"/>
      <url>/811929dc/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者： 李超 音视频直播技术专家<br>曾在 跟谁学 负责直播平台技术团队的管理工作；在 新东方集团 任职音视频技术专家；<br>在音视频会议行业工作6年，在线教育行业工作4年，一直聚焦在多人音视频实时互动领域。</p></blockquote><p>最近经常遇到一些同学问我如何学习音视频，怎样才能快速上手？还有一些对音视频不了解的同学问我该不该学习音视频？作为一名音视频行业的10年老兵，我有一些思考分享给大家，希望能对你有所帮助。</p><a id="more"></a><h2 id="大背景"><a href="#大背景" class="headerlink" title="大背景"></a>大背景</h2><p><img data-src="https://img1.sycdn.imooc.com/5e84c07f0001c21806890390.jpg" alt=""></p><p>2020年真的是一个多灾、多难的年份，冠状病毒的爆发使得本该举国欢庆的春节变得尤为沉闷。不能走亲，不能访友，除了呆在家里，那儿也不能去。正如张文宏大夫向我们劝解的，我们要将病毒给<code>闷死</code>。</p><p>大家都盼着疫情可以赶紧过去，早点恢复正常的生活。但从目前的情况看，短时间内这个疫情是很难结束的。这不刚从中国消停了一阵，又跑到海外大爆发了，谁知道它会不会又转回来呢？</p><p>可我们还得生活！还得工作！还要学习！</p><h2 id="好时代"><a href="#好时代" class="headerlink" title="好时代"></a>好时代</h2><p><img data-src="https://img1.sycdn.imooc.com/5e84c080000173fe12000437.jpg" alt=""></p><p>幸运的是我们生活在一个好时代，科技在这几十年得到了迅猛的发展。在疫情肆虐的当下，我们可以通过音视频会议进行远程办公；我们还有在线教育系统，对于大多数学生来说，完全可以在家进行在线学习。</p><p>从某个角度看，这次疫情虽然导致很多行业处于崩溃边缘，但也催生了新的行业发展，其中音视频会议和在线教育就是因<code>疫</code>而起的行业。在疫情短时间内难以结束的情况下，音视频会议和在线教育的重要性马上体现了出来，新的沟通方式和教育方式被越来越多的人所认知，所接纳。</p><p>甚至我们可以判定，在线教育行业和音视频会议行业会在今年崛起，并在未来十年得到迅猛发展。</p><p>目前，各大巨头公司（如阿里、腾讯、今日头条，新东方等），纷纷在这两个方向上谋篇布局，进行了大量的投资，笼络技术人才，也可以间接佐证这个判断了。</p><h2 id="大趋势"><a href="#大趋势" class="headerlink" title="大趋势"></a>大趋势</h2><p><img data-src="https://img1.sycdn.imooc.com/5e84c0820001ade512400564.jpg" alt=""></p><p>从未来的大趋势来看，随着5G时代的到来，音视频慢慢变成人们日常生活中的必须品。除了在线教育、音视频会议、即时通讯这些必须使用音视频技术的产品外，其它的产品也需要加入音频、视频元素。比如说将现在的网站注册与登陆的图文方式全部改为语音方式是否更加安全？相信随着音视频技术的普及，更加有创意的产品会如雨后春笋般孕育而生。</p><p>目前，音视频技术从之前的<strong>象牙塔</strong>逐渐走向<strong>百姓家</strong>已是不争的事实。正是因为这样一个大的趋势，现在除了各大厂之外，其它一些小厂也开始寻找音视频人才。一名稍好点的音视频人才现在可能会有3-4家公司抢着要、挣着要。</p><p>对音视频人才的需求从小众变成了大众，这更多的是大家对未来市场预期的结果。做个不恰当的比喻，3G/4G的出现，促成了移动互联网10年繁荣。而5G的出现，也会促成至少10年音视频行业的繁荣。</p><p><strong>除了5G的到来可以让音视频得到更广范的应用外，音视频技术在未来还有更重要的作用</strong>。事实上，在人类可以识别人信息中，音视频包含的信息是最丰富的，但人类并没有很好的将它们利用起来。</p><p>究其原因，是因为这些信息都是非结构化的数据，而人类善长的是处理结构化数据（比如数据库）。而对于这些非结构化的数据却无从下手的，所以这些音视频数据都被白白浪费掉了。</p><p>但随着计算机视觉、人工智能的发展，人们开始撑握了如何将音视频这类非结构化数据转化为结构化数据的方法。一旦我们将音视频数据转为结构化数据后，我们就可以利用现有的技术（如搜索引擎、大数据，数据挖掘等）对这些数据进行各种分析了，这个价值是不是更加惊人呢？而这一切的基础都是音视频技术。</p><p>所以，音视频研发的未来是极为广阔的。目前可以说是学习音视频的最佳时机，<strong>及早的加入音视频研发的队伍，才能使自己在未来的职场上更有作为</strong>。</p><h2 id="有钱景"><a href="#有钱景" class="headerlink" title="有钱景"></a>有钱景</h2><p><img data-src="https://img2.sycdn.imooc.com/5e84c0830001d45512000437.jpg" alt=""></p><p>正如我上面所说的，各大厂为了争夺未来，抢占先机，不惜重金笼络人才。通过招聘市场我们可以了解到，一名合格的音视频开发人员，少则年薪 30 万起，多则可以达 100万以上。</p><p>出现这种情况的原因主要有两个，一是音视频方面的人才不好培养，二是现有的优秀人才太少了。</p><p>从技术上来说，音视频从业者分成两个方向，一是搞算法的，另一个是搞工程的。搞音视频算法的这类人非常少，需要有深的数学能力和算法背景。相对来说，学习成本高，一般企业不需要，也养不起。这类人一般都会选择去大公司，薪水百万都是Low的。这些人一般只专注在一个领域上，因此就业面也窄。</p><p>搞工程的人相对多一些，他们有扎实的理论基础，很强的技术功底，对音频/视频都非常熟悉。这类人才工资要比同级别的其它开发人员薪资高20%以上。</p><p>因此，搞音视频技术的开发人员钱景还是非常乐观的。而且随着时间的推移，在未来几年音视频人才会更加炙手可热。</p><h2 id="音视频好学吗？"><a href="#音视频好学吗？" class="headerlink" title="音视频好学吗？"></a>音视频好学吗？</h2><p><img data-src="https://img1.sycdn.imooc.com/5e84c0850001c42712400565.jpg" alt=""></p><p>说句实话，音视频自学起来困难重重，学习成本非常高，且效率低。主要有两方面的原因，一是音视频知识庞杂，通俗易懂的资料非常少；另一方面，网上充斥着大量的错误信息，使得很多初学者掉到坑里就爬不出来了。</p><p>我来举个例子，按照传统的音视频学习方法，学习音视频你首先要阅读大量的音视频规范/协议文档（如H264、MP4/FLV、RTP/RTCP等）。这些文档中的内容基本都以<strong>位</strong>为单位的，即每个二进制位的变化都代表不同的含义，这种文档极其枯燥，很难阅读。</p><p>在对文档熟悉的前提下，再进行代码的开发难度就“更上一层楼”了。这时你会发现，如果你对 C/C++ 使用不熟练，没有专门进行过训练的话，你就进入了炼狱般的状况，那是一种折磨。</p><p>好在现在有FFMPG、WebRTC 等开源库，大大降低了研发成本。但即使这样，对于小白同学来说学习音视频依然是十分困难的。</p><h2 id="小白如何学习音视频？"><a href="#小白如何学习音视频？" class="headerlink" title="小白如何学习音视频？"></a>小白如何学习音视频？</h2><p><img data-src="https://img1.sycdn.imooc.com/5e84c0850001599610240576.jpg" alt=""></p><p>如上面所讲，音视频的入门难度还是蛮大的，我们该如何更快的入门呢？</p><p>我觉得最好的方式有非常好的课程，可以循序渐近，有条理、系统的学习。当然能有老师指导，遇到问题时老师能及时给予解答就更加锦上添花了。这样既可以快速入门，又可以系统的学习音视频知识，可以说这是最佳途径了。</p><p>对于能力强的同学也可以自学，但相对来说，这个时间成本就太高了。遇到一个坑卡几天是很正常的。网上音视频资料那么多坑，你想想要经历多长时间你才能真正学会它呢？即使你历尽千辛入门之后，你会发现离用人单位的要求还差着十万八千里呢。</p><p>对于各大厂来说，他们要招聘的人才既要有非常扎实的基础知识，又需要有一定的工程经验；如果你在学习的过程中没有实际做一些项目就很难达到它们的要求。</p><p>正是基于这样的考虑，我推出了一系列音视频的课程。这些课程中既有适合小白同学入门的课程（如<a href="https://coding.imooc.com/class/415.html?mc_marking=458ad0334bdc050a302667f903757fa0&mc_channel=shouji" target="_blank" rel="noopener">音视频小白系统入门</a>）, 又有进阶的课程（如<a href="https://coding.imooc.com/class/279.html?mc_marking=59c321c0417e144904c49c366f94dd57&mc_channel=shouji" target="_blank" rel="noopener">FFmpeg音视频核心技术精讲与实战</a>）。</p><p>其中与ffmpeg相关的课程是<a href="https://coding.imooc.com/class/415.html?mc_marking=458ad0334bdc050a302667f903757fa0&mc_channel=shouji" target="_blank" rel="noopener">音视频小白系统入门</a>和<a href="https://coding.imooc.com/class/279.html?mc_marking=59c321c0417e144904c49c366f94dd57&mc_channel=shouji" target="_blank" rel="noopener">FFmpeg音视频核心技术精讲与实战</a>。与 WebRTC 相关的课程是<a href="https://coding.imooc.com/class/329.html?mc_marking=59909dfb407cd07d4f3998dbc2d45c49&mc_channel=shouji" target="_blank" rel="noopener">WebRTC实时互动直播技术入门与实战</a>和 <a href="https://coding.imooc.com/class/387.html?mc_marking=6ebf81516468954587f53973c3c1789a&mc_channel=shouji" target="_blank" rel="noopener">WebRTC流媒体服务器设计与开发</a>。</p><p>如果你想学习音视频基础知识，音视频处理、编辑、特效相关的内容就学习ffmpeg的系列课程。如果你想学习音视频实时通讯（如音视频会议、在线教育）就学习WebRTC相关的课程。</p><h2 id="入门音视频要学习哪些内容呢？"><a href="#入门音视频要学习哪些内容呢？" class="headerlink" title="入门音视频要学习哪些内容呢？"></a><a href="https://coding.imooc.com/class/415.html?mc_marking=458ad0334bdc050a302667f903757fa0&mc_channel=shouji" target="_blank" rel="noopener">入门音视频要学习哪些内容呢？</a></h2><p><img data-src="https://img1.sycdn.imooc.com/5e84c086000163a706360300.jpg" alt=""></p><p>这里我简单列举一下入门音视频都要学哪些知识。对于已经学习了一些音视频知识而不知道自己目前水平的同学也可以作为一个参考，看看自己是否达到了入门水平。</p><ul><li>ffmpeg在不同系统中的安装与简单裁剪</li><li>音频基础知识，如频率、采样大小和通道数等</li><li>音频的压缩原理</li><li>如何从不同的设备上采集音频数据</li><li>如何对音频进行不同的编解码</li><li>视频的基础知识</li><li>H264编码原理</li><li>如何从不同设备上采集视频数据</li><li>熟悉YUV的一些常见格式（YUV420、NV21，YV12的不同）</li><li>如何将YUV数据编码为H264/H265、VP8/VP9等</li><li>FLV/RTMP/HLS/MP4协议要十分清楚<br>……</li></ul><p>从上面的列表中你可能看到，要入门音视频要学的知识还是不少的。尤其是音视频的基础原理是最为重要的，否则你去面试人家问你为什么会产生花屏，为什么会产生卡顿，如何才能秒开这些简单的问题你都无法回答上来。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总之，音视频已经强势崛起，相信未来的十年一定是音视频的十年。并且将音视频技术与计算机视觉和人工智能结合将引领未来二十年。</p><p>现在正是学习音视技术的最佳时机，大家一定要把握住机会，跟上时代的步伐，让自己可以在未来大有作为。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://coding.imooc.com/class/415.html?mc_marking=458ad0334bdc050a302667f903757fa0&mc_channel=shouji" target="_blank" rel="noopener">音视频小白系统入门</a></li><li><a href="https://coding.imooc.com/class/279.html?mc_marking=59c321c0417e144904c49c366f94dd57&mc_channel=shouji" target="_blank" rel="noopener">FFmpeg音视频核心技术精讲与实战</a></li><li><a href="https://coding.imooc.com/class/329.html?mc_marking=59909dfb407cd07d4f3998dbc2d45c49&mc_channel=shouji" target="_blank" rel="noopener">WebRTC实时互动直播技术入门与实战</a></li><li><a href="https://coding.imooc.com/class/387.html?mc_marking=6ebf81516468954587f53973c3c1789a&mc_channel=shouji" target="_blank" rel="noopener">WebRTC流媒体服务器设计与开发</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 音视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript入门</title>
      <link href="/48922786/"/>
      <url>/48922786/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/typescript/typescript.jpg" alt="TypeScript"><br>我们要学习一门新知识，首先要了解一些新知识的历史。<code>TypeScript</code> 是微软开发的，它的出现是为了解决 <code>JavaScript</code> 没有类型检查的弊端。因此，<code>TypeScript</code>并不是一门新语言，它的作用就是帮<code>JavaScript</code>检查数据类型是否正确，所以称它为<code>JavaScript</code>的一个<code>超集</code>是更贴切的。</p><p>有很多同学对 <code>TypeScript</code> 产生疑惑，他们会问 <code>TypeScript</code> 可以在浏览器上运行吗？</p><a id="more"></a><p>虽然<code>TypeScript</code>是<code>JavaScript</code>的一个<code>超集</code>，但由于它要进行类型检查，所以就与 JavaScript 的语法有一些不同了，因此 TypeScript 编写的程序是无法直接运行在浏览器上的。</p><h2 id="TypeScript-工作原理"><a href="#TypeScript-工作原理" class="headerlink" title="TypeScript 工作原理"></a>TypeScript 工作原理</h2><p>在讲解 <code>TypeScript</code> 工作原理之前，有一句话是你必须清楚且要印在脑子里的: <strong>在浏览器上，只能运行 JavaScript 脚本</strong>。</p><p>既然浏览器里只能运行<code>JavaScript</code>，那<code>TypeScript</code>具体又做了什么事儿呢？下面我就向你解释一下<code>TypeScript</code>都做了哪些事儿。</p><p>学习过编译原理的同学都清楚，<strong>类型检查</strong>就是<strong>语法分析</strong>，它属于编译器的范筹。TypeScript官网说: <strong>“TypeScrpt是JavaScript的超集，可以进行JavaScript类型检查。”</strong> 表明<code>TypeScript</code>为<code>JavaScript</code>增加了<strong>类型语法</strong>，并且它还有一个<strong>编译器</strong>，可以将用<code>TypeScript</code>语法编写的程序（.ts文件)，<strong>翻译成</strong> <code>JavaScript</code> 脚本语言。</p><p>因此，<code>TypeScript</code>的使用步骤一定是这样的: 首先用 <code>TypeScript</code> 语法编写程序；然后<strong>编译</strong>，输出<code>JavaScript</code>脚本；最终在浏览器中引用生成的 JavaScript 脚本这样一个过程。</p><p>实际情况也确实如此，在TypeScript的官网上你可以找到，TypeScript 有一个编译工具称为 <code>tsc</code>，即 <code>t</code>(ype) <code>s</code>(cript) <code>c</code>(ompiler)的缩写 。</p><h2 id="JavaScript的最大问题"><a href="#JavaScript的最大问题" class="headerlink" title="JavaScript的最大问题"></a>JavaScript的最大问题</h2><p>使用过其它面向对象语言的同学们再使用JavaScript开发时，都会觉得特别<code>难受</code>，因为JavaScript无法进行类型检查。对于Javascript语法来说，你传给它什么类型的数据都可以，这样虽然看似很<code>很好</code>，但一旦你将数据传错了，你得到的结果就是错误的。当错误出现时，没有任何的提示，光凭我们肉眼去查找错误实在是太费力了，这就是JavaScript的最大问题。</p><p>我们来看一个最简单的JavaScript例子你应该就清楚了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function func(msg)&#123;</span><br><span class="line">    console.log(&quot;the message is :&quot; + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码是一段最简单的JS代码，它需要一个字符串参数。但由于JavaScript并没有对参数的类型做限制，所以你在调用这个函数时，可以给他传任意的值。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func(123);</span><br><span class="line">func(&#39;this is my book!&#39;);</span><br><span class="line">func(func);</span><br></pre></td></tr></table></figure><p>我的本意是只有第二种调用<code>func</code>的方式才是正确的，但在JavaScript中上面这几种调用<code>func</code>函数的方法都是正确的。在我们实际工作中，我们写了很长的代码后，传入了一个错误的值时JavaScript就无法为我们检测出那里出错了，这是最可怕的。</p><p>这也是为什么<code>TypeScript</code>逐渐受到大家喜欢的原因。</p><h2 id="一个最简单的-TypeScript-程序"><a href="#一个最简单的-TypeScript-程序" class="headerlink" title="一个最简单的 TypeScript 程序"></a>一个最简单的 TypeScript 程序</h2><p>下面我们就来写一个最简单的 TypeScript程序，了解一下整个使用过程。咱们还是以 Helloworld 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function hello(person: string) &#123;</span><br><span class="line">  return &#39;Hello , &#39; + person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let user&#x3D;&#39;xxx&#39;</span><br><span class="line">console.log(hello(user));</span><br></pre></td></tr></table></figure><p>上面就是一个简单的 TypeScript脚本，有了这个脚本后我们需要先对其进行编译，编译执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc hello.ts</span><br></pre></td></tr></table></figure><p>编译出 JavaScript 脚本后，通过 HTML5 引用一下就好了，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;user typescript&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;.&#x2F;hellots.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br></pre></td></tr></table></figure><p>至此，一个 TypeScript的简单使用过程就完成了，还是蛮简单的对吧！</p><h2 id="TS-调用JS"><a href="#TS-调用JS" class="headerlink" title="TS 调用JS"></a>TS 调用JS</h2><p>我们在使用TS开发时最常见的一个问题是如何通过 TS 调用 JS。产生该问题的根本原因是一些著名的 JS 库(如VUE）的TS版本还没有开发出来，但我们的项目中又必须使用他们，因此就产生了我前面所说的TS 库要调用 JS 库的情况。</p><p>我们前面也讲了 TS 本来就是 JS 的一个<code>超集</code>，因此它是有办法调用JS库的。从原理上我们可以证明这一点，因为TS程序最终要经过编译生成JS脚本程序后才能被浏览器执行，因此只要在浏览器上引入它需要的 JS 库，经编译后的 TS 程序就可以与其它的JS库相互调用。</p><p>按照上面的描述好像TS 调JS是很简单的事儿，那问题在哪儿呢？其实问题在于如果我们自己写的 TS 程序调用了其它第三方 JS 库，那么正常情况下 <code>tsc</code> 编译我们的 <code>ts</code> 程序时就会报错。所以实际的问题应该是，我们编写的TS程序在调用第三方JS库时，如何可以顺利编译通过呢？</p><p>我们在网上可以找到以下几种方案，第一种是将引用到的 JS 库直接翻译成 TS 库。很多同学看到这句话会<code>嗤之以鼻</code>，这明显就是行不通的方案。不过这种方案虽然难度很大，但总归还是一种方案不是；第二种是让<code>tsc</code>编译器不进行类型检查，那也就失去了 <code>TS</code> 的意义，所以这种方法也不是好办法；第三种是为 JS 库增加声名函数，这种方式既可以让<code>tsc</code>在编译时顺利通过，又同时可以检查我们写的代码是否有问题。</p><p>所以综上所述，第三种方案是最优的方案。</p><p>接下来我就来重点讲解一下如何通过第三种方案实现<code>TS</code>调用第三方<code>JS库</code>。首先我们先来创建一个JS库<code>test.js</code>，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function showmsg(msg)&#123;</span><br><span class="line">    console.log(&quot;the msg is :&quot; + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码非常简单，只实现了一个函数。该函数有一个参数<code>msg</code>，当该函数被调用时，输出传入的参数值。</p><p>接下来我们来看一下在<code>TS</code>中如何调用JS中的方法。为了使 TS 可以调用JS的方法，我们需要写一个与<code>JS</code>文件名对应的<code>.d.ts</code>文件。对于我们上面的<code>test.js</code>则需要有一个<code>test.d.ts</code>与之对应。</p><p>编写<code>.d.ts</code>文件也很简单，对于test.js来说，它的<code>.d.ts</code>文件内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare function showmsg( msg: string) : void;</span><br></pre></td></tr></table></figure><p>只需要这样一句就可以了。实际上，它就是为test.js文件中的showmsg函数定个声名。然后我们在使用它的TS文件中引用这个<code>.d.ts</code>文件就好了。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;reference path &#x3D; &quot;.&#x2F;test.d.ts&quot; &#x2F;&gt;</span><br><span class="line">function doSomeThing()&#123;</span><br><span class="line">    showmsg(&#39;ts&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSomeThing();</span><br></pre></td></tr></table></figure><p>在TS文件中引用<code>.d.ts</code>文件的方法是，在文件的开头写上 <code>/// &lt;reference path=&quot;./test.d.ts&quot; /&gt;</code> 即可。这样当我们使用<code>tsc</code>去编译<code>.ts</code>文件时就不会报错了。</p><p>当<code>tsc</code>编译好TS文件后，我们可以在HTML中引入生成的JS文件以及它所使用的JS库了。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt; test ts call js&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;script src&#x3D;&quot;.&#x2F;test.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">        &lt;script src&#x3D;&quot;.&#x2F;my.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>此时，在浏览器的<code>debugger</code>里就可以看到<code>the msg is :ts</code>这句话了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我向你介绍了<code>TypeScript</code>的基本工作原理，从中我们可能知道TypeScript解决了JavaScript最大的问题，即类型检测。但TypeScript并不是一门新语言，它也不会代替JavaScript，它只是JavaScript的一个超集而以。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多人实时互动之各WebRTC流媒体服务器比较</title>
      <link href="/947c722a/"/>
      <url>/947c722a/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/sfu/conference.jpg" alt="SUF"><br>随着网络基础设施的提高，音视频实时通信越来越成为人们日常生活和工作中必不可少的需求。2011年 WebRTC的出现，则更加速了这种需求变为现实的可能性。</p><p>熟悉 WebRTC 的同学应该都知道，WebRTC规范只定义了实时通信中客户端的行为，而没有规范服务端（包括哪些信令、数据如何流转）的行为。所以，你可以使用WebRTC库方便的实现 1:1 实时通信，但对于多人实时互动，光依靠 WebRTC库显然就无法完成要求了。</p><p>那我们该如何实现多人实时互动通信呢？</p><a id="more"></a><h2 id="WebRTC-流媒体服务器"><a href="#WebRTC-流媒体服务器" class="headerlink" title="WebRTC 流媒体服务器"></a>WebRTC 流媒体服务器</h2><p>要想实现多人的实时互动，如音视频会议、在线教育这类产品，我们必须使用 WebRTC + WebRTC流媒体服务器这种方案。</p><p>目前有很多比较有名的开源流媒体服务器，如 Janus、Medooze、Mediasoup、Licode(OWT)、Jitsi等等。这些流媒体服务器各有优缺点，下面我就对这几种流媒体服务器作下简要的介绍与比较。</p><p>通过本文，你将知道各 WebRTC 流媒体服务器的优缺点，并依俱它们的优缺点选择出更适合你的那款WebRTC流媒体服务器。</p><h3 id="Mediasoup"><a href="#Mediasoup" class="headerlink" title="Mediasoup"></a>Mediasoup</h3><p><img data-src="https://cdn.avdancedu.com/image/article/sfu/mediasoup.jpg" alt="mediasoup 整体结构"></p><p>上图是Mediasoup整体架构图，通过该图我们可以知道 Mediasoup 流媒体服务器是由 Nodejs 和 Mediasoup(C++) 两部分组成。</p><ul><li>Nodejs，负责 Mediasoup 的信令接收与业务管理。如创建/消毁房间，创建/关闭生产者，创建/关闭消费者等。</li><li>Mediasoup(C++)，这是一个单独的程序，但该程序无法直接启动。因为它在内部会判断是否是 Nodejs 将它启动起来了。只有在Nodejs 的 Mediasoup 管理模块加载之后，再将 Mediasoup(C++)启动起来，这样它才能正常工作。</li></ul><p>在众多的 WebRTC 流媒体服务器中，Mediasoup 可以说是性能最优秀的WebRTC流媒体服务器。它使用 C++ 作为开发语言，底层使用 libuv 处理 I/O 事件。</p><p>有很多人对 Nodejs 比较诟病，认为 Nodejs 提拱不了高性能的流媒体服务器。实际上，如果按照传输的 Nodejs 应用开发出的流媒体服务器肯定是不能胜任这项工作的。但对于 Mediasoup 来讲，它只不过使用 Nodejs 做 信令处理 及 业务的管理 工作，所以它的负担并不重。对性能要求高的是媒体数据流的转发工作，而这部分工作是由 Mediasoup(C++)部分实现的。Nodejs 与 Mediasoup之间通过管道进行通信。</p><p>严格意义上来说，Mediasoup是单进程的。但你不要以为这就影响了它的性能。实际上，它是使用单进程的方式将服务器上CPU某个 <code>核</code> 充分利用好，然后在业务层控制进程的个数。比如说你的服务器是个 8 核的CPU，那么在业务层你就该启动 8 个Mediasoup进程。通过这种方式来达到对 CPU 的充分利用。</p><p><img data-src="https://cdn.avdancedu.com/image/article/sfu/mediasoup_arch.jpg" alt="mediasoup结构图"></p><p>Mediasoup中的每个进程称为一个 Worker, 你也可以把它理解为一个<code>节点</code>，在每个 Worker 中可以有多个 Router。对于 Router，你站在不同的解度可以有不同的理解。如果你占在应用层的角度，你可以把它理解为一个房间；如果你站在数据流转的角度，可以把它理解为一个路由器，数据通过 <code>路由器</code> 转发给目标用户。</p><p>想了解更多Mediasoup的细节，可以观看我的视频课 <a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级高并发WebRTC流媒体服务器设计与开发》</a>，在这个视频中我对 Mediasoup 源码做了深入剖析。</p><h3 id="Janus"><a href="#Janus" class="headerlink" title="Janus"></a>Janus</h3><p><img data-src="https://cdn.avdancedu.com/image/article/sfu/janus_arch.jpg" alt="Janus架构"></p><p>上面这张图是 Janus 的整体架构图。在这张图中我们可以看到， 从大的方面说 Janus 由 Janus CORE、Janus Plugin 以及信令接口三部分组成。</p><ul><li>信令接口，Janus 支持的信令协议比较多，如 HTTP、WebSocket、RabbitMQ 等。这些信令协议使得 Janus 具有非常好的接入性。因为很多公司喜欢各种不同的协议，如有的喜欢 websocket，有的喜欢http，proto等。因此 Janus 在信令接入方面具有很大的优势。</li><li>Janus Plugin，Janus 的业务管理是按照 Plugin 的方式管理的，因此你可以在Janus中根据自己的需要实现自己的业务插件。实际上，对于一般性的需求 Janus 已经相关的插件。如：<ul><li>VideoRoom，用于多人音视频互动，像音视频会议，在线教育都可以通过该插件来实现。</li><li>VideoCall，用于 1:1 的音视频通信。</li><li>SIP，用于与传统电话设备对接。</li><li>Streaming，用于广播，也就是我们通常所说的一人共享，多人观看的直播模式。</li><li>TextRoom，它是一个聊天室，通过它可以进行文本聊天。</li><li>RecordPlay，用于录制和回放。</li></ul></li><li>Janus Core 是Janus的核心，其作用是处理流的转发，各种协议的接入。以浏览器为例，要想让浏览器接入到 WebRTC 流媒体服务器上，那流媒体服务器必须要支持 STUN、DTLS、SRTP、ICE 等协议。而 Janus Core 就是专门做这事儿的。</li></ul><p>Janus 是由 C语言开发的，因此它的性能非常优秀。要说不足的话，janus 底层没有使用 epoll 这类异步I/O事件处理机制，这应该说是它的一大缺陷；另外，Janus还使用 glib 库，由于 glib 库对于国内的很多开发同学来说用的比较少，所以会有一定的学习成本。</p><p>整体上看，Janus采用了插件的架构设计方案。这种方案非常适合于有多种业务模型或业务经常发生变化的公司或项目。另外 Janus 支持多种消息传输协议，这对于开发人员来说具有极大的吸引力。</p><h2 id="Medooze"><a href="#Medooze" class="headerlink" title="Medooze"></a>Medooze</h2><p><img data-src="https://cdn.avdancedu.com/image/article/sfu/medooze_arch.jpg" alt="Medooze 架构.png"></p><p>Medooze 的整体架构与 Mediasoup 类似，不过它的信令处理、业务管理以及媒体数据的转发功能都是放在 Nodejs下进行统一管理的。实际上，这样的管理方式也不会对性能造成什么影响，因为重的媒体流的转发工作仍然是使用的 C++ 在 Nodejs 底层实现的。</p><p>Medooze 的业务功能要比 Mediasoup 强大，像服务端录制、推流这些 Mediasoup 没有的功能它都支持。但它性能没有 Mediasoup 做的极致，在Medooze的底层使用的poll来处理I/O事件，poll与epoll性能相差距大。除此之外，Medooze的业务逻辑也没有Mediasoup简洁；另外与 Janus 相比，它的业务管理不如 Janus 灵活，Janus 的插件管理方式显然要优于 Medooze 和 mediasoup。</p><p>但总的来说，Medooze还是一款非常不错的 WebRTC 流媒体服务器。虽然有一些小的暇疵，但还是非常不错的一款流媒体服务器。</p><p>想了解更多 Medooze 细节的同学可以看我的专栏 <a href="https://time.geekbang.org/column/article/136000" target="_blank" rel="noopener">《从0打造音视频直播系统》</a>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过上面的描述，我想你应该对目前主流的 WebRTC 流媒体服务器有了一个大体的了解。所以在选型上你可以按照自己团队的能力进行评估到底该用那个流媒体服务器。</p><p>如果你团队能力比较强，可以做底层开发，那么建议你使用 Mediasoup。因为 Mediasoup 不关心应用层，它关注的是底层数据如何高效的流转，代码简洁、高效，性能极佳。</p><p>如果你们要做的业务种类比较多，变化比较快，那建议你选择使用 Janus 作为流媒体服务器。将你的业务做成一个插件放到 Janus上很快就能实现你们的业务需求。</p><p>如果你们的业务变化不大，除了追求性能外，还需要录制、推流之类的功能，那么你可以选择使用Medooze，它可以很好的满足你们的需求。</p><p>当然，除了上面我介绍到的几款比较流行的 WebRTC 流媒体服务器外，还有一些其它的流媒体服务器，如 Licode、OWT、Jitsi等也可以选择。</p><p>Licode 之所以名气比较大，是因为它推出的时间比较早。而 OWT 是 Licode 的一个变种，它在 Licode上实现了 SFU 功能。看一下 Licode 代码你就会发现，Licode 实现了一套完整的音视频会议系统，对于这样一套系统它的实现非常复杂。如果你的团队没有音视频方面的开发人才的话，可以考虑Licode，将它搭建出来之后就可以直接使用了。但如果你有业务变化想修改它就太麻烦了。</p><p>Jitsi 上层是使用 Java 语言开发的，但底层也是使用的 C/C++ 语言。它通过 JNI 来实现Java与 C/C++之间的通信。在 2018 年有机构做过一次性能评测，当时 Jitsi 表现比较差强人意，不知现在是否已经有了改进。</p><p>以上就是对几款 WebRTC流媒体服务器的比较，希望本文可以帮助你解决WebRTC流媒体服务器的选择问题。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级高并发WebRTC流媒体服务器设计与开发》</a></li><li><a href="https://time.geekbang.org/column/article/136000" target="_blank" rel="noopener">《从0打造音视频直播系统》</a></li><li><a href="https://avdancedu.com/ed54b3d4/" target="_blank" rel="noopener">音视频会议系统 Janus 的编译与布署</a></li><li><a href="https://avdancedu.com/8f43ddc9" target="_blank" rel="noopener">janus的线程模型</a></li><li><a href="https://avdancedu.com/26c3d930" target="_blank" rel="noopener">深入理解janus中的plugin</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> WebRTC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mediasoup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mediasoup 课程常见问题</title>
      <link href="/5a9f427c/"/>
      <url>/5a9f427c/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/mediasoup_ask/mediasoup_banner.jpg" alt="mediasoup"><br>《WebRTC流媒体服器》课程推出已经有一段时间了，受到很多同学们的好评，是慕课网为数不多的10分好课。这门课是专门讲解与WebRTC互通的流媒体服务器的高端课，课程从如何开发服务器程序讲起，逐步向你介绍如何构建出一个可商用的、高并发的、性能优越的流媒体服务器。</p><p>该服务器可以与Chrome等浏览器对接，实现多人音视频会议系统或实时互动在线教育系统。毫不夸张的说，只要你能撑握课程中的 85% 的内容，去应聘流媒体服务器的研发岗时，你就不用再担心技术问题了。</p><a id="more"></a><p>在课程的评论区有很多评论，有兴趣的同学也可以参考一下</p><p><img data-src="https://cdn.avdancedu.com/image/article/mediasoup_ask/ping.jpg" alt="课程评论"></p><p>同学们在学习课程内容的时候也经常问一些问题，这里我总结了一些大家常见的问题以及问题答案希望对你能有所帮助。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="Linux-安装环境"><a href="#Linux-安装环境" class="headerlink" title="Linux 安装环境"></a>Linux 安装环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node version &gt;&#x3D; v10.0.0</span><br><span class="line">python version 2 or 3</span><br><span class="line">make</span><br><span class="line">gcc and g++ &gt;&#x3D; 4.9 or clang (with C++11 support)</span><br></pre></td></tr></table></figure><blockquote><p>In Debian and Ubuntu install the build-essential DEB package. It includes both make and gcc/g++.<br>In YUM based Linux (Red Hat, CentOS) use yum groupinstall “Development Tools”.<br>If there is not python command pointing to Python 2 or 3 executable, set the PYTHON environment variable during mediasoup installation:</p><blockquote><p>$ PYTHON=python3 npm install mediasoup@3 –save</p></blockquote></blockquote><h3 id="Q-有mediasoup、janus、licode等流媒体服务器的比较吗？"><a href="#Q-有mediasoup、janus、licode等流媒体服务器的比较吗？" class="headerlink" title="Q: 有mediasoup、janus、licode等流媒体服务器的比较吗？"></a>Q: 有mediasoup、janus、licode等流媒体服务器的比较吗？</h3><p>A: <a href="https://www.avdancedu.com/947c722a/" target="_blank" rel="noopener">可以看我这篇文章</a></p><h3 id="Q-有各流媒体服务器之间的性能比较吗？"><a href="#Q-有各流媒体服务器之间的性能比较吗？" class="headerlink" title="Q: 有各流媒体服务器之间的性能比较吗？"></a>Q: 有各流媒体服务器之间的性能比较吗？</h3><p>A: <a href="https://webrtchacks.com/sfu-load-testing/" target="_blank" rel="noopener">可以看这篇文章</a></p><h3 id="Q-单台mediasoup流媒体服务器能承载多少路流？"><a href="#Q-单台mediasoup流媒体服务器能承载多少路流？" class="headerlink" title="Q: 单台mediasoup流媒体服务器能承载多少路流？"></a>Q: 单台mediasoup流媒体服务器能承载多少路流？</h3><p>A: 官方答案为单核支持 500 路流。</p><h3 id="Q-布署流媒体服务器是需要怎样的配置"><a href="#Q-布署流媒体服务器是需要怎样的配置" class="headerlink" title="Q: 布署流媒体服务器是需要怎样的配置?"></a>Q: 布署流媒体服务器是需要怎样的配置?</h3><p>A: <a href="https://github.com/havfo/multiparty-meeting/wiki/Scaling-and-recommended-Hardware" target="_blank" rel="noopener">这里有一份说明</a></p><h3 id="Q-mediasoup安装时报错是什么原因？"><a href="#Q-mediasoup安装时报错是什么原因？" class="headerlink" title="Q: mediasoup安装时报错是什么原因？"></a>Q: mediasoup安装时报错是什么原因？</h3><p>A: 建议使用Ubuntu18.04 安装mediasoup。</p><h3 id="Q-在Ubuntu18-04上安装也报错"><a href="#Q-在Ubuntu18-04上安装也报错" class="headerlink" title="Q: 在Ubuntu18.04上安装也报错"></a>Q: 在Ubuntu18.04上安装也报错</h3><p>A: node 版本在 10 以上，npm 版本在 6.4 版本以上。</p><h3 id="Q-mediasoup安装好后看不对远端视频"><a href="#Q-mediasoup安装好后看不对远端视频" class="headerlink" title="Q: mediasoup安装好后看不对远端视频"></a>Q: mediasoup安装好后看不对远端视频</h3><p>A: 配置文件是否配置对了？对于云主机来说正确的配置如下图所示：<br><img data-src="https://cdn.avdancedu.com/image/article/mediasoup_ask/mediasoup_ip_setting.png" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">WebRTC高并发流媒体服务器mediasoup</a></p>]]></content>
      
      
      <categories>
          
          <category> WebRTC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mediasoup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js类的探究</title>
      <link href="/18fc7df1/"/>
      <url>/18fc7df1/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/js/javascript.png" alt="javascript"></p><p>随着浏览器的发展，JS（JavaScript) 越来越受到人们的欢迎。它不再像以前只能做单一的渲染页面这样的事情了，在Chrome等现代浏览器上，你甚至可以用JS来做音视频的处理，是不是觉得很神奇？</p><p>不过今天我要讨论的并不是如何使用JS来做一些<strong>神奇</strong>的事儿，而是来重新认识一下JS中<strong>类</strong>的使用。对于这部分知识的理解，将为我们后面阅读Janus(一款WebRTC流媒体服务器)代码有着至关重要的作用。</p><a id="more"></a><h2 id="JS中的function"><a href="#JS中的function" class="headerlink" title="JS中的function"></a>JS中的function</h2><p>在ES5以前，JS中并没有<strong>class</strong>关键字，那时候JS是如何表示一个类的呢？说来也奇怪，它使用<strong>function</strong>来表示。</p><p>我在了解这部分知识的时候也是觉得不可思意！实际上我早在2003年的时候就学习并使用JS了，那时候JS还很简单。虽然后来很久没有再碰过它，但印象中<strong>function</strong>一直是用来定义一个函数的，现在怎么又用来定义<strong>类</strong>了呢？</p><p>后来看了一些资料才逐渐理清，原来现在的JS中<code>function</code>既可以用来定义函数，也可以用来定义类。有点类似于语文中的<strong>一语双关</strong>。</p><p>之所以<code>function</code>有双层含义，是因为JS最开始并不支持面向对象开发模式。但随着技术的发展，面向对象的开发模式越来越受到人们的欢迎，JS为了能跟上时代，所以也必须支持面向对象开发。</p><p>不过JS在转向面向对象语言时面临一种选择，即从原生语言上支持<code>class</code>，那JS解析器就要做大的调整，这可不是一时半会儿可以完成的。而如果在原有的基础上修改则要容易得多。</p><p>权衡利弊之后，JS<code>大神</code>们还是决定在现有的基础上修改是最省时少力的。于是就借用了<code>function</code>函数，把它看作是一个<strong>构造函数</strong>，这样就可以快速的将JS改造成面向对象的开发语言了。</p><p>以上就是JS中使用<code>function</code>定义类的大致由头！下面我们就来看看在ES5上该如何定义一个<strong>类</strong>。</p><h2 id="类及成员"><a href="#类及成员" class="headerlink" title="类及成员"></a>类及成员</h2><p>在JS中如何定义一个类呢？实际上它与其它面向对象语言(如Java)是很类似的，只不过在Java中定义类用的是<code>class</code>关键字，而在JS中用<code>function</code>代替而以。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function classname() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 中，类的成员按安全性可以分为<strong>公有</strong>和<strong>私有</strong>，JS中是否也有类似的概念呢？答案是肯定的，接下来我们就来看一下在JS类中如何定义公有成员和私有成员吧。</p><p>JS中公有成员和私有成员的定义都是隐式的，不像Java有明确的<code>public</code>和<code>private</code>关键字来指明它们的权限。在JS类中直接定义的函数或变量都是私有成员，在类成员或函数前面加<code>this</code>关键字的，则表式是公有成员。</p><p>我们来看个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function myclass ()&#123;</span><br><span class="line"></span><br><span class="line">    function test()&#123;</span><br><span class="line">        console.log(&quot;testA function&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; new myclass();</span><br><span class="line">obj.test();</span><br></pre></td></tr></table></figure><p>如果我们在浏览器执行上面的代码，在浏览器的<code>debugger</code>中你一定可以看到这样一条错误信息<code>“Uncaught TypeError: obj.testfunc is not a function”</code>，这说明通过<code>obj</code>对像是无法访问到<code>test()</code>函数的。</p><p>我们稍微调整一下这段代码，修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function myclass ()&#123;</span><br><span class="line"></span><br><span class="line">    this.test &#x3D; test() &#123; &#x2F;&#x2F;这里加了this 关键字</span><br><span class="line">        console.log(&quot;testA function&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; new myclass();</span><br><span class="line">obj.test();</span><br></pre></td></tr></table></figure><p>我们在<code>test</code>函数前加上<code>this.</code>，只做这一点点修改，这段代码就可以在浏览器上成功运行了。</p><p>由此我们可以知道，如果你想让外面访问对象中的成员（成员变量或成员方法），你就应该在这些成员前面加上<code>this</code>关键字。反过来讲，如果你不想让外面访问到对象中的成员，则不要在这些成员前面加<code>this</code>。</p><h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><p>在Java中除了有对象成员外，还可以有类成员，比如在使用单例模式时，我们都会定义一个静态的成员。在JS中如何做到这点呢？我们来看个具体例子吧。还是刚才那个代码，我们在其基础上稍做修改即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义类方法</span><br><span class="line">myclass.init &#x3D; function()&#123; </span><br><span class="line">    console.log(&quot;class method!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function myclass ()&#123;</span><br><span class="line"></span><br><span class="line">    this.test &#x3D; test() &#123; &#x2F;&#x2F;这里加了this 关键字</span><br><span class="line">        console.log(&quot;testA function&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用类方法</span><br><span class="line">myclass.init();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建对象</span><br><span class="line">var obj &#x3D; new myclass();</span><br><span class="line">obj.test();</span><br></pre></td></tr></table></figure><p>在这段代码中，加入了类方法的定义及调用类方法的代码。从上述代码中我们可以知道，在JS中类方法是在类之外定义的，而不像Java在是类内加<code>static</code>关键字。</p><h2 id="类的原型prototype"><a href="#类的原型prototype" class="headerlink" title="类的原型prototype"></a>类的原型prototype</h2><p>在JS中，每个类都有一个类属性<code>prototype</code>，用来指向类原型。或者你可以把它理解为指向<strong>类原型的地址</strong>。当我们想为这个类添加方法或成员变量的时候，就可以通过prototype来实现，只需修改prototype指向的内存地址的内容就可以达到添加成员的目的。</p><p>举个例子，假设我们定义了一个类如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function myjs()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前在这个类中没有写任何方法或成员变量，只是定义了一个空类。下面我想修改这个类，给这个类增加一些内容，该怎么做呢？实现的方法很简单，修改prototype即可，看下面的例子你就明白了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function myjs()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myjs.prototype.a  &#x3D; 5;</span><br><span class="line">myjs.prototype.test &#x3D; function() &#123;</span><br><span class="line">    console.log(&quot;this is a function of myjs object!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; new myjs();</span><br><span class="line">console.log(&quot;myjs.a &#x3D;&#x3D; &quot; + obj.a );</span><br><span class="line">obj.test();</span><br></pre></td></tr></table></figure><p>通过上面的代码，我们就给<code>myjs</code>类增加了两个成员，即一个变量<code>a</code>和一个方法<code>test</code>。当我们生成myjs对象时，生成的对象中就有我们之前添加的成员变量和成员方法了。</p><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>JS中没有专门用于类继承的语法，不过你可以通过上一节介绍的prototype来实现<code>类继承</code>。在我们正式讲解继承之前，我们先了解一下prototype在内存中是如何表示的。如下图所示：<br><img data-src="https://cdn.avdancedu.com/image/article/js/prototype.jpg" alt="prototype"></p><p>通过上图我们可以看到，使用<code>function</code>定义的类并非真实的<code>类</code>，更准确的说它应该是一个<code>构造函数</code>。而类属性<code>prototype</code>指向的才是类的真正地址。</p><p>可能很多同学会问JS是如何通过构造函数找到它所在的类的呢？其实这是C语言的一个小巧，其过程是JS调用浏览器，通过浏览器使用C语言中的<code>技巧</code>获取构造函数所在类的地址，这对于浏览器来当然是小菜一碟。</p><p>了解了<code>prototype</code>的物理意义后，接下来我们看看类生成的对象在内存中的情况，它与prototype之间的关系又是怎样的？如下图所示。<br><img data-src="https://cdn.avdancedu.com/image/article/js/js_obj.jpg" alt="对象在内存中"></p><p>通过上图我们可以看到，JS在创建对象时会为每个对象分配内存空间。更为重要的一点是，多个相同类型的<code>对象</code>会指向同一个prototype。</p><p>了解了上面的特性后，我们就可以利用<code>prototype</code>来实现类的继承了。如何来做呢？我们再来举个例子。</p><p>首先，我们定义一个基类，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function parent() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;给基类添加一个新的属性 a</span><br><span class="line">parent.prototype.a &#x3D; 1;</span><br></pre></td></tr></table></figure><p>然后，我们创建一个子类，并让子类的prototype指向父类，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function child() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">child.prototype &#x3D; new parent();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;再给子类添加一个属性 b</span><br><span class="line">child.prototype.b &#x3D; 2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建子类</span><br><span class="line">var obj_child &#x3D; new child();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;访问子类的属性</span><br><span class="line">console.log(&quot;a &#x3D; &quot; + obj_child.a);</span><br><span class="line">console.log(&quot;b &#x3D; &quot; + obj_child.b);</span><br></pre></td></tr></table></figure><p>执行上面的例子，我们通过浏览器的<code>debugger</code>就可以看到如下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 1</span><br><span class="line">b &#x3D; 2</span><br></pre></td></tr></table></figure><p>说明child子类确实是继承了parent类。我们再深扒一下，对于上面这段代码表示的继承关系在内存中的物理意义是什么呢？如下图所示：</p><p><img data-src="https://cdn.avdancedu.com/image/article/js/js_extend.jpg" alt="js继承"></p><p>在JS中，正常情况下每生成一个对象，该对象的 <code>__proto__</code> 都指向该对象的<strong>原始类的地址</strong>。如上图所示parent对象的<code>__proto__</code>指向parent.prototype，child对象的<code>__proto__</code>指向child.prototype。</p><p>为什么会这样呢？要理解其中的奥秘，我们必须要知道JS中 <code>new xxx</code> 做了哪些事儿。实际上，<code>new xxx</code> 做了四件事儿，我们以上图中的<code>new parent()</code>为例，它做的四件事儿如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line">obj.__proto__ &#x3D; parent.prototype; &#x2F;&#x2F;即parent</span><br><span class="line">parent.call(obj);                 &#x2F;&#x2F;调用parent的构造函数</span><br><span class="line">return obj;</span><br></pre></td></tr></table></figure><p>在这步中，第二步是最关键的，它表明了新对象的<code>__proto__</code>指向了哪里。这样我们就可以理解 <strong>“对象的 <code>__proto__</code> 都指向该对象的原始类的地址”</strong> 这句话了。</p><p>当我们理解了 <code>new xxx</code> 的真实含义之后，<code>child.prototype = new parent()</code> 这句代码的含义立马就清楚了，它的含义是改变 <code>child.prototype</code> 的指向， 让他重新指向<code>parent</code>对象。</p><p>由于生成parent对象时，它的<code>__proto__</code>指向了parent的<strong>原始类</strong>，因此child.prototype就与parent的prototype建立了连接。</p><p>在接下来创建<code>obj_child</code>对象时，由于child.prototype已经指向了parent对象，因此<code>obj_child.__proto__</code>也就指向了parent对象。此时通过 old_child 就可以访问到parent对象的内容了，从而也就达到了继承的目的。</p><h2 id="ES6-中的类"><a href="#ES6-中的类" class="headerlink" title="ES6 中的类"></a>ES6 中的类</h2><p>大家对于在JS中使用<code>function</code>方式定义类实在感到很厌烦，就不能与其它语言一样可以使用<code>class</code>来定义类吗？在ES6时代，JS终于可以做到这一点了。</p><p>现在我们来看看在JS中该如何定义类吧，例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class cls &#123;</span><br><span class="line">    constructor(arg)&#123;</span><br><span class="line">        this.a &#x3D; arg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    do()&#123;</span><br><span class="line">        console.log(&quot;a value &#x3D;&#x3D;&quot; + this.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var t &#x3D; new cls(&#39;hello&#39;);</span><br><span class="line">t.do();</span><br></pre></td></tr></table></figure><p>上面的代码是不是看着就舒服多了？但实际上，ES6中的<code>class</code>只是一个<code>语法糖</code>。啥意思呢？也就是说虽然语法上JS改成了与其它面向对象语言一致的用法，但在JS内部还是使用的<code>function</code>的机制来实现的。</p><h3 id="公有成员与私有成员"><a href="#公有成员与私有成员" class="headerlink" title="公有成员与私有成员"></a>公有成员与私有成员</h3><p>使用 ES6 中的 <code>class</code> 定义类时，类中的成员默认都是公有成员，外面都可以直接访问到。当然在class中也可以使用<code>#</code>来定义私有成员变量，但一般情况下我们很少用到。我们来看一下例子吧，在上面的代码中做一点修改即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class cls &#123;</span><br><span class="line">    #a;</span><br><span class="line">    constructor(arg)&#123;</span><br><span class="line">        this.#a &#x3D; arg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    do()&#123;</span><br><span class="line">        console.log(&quot;a value &#x3D;&#x3D;&quot; + this.#a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var t &#x3D; new cls(&#39;hello&#39;);</span><br><span class="line">console.log(&quot;#a&#x3D; &quot; + t.#a);</span><br><span class="line">t.do();</span><br></pre></td></tr></table></figure><p>我们在上面代码中增加了 <code>#a</code> 变量，因<code>#</code>表示的是私有成员，所以当我们创建对象 <code>t</code> 后，通过 <code>t.a</code> 是无法访问它的，此时只能通过cls类的成员方法<code>do()</code>才能访问 <code>#a</code>变量。</p><h3 id="类的继承-1"><a href="#类的继承-1" class="headerlink" title="类的继承"></a>类的继承</h3><p>接下来我们再来看看在 ES6 中如何实现<code>类的继承</code>。在ES5中要实现类继承必须使用<code>prototype</code>，如果你不从内存存储的角度去思考的话，就很难理解它是如何实现<code>类继承</code>的。而在 ES6 中，类的继承就就像我们使用其它语言中的类继承一样，让我们一目了然。</p><p>我们来举个例子，你一看就明白了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class parent &#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.a &#x3D; &#39;hello&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class child extends parent &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.b &#x3D; &#39;world&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var c &#x3D; new child();</span><br><span class="line"></span><br><span class="line">console.log(c.a + &quot; &quot; + c.b);</span><br></pre></td></tr></table></figure><p>上面的代码定义了两个类，一个父类<code>parent</code>;一个子类<code>child</code>。当我们创建 <code>child</code> 对象 <code>c</code>时，首先会触发 child的构造函数。在child构造函数中，它首先调用 <code>super()</code>方法，而该方法会调用<code>parent</code> 类的构造函数，从而将parent类中的<code>a</code>属性进行初始化。之后又回到child构造函数中对<code>b</code>属性进行初始化，至此所有的初始化工作完成，最终<code>c</code>对象被创建出来。</p><p>当c对象创建好后，我们就可以直接访问它里边的 <code>a</code> 和 <code>b</code> 属性了，以上就是ES6中类继承的过程。其过程与其它面向对象语言完成一致，所以大家在使用它时会觉得非常自然。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上我对JS中 ES5 和 ES6 标准中的<code>类</code>做的一些浅显的探究，在ES5 中类是通过<code>function</code>创建了，由于JS最开始并不支持面向对象开发，所以在ES5中使用JS实现面向对象开发的方式让人觉得很<code>诡异</code>。我在理解这部分知识时，也颇费了一翻周折。不过如果你对内存管理比较熟悉的话，从内存管理的角度去理解 ES5 中的类与继承就比较容易了。</p><p>对于 ES6 来说，类的定义与类的继承几乎完全照搬了 Java 的语法，所以我们在学习和使用它时就非常方便了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="noopener">阮一峰</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo中如何画图</title>
      <link href="/f3ccc53/"/>
      <url>/f3ccc53/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/markdown_flow/markdown.jpg" alt="Markdown时序图"></p><p>有很多同学觉得用Markdown画图是一个很鸡肋的事儿，一是Markdown画不了太复杂的图，如果图太复杂了估计能把自己绕晕；二是Markdown画不了特别漂亮的图，比如你想通过颜色来区分一些元素的作用Markdown就无能为力了。</p><p>我以前也是持有这种态度，所以一直很反对使用Markdown画图。但最近我的思想有所改变，我认为Markdown画图还是有它的优势的。</p><a id="more"></a><p>Markdown绘图有两方面优势，一是通过Markdown画的图不占带宽，这个优势对我来说特别有吸引力。因为我的主机本来带宽就不足，要是在一篇文章中图片太多的话页面加载的速度就太慢了。</p><p>二是Markdown的绘图功能还在不断发展中，没准那天就可以做到手工在页面里直接编辑的程度了，我相信这一天不会太迟到来。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>下面这两幅图就是用Markdown语法绘制的，第一个是流程图，第二个是时序图。看着是不是觉得也还蛮不错的呢？</p><ul><li><p>流程图</p><center><div id="flowchart-0" class="flow-chart"></div></center></li><li><p>时序图</p></li></ul><center><div id="sequence-0"></div></center><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>当然，目前要想实现Markdown绘图还需要安装插件，对于每种不同类型图要安装不同的插件。绘制流程图要安装<code>hexo-filter-flowchart</code>; 绘制时序图要安装<code>hexo-filter-sequence</code>。</p><p>安装的方法以及Markdown的语法我以后再来补充</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在Markdown上绘制图型还是有它的优势的，尤其对于自建博客的同学会更愿意偿试这种方式绘制图型。</p><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdn.bootcss.com/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">Alice->Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob-->Alice: I am good thanks!</textarea><textarea id="sequence-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12,"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script><script src="https://cdn.bootcss.com/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Start|past:>https://www.google.com[blank]e=>end: End:>https://www.google.comop1=>operation: My Operation|pastop2=>operation: Stuff|currentsub1=>subroutine: My Subroutine|invalidcond=>condition: Yesor No?|approved:>https://www.google.comc2=>condition: Good idea|rejectedio=>inputoutput: catch something...|requestst->op1(right)->condcond(yes, right)->c2cond(no)->sub1(left)->op1c2(yes)->io->ec2(no)->op2->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12,"theme":"simple"}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script>]]></content>
      
      
      
        <tags>
            
            <tag> 时序图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令及一些特殊用法</title>
      <link href="/423abe9e/"/>
      <url>/423abe9e/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/git/git-banner.jpg" alt=""><br>本文主要记录一些工作中常用的 git 命令，以及一些比较特殊的git用法，希望这些命令对您也能有所帮助。</p><a id="more"></a><h2 id="git-的基本工作原理"><a href="#git-的基本工作原理" class="headerlink" title="git 的基本工作原理"></a>git 的基本工作原理</h2><p>其实要想使用好git，你必须要知道一点git的工作原理，否则你在使用git时就只能死记硬背一些命令。如果你还处理死记硬背一些git命令的阶段，那么一旦你遇到一个非常复杂的或非手棘手的git case时，可以100%肯定你是无法解决的。</p><p>因此，了解一点git的基本工作原理是我们每个开发人员都必须的基础知识，下面我就对git的的基本工作原理做一下简要介绍。</p><h3 id="git的结构"><a href="#git的结构" class="headerlink" title="git的结构"></a>git的结构</h3><p>首先我们必须要清楚是，git是由三大部分组成的，即本地工作区，本地仓库以及远程仓库。</p><ul><li>本地工作区，就是你平常写代码或修改代码的地方。</li><li>本地仓库，就是我们工作区中.git目录。它里边有一堆子目录，这些子目录都有各自的用途，我们暂且不管。</li><li>远程仓库，这个比较好理解了，就是远端的git仓库，比如我们在github上创建的仓库。</li></ul><p>通过下面这张图我们可以更直观的了解这三大部分：<br><img data-src="https://cdn.avdancedu.com/image/article/git/git_base.jpg" alt="git结构图"></p><p>从图中我们可以清楚的知道，平时我们使用git的三个主要命令(git add、git commit、git push)具体都做了些什么:</p><ul><li>git add: 将本地工作区中代码的修改保存到本地仓库的staged区，即暂存区。</li><li>git commit: 将staged区中的内容保存到本地仓库。</li><li>git push: 将本地仓库中的内容推送给远程仓库保存。</li></ul><p>通过上面这张图我们可以得出以下几点重要结论。</p><p>第一，git在处理我们的提交时是按顺序、分阶段的。比如我们的一个提交，必须先到 staged 后才能进入本地仓库，这个处理顺序是不能乱的。</p><p>第二，git管理中有一个 HEAD 指针，它始终指向正在处理的git commit。而它的前一次git commit 可以用<code>HEAD^</code>表式，它的上上次commit可以用<code>HEAD ^^</code>表式。</p><p>第三，当我们想用地本仓库的内容更新本地工作区的内容时，如果 staged 中没有内容，则可以直接用本地仓库的内容更新本地工作区内容。但如果 staged 中有内容，则需要先更新staged ，然后再更新本地工作区。</p><p>第四，git的核心是本地仓库，所有的操作都是围绕着它来的。它既是用户<code>commit</code>的终点，又是远程仓库的接收<code>commit</code>起点。我们在使用git时，可以向本地仓库提交多次修改，而只向远程仓库推送一次，git推送时会将之前的多个<code>commit</code>合并到一起。</p><h3 id="git的分支管理"><a href="#git的分支管理" class="headerlink" title="git的分支管理"></a>git的分支管理</h3><p>在git中还有一个特别重要的概念就是branch，即分支。它是我们多人合作开发的基础。如下图所示：<br><img data-src="https://cdn.avdancedu.com/image/article/git/git_branch.jpg" alt="git 分支"></p><p>通过上图我们可以清楚的知道，git是以<strong>指针</strong>的方式对分支进行管理的。下面我们来详述一下git是如何管理分支的。</p><p>当我们执行<code>git init</code>时，git默认为我们创建一个分支，即<code>Master</code>分支。而HEAD指针也被初始化指向Master分支，因此每当你提交新的修改时，这些修改都会被压入到Master分支<strong>栈</strong>上。</p><p>当然一般情况下我们都不会轻易对Master分支做操作，而是创建一个<code>Dev</code>分支作为我们的开发分支。在git中你可以执行<code>git branch branchname</code>命令来创建一个新分支，比如将branchname设置为<code>Dev</code>，这样我们就创建出了<code>Dev</code>分支。</p><p>然后你可以执行<code>git checkout Dev</code> 命令，它的作用是让<code>HEAD</code>指向Dev分支。后面你所有的commit就都被<strong>push</strong>到Dev分支上了。</p><p>如果你觉得执行两条命令比较麻烦，你也可以将上面的两步合并为一步，执行<code>git checkout -b branchname</code>这一条命令就可以了，这也是我们平常真正使用的命令。</p><p>通过上面的描述，我想你应该对git的工作原理有了最基本的了解了，下面我们再来看这些命令时就很容易理解它们的作用以及为什么要这么做了。</p><h2 id="已有代码该如何提效到仓库中"><a href="#已有代码该如何提效到仓库中" class="headerlink" title="已有代码该如何提效到仓库中"></a>已有代码该如何提效到仓库中</h2><p>第一步，在github 上创建一个仓库。<br>第二步，执行下面的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:avdance&#x2F;test.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h2 id="本地与远程有突冲，想放弃本地修改"><a href="#本地与远程有突冲，想放弃本地修改" class="headerlink" title="本地与远程有突冲，想放弃本地修改"></a>本地与远程有突冲，想放弃本地修改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard FETCH_HEAD</span><br></pre></td></tr></table></figure><h2 id="重新从远端拉取某个文件"><a href="#重新从远端拉取某个文件" class="headerlink" title="重新从远端拉取某个文件"></a>重新从远端拉取某个文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- a.c</span><br></pre></td></tr></table></figure><h2 id="撤消某次-add"><a href="#撤消某次-add" class="headerlink" title="撤消某次 add"></a>撤消某次 add</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached &lt;added_file_to_undo&gt;</span><br></pre></td></tr></table></figure><h2 id="撤消某次-commit"><a href="#撤消某次-commit" class="headerlink" title="撤消某次 commit"></a>撤消某次 commit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft commitID  只是删除了commitId之后的commit记录,但是代码改动仍然存在</span><br><span class="line">git reset --hard commitID  彻底的回到CommitID时候的版本,之后的改动不存在了</span><br></pre></td></tr></table></figure><h2 id="将本地修改先暂存起来"><a href="#将本地修改先暂存起来" class="headerlink" title="将本地修改先暂存起来"></a>将本地修改先暂存起来</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash 将本地修改暂存起来</span><br><span class="line">git stash pop 弹出暂存的修改</span><br></pre></td></tr></table></figure><h2 id="查看有冲突的文件"><a href="#查看有冲突的文件" class="headerlink" title="查看有冲突的文件"></a>查看有冲突的文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status -uno</span><br></pre></td></tr></table></figure><h2 id="不显示临时文件"><a href="#不显示临时文件" class="headerlink" title="不显示临时文件"></a>不显示临时文件</h2><p>在 .gitignore 中添加不想被 git staus 看到的文件或目录</p><h2 id="暂时回滚到某版本"><a href="#暂时回滚到某版本" class="headerlink" title="暂时回滚到某版本"></a>暂时回滚到某版本</h2><p>首先通过 git log查看你之前的提交码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log | more</span><br></pre></td></tr></table></figure><blockquote><p>commit 4adb3f0ecd9dbc79bd09666d88f8c2520305c001<br>Author: xxxxxx<br>Date:   Thu Jan 25 11:51:45 2018 +0800</p></blockquote><p>摘取 commit 码的前 7位，执行下面的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout 4adb3f0</span><br><span class="line">git reset --hard 4adb3f0</span><br></pre></td></tr></table></figure><h2 id="切换-回滚到主分支"><a href="#切换-回滚到主分支" class="headerlink" title="切换/回滚到主分支"></a>切换/回滚到主分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><h2 id="服务端有更新，但你却-commit了你的代码"><a href="#服务端有更新，但你却-commit了你的代码" class="headerlink" title="服务端有更新，但你却 commit了你的代码"></a>服务端有更新，但你却 commit了你的代码</h2><ul><li><p>先拉取服务端代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure></li><li><p>提交代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure></li><li><p>如果你在 dev分支，此时还要拉取master的代码<br><strong>1. 先 切换到 master 分支</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p><strong>2. 拉取代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p><strong>3. 重新切换到 dev 分支</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev</span><br></pre></td></tr></table></figure></li></ul><h2 id="查看每次提交的文件列表"><a href="#查看每次提交的文件列表" class="headerlink" title="查看每次提交的文件列表"></a>查看每次提交的文件列表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --stat | more</span><br></pre></td></tr></table></figure><h2 id="查看某些提交代码的变化"><a href="#查看某些提交代码的变化" class="headerlink" title="查看某些提交代码的变化"></a>查看某些提交代码的变化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show &lt;commit id&gt; [&lt;filename&gt;]</span><br></pre></td></tr></table></figure><h2 id="显示所有本地与远端分支"><a href="#显示所有本地与远端分支" class="headerlink" title="显示所有本地与远端分支"></a>显示所有本地与远端分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><h2 id="显示所有远程分支"><a href="#显示所有远程分支" class="headerlink" title="显示所有远程分支"></a>显示所有远程分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure><h2 id="显示远端地址"><a href="#显示远端地址" class="headerlink" title="显示远端地址"></a>显示远端地址</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><h2 id="创建一个新分支"><a href="#创建一个新分支" class="headerlink" title="创建一个新分支"></a>创建一个新分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b new_branch</span><br><span class="line">git --set-upstream origin new_branch</span><br><span class="line">git push origin new_branch</span><br></pre></td></tr></table></figure><h2 id="远程仓库已经删除，而本地仓库还在，如果清除？"><a href="#远程仓库已经删除，而本地仓库还在，如果清除？" class="headerlink" title="远程仓库已经删除，而本地仓库还在，如果清除？"></a>远程仓库已经删除，而本地仓库还在，如果清除？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull -p</span><br></pre></td></tr></table></figure><h2 id="git-diff-不显示修改的内容"><a href="#git-diff-不显示修改的内容" class="headerlink" title="git diff 不显示修改的内容"></a>git diff 不显示修改的内容</h2><p>有些情况下，通过 <code>git status</code> 能查到某些文件有变化，但使用 <code>git diff</code> 却看不到修改的内容。可以使用下面的面试查看变化。</p><ul><li>第一种方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached 文件名</span><br></pre></td></tr></table></figure></li><li>或者<br>先将修改的文件重命名，然后执行下面的语句<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD</span><br></pre></td></tr></table></figure></li></ul><h2 id="配置更好的-git-diff-工具"><a href="#配置更好的-git-diff-工具" class="headerlink" title="配置更好的 git diff 工具"></a>配置更好的 git diff 工具</h2><p>在使用 git diff 时，常常发现有很多不方便的地方。因为git diff 默认使用 patch 方式展示代码的不同。如果想看修改后代码的上下文就比较麻烦了（比如代码 review）。</p><p>其实 git 已经提供了扩展功能。可经将它的默认 diff 工具修改为vimdiff。配置如下：</p><ul><li>首先打开 git config 文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.gitconfig</span><br></pre></td></tr></table></figure></li><li>增加配置项<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[difftool]</span><br><span class="line">    prompt &#x3D; false</span><br><span class="line">[diff]</span><br><span class="line">    vimdiff</span><br><span class="line">    tool &#x3D; vimdiff</span><br><span class="line">[difftool &quot;vimdiff&quot;]</span><br><span class="line">    path &#x3D; &#x2F;usr&#x2F;bin&#x2F;vimdiff</span><br></pre></td></tr></table></figure></li></ul><h2 id="打tag"><a href="#打tag" class="headerlink" title="打tag"></a>打tag</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;为git打tag, 第一次需要在前面加一个v</span><br><span class="line">git tag &quot;v1.0.0&quot;</span><br><span class="line">&#x2F;&#x2F;将tag推送到远程仓库</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><h2 id="git-merge-每次都生成一次commit"><a href="#git-merge-每次都生成一次commit" class="headerlink" title="git merge 每次都生成一次commit"></a>git merge 每次都生成一次commit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff</span><br></pre></td></tr></table></figure><blockquote><p>注：ff表示 fast forward</p></blockquote><h2 id="切到某个tag"><a href="#切到某个tag" class="headerlink" title="切到某个tag"></a>切到某个tag</h2><p>与切到某个分支是类似的，只不过将branch 名换为 tag 名而以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout tag_name</span><br></pre></td></tr></table></figure><h2 id="查看某个人的所有提交"><a href="#查看某个人的所有提交" class="headerlink" title="查看某个人的所有提交"></a>查看某个人的所有提交</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --author&#x3D;“author”</span><br></pre></td></tr></table></figure><h2 id="为git设置默认用户名和密码"><a href="#为git设置默认用户名和密码" class="headerlink" title="为git设置默认用户名和密码"></a>为git设置默认用户名和密码</h2><p>在使用Git 的时候，经常会遇到需要频繁输入密码的情况，每次git push 和 git pull 都要求输入用户名和密码，如果提交频繁的话就十分不方便。</p><p>可以使用下面的方法，只需要第一次输入用户名和密码，以后都不用再输入了。</p><h3 id="进入Git-配置文件"><a href="#进入Git-配置文件" class="headerlink" title="进入Git 配置文件"></a>进入Git 配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.gitconfig</span><br></pre></td></tr></table></figure><h3 id="修改配置文件，添加下面这一行。"><a href="#修改配置文件，添加下面这一行。" class="headerlink" title="修改配置文件，添加下面这一行。"></a>修改配置文件，添加下面这一行。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[credential]  </span><br><span class="line">    helper &#x3D; store</span><br></pre></td></tr></table></figure><p>##修改已提交的commit的用户名邮箱</p><ol><li><p>第一步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;newName&quot;</span><br><span class="line">git config --global user.email &quot;newEmail&quot;</span><br></pre></td></tr></table></figure></li><li><p>修改已提交commit的用户名邮箱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend --author&#x3D;&quot;userName &lt;userEmail&gt;&quot;</span><br></pre></td></tr></table></figure></li></ol><p><strong>注意不能缺少<code>&lt; &gt;</code></strong><br><strong>此指令仅能更新最近的一次commit的用户名邮箱</strong></p><h2 id="git-应用-patch"><a href="#git-应用-patch" class="headerlink" title="git 应用 patch"></a>git 应用 patch</h2><ol><li>预览patch的结是</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git apply --stat file.patch</span><br></pre></td></tr></table></figure><ol start="2"><li>检测patch后是否有错误</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git apply --check file.patch</span><br></pre></td></tr></table></figure><ol start="3"><li>打patch</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git am --signoff &lt; a_file.patch</span><br></pre></td></tr></table></figure><ol start="4"><li>执行commit</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  commit -m &quot;&quot;</span><br></pre></td></tr></table></figure><ol start="5"><li>提交代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><h2 id="循环克隆"><a href="#循环克隆" class="headerlink" title="循环克隆"></a>循环克隆</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive https:&#x2F;&#x2F;xxx.git</span><br></pre></td></tr></table></figure><h2 id="给代码设置两个不同的源"><a href="#给代码设置两个不同的源" class="headerlink" title="给代码设置两个不同的源"></a>给代码设置两个不同的源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin https:&#x2F;&#x2F;xxx.git</span><br></pre></td></tr></table></figure><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>命令在不断更新中…</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰git教程</a></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg精讲常见问题</title>
      <link href="/f3f66133/"/>
      <url>/f3f66133/</url>
      
        <content type="html"><![CDATA[<h2 id="问：编译-ffmpeg-方法"><a href="#问：编译-ffmpeg-方法" class="headerlink" title="问：编译 ffmpeg 方法"></a>问：编译 ffmpeg 方法</h2><p>答：在各个平台编译方法基本都是一样的。</p><ul><li>首先下载 ffmpeg 源码，地址为: <a href="https://www.ffmpeg.org/download.html" target="_blank" rel="noopener">https://www.ffmpeg.org/download.html</a></li><li>进入到下载后的<a href="https://coding.imooc.com/class/279.html?mc_marking=59c321c0417e144904c49c366f94dd57&mc_channel=shouji" target="_blank" rel="noopener">ffmpeg目</a>录下，执行下面的指令：<a id="more"></a><ul><li>Mac 平台：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;ffmpeg</span><br><span class="line">                  --enable-gpl</span><br><span class="line">                  --enable-nonfree</span><br><span class="line">                  --enable-libfdk-aac</span><br><span class="line">                  --enable-libx264</span><br><span class="line">                  --enable-libx265</span><br><span class="line">                  --enable-filter&#x3D;delogo</span><br><span class="line">                  --enable-debug</span><br><span class="line">                  --disable-optimizations</span><br><span class="line">                  --enable-libspeex</span><br><span class="line">                  --enable-videotoolbox</span><br><span class="line">                  --enable-shared</span><br><span class="line">                  --enable-pthreads</span><br><span class="line">                  --enable-version3</span><br><span class="line">                  --enable-hardcoded-tables</span><br><span class="line">                  --cc&#x3D;clang</span><br><span class="line">                  --host-cflags&#x3D;</span><br><span class="line">                  --host-ldflags&#x3D;</span><br></pre></td></tr></table></figure></li><li>Linux平台<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;ffmpeg</span><br><span class="line">                  --enable-gpl</span><br><span class="line">                  --enable-nonfree</span><br><span class="line">                  --enable-libfdk-aac</span><br><span class="line">                  --enable-libx264</span><br><span class="line">                  --enable-libx265</span><br><span class="line">                  --enable-filter&#x3D;delogo</span><br><span class="line">                  --enable-debug</span><br><span class="line">                  --disable-optimizations</span><br><span class="line">                  --enable-libspeex</span><br><span class="line">                  --enable-shared</span><br><span class="line">                  --enable-pthreads</span><br></pre></td></tr></table></figure></li><li>Windows平台<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;ffmpeg</span><br><span class="line">                  --enable-gpl</span><br><span class="line">                  --enable-nonfree</span><br><span class="line">                  --enable-libfdk-aac</span><br><span class="line">                  --enable-libx264</span><br><span class="line">                  --enable-libx265</span><br><span class="line">                  --enable-filter&#x3D;delogo</span><br><span class="line">                  --enable-debug</span><br><span class="line">                  --disable-optimizations</span><br><span class="line">                  --enable-libspeex</span><br><span class="line">                  --enable-static</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="问：make-amp-amp-make-install失败"><a href="#问：make-amp-amp-make-install失败" class="headerlink" title="问：make &amp;&amp; make install失败"></a>问：make &amp;&amp; make install失败</h2><p>答：make &amp;&amp; make install 之所以会失败，则由于该用户没有操作目录的权限引起的。所以只需要在make install 之前加 sudo即可。</p><p>另一种方法是将用户切换成 root用户，因 root用户的权力最大，所以这样做也是没问题的。但建议还是用 非 root用户操作，这样更安全。</p><h2 id="问：库已经安装好了，但仍报找不到它的错误？"><a href="#问：库已经安装好了，但仍报找不到它的错误？" class="headerlink" title="问：库已经安装好了，但仍报找不到它的错误？"></a>问：库已经安装好了，但仍报找不到它的错误？</h2><p>答：首先确认是否已经将 <code>pkg-config</code>工具安装好了。可以执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config</span><br></pre></td></tr></table></figure><p>如果提示没有安装，则先将该工具安装好，安装命令如下：</p><ul><li>ubuntu  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt intall pkg-config</span><br></pre></td></tr></table></figure></li><li>mac  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install pkg-config</span><br></pre></td></tr></table></figure></li><li>cygwin  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cyg install pkg-config</span><br></pre></td></tr></table></figure></li><li>centos  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install pkg-config</span><br></pre></td></tr></table></figure>安装完该工具后仍然报错？那再按照具体的错误看下面的解决方案吧。</li></ul><h2 id="问：libx264库找不到（-ERROR-libx264-not-found-）"><a href="#问：libx264库找不到（-ERROR-libx264-not-found-）" class="headerlink" title="问：libx264库找不到（[ERROR: libx264 not found]）"></a>问：libx264库找不到（[ERROR: libx264 not found]）</h2><p>该问题可能由下面三个方面的问题引起。</p><ul><li>libx264库没有安装。对于这种情况有两种解决办法:<ul><li>其一，是通过平台的安装工作进行安装，如 apt/brew/yum install x264。（注：在Linux下应该安装 libx264-dev）。</li><li>其二，是通过源码安装，步骤如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. wget https:&#x2F;&#x2F;code.videolan.org&#x2F;videolan&#x2F;x264&#x2F;-&#x2F;archive&#x2F;master&#x2F;x264-master.tar.bz2</span><br><span class="line">2. bunzip2 x264-master.tar.bz2</span><br><span class="line">3. tar -vxf x264-master.tar.tar</span><br><span class="line">4. .&#x2F;configure --enable-static --enable-shared --disable-asm --disable-avs</span><br><span class="line">5. make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure></li></ul></li><li>通过 pkg-config 命令无法找到。对于这类问题，我们可以使用下面的命 <code>pkg-config --cflags --lib libx264</code>看是否可以找到 libx264，如果找不到，就说明确实是这个问题。解决的办法是设置环境变量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PKG_CONFIG_PATH&#x3D;$PKG_CONFIG_PATH:&#x2F;xxx&#x2F;xxx&#x2F;lib&#x2F;pkgconfig</span><br></pre></td></tr></table></figure>其中 <code>xxx</code> 由你的实际路径代替。</li></ul><blockquote><p>注，有可能你的系统中并没有装 pkg-config工具，可以使用 brew/apt/yum install pkg-config进行安装。</p></blockquote><ul><li>无法链接上libx264, 这是由于通过环境变量 LD_LIBRARY_PATH 无法定位到 libx264库。解决的办法也很简单，与上面类似，可以通过设置环境变量来解决该问题。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH&#x3D;$LIB_LIBRARY_PATH:&#x2F;xxx&#x2F;xxx&#x2F;lib</span><br></pre></td></tr></table></figure>其中，<code>xxx</code>由你的实际路径代替。</li></ul><p>当然，你也可以将环境变量设置在脚本里，这样就不用每次都写export命令了。只需要将上面的两条语句加入到 <del>/.bashrc / 或</del>/.bash_profil 文件里，然后在控制台执行 <code>source ~/.bashrc</code> 或 <code>source ~/.bash_profile</code>即可。</p><h2 id="问：fdk-aac库找不到（-ERROR-libfdk-aac-not-found-）"><a href="#问：fdk-aac库找不到（-ERROR-libfdk-aac-not-found-）" class="headerlink" title="问：fdk-aac库找不到（[ERROR: libfdk_aac not found]）"></a>问：fdk-aac库找不到（[ERROR: libfdk_aac not found]）</h2><p>答：该问题与上面的 libx264 问题类似，所以只需要将上面的 libx264替换为libfdk-aac即可。这里不在赘述。</p><h2 id="问：speex库找不到（-ERROR-speex-not-found-）"><a href="#问：speex库找不到（-ERROR-speex-not-found-）" class="headerlink" title="问：speex库找不到（[ERROR: speex not found]）"></a>问：speex库找不到（[ERROR: speex not found]）</h2><p>答：该问题与上面的 libx264 问题类似，所以只需要将上面的 libx264替换为speex即可。这里不在赘述。</p><h2 id="问：编译不出ffplay"><a href="#问：编译不出ffplay" class="headerlink" title="问：编译不出ffplay"></a>问：编译不出ffplay</h2><p>答：引起该问题有以下几方面的原因：</p><ul><li>所使用的操作系统没有安装图形库。如有的同学在阿里的云服务器上想安装ffplay是肯定不行的。</li><li>没有安装 SDL2 库。解决办法是通过 brew/apt/yum install sdl2 即可 或 通过 SDL2 源码安装。<strong>安装完成后，要重新进行到 ffmpeg目录下，执行 ./configure…这指命令。</strong></li><li>有的同学编译ffmpeg时，在ffmpeg目录执行./configure … 之后，没有修改config.h文件，这样也编译不出ffplay来。解决办法是进入到 ffmpeg 目录下，打开 config.h文件找 FFPLAY 关键字，将其后面的 0 修改为 1，保存并退出该文件。在当前目录下执行 make &amp;&amp; sudo  make install。<strong>注意，修改 config.h文件后，不要再执行./configure …了，否则config.h中的值又都恢复为原来的值了。</strong></li><li>SDL2与最新的Mac系统 mojave不兼容。解决办法：<ul><li>方法一<ul><li>从 <a href="https://www.libsdl.org/tmp/release/SDL2-2.0.9.tar.gz" target="_blank" rel="noopener">SDL</a>下载 2.0.9版本或以后的SDL2代码。</li><li>执行 ./configure</li><li>执行 make &amp;&amp; sudo make install</li><li>执行 export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig</li><li>[重新]编译ffmpeg</li></ul></li><li>方法二<ul><li>从<a href="https://www.libsdl.org/tmp/release/SDL2-2.0.9.dmg" target="_blank" rel="noopener">SDL</a>下载dmg包。</li><li>执行 open SDL2-2.0.9.dmg</li><li>[重新]编译ffmpeg</li></ul></li></ul></li></ul><h2 id="SDL在windows的-cygwin下无法打印日志"><a href="#SDL在windows的-cygwin下无法打印日志" class="headerlink" title="SDL在windows的 cygwin下无法打印日志"></a>SDL在windows的 cygwin下无法打印日志</h2><p>在编译 SDL 时，将configure 中的 <code>-mwindows</code> 参数去掉。</p><h2 id="问：如何在Windows下编译ffmpeg问题"><a href="#问：如何在Windows下编译ffmpeg问题" class="headerlink" title="问：如何在Windows下编译ffmpeg问题"></a>问：如何在Windows下编译ffmpeg问题</h2><p>答：参见 <a href="https://www.imooc.com/article/247113" target="_blank" rel="noopener">Windows下编译ffmpeg问题</a></p><h2 id="问：在Windows下编译安装ffmpeg是不是特别麻烦？"><a href="#问：在Windows下编译安装ffmpeg是不是特别麻烦？" class="headerlink" title="问：在Windows下编译安装ffmpeg是不是特别麻烦？"></a>问：在Windows下编译安装ffmpeg是不是特别麻烦？</h2><p>答：确实是这样。所以建议在Window开发者最好装一个 Ubuntu的虚拟机，这样就方便很多了。如果条件允许的话，最好能用Mac开发。可以说Mac Pro是关专为开发者制造的，一旦你用上它会让你爱不释手。</p><h2 id="问：编译时，各种库找不到问题"><a href="#问：编译时，各种库找不到问题" class="headerlink" title="问：编译时，各种库找不到问题"></a>问：编译时，各种库找不到问题</h2><p>答：该问题与上面的 libx264类似，我们可以通过 <code>brew/apt/yum install xxx</code> 命令进行安装，一般情况下这种方式都可以满足我们的需求。如果始终不行的话，就需要源码安装了。源码安装的方法可以参见 <a href="https://www.imooc.com/article/247113" target="_blank" rel="noopener">Windows下编译ffmpeg问题</a> 里的说明。</p><h2 id="问：ffmpeg如何使用-libx265"><a href="#问：ffmpeg如何使用-libx265" class="headerlink" title="问：ffmpeg如何使用 libx265"></a>问：ffmpeg如何使用 libx265</h2><p>答：准确的讲ffmpeg应该是一个音视频框架，所有的音视频编解码器都是以插件的方式与ffmpeg联系起来的。换句话说，ffmpeg在上层提供了统一的 API，无法你使用的编解决是 x264, open264, x265, vp8/vp9/av1 上层用户都不管心，它仍然使用同样的 API， 只是在find_decoder 或 find_encoder时，指定具体的编解码器就可以了。也就是说在find_xxx时，你要设置了 x264 它最终就会调用 x264进行编解码，设置了 x265它就使用 x265进行编解码。如些而已。</p><h2 id="问：这门课有群吗？"><a href="#问：这门课有群吗？" class="headerlink" title="问：这门课有群吗？"></a>问：这门课有群吗？</h2><p>答：有的，群号：883069602，不过<a href="https://coding.imooc.com/class/279.html?mc_marking=59c321c0417e144904c49c366f94dd57&mc_channel=shouji" target="_blank" rel="noopener">需要购买课程</a>后输入验证码才可以进群。大家可以在群里讨论问题，也可以在课程的评论区里搜索答案。目前评论区里已经积累了大量问题的解决方案。</p><h2 id="问：为什么我使用课程中的程序无法成功抽取AAC音频？"><a href="#问：为什么我使用课程中的程序无法成功抽取AAC音频？" class="headerlink" title="问：为什么我使用课程中的程序无法成功抽取AAC音频？"></a>问：为什么我使用课程中的程序无法成功抽取AAC音频？</h2><p>答：<a href="https://www.imooc.com/article/254733" target="_blank" rel="noopener">详细回答在这里</a></p><h2 id="问：Android播放器例子为什么调API失败"><a href="#问：Android播放器例子为什么调API失败" class="headerlink" title="问：Android播放器例子为什么调API失败"></a>问：Android播放器例子为什么调API失败</h2><p>答：你目前使用的 NDK 版本与我编译时使用的 NDK 版本不一致造成的，换成 NDK10e试试。</p><h2 id="问：NDK10e-从哪里下载"><a href="#问：NDK10e-从哪里下载" class="headerlink" title="问：NDK10e 从哪里下载"></a>问：NDK10e 从哪里下载</h2><p>答：可以到<a href="https://developer.android.com/ndk/downloads/older_releases" target="_blank" rel="noopener">这里</a>下载。</p><ul><li><a href="https://dl.google.com/android/repository/android-ndk-r10e-darwin-x86_64.zip" target="_blank" rel="noopener">mac NDK10e</a></li><li><a href="https://dl.google.com/android/repository/android-ndk-r10e-windows-x86.zip" target="_blank" rel="noopener">windows 32 位 NDK10e</a></li><li><a href="https://dl.google.com/android/repository/android-ndk-r10e-windows-x86_64.zip" target="_blank" rel="noopener">windows 64位 NDK10e</a></li><li><a href="https://dl.google.com/android/repository/android-ndk-r10e-linux-x86_64.zip" target="_blank" rel="noopener">linux NDK10e</a></li></ul><h2 id="问：NDKr21-从哪里下载"><a href="#问：NDKr21-从哪里下载" class="headerlink" title="问：NDKr21 从哪里下载"></a>问：NDKr21 从哪里下载</h2><p>答：可以到这里下载。</p><ul><li><a href="https://dl.google.com/android/repository/android-ndk-r21-darwin-x86_64.zip" target="_blank" rel="noopener">mac NDKr21</a></li><li><a href="https://dl.google.com/android/repository/android-ndk-r21-windows-x86_64.zip" target="_blank" rel="noopener">windows NDKr21</a></li><li><a href="https://dl.google.com/android/repository/android-ndk-r21-linux-x86_64.zip" target="_blank" rel="noopener">linux NDKr21</a></li></ul><h2 id="问：ffmpeg安装好后，编译视频中的ffmpeg-log不成功"><a href="#问：ffmpeg安装好后，编译视频中的ffmpeg-log不成功" class="headerlink" title="问：ffmpeg安装好后，编译视频中的ffmpeg_log不成功"></a>问：ffmpeg安装好后，编译视频中的ffmpeg_log不成功</h2><p>答：执行下面的命令进行编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -o ffmpeg_log ffmpeg_log.c &#96;pkg-config --libs --cflags libavutil&#96;</span><br></pre></td></tr></table></figure><p><strong>注意：pkg-confg 前面的符号不是<code>&#39;</code>哟！它是键盘左上角 ESC键下面的键。</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>该文章会不定期更新，我们将一些大家使用<a href="https://coding.imooc.com/class/279.html?mc_marking=59c321c0417e144904c49c366f94dd57&mc_channel=shouji" target="_blank" rel="noopener">ffmpeg</a>常见的问题更新到这里来。</p><h2 id="视频课地址"><a href="#视频课地址" class="headerlink" title="视频课地址"></a>视频课地址</h2><p><a href="https://www.imooc.com/u/4873493/courses?sort=publish" target="_blank" rel="noopener">课程主页地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 音视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffmpeg </tag>
            
            <tag> 音视频 </tag>
            
            <tag> 直播 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音视频系统入门常见问题</title>
      <link href="/631d466a/"/>
      <url>/631d466a/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/av_base/question.jpg" alt=""></p><p>同学们在学习《音视频课小白系统入门》这门课的过程中，经常遇到一些问题，如Mac系统下为什么无法编译ffmpeg? Xcode编译课程中的程序为什么不成功? 为什么我从设备中读的数据很小?等等不足而一。</p><p>实际上，大部分同学提出的问题都是重复的。因此，我将一些最常见的问题整理出了答案放在这里，同学们可以根据自己的情况去查找相应的解决办法，以免我个人原因不能及时回答问题时，给大家的学习造成麻烦和不便。</p><a id="more"></a><h2 id="Q-遇到下面的问题该怎么办？"><a href="#Q-遇到下面的问题该怎么办？" class="headerlink" title="Q: 遇到下面的问题该怎么办？"></a>Q: 遇到下面的问题该怎么办？</h2><p><img data-src="https://cdn.avdancedu.com/image/article/av_base/mac_error.png" alt=""></p><p>如果你的程序可以正常运行，这个错误可以忽略，这应该是Mac新版本引入的问题。</p><h2 id="Q-在-Mac-10-15-3-系统下编译-ffmpeg-成功后，在运行-ffmpeg-命令时出现crash"><a href="#Q-在-Mac-10-15-3-系统下编译-ffmpeg-成功后，在运行-ffmpeg-命令时出现crash" class="headerlink" title="Q: 在 Mac 10.15.3 系统下编译 ffmpeg 成功后，在运行 ffmpeg 命令时出现crash."></a>Q: 在 Mac 10.15.3 系统下编译 ffmpeg 成功后，在运行 ffmpeg 命令时出现crash.</h2><p>A: 重新编译ffmpeg，在执行 ./configure 时增加 –extra-cflags=”fno-static-check” 选项，注意该选项一定要放在前面，否则编译有问题。</p><h2 id="Q-在Mac下添加-–extra-cflags-”fno-static-check”-选项仍然-crash"><a href="#Q-在Mac下添加-–extra-cflags-”fno-static-check”-选项仍然-crash" class="headerlink" title="Q: 在Mac下添加 –extra-cflags=”fno-static-check” 选项仍然 crash"></a>Q: 在Mac下添加 –extra-cflags=”fno-static-check” 选项仍然 crash</h2><p>A: 编译时保持尽量少的参数，应该是与其它一些参数有突冲。</p><h2 id="Q-无论通过何种方式编译出的ffmpeg都会引发crash，如何解决？"><a href="#Q-无论通过何种方式编译出的ffmpeg都会引发crash，如何解决？" class="headerlink" title="Q: 无论通过何种方式编译出的ffmpeg都会引发crash，如何解决？"></a>Q: 无论通过何种方式编译出的ffmpeg都会引发crash，如何解决？</h2><p>A: 那就只能用命令的方式安装ffmpeg了，执行 <code>brew install ffmpeg</code>即可。</p><h2 id="Q-在Mac下，通过命令方式安装的ffmpeg没有带fdk-aac库怎么办"><a href="#Q-在Mac下，通过命令方式安装的ffmpeg没有带fdk-aac库怎么办" class="headerlink" title="Q: 在Mac下，通过命令方式安装的ffmpeg没有带fdk-aac库怎么办?"></a>Q: 在Mac下，通过命令方式安装的ffmpeg没有带fdk-aac库怎么办?</h2><p>A: 以命令方式安装带 fdk-aac 的ffmpeg需要按下面的步骤执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0. brew unstall ffmpeg</span><br><span class="line">1. brew tap homebrew-ffmpeg&#x2F;ffmpeg</span><br><span class="line">2. brew install homebrew-ffmpeg&#x2F;ffmpeg&#x2F;ffmpeg --with-fdk-aac</span><br></pre></td></tr></table></figure><p>注意，安装时如果报<code>ERROR: libsnappy not found</code> 错误，则你需要到<code>https://github.com/google/snappy</code>下载源码，并按照项目的说明编译并安装snappy库。</p><p>安装好snappy库后，重新执行<code>brew install homebrew-ffmpeg/ffmpeg/ffmpeg --with-fdk-aac</code>命令。</p><h2 id="Q-在Mac下通过命令方式安装ffmpeg库时，如何能带上其它第三方库呢？如x264"><a href="#Q-在Mac下通过命令方式安装ffmpeg库时，如何能带上其它第三方库呢？如x264" class="headerlink" title="Q: 在Mac下通过命令方式安装ffmpeg库时，如何能带上其它第三方库呢？如x264"></a>Q: 在Mac下通过命令方式安装ffmpeg库时，如何能带上其它第三方库呢？如x264</h2><p>A: 与上面安装ffmpeg带fdk-aac库的命令是类似的，命令格式为: <code>brew install ffmpeg --with-xxxx</code>，添加某个库的具体参数可以通过<code>homebrew-ffmpeg/ffmpeg/ffmpeg</code> 来查找。</p><h2 id="Q-Xcode-编译课程中的程序成功，但执行失败，报的错误是没有权限该如何解决？"><a href="#Q-Xcode-编译课程中的程序成功，但执行失败，报的错误是没有权限该如何解决？" class="headerlink" title="Q: Xcode 编译课程中的程序成功，但执行失败，报的错误是没有权限该如何解决？"></a>Q: Xcode 编译课程中的程序成功，但执行失败，报的错误是没有权限该如何解决？</h2><p>A:<br><img data-src="https://cdn.avdancedu.com/image/article/av_base/nopriv.jpg" alt=""></p><p>如果是上面这种错误信息，解决办法是: 在编译课程中的例子时，先将将沙盒关闭掉，在info.list中增加访问mic phone 访问权限。具体操作如下图所示:</p><p><img data-src="https://cdn.avdancedu.com/image/article/av_base/info.jpg" alt=""></p><h2 id="Q-info-plist加了权限仍然报没有权限怎么解决？"><a href="#Q-info-plist加了权限仍然报没有权限怎么解决？" class="headerlink" title="Q: info.plist加了权限仍然报没有权限怎么解决？"></a>Q: info.plist加了权限仍然报没有权限怎么解决？</h2><p>A: 按下图操作试试<br><img data-src="https://cdn.avdancedu.com/image/article/av_base/priv2.jpg" alt=""></p><h2 id="Q-引入ffmpeg库后，报libavformat-xxx-dylib-未签名，错误信息类似”code-signature…not-valid”"><a href="#Q-引入ffmpeg库后，报libavformat-xxx-dylib-未签名，错误信息类似”code-signature…not-valid”" class="headerlink" title="Q: 引入ffmpeg库后，报libavformat.xxx.dylib 未签名，错误信息类似”code signature…not valid”"></a>Q: 引入ffmpeg库后，报libavformat.xxx.dylib 未签名，错误信息类似”code signature…not valid”</h2><p>A:<br><img data-src="https://cdn.avdancedu.com/image/article/av_base/unsigned.jpg" alt=""><br>如果像上图所展示的一样，则按下面步骤操作：</p><ul><li><ol><li>打开 Mac 中的 keychain Access.app, 选择“我的证书”</li></ol></li><li><ol start="2"><li>执行 codesign -f -s “证书名” xxx.dylib</li></ol></li><li><ol start="3"><li>为了避免逐个签名，可以进行批量操作 codesign -f -s “证书名” /usr/local/ffmpeg/lib/*.dylib</li></ol></li></ul><h2 id="Q-ffmpeg-执行时提示没有权限执行ffmpeg"><a href="#Q-ffmpeg-执行时提示没有权限执行ffmpeg" class="headerlink" title="Q: ffmpeg 执行时提示没有权限执行ffmpeg"></a>Q: ffmpeg 执行时提示没有权限执行ffmpeg</h2><p>A: 将目录切换到你自己的用户目录下再执行ffmpeg试试。</p><h2 id="Q-在Linux虚似机中每次获取的音频数据很小，只有64个字节，如果进行重采样？"><a href="#Q-在Linux虚似机中每次获取的音频数据很小，只有64个字节，如果进行重采样？" class="headerlink" title="Q: 在Linux虚似机中每次获取的音频数据很小，只有64个字节，如果进行重采样？"></a>Q: 在Linux虚似机中每次获取的音频数据很小，只有64个字节，如果进行重采样？</h2><p>A: ffmpeg中最低采样个数为32个，所以只有 64 字节数据时，是无进行重采样的。解决办法是将数据放到一个缓冲区中，积攒到一定大小后，再进行重采样。</p><h2 id="Q-在从设备采体音频数据时，返回错误-35"><a href="#Q-在从设备采体音频数据时，返回错误-35" class="headerlink" title="Q: 在从设备采体音频数据时，返回错误 -35"></a>Q: 在从设备采体音频数据时，返回错误 -35</h2><p>A: 说明你的设备现在暂时还没准备好，此时你应该等待它几秒，之后就可以正常读数据了。例如：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while(re&#x3D;av_read_frame(...))&#123;</span><br><span class="line">   if(ret&#x3D;&#x3D;-35) &#123;</span><br><span class="line">       sleep(1);</span><br><span class="line">       continue;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Q-在编码时，编码器返回-35-错误"><a href="#Q-在编码时，编码器返回-35-错误" class="headerlink" title="Q: 在编码时，编码器返回 -35 错误"></a>Q: 在编码时，编码器返回 -35 错误</h2><p>A: 此时说明编码器没有准备好，像上面的一样需要等待一会儿。</p><h2 id="Q-采集到的音频数据编码-AAC-时，报无法找到libfdk-aac库"><a href="#Q-采集到的音频数据编码-AAC-时，报无法找到libfdk-aac库" class="headerlink" title="Q: 采集到的音频数据编码 AAC 时，报无法找到libfdk-aac库"></a>Q: 采集到的音频数据编码 AAC 时，报无法找到libfdk-aac库</h2><p>A: 如果是通过命令安装的ffmepg，则上面已经给了答案。下面的方案是通过源码编译出带fdk-aac的ffmeg。具体步骤如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 安装好 fdk-aac库</span><br><span class="line">2. 重新在ffmpeg源码目录下执行.&#x2F;configure 并增加--enable-libfdk-aac 参数</span><br><span class="line">3. make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h2 id="Q-在Linux中何采集音频数据"><a href="#Q-在Linux中何采集音频数据" class="headerlink" title="Q: 在Linux中何采集音频数据"></a>Q: 在Linux中何采集音频数据</h2><p>A: ffmpeg -f alsa -i hw:0,0 xxx.wav</p><h2 id="Q-在-Linux-中找不到-alsa-设备"><a href="#Q-在-Linux-中找不到-alsa-设备" class="headerlink" title="Q: 在 Linux 中找不到 alsa 设备"></a>Q: 在 Linux 中找不到 alsa 设备</h2><p>A：可以通过 arecord -l 查看你linux系统下有哪些音频设备。如果没有alsa, 可以使用  oss.<br>或安装alsa,安装方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install alsa-base alsa-utils alsa-source libasound2-dev</span><br></pre></td></tr></table></figure><p>当然，安装完alsa还只是完成了第一步，由于系统一开始没有alsa，所以你之前编译的ffmpeg是不包含alsa模块的，此时你需要到ffmpeg源码中，重新执行<code>./configure...</code>生成Makefile，之后执行<code>make install</code>进行编译安装</p><h2 id="Q-编译ffmpeg-时-filter-编译不过"><a href="#Q-编译ffmpeg-时-filter-编译不过" class="headerlink" title="Q: 编译ffmpeg 时 filter 编译不过"></a>Q: 编译ffmpeg 时 filter 编译不过</h2><p>A：选择使用 libstdc++ 库试试</p><h2 id="Q-Windows下编译ffmpeg"><a href="#Q-Windows下编译ffmpeg" class="headerlink" title="Q: Windows下编译ffmpeg"></a>Q: Windows下编译ffmpeg</h2><p>A:  <a href="https://trac.ffmpeg.org/wiki/CompilationGuide/MinGW" target="_blank" rel="noopener">https://trac.ffmpeg.org/wiki/CompilationGuide/MinGW</a></p><h2 id="Q-AAC-编码为-AAC-HE-V2-时，声音与原始声音不一样"><a href="#Q-AAC-编码为-AAC-HE-V2-时，声音与原始声音不一样" class="headerlink" title="Q: AAC 编码为 AAC_HE_V2 时，声音与原始声音不一样"></a>Q: AAC 编码为 AAC_HE_V2 时，声音与原始声音不一样</h2><p>A：这是因为老师用的 AAC 版本比较老，老版本的 AAC 与新版本的 AAC 可能有一些差异，这个我会后面查找一下原因。大家测试时可以将profile修改为 AAC HE 或 AAC LC，这样就可以正常编码出 AAC 数据了。</p><h2 id="Q-库已经安装好了，但仍报找不到它的错误？"><a href="#Q-库已经安装好了，但仍报找不到它的错误？" class="headerlink" title="Q: 库已经安装好了，但仍报找不到它的错误？"></a>Q: 库已经安装好了，但仍报找不到它的错误？</h2><p>A：首先确认是否已经将 <code>pkg-config</code>工具安装好了。可以执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config</span><br></pre></td></tr></table></figure><p>如果提示没有安装，则先将该工具安装好，安装命令如下：</p><ul><li>ubuntu  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt intall pkg-config</span><br></pre></td></tr></table></figure></li><li>mac  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install pkg-config</span><br></pre></td></tr></table></figure></li><li>cygwin  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cyg install pkg-config</span><br></pre></td></tr></table></figure></li><li>centos  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install pkg-config</span><br></pre></td></tr></table></figure>安装完该工具后仍然报错？那再按照具体的错误看下面的解决方案吧。</li></ul><h2 id="Q-libx264库找不到（-ERROR-libx264-not-found-）"><a href="#Q-libx264库找不到（-ERROR-libx264-not-found-）" class="headerlink" title="Q: libx264库找不到（[ERROR: libx264 not found]）"></a>Q: libx264库找不到（[ERROR: libx264 not found]）</h2><p>A:<br>该问题可能由下面三个方面的问题引起。</p><ul><li>libx264库没有安装。对于这种情况有两种解决办法:<ul><li>其一，是通过平台的安装工作进行安装，如 apt/brew/yum install x264。（注：在Linux下应该安装 libx264-dev）。</li><li>其二，是通过源码安装，步骤如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. wget https:&#x2F;&#x2F;code.videolan.org&#x2F;videolan&#x2F;x264&#x2F;-&#x2F;archive&#x2F;master&#x2F;x264-master.tar.bz2</span><br><span class="line">2. bunzip2 last_x264.tar.bz2</span><br><span class="line">3. tar -vxf last_x264.tar</span><br><span class="line">4. .&#x2F;configure --enable-static --enable-shared --disable-asm --disable-avs</span><br><span class="line">5. make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure></li></ul></li><li>通过 pkg-config 命令无法找到。对于这类问题，我们可以使用下面的命 <code>pkg-config --cflags --lib libx264</code>看是否可以找到 libx264，如果找不到，就说明确实是这个问题。解决的办法是设置环境变量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PKG_CONFIG_PATH&#x3D;$PKG_CONFIG_PATH:&#x2F;xxx&#x2F;xxx&#x2F;lib&#x2F;pkgconfig</span><br></pre></td></tr></table></figure>其中 <code>xxx</code> 由你的实际路径代替。</li></ul><blockquote><p>注，有可能你的系统中并没有装 pkg-config工具，可以使用 brew/apt/yum install pkg-config进行安装。</p></blockquote><ul><li>无法链接上libx264, 这是由于通过环境变量 LD_LIBRARY_PATH 无法定位到 libx264库。解决的办法也很简单，与上面类似，可以通过设置环境变量来解决该问题。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH&#x3D;$LIB_LIBRARY_PATH:&#x2F;xxx&#x2F;xxx&#x2F;lib</span><br></pre></td></tr></table></figure>其中，<code>xxx</code>由你的实际路径代替。</li></ul><p>当然，你也可以将环境变量设置在脚本里，这样就不用每次都写export命令了。只需要将上面的两条语句加入到 ~/.bashrc / 或~/.bash_profile 文件里，然后在控制台执行 <code>source ~/.bashrc</code> 或 <code>source ~/.bash_profile</code>即可。</p><h2 id="Q-通过-avcodec-find-encoder-by-name-无法找到编码器"><a href="#Q-通过-avcodec-find-encoder-by-name-无法找到编码器" class="headerlink" title="Q: 通过 avcodec_find_encoder_by_name() 无法找到编码器"></a>Q: 通过 avcodec_find_encoder_by_name() 无法找到编码器</h2><p>A：通过以下步骤进行解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0. 你使用的ffmpeg必须是经过源码编译的</span><br><span class="line">1. 你在编译 ffmpeg 时，执行.&#x2F;configure时是否将此编码器模块添加到 ffmpeg中了？以 fdk_aac 为例，在执行 .&#x2F;configure …时你应该加上 --enable-libfdk-aac 选项。</span><br><span class="line">2. 如果通过源码编译ffmpeg时有报错，请根据错误信息查看本文档的相应处理方法</span><br><span class="line">3. 确保 pkg-config 命令查询到的是你通过源码编译的ffmpeg库</span><br></pre></td></tr></table></figure><h2 id="Q-编译不出ffplay"><a href="#Q-编译不出ffplay" class="headerlink" title="Q: 编译不出ffplay"></a>Q: 编译不出ffplay</h2><p>A：引起该问题有以下几方面的原因：</p><ul><li>所使用的操作系统没有安装图形库。如有的同学在阿里的云服务器上想安装ffplay是肯定不行的。</li><li>没有安装 SDL2 库。解决办法是通过 brew/apt/yum install sdl2 即可 或 通过 SDL2 源码安装。<strong>安装完成后，要重新进行到 ffmpeg目录下，执行 ./configure…这指命令。</strong></li><li>有的同学编译ffmpeg时，在ffmpeg目录执行./configure …时没有添加 –enable-sdl2 选项也会导致无法编译出 ffplay</li><li>SDL2与最新的Mac系统 mojave不兼容。解决办法：<ul><li>方法一</li><li>从 <a href="https://www.libsdl.org/tmp/release/SDL2-2.0.9.tar.gz" target="_blank" rel="noopener">SDL</a>下载 2.0.9版本或以后的SDL2代码。</li><li>执行 ./configure</li><li>执行 make &amp;&amp; sudo make install</li><li>执行 export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig</li><li>[重新]编译ffmpeg</li><li>方法二</li><li>从<a href="https://www.libsdl.org/tmp/release/SDL2-2.0.9.dmg" target="_blank" rel="noopener">SDL</a>下载dmg包。</li><li>执行 open SDL2-2.0.9.dmg</li><li>[重新]编译ffmpeg</li></ul></li><li>如果是ubuntu系统可以用下面的命令安装  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install sdl2-dev</span><br></pre></td></tr></table></figure></li></ul><h2 id="Q-非Mac同学如何学习本课程"><a href="#Q-非Mac同学如何学习本课程" class="headerlink" title="Q: 非Mac同学如何学习本课程"></a>Q: 非Mac同学如何学习本课程</h2><p>A：本课程中的例子的界面是由 Swift 编写的，如果你没有 Mac 系统的话，你可以用 Qt 甚至不用界面开发，代码中与ffmpeg相着的代码都是跨平台的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://coding.imooc.com/class/415.html?mc_marking=b587280c0c1c0e76c1092aa21406565a&mc_channel=syb6" target="_blank" rel="noopener">音视频小白系统入门课</a></p>]]></content>
      
      
      <categories>
          
          <category> 音视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffmpeg </tag>
            
            <tag> 音视频 </tag>
            
            <tag> 直播 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客系统的实现原理与搭建</title>
      <link href="/2ef51851/"/>
      <url>/2ef51851/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/hexo/hexo-logo.png" alt=""></p><p>作为技术人员，定期写Blog是一个非常好的习惯。你可以通过它将自己的一些学习心得记录下来，也可以对平常的工作做一些经验总结等等。对于我来说Blog就更为重要了，因为Blog是我推广<strong>音视频技术</strong>的一块<strong>“阵地”</strong>，我需要将我写的一些<strong>音视频技术</strong>知识、视频课程中的问题解答等内容放在它上面，以便同学们交流学习。</p><a id="more"></a><p>以前，我的文章一直都在<strong>简书</strong>上发布，可最近不知为何，简书将我的账户封掉了。我经多次申诉却依然无果，既不告之那里违规，也不给我解封，真让人无语！考虑到在其它平台也可能遇到类似情况，因此决心搭建自己的博客，这样才能放心。</p><p>如何才能快速搭建一套比较专业的博客系统呢？通过调研，我发现开源项目<strong>hexo</strong>完全可以满足我的要求。它既可以发布文章，还支持一些常见的功能，如阅览数、文章字数统计、本地搜索等等。下面我就来详细讲述一下我是如何通过<strong>hexo</strong>搭建自已的博客系统的。</p><h2 id="Blog系统"><a href="#Blog系统" class="headerlink" title="Blog系统"></a>Blog系统</h2><p>在搭建Blog系统之前，我们有必要先了解一下Blog系统是干什么的，它都应该有哪些功能。</p><p>Blog是在2000年左右出现的，原本的称法为weblog，即网络日志。后来逐渐被人们改为 we blog，进而简称为Blog。Blog中的每一篇文章/日志就是一个页面，Blog将这些页面聚集在一起就形成了现在的形式。</p><p>现在大家在写Blog时已经很少直接写在页面里了，而是改用Markdown语法，这种语法非常简洁，特别适合我们平常的写作。所以现今的Blog系统最重要的一个环节就是，将Markdown语法写成的文档转化成HTML页面，然后放到Web服务器上发布出来。除此之外，Blog还要有一个管理系统可以将这些页面管理起来，如生成目录、标签，分类、搜索等等。</p><p>如果要我们自己实现这样一套系统还是非常麻烦的，好在已经有开源项目实现了，这就是<strong>hexo</strong>。hexo 不但实现了这些功能，还实现了很多其它的功能，如文章浏览次数、打赏、接入评论系统等等。这些功能对于我们来说都是非常有用的，然而在讲解如何搭建这些功能之前，我们先来了解一下hexo的实现原理，这样可以让我们更容易理解后面的知识。</p><h2 id="hexo基本原理"><a href="#hexo基本原理" class="headerlink" title="hexo基本原理"></a>hexo基本原理</h2><p>要了解hexo的实现原理，我们首先要知清楚 hexo 的目录结构，这样可以更有助于了解hexo。</p><p>hexo由以下几个重要文件/目录组成：</p><ul><li>_config.yml，该文件是hexo 的<code>站</code>级配置文件。所谓<strong>站</strong>级配置文件是指，对整个站点起效果的配置文件。</li><li>source目录，该目录存放源文件。即用户编写的博文都放在该目录下。在该目录下又有几个子目录我们来分别看一下。<ul><li>_post，用于存放博文，基本上每篇文章都是由Markdown语法编写的。</li><li>tags，存放tag 的文件。hexo中的tags是自动生成的，所以我们不用手动修改tags目录下的index.md文件，在发布时它会自动生成。</li><li>categories，存放<strong>分类</strong>。它与tags是类似的，也是自动生成的，所以不需要我们手工修改。</li><li>…</li></ul></li><li>themes目录，该目录用于存放主题，目前hexo中最热门的主题就是<strong>next</strong>了。最近的 next release 版本是 7.8 。</li><li>public目录，该目录存放hexo转出的文件，如html、css、js等。</li><li>scaffolds目录，它里面存放了一些<strong>“脚手架”</strong>程序，用于生成模板页面，如执行<code>hexo new &quot;title&quot;</code>时，就会生成一个Markdown文件模板。</li></ul><p>上面就是hexo中最重要的几个文件和目录了。</p><p>清楚之hexo目录结构之后，我们再来看看hexo的基本原理。</p><p>hexo最基本的功能是将Markdown程序转成HTML页面，而这个转换并不是一次完成的，要经历两步:</p><ul><li><p>第一步，将Markdown翻译成下面格式的JSON对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">article: &#123;</span><br><span class="line">  title:</span><br><span class="line">  date:</span><br><span class="line">  tags:</span><br><span class="line">  categories:</span><br><span class="line">  content:</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二步，根据上面生成的JSON对象生成 HTML 页面。</p></li></ul><p>对于我们来说，清楚了上面hexo将Markdown转HTML页面的过程后，我们就很容易理解hexo 在执行不同命令时它都在做什么事儿了。</p><p>下面我们再来看看<strong>hexo</strong>的组成，它由三部分组成: <strong>hexo-cli</strong>、<strong>hexo-core</strong>以及<strong>hexo plugs</strong>。在这三部分中最核心的是hexo-core模块，它的作用就是执行上面讲的两步转换，从而生成目标文件；hexo-cli为我们供了一些非常方便的命令。当我们敲入命令时，它会根据命令调用不同的模块；hexo plugin是hexo的扩展，当hexo本身不能完成某项任务时，它允许你自己开发一个插件来完成。当然你也可以使用其它人写好的插件。</p><p>上以就是hexo的基本原理。</p><h2 id="hexo的常用命令"><a href="#hexo的常用命令" class="headerlink" title="hexo的常用命令"></a>hexo的常用命令</h2><p><strong>hexo</strong> 提供了几个常用命令，如<code>hexo clean</code>、<code>hexo g</code>、<code>hexo s</code>等等。下面我们分别看一下这几个命令的具体作用是什么：</p><ul><li>hexo clean: 删除 hexo 生成的所有文档。当我们执行这个命令后，你会发现public目录被删除了。</li><li>hexo g: 根据 source 目录中的文件生成html等可以发布的文件。</li><li>hexo s: 在本地起动 <strong>http</strong> 服务，将生成的 html  等输出文件布署到本地服务器上。 </li><li>hexo d: 将生成的html代码推送到 github 上</li></ul><p>这几个命令的含义都非常清晰，我就不再做其它赘述了。</p><h2 id="hexo发布页面"><a href="#hexo发布页面" class="headerlink" title="hexo发布页面"></a>hexo发布页面</h2><p>如上面所介绍的，我们可以使用<code>hexo d</code>命令将生成的目标文件发布出来，但在使用它之前，你需要在站节点的_config.yml文件中配置发布的方法。我们举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- type: git #leancloud_counter_security_sync #git</span><br><span class="line">  repo: git@github.com:avdance&#x2F;avdance.github.io.git</span><br></pre></td></tr></table></figure><p>当我们执行<code>hexo d</code>命令时，它会调用 hexo 中的 <code>hexo-deployer-git</code> 插件。在该插件内部会启动一个进程调用<code>git</code>命令，从而将生成的html等代码上传到 github上。</p><p>这里可能有些同学会有疑问，为什么上传到github上就算是发布了呢？这是因为github为我们提供了免费的个人博客空间。只要你在github上创建一个<code>用户名.github.io</code>的项目，github就会自动将这个项目中的文件发布出来。</p><p>当然你也可以采用传输的方式，自己购买台云主机，然后在云主机上用ngnix、nodejs等搭建一个Web服务，最终将页面发布出来。</p><h2 id="next主题的安装与配置"><a href="#next主题的安装与配置" class="headerlink" title="next主题的安装与配置"></a>next主题的安装与配置</h2><p>hexo中有很多的主题，但其中用的最多的、最著名的就是<strong>next</strong>主题了。下面我们就来介绍一下，如何安装next主题并对其做一些简单的配置。</p><p>next的安装比简单了，你只需要将next源码从github上下载下来，然后放到hexo的themes目录下即可。如下面这行语句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --branch v7.8.0 https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next.git themes&#x2F;next</span><br></pre></td></tr></table></figure><p>这里需要注意的是，我们在github中搜索关键字<code>hexo-theme-next</code>时，你会发现有两个github star数特别多，这两个地址分别是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;iissnan</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;theme-next</span><br></pre></td></tr></table></figure><p>上面的地址是next老版本的官方地址，下面这个是新版本的官方地址。你清楚他们之间的关系就不会给你造成混乱了。</p><p>next下载好后，下一步就是进行配置了。在themes/next目录下也有一个_config.yml文件，它是next主题的配置文件，千万不要将它与站点的_config.yml弄混了。</p><p>如果你要配置next主题时，需要修改的是themes/next目录下的_config.yml文件。</p><p>打开该文件，找到<code>Scheme</code>关键字，你会发现next支持多种Scheme。你可以根据喜好选择你自己喜欢的Scheme，我这里选择的是<code>Gemini</code>。选择好Scheme后，我们博客的基本结构就定下来了。接下来你可以对它进行配置了。具体的配置我会在下面再做详细论述。</p><p>当所有的配置都修改好后，你可以执行下面的命令将博客发布出来了。</p><blockquote><ul><li>hexo clean</li><li>hexo g</li><li>hexo s</li></ul></blockquote><h2 id="高级知识"><a href="#高级知识" class="headerlink" title="高级知识"></a>高级知识</h2><p>通过上面的操作，我们就将自己的Blog搭建好了。但此时这个Blog还只是一个最基本、最简单的Blog。如果你想让你的Blog更专业的话，还要对它进行细细的打磨。</p><p>接下来，我们就来看看还需要对我们的Blog做哪些处理?</p><ul><li>为文章设置摘要</li><li>增加图片床</li><li>统计阅读次数</li><li>显示文章字个数</li><li>添加评论区</li><li>文章置顶</li><li>设置标签</li><li>设置标签云</li><li>增加本地搜索</li><li>设置关于</li><li>设置404</li><li>SEO优化</li></ul><p>下面我们就按着这个清单细细打磨我们的Blog吧。</p><h3 id="为文章设置摘要"><a href="#为文章设置摘要" class="headerlink" title="为文章设置摘要"></a>为文章设置摘要</h3><p>在hexo中实现摘要有两种方法，一种主是在正文中加入如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure><p>它的作用是将<code>more</code>之前的文字作为摘要。</p><p>需要注意的是，一般情况下摘要都在 200 字以内，所以你自己要控制好放置<code>more</code>的位置。这种方式是我最常使用的方式，感觉非常方便。</p><p>第二种方法是，在文章头的 <code>description</code> 域写摘要，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: xxxx</span><br><span class="line">date: xxxx-xx-xx</span><br><span class="line">...</span><br><span class="line">description: xxxxxxx...</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>这处方式的好处是，可以将文中某一段设置为摘要，或者自己单独写一段摘要。所以这种方式更灵活，也更便于做 SEO 优化。</p><p>以上两种方法都可以，你可以根据自己的习惯选择最合适自已的方法。</p><h3 id="增加图片床"><a href="#增加图片床" class="headerlink" title="增加图片床"></a>增加图片床</h3><p>我们文章发布时，一般都是通过github发布出来，但必竟github给我们每个人的资源是有限的。如果你在github上放一些特别大的文件的话，那么你博客的访问速度一定很慢，甚至会严重影响用户的体验。</p><p>另外不论你在哪儿发布文章，一条必须遵守的原则是，尽量避免在主站上放置特别大的文件，尤其是图片。但现实是残酷的，有写作经验的同学都知道，在文章中放一些图片不但可以让读者更容易理解的要表达的思想，而且还有美化文章的作用。</p><p>如何解决上述的矛盾呢？ 答案就是使用<strong>图床</strong>。所谓图床，其实就是使用云存储(像阿里云、腾讯云、七牛云)来存储图片，然后用CDN进行加速。这样可以大大优化网站的访问速度。</p><p>我搭建的Blog使用的就是阿里云的云加速。对于使用阿里云加速的方法我这里就不赘述了，有兴趣的小伙伴可以到阿里的官网上自行查阅使用说明。</p><h3 id="统计阅读次数"><a href="#统计阅读次数" class="headerlink" title="统计阅读次数"></a>统计阅读次数</h3><p>由于hexo自己没有提供数据库的功能，因此对文章访问次数的统计需要通过第三方云服务来提供支持。</p><p>大多数情况下，我们使用leancloud做服务统计，而且hexo中也实现了与之相关的接入代码。当然，你也可以通过云数据库来实现这个功能，至于你选择那种方案就看你自己的喜好了。</p><p>下面我就来介绍一下通过leancloud如何实现统计阅读次数这一功能。</p><p>首先，你要注册一个leancloud账户。leancloud上提供了两种用户类型，一种是developer，一种是商业用户。developer用户是免费的，但有限制。不过这种限制对于我们这种访问量很少的Blog来说是无所谓的。</p><p>注册好用户后，我们需要在leancloud上创建一个<strong>class</strong>，这里的<code>class</code>类似于关系型数据库中的表。class的名子是固定的，必须是<code>Counter</code>，只有这样 hexo 才能将数据保存到leancloud上，也才能真正的实现阅读量的统计，</p><p>leancloud class创建好后，我们就要对hexo进行配置了。实际上，真正进行统计的模块是next。如果你使用的是其它主题的话，那就要找对应的统计方法。</p><p>对于next来说，它的V5版本与V7版本在使用leancloud的方法是不一样的。据说V5版本存在统计漏洞，很容易被黑客攻击，因此改为现然V7的方式了。</p><p>不过经我测试，V5的方式配置起来比较简单，V7的方式我没有验证通过。也就是说，通过V7的方法无法进行阅读量统计。我想一定是我那里没有配置对，希望有这方面经验的同学可以分享一下。</p><p>下面我们来看看如何修改next的配置使其与leancloud相联(这里讲的是V5的方法)。打开themes/next目录下的_config.yml文件，找到<code>leadcloud_visitors</code>关键字，修改其配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leancloud\_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app\_id: &lt;your app id&gt;</span><br><span class="line">  app\_key: &lt;your app key&gt;</span><br></pre></td></tr></table></figure><p>这三个字段的含义如下，<code>enable</code>表示是否开启leadcloud_visitors功能，所以这个选项我们要修改为true；<code>app_id</code>是你注册leancloud时分配给你的ID; <code>app_key</code>也是你注册leancloud时分配的。只要我们将上面的参数配置好后，当你再浏览你的文章时，就会发现访问次数发生变化了。</p><h3 id="统计文章字数"><a href="#统计文章字数" class="headerlink" title="统计文章字数"></a>统计文章字数</h3><p>hexo本身并不支持文章字数的统计，因此要想实现这一功能我们需要安装一个插件，即<code>hexo-symbols-count-time</code>。在以前，大家都使用wordcount插件，但到了next V6之后<code>hexo-symbols-count-time</code>逐渐替代了<code>wordcount</code>。</p><p>下面我们来看一下如何使用<code>hexo-symbols-count-time</code>插件。使用它之前我们需要先将其安装好，执行下面的命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure><p>hexo-symbols-count-time插件安装完成后，我们要修改两个配置文件: hexo 中的_config.yml文件和next主题中的_config.yml文件。</p><p>第一步，修改hexo中的_config.xml的<code>symbols\_count\_time</code>项，修改配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 设置博客单词统计</span><br><span class="line">symbols_count_time:</span><br><span class="line">  # 文章字数统计</span><br><span class="line">  symbols: true</span><br><span class="line">  # 文章阅读时间统计</span><br><span class="line">  time: true</span><br><span class="line">  # 站点总字数统计</span><br><span class="line">  total_symbols: false</span><br><span class="line">  # 站点总阅读时间统计</span><br><span class="line">  total_time: false</span><br><span class="line">  exclude_codeblock: false</span><br></pre></td></tr></table></figure><p>第二步，修改 themes/next 目录下的 _config.yml 文件，仍然找 <code>symbols_count_time</code> 项，配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 设置博客单词统计</span><br><span class="line">symbols_count_time:</span><br><span class="line">  # 是否另起一行（true的话不和发表时间等同一行）</span><br><span class="line">  separated_meta: true</span><br><span class="line">  # 首页文章统计数量前是否显示文字描述（本文字数、阅读时长）</span><br><span class="line">  item_text_post: true</span><br><span class="line">  # 页面底部统计数量前是否显示文字描述（站点总字数、站点阅读时长）</span><br><span class="line">  item_text_total: false</span><br><span class="line">  # 平均字长</span><br><span class="line">  awl: 4</span><br><span class="line">  # 每分钟阅读字数</span><br><span class="line">  wpm: 275</span><br></pre></td></tr></table></figure><p>上面的配置修改后，文章字数统计功能就算配置好了，现在只要你重新生成静态页面，然后发布出来就可以看到效果了。</p><h3 id="如何添加评论系统"><a href="#如何添加评论系统" class="headerlink" title="如何添加评论系统"></a>如何添加评论系统</h3><p>hexo还可以接入评论系统，而且可以接入多种评论系统。在从多的评论系统中，Valine是其中一款比较出众的评论系统。</p><p>hexo接入valine非常容易，就像之前介绍的接入阅读统计系统一样，它也需要在leancloud系统上创建一个类，即 <code>Comment</code>类，用于保存用户的评论。</p><p>因此我们在接入用户评论系统时，需要经过以下几步:</p><ul><li>第一步，在leancloud上创建comment类；</li><li>第二步，修改 themes/next 目录下的_config.yml 文件，做如下配置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: true #是否接入valine 系统</span><br><span class="line">  appid:  #LeanClound获得的appid</span><br><span class="line">  appkey: #LeanClound获得的appkey</span><br><span class="line">  notify: false # 邮件提醒</span><br><span class="line">  verify: false # Verification code</span><br><span class="line">  placeholder: 欢迎畅所欲言 # 占位字符串 </span><br><span class="line">  avatar: mm #默认头像设置</span><br><span class="line">  guest_info: nick #评论区的title </span><br><span class="line">  pageSize: 10 # Pagination size</span><br><span class="line">  language: zh-cn # Language, available values: en, zh-cn # 语言，设为zh-cn</span><br><span class="line">  # 是否开启当前文章阅读量统计</span><br><span class="line">  visitor: false #这个要设置为false，以免与 leancloud_visitors 突冲 </span><br><span class="line">  comment_count: true #是否在主页里也显示评论个数，为false是不显示</span><br></pre></td></tr></table></figure></li></ul><p>通过上面的设置后，你就可以在文章中看到评论区了。</p><p>实际上，我们还可以真对每一篇文章单独设置是否显示评论区，如何做呢？</p><p>只要你在想要关闭评论区的文章头加上<code>comments: false</code>这句即可。具体例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2019-07-18 15:16:50</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure><p>到此为止，我们就将评论系统接入到我们的博客中了。</p><h3 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h3><p>文章写好后，有一些我们认为特别好的文章希望置顶，这该如何做呢？</p><p>hexo默认的方式是按时间顺序排放文章的，也就是最后写完的文章会放在最一个。如果要打破这个规则，我们就需要给它建立一个新规则。</p><p>应该定义个什么样的规则呢？实际上已经有人帮我们想好了，就是给文章做个编号，有编号的优先排序，并且按照编号进行排序；而没有编号的再按时间排序，这样就解决了我们想将文章顶置的需求。</p><p>更好的消息时，现在hexo已经有了这样一个新的排序插件叫<code>hexo-generator-index-pin-top</code>，我们只需要用它替换原来老的排序插件即可。具体操作步骤如下：</p><ul><li>先将老的排序插件删除掉<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn remove hexo-generator-index</span><br></pre></td></tr></table></figure></li><li>按装新插件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-generator-index-pin-top</span><br></pre></td></tr></table></figure></li></ul><p>光安装好插件还不行，我们要想让文章置顶还要修改文章的title域，在title域中增加一个<strong>top</strong> 域，这样这篇文章就会被置顶了。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">----</span><br><span class="line">title: xxxx</span><br><span class="line">date: xxxx-xx-xx</span><br><span class="line">...</span><br><span class="line">top: 1</span><br><span class="line">...</span><br><span class="line">----</span><br></pre></td></tr></table></figure><p>经上面这样设置后，我们想置顶的文章就会跑到主页的顶部，马上去试试看吧。</p><p>不过这里还有一个小问题，文章是置顶了，但对于用户来说却感受不到。从用户的角度看，如果不仔细观察的话还真不会发现前面几篇文章是置顶文章。有没有办法可以将置顶文章做个标识呢？</p><p>当然有办法，不过我们需要修改一点next主题的代码了。我们进行到<code>next/layout/_macro</code>目录下，打开post.swig文件，找到 <code>&lt;div class=&quot;post-meta&quot;&gt;</code> 标记，然后在它下面添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">  &lt;i class&#x3D;&quot;fa fa-thumb-tack&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  &lt;font color&#x3D;7D26CD&gt;置顶&lt;&#x2F;font&gt;</span><br><span class="line">  &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>经过这样的设置后，我就可以在博客主页中看到前面被置顶的文章被打上标记了。打开<a href="https://blog.avdancedu.com">我的博客</a>你应该就可以看到真实的效果了。</p><h3 id="如何开启打赏功能"><a href="#如何开启打赏功能" class="headerlink" title="如何开启打赏功能"></a>如何开启打赏功能</h3><p>hexo 中 next 主题开启打赏功能非常简单，只要稍微配置一下就可以了。在里需要普及一些支付的基本知识，对于正常的支付来说，当用户点击打赏时，可以选择要打赏的金额，之后应该调用腾讯或阿里的支付接口，最终完成支付。但对于hexo来说，显然它做不了这么复杂的交互逻辑，那它是如何做的呢？</p><p>实际上，它只是将微信/支付完的收款二维码放到网页上面来实现打赏功能的。具体的步骤如下：</p><ul><li>生成收款二维码，打开微信/支付宝，将收款二维码保存成图片。</li><li>编辑next主题下面的_config.xmy文件，将该文件中的<code>reward\_settings</code>打开即可。具体配置如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Reward (Donate)</span><br><span class="line">reward\_settings:</span><br><span class="line">  enable: true</span><br><span class="line">  animation: true</span><br><span class="line">  comment: 只想买包辣条</span><br><span class="line"></span><br><span class="line">reward:</span><br><span class="line">  wechatpay: &#x2F;images&#x2F;wechatpay.png   #微信收款码</span><br><span class="line">  alipay: &#x2F;images&#x2F;alipay.png   #支付宝收款码</span><br><span class="line">  #bitcoin: &#x2F;images&#x2F;bitcoin.png</span><br></pre></td></tr></table></figure></li></ul><p>通过上面的设置，我们就将hexo的打赏功能设置好了。</p><h3 id="添加标签和分类"><a href="#添加标签和分类" class="headerlink" title="添加标签和分类"></a>添加标签和分类</h3><p>在hexo中给文章添加标签并给文章分类很容易，只要在文章头里加 <code>tags</code> 和<code>categories</code>域即可。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: xxx    &#x2F;&#x2F;在此处添加你的标题。</span><br><span class="line">date: 2016-10-07 13:38:49   &#x2F;&#x2F;在此处输入编辑这篇文章的时间。</span><br><span class="line">tags: [aaa, bbb, ccc]    &#x2F;&#x2F;在此处输入这篇文章的标签。</span><br><span class="line">categories: xxx, yyy    &#x2F;&#x2F;在此处输入这篇文章的分类。</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>通过上面的例子我们可以看到，可以给一篇文章增加多个tag，也可以将文章划分到多个不同的类别中去。</p><p>除了在文章中我们可以给文章打多个标签和分类外，我们还应该将hexo next中的标签/分类入口打开，这样可以方便用户查看博客中所有的标签和分类，从而可以快速找到它们感兴趣的文章。</p><p>具体做法如下，进入到 themes/next 目录，打开_config.yml 文件，找到<code>menu</code>项，配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">home: &#x2F;|| home</span><br><span class="line">tags: &#x2F;tags&#x2F;|| tags</span><br><span class="line">categories: &#x2F;categories&#x2F;|| th</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过上面的配置，我们就将<strong>标签</strong>和<strong>分类</strong>入口打开了。不过光打开入口还不行，我们还要创建 tag 和 categories 目录和文章，执行下面的命令即可完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags&#x2F;categories</span><br></pre></td></tr></table></figure><p>执行完上述命令后，我们就可以在source目录下看到tags和categories目录了。</p><p>此时，我们重新执行<code>hexo g</code>生成页面，你就可以看到我们在文章中打的标签和分类被写到各目录的index文件中了。</p><h3 id="如何设置标签云"><a href="#如何设置标签云" class="headerlink" title="如何设置标签云"></a>如何设置标签云</h3><p>当我在浏览其它人使用hexo搭建的博客时，发现它的标签特别炫，有一些标签用的少就会是很小的字体，而一些经常用的标签则是很大的字体。经了解才知道这就是标签云。可以通过<code>hexo-tag-cloud</code>插件来实现。该插件除了可以实现我上面所说的功能外，还能在你的博客的左边或右边出现标签滚动的效果。</p><p>下面我们就来看看该如何设置标签云吧。第一步自然不必多说，一定是安装插件，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-tag-cloud --save</span><br></pre></td></tr></table></figure><p>插件安装好后，在站点的_config.yml文件中添加如下配置信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># hexo-tag-cloud 标签云 | see https:&#x2F;&#x2F;github.com&#x2F;MikeCoder&#x2F;hexo-tag-cloud</span><br><span class="line">tag_cloud:</span><br><span class="line">  textFont: Trebuchet MS, Helvetica # 字体</span><br><span class="line">  textColor: &#39;#555&#39; # 字体颜色</span><br><span class="line">  textHeight: 25 # 字体高度</span><br><span class="line">  outlineColor: &#39;#E2E1D1&#39; # 字体背景色</span><br><span class="line">  maxSpeed: 0.1 # 标签云最大移动速度</span><br></pre></td></tr></table></figure><p>上面的配置信息是用于控制标签云显示的效果的。其中，<code>maxSpeed</code>我们要介绍一下，该值为 1 时运转的速度最快，该值为0是基本处理不动的状态。当然如果你不喜欢标签滚动的效果，则可以不设置这些信息。</p><p>对于要达到滚动效果的标签云来说，光有这些信息还不够，还要修改一点代码。打开source/layout/_macro/sidevar.swig文件，在文中搜索找到<code>sidebar-inner</code> 的 div 元素，在其下面加入下面这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if site.tags.length &gt; 1 %&#125;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; charset&#x3D;&quot;utf-8&quot; src&#x3D;&quot;&#123;&#123; url_for(&#39;&#x2F;js&#x2F;tagcloud.js&#39;) &#125;&#125;&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; charset&#x3D;&quot;utf-8&quot; src&#x3D;&quot;&#123;&#123; url_for(&#39;&#x2F;js&#x2F;tagcanvas.js&#39;) &#125;&#125;&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;widget-wrap&quot;&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;myCanvasContainer&quot; class&#x3D;&quot;widget tagcloud&quot;&gt;</span><br><span class="line">    &lt;canvas width&#x3D;&quot;220&quot; height&#x3D;&quot;250&quot; id&#x3D;&quot;resCanvas&quot; style&#x3D;&quot;width&#x3D;100%&quot;&gt;</span><br><span class="line">        &#123;&#123; list_tags() &#125;&#125;</span><br><span class="line">    &lt;&#x2F;canvas&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>通过上面的配置我们就将标签云设置好了。</p><h3 id="如何添加本地搜索"><a href="#如何添加本地搜索" class="headerlink" title="如何添加本地搜索"></a>如何添加本地搜索</h3><p>在hexo中支持很多种搜索，这里我就不一一介绍了，我只用到了其中的本地搜索，并感觉hexo本地搜索的表现还是不错的，所以我也推荐大家用本地搜索。hexo本地搜索的原理很简单，就是通过hexo-generator-search插件在本地生成一个search.xml/json文件，通过这个文件实现搜索功能。</p><p>为hexo添中本地搜索功能的步骤很简单，第一步是按装插件，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search</span><br><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure><p>然后修改 hexo 下面的配置文件_config.yml，在其中增加下面配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><p>接下来我们把本地搜索入口打开，打开next/_config.yml文件，找到<code>local\_search</code>选项，将该选项设置为true就好了。具体设置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">local\_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top\_n\_per\_article: 1</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>上面都配置好后，使用hexo命令重新生成代码并重新进行布署，这样我们就可以看到搜索功能的效果了。</p><h3 id="设置关于"><a href="#设置关于" class="headerlink" title="设置关于"></a>设置关于</h3><p>hexo上设置关于与设置标签是类似的，首先执行下面的命令生成关于目录和源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;about&quot;</span><br></pre></td></tr></table></figure><p>该命令执行后，你就可以在source/ 目录下面看到about目录了。然后向 about 目录中的index.md 写入关于的信息就好了。</p><p>除此之外，我们还应该像创建标签一样在 themes/next 目录下_config.yml文件中将 about 的入口打开。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">home: &#x2F;|| home</span><br><span class="line">tags: &#x2F;tags&#x2F;|| tags</span><br><span class="line">...</span><br><span class="line">about: &#x2F;about&#x2F;|| about</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这样我们就将关于页面加载好了。</p><h3 id="设置404"><a href="#设置404" class="headerlink" title="设置404"></a>设置404</h3><p>设置 404 与设置关于是类似的，也是首先执行 <code>hexo new page &#39;404&#39;</code>命令生成对应的目录和文件，之后是编写404页面。在编写 404 页面时有一点需要注意，就是在404页面的头部要加<code>permalink</code>关键字，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">...</span><br><span class="line">permalink: &#x2F;404</span><br><span class="line">...</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>这样当用户访问非发布的页面时，hexo会始终定位到 404 页面上。</p><h3 id="将文章名修改为数字码"><a href="#将文章名修改为数字码" class="headerlink" title="将文章名修改为数字码"></a>将文章名修改为数字码</h3><p>当我在hexo发布文件时发现一个问题，就是hexo生成的文章名如果有中文的话会被转码，这样就变成了一个特别长的字符串，让人看起来非常别拗。能不能将它修改为像简书一样的字符串呢？hexo同样提供了这样一个插件，叫<code>hexo-abbrlink</code>。我们只要装上这个插件再修改一下配置文件就OK了。下面我们就来偿试下吧。</p><p>首先还是安装插件，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>插件安装好后，我们再来修改一下配置文件，打开站目录下的_config.yml文件，找到<code>permalink</code>并将它的值修改为 <code>post/:abbrlink/</code>，之后添加abbrlink属性。具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">permalink: posts&#x2F;:abbrlink&#x2F;</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32</span><br><span class="line">  rep: hex</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>全部配置好后我们就可以重新生成静态文件了。当我们将静态文件发布出来后，你再访问文章时你就会发现以前一长号字符的地址现在已经变的非常短了。</p><h3 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h3><p>涉及的知识比较多，待进一步完成！</p> <!-- 引入 flv.js 库 --> <!-- <video id="flv_file" controls autoplay>          You Browser doesn't support video tag </video> <script src="https://cdnjs.cloudflare.com/ajax/libs/flv.js/1.5.0/flv.min.js"></script> <script>            //通过 JavaScript 脚本创建 FLV Player            if (flvjs.isSupported()) {                var videoElement = document.getElementById('flv_file');                var flvPlayer = flvjs.createPlayer({                    type: 'flv',                    url: 'https://avdancevod.oss-cn-beijing.aliyuncs.com/vodio/killer.flv'                });                flvPlayer.attachMediaElement(videoElement);                flvPlayer.load();                flvPlayer.play();            } </script> --><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文是我自己搭建博客的总结文章。该文记录的是从我对hexo有所了解，到逐步深入，再到一步一步搭建出我们自己比较满意的博客的过程。在整个过程中，我感触最多的是我在搭建过程中对博客技术的思考以及对技术的重新认知，这两个方面是我对hexo特别兴奋点。也正因于此，才使我写出这一万多字的文章。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
            <tag> Blog </tag>
            
            <tag> 博客 </tag>
            
            <tag> 标签 </tag>
            
            <tag> hexo </tag>
            
            <tag> next </tag>
            
            <tag> SEO </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
