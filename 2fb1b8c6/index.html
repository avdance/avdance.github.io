<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.1"><link rel="icon" type="image/png" sizes="32x32" href="/images/avdance32_32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/avdance16_16.ico"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"blog.avdancedu.com",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!0,pangu:!1,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!1,nav:null,activeClass:"valine"},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="N多年没有写过 Window 程序了。为了研究 WebRTC 源码，这两天重新学习一下。还记得上大学的时候看过 《Windows95 程式设计》台湾版，对那本书印象极为深刻。一是当时国内确实没有一本写的那么深入的书籍，二是那本书翻译的特别好，让人一看就特别明白。10多年过多了，当时的情景还记忆犹新，也可见那本书写的有多好了。"><meta property="og:type" content="article"><meta property="og:title" content="分析WebRTC，重学Windows开发"><meta property="og:url" content="https://blog.avdancedu.com/2fb1b8c6/index.html"><meta property="og:site_name" content="音视跳动科技"><meta property="og:description" content="N多年没有写过 Window 程序了。为了研究 WebRTC 源码，这两天重新学习一下。还记得上大学的时候看过 《Windows95 程式设计》台湾版，对那本书印象极为深刻。一是当时国内确实没有一本写的那么深入的书籍，二是那本书翻译的特别好，让人一看就特别明白。10多年过多了，当时的情景还记忆犹新，也可见那本书写的有多好了。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.avdancedu.com/image/article/windows/win95.jpg"><meta property="article:published_time" content="2020-06-29T14:47:36.000Z"><meta property="article:modified_time" content="2020-06-29T15:39:27.749Z"><meta property="article:author" content="音视跳动"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.avdancedu.com/image/article/windows/win95.jpg"><link rel="canonical" href="https://blog.avdancedu.com/2fb1b8c6/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>分析WebRTC，重学Windows开发 | 音视跳动科技</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="音视跳动科技" type="application/atom+xml"></head><body itemscope itemtype="https://schema.org/WebPage"><div class="container"><div class="headband"></div><div id="needsharebutton-float"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div><header class="header" itemscope itemtype="https://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">音视跳动科技</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">传播最前沿的科技知识！</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i> 关于</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div> <a href="https://github.com/avdance" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="https://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.avdancedu.com/2fb1b8c6/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="image" content="/images/avdancelogo.jpg"><meta itemprop="name" content="音视跳动"><meta itemprop="description" content="传输最前沿的科技知识，学习音视频的圣地！ffmpeg, webrtc, H264, AAC"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="音视跳动科技"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 分析WebRTC，重学Windows开发</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-06-29 22:47:36 / 修改时间：23:39:27" itemprop="dateCreated datePublished" datetime="2020-06-29T22:47:36+08:00">2020-06-29</time></span><span id="/2fb1b8c6/" class="post-meta-item leancloud_visitors" data-flag-title="分析WebRTC，重学Windows开发" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/2fb1b8c6/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2fb1b8c6/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>4.6k</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img data-src="https://cdn.avdancedu.com/image/article/windows/win95.jpg" alt=""></p><p>N多年没有写过 Window 程序了。为了研究 WebRTC 源码，这两天重新学习一下。还记得上大学的时候看过 《Windows95 程式设计》台湾版，对那本书印象极为深刻。一是当时国内确实没有一本写的那么深入的书籍，二是那本书翻译的特别好，让人一看就特别明白。10多年过多了，当时的情景还记忆犹新，也可见那本书写的有多好了。</p><a id="more"></a><p>Windows开发有很多知识点，窗口啊，句柄啊，消息啊，重绘啊，baba …..，但一个 Windows 程序的核心就是一个消息处理机制。</p><h2 id="Windows程序运行的基本原理"><a href="#Windows程序运行的基本原理" class="headerlink" title="Windows程序运行的基本原理"></a>Windows程序运行的基本原理</h2><p>Windows程序是消息为驱动的，所以它的核心就是消息的传递与处理。如鼠标消息、键盘消息，Timer消息，窗口的创建与消毁等等。那么，Windows程序是在哪儿处理消息呢？是否掌握了它，就控制了Windows程序的核心呢？答案是肯定的，它就是 WndProc 函数。所有的消息都要经过这个函数处理。</p><p>Windows 程序有两种消息，一种是队列消息，它通过 DispatchMessage 函数分发给 WndProc 函数，像鼠标消息、键盘消息，Timer消息都是这类消息。另一种是非队列消息，它是系统函数直接发送给 WndProc 函数的，像窗口的创建与消毁消息，WM_COMMON消息等等都是非队列消息。</p><h2 id="最简单的-Windows-程序"><a href="#最简单的-Windows-程序" class="headerlink" title="最简单的 Windows 程序"></a>最简单的 Windows 程序</h2><p>一个最简单的 Windows 程序都包括哪些内容呢？下面我们详细介绍一下：</p><h3 id="WinMain-函数"><a href="#WinMain-函数" class="headerlink" title="WinMain 函数"></a>WinMain 函数</h3><p>我们都知道无论是Windows程序，还是Linux程序，也无论是C/C++，还是 Java语言，它们都有一个 main 函数。更准确点说应该叫“程序入口点”。</p><p>我们写程序时，一般都以 main 开头，编译器在编译该程序时，会将 main 函数地址写入到可执行文件的文件头中，这就是“程序入口点”了。</p><p>在执行程序时，操作系统首先通过程序加载器将要运行的程序加载到内存中，然后重新计算符号地址表。一切准备就绪后，才跳到程序入口点，将一条条指令送入CPU流水线开始执行程序。这就是程序的运行的基本流程。</p><p>因此，我们可以知道每个程序都有一个入口点。但是否一定以 main 开头呢? 其实，只要编译器能识别出入口点就可以，不必非要以 main 为标志。对于 Windows 程序就是这样，它就不使用 main作为入口点，而是换成了 WinMain 作为程序入口点。格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int CALLBACK WinMain(</span><br><span class="line">   _In_  HINSTANCE hInstance,</span><br><span class="line">   _In_  HINSTANCE hPrevInstance,</span><br><span class="line">   _In_  LPSTR lpCmdLine,</span><br><span class="line">   _In_  int nCmdShow</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="实现消息中心函数-WndProc"><a href="#实现消息中心函数-WndProc" class="headerlink" title="实现消息中心函数 WndProc()"></a>实现消息中心函数 WndProc()</h3><p>前面我已经介绍了 WndProc 是 Windows 程序的消息中心，所有的消息都要在这个函数中处理。如 窗口创建时发送的 WM_CREATE 消息，如果我们不处理它，Windows 操作系统就不会显示创建的窗口。</p><p>但 Windows 中有那么多消息，我们每个都处理岂不是要累死人？所以 Windows 很贴心的提供了一个API，就是 DefWindowProc 函数。该函数对所有的 Windows 消息都做了默认处理，如果我们很懒的话，可以将所有消息都交由它就好了。</p><p>有没有坐过山车的感脚？开始觉得很苦闷，突然又拨云见日了。嘿嘿！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK WndProc(</span><br><span class="line">        _In_  HWND hwnd,</span><br><span class="line">        _In_  UINT uMsg,</span><br><span class="line">        _In_  WPARAM wParam,</span><br><span class="line">        _In_  LPARAM lParam</span><br><span class="line">) &#123;</span><br><span class="line">	return DefWindowProc(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册窗口类"><a href="#注册窗口类" class="headerlink" title="注册窗口类"></a>注册窗口类</h3><p>我们在创建窗口之前要注册一个窗口类，它是干啥用的呢？就是告诉操作系统，我要创建个什么样子的窗口，是啥背景色，鼠标是啥样子的，程序叫啥名子等等。</p><p>有了这个窗口类，我们就可以创建不同样式的窗口了，这样是不是觉得很方便呢？当然，一般情况下我们都使用默认样式！</p><p>这个窗口类除了设置样式外，其实它<strong>更重要的作用</strong>是指定 WndProc 函数，也就是为 Window 程序指定 “消息处理中心”。消息中心是谁，完全是由 RegisterClass 说了算，它说消息处理中心是 WndProc 就是 WndProc，它说 ABC 那就是 ABC。</p><p>一般我们调用注册窗口的代码都长的像下面这样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 类名</span><br><span class="line">WCHAR* cls_Name &#x3D; L&quot;My Class&quot;;</span><br><span class="line">&#x2F;&#x2F; 设计窗口类</span><br><span class="line">WNDCLASS wc &#x3D; &#123; &#125;;</span><br><span class="line">wc.hbrBackground &#x3D; (HBRUSH)COLOR_WINDOW;</span><br><span class="line">wc.lpfnWndProc &#x3D; WndProc;</span><br><span class="line">wc.lpszClassName &#x3D; cls_Name;</span><br><span class="line">wc.hInstance &#x3D; hInstance;</span><br><span class="line">&#x2F;&#x2F; 注册窗口类</span><br><span class="line">RegisterClass(&amp;wc);</span><br></pre></td></tr></table></figure><h3 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h3><p>创建窗口就比较简单了，高多少，宽多少，透明的还是非透明的，可显示还是不可显示，标题栏上要写啥字等等，这些都是由<code>创建窗口</code>说了算。形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建窗口</span><br><span class="line">      HWND hwnd &#x3D; CreateWindow(</span><br><span class="line">      cls_Name,           &#x2F;&#x2F;类名，要和刚才注册的一致</span><br><span class="line">      L&quot;我的应用程序&quot;,  &#x2F;&#x2F;窗口标题文字</span><br><span class="line">      WS_OVERLAPPEDWINDOW, &#x2F;&#x2F;窗口外观样式</span><br><span class="line">      38,                 &#x2F;&#x2F;窗口相对于父级的X坐标</span><br><span class="line">      20,                 &#x2F;&#x2F;窗口相对于父级的Y坐标</span><br><span class="line">      480,                &#x2F;&#x2F;窗口的宽度</span><br><span class="line">      250,                &#x2F;&#x2F;窗口的高度</span><br><span class="line">      NULL,               &#x2F;&#x2F;没有父窗口，为NULL</span><br><span class="line">      NULL,               &#x2F;&#x2F;没有菜单，为NULL</span><br><span class="line">      hInstance,          &#x2F;&#x2F;当前应用程序的实例句柄</span><br><span class="line">      NULL);              &#x2F;&#x2F;没有附加数据，为NULL</span><br></pre></td></tr></table></figure><h3 id="显示窗口"><a href="#显示窗口" class="headerlink" title="显示窗口"></a>显示窗口</h3><p>窗口创建完了，还要主动调<code>ShowWindows</code>函数让窗口显示出来，否则它是不会出来干活的。形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 显示窗口</span><br><span class="line">ShowWindow(hwnd, SW_SHOW);</span><br></pre></td></tr></table></figure><h3 id="循环处理，检索与分发消息"><a href="#循环处理，检索与分发消息" class="headerlink" title="循环处理，检索与分发消息"></a>循环处理，检索与分发消息</h3><p>这部分工作是在 WinMain 函数中要做的事儿。在 WinMain 中写一个循环，不停的从系统消息队列中取消息。</p><p>如果此时没有消息，则该线被程阻塞，并将CPU资源释放；如果有消息，需要判断是不是退出消息？如果不是，使用 DispatchMessage 将该消息分配出去。如果是退出消息，则退出消息循环，程序结束。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void WinMan(...)&#123;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 消息循环</span><br><span class="line">	MSG msg;</span><br><span class="line">	while(GetMessage(&amp;msg, NULL, 0, 0))</span><br><span class="line">	&#123;</span><br><span class="line">	    TranslateMessage(&amp;msg);</span><br><span class="line">	    DispatchMessage(&amp;msg);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是一个最简单的窗口 Window 程序。了解了上面这些知识，大家是不是觉得即使不用 MFC 也可以写出一个很不错的 Windows 程序呢？</p><h2 id="重要函数详细介绍"><a href="#重要函数详细介绍" class="headerlink" title="重要函数详细介绍"></a>重要函数详细介绍</h2><h3 id="WinMain"><a href="#WinMain" class="headerlink" title="WinMain"></a>WinMain</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int CALLBACK WinMain(</span><br><span class="line">  _In_ HINSTANCE hInstance, &#x2F;&#x2F;句柄</span><br><span class="line">  _In_ HINSTANCE hPrevInstance, &#x2F;&#x2F;总是 NULL</span><br><span class="line">  _In_ LPSTR     lpCmdLine, &#x2F;&#x2F;在命令行启动程序时的命令</span><br><span class="line">  _In_ int       nCmdShow &#x2F;&#x2F;程序启动时的显示方式</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>hInstance：句柄，就是一个内存地址，在该地址上有该程序的基本信息。</li><li>hPrevInstance：总是NULL，没啥用。</li><li>lpCmdLine： 用命令行启动时的命令，有兴趣的可以自己打印出来。</li><li>nCmdShow：程序启动时的显示方式，是隐藏，还是显示，是最大化，还是最小化显示。</li></ul><h3 id="注册窗口"><a href="#注册窗口" class="headerlink" title="注册窗口"></a>注册窗口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagWNDCLASS &#123;</span><br><span class="line">  UINT      style;</span><br><span class="line">  WNDPROC   lpfnWndProc;</span><br><span class="line">  int       cbClsExtra;</span><br><span class="line">  int       cbWndExtra;</span><br><span class="line">  HINSTANCE hInstance;</span><br><span class="line">  HICON     hIcon;</span><br><span class="line">  HCURSOR   hCursor;</span><br><span class="line">  HBRUSH    hbrBackground;</span><br><span class="line">  LPCTSTR   lpszMenuName;</span><br><span class="line">  LPCTSTR   lpszClassName;</span><br><span class="line">&#125; WNDCLASS, *PWNDCLASS;</span><br><span class="line"></span><br><span class="line">ATOM WINAPI RegisterClass(</span><br><span class="line">  _In_ const WNDCLASS *lpWndClass</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>style ：设置窗口样式。可以不设置。</li><li>lpfnWndProc ：这个字段特别重要，设置消息处理函数，它是消息的中心。</li><li>cbClsExtra ：不用设置。</li><li>cbWndExtra ：不用设置。</li><li>hInstance ：窗口句柄，与WinMain中的一样。</li><li>hIcon ：窗口图标。如果是NULL，使用默认图标。</li><li>hCursor ：设置光标样式。可以不设置</li><li>hbrBackground ：设置窗口背景色。</li><li>lpszMenuName：菜单名。如果为NULL说明没有菜单。</li><li>lpszClassName：这个参数要提供，长度不超过 256。</li></ul><h3 id="创建窗口-1"><a href="#创建窗口-1" class="headerlink" title="创建窗口"></a>创建窗口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HWND WINAPI CreateWindow(</span><br><span class="line">  _In_opt_ LPCTSTR   lpClassName,</span><br><span class="line">  _In_opt_ LPCTSTR   lpWindowName,</span><br><span class="line">  _In_     DWORD     dwStyle,</span><br><span class="line">  _In_     int       x,</span><br><span class="line">  _In_     int       y,</span><br><span class="line">  _In_     int       nWidth,</span><br><span class="line">  _In_     int       nHeight,</span><br><span class="line">  _In_opt_ HWND      hWndParent,</span><br><span class="line">  _In_opt_ HMENU     hMenu,</span><br><span class="line">  _In_opt_ HINSTANCE hInstance,</span><br><span class="line">  _In_opt_ LPVOID    lpParam</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>lpClassName ： 与注册的类名子一致。</li><li>lpWindowName ：窗口标题栏名子。</li><li>dwStyle ：窗口外观样式。</li><li>x ：窗口起始位置 x。</li><li>y ：窗口起始位置 y。</li><li>nWidth ：窗口宽度。</li><li>nHeight ：窗口高度。</li><li>hWndParent ：父窗口，没有的话设置为NULL</li><li>hMenu ：窗口菜单，没有设置为NULL</li><li>hInstance ： 窗口句柄。</li><li>lpParam ：符加数据，没有设置为 NULL</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过上面的介绍，我想你首先知道了Windows程序是由消息驱动的，真正负责消息处理的函数是 WinProc，它是在调用 RegisterClass 时指定的。通过 RegisterClass 我们还可以给窗口指定样式，并最终由 CreateWindow 创建出来。同时我们还可以总结出，通过 6 大步既可以创建出一个最简单的 Windows程序，这6步分别是：</p><ul><li>设置入口点，WinMain。</li><li>创建 WinProc 函数。</li><li>注册窗口类。</li><li>创建窗口。</li><li>显示窗口。</li><li>循环处理，检索与分发消息</li></ul><p>至此，一个Windows程序窗口已经展现在你面前了。 希望本文能对你有所帮助!</p><p> 谢谢！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/garrylea/SimpleWindow" target="_blank" rel="noopener">github地址</a></p></div><div class="reward-container"><div></div> <button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'> 打赏</button><div id="qr" style="display:none"><div style="display:inline-block"> <img src="https://cdn.avdancedu.com/image/next/wechat.jpeg" alt="音视跳动 微信支付"><p>微信支付</p></div><div style="display:inline-block"> <img src="https://cdn.avdancedu.com/image/next/alipay.jpeg" alt="音视跳动 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> 音视跳动-李超 [avdance@163.com]</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://blog.avdancedu.com/2fb1b8c6/" title="分析WebRTC，重学Windows开发">https://blog.avdancedu.com/2fb1b8c6/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><p>欢迎关注我的其它发布渠道</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="https://cdn.avdancedu.com/image/next/WeChat.jpeg"><span class="icon"><i class="fa fa-wechat"></i></span> <span class="label">WeChat</span></a></div><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/8f43ddc9/" rel="prev" title="janus的线程模型"><i class="fa fa-chevron-left"></i> janus的线程模型</a></div><div class="post-nav-item"> <a href="/5e7916e3/" rel="next" title="重学C/C++中的const">重学C/C++中的const<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Windows程序运行的基本原理"><span class="nav-number">1.</span> <span class="nav-text">Windows程序运行的基本原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最简单的-Windows-程序"><span class="nav-number">2.</span> <span class="nav-text">最简单的 Windows 程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#WinMain-函数"><span class="nav-number">2.1.</span> <span class="nav-text">WinMain 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现消息中心函数-WndProc"><span class="nav-number">2.2.</span> <span class="nav-text">实现消息中心函数 WndProc()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注册窗口类"><span class="nav-number">2.3.</span> <span class="nav-text">注册窗口类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建窗口"><span class="nav-number">2.4.</span> <span class="nav-text">创建窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#显示窗口"><span class="nav-number">2.5.</span> <span class="nav-text">显示窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环处理，检索与分发消息"><span class="nav-number">2.6.</span> <span class="nav-text">循环处理，检索与分发消息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重要函数详细介绍"><span class="nav-number">3.</span> <span class="nav-text">重要函数详细介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#WinMain"><span class="nav-number">3.1.</span> <span class="nav-text">WinMain</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注册窗口"><span class="nav-number">3.2.</span> <span class="nav-text">注册窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建窗口-1"><span class="nav-number">3.3.</span> <span class="nav-text">创建窗口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">4.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">5.</span> <span class="nav-text">参考</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="https://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="音视跳动" src="/images/avdancelogo.jpg"><p class="site-author-name" itemprop="name">音视跳动</p><div class="site-description" itemprop="description">传输最前沿的科技知识，学习音视频的圣地！ffmpeg, webrtc, H264, AAC</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">48</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">26</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/avdance" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;avdance" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/garrylea/posts" title="ZhiHu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;garrylea&#x2F;posts" rel="noopener" target="_blank"><i class="fa fa-fw fa-zhihu"></i> ZhiHu</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://www.beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备19056322号-1</a> <img src="/images/beianico.png" style="display:inline-block"><a href="https://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11011102001366" rel="noopener" target="_blank">京公网安备11011102001366号</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2021</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">李超</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span title="站点总字数">220k</span></div><script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"Cu6h7B3RnNt3uEMrRWpVlIU6-gzGzoHsz","app_key":"5dKv9XFD2w3gjJnb0xnWIIWz","server_url":"https://leancloud.cn","security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        //if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script><script>AV.initialize("Cu6h7B3RnNt3uEMrRWpVlIU6-gzGzoHsz","5dKv9XFD2w3gjJnb0xnWIIWz")</script><script>function showTime(e){var t=new AV.Query(e),c=[],u=$(".leancloud_visitors");u.each(function(){c.push($(this).attr("id").trim())}),t.containedIn("url",c),t.find().done(function(e){var t=".leancloud-visitors-count";if(0!==e.length){for(var n=0;n<e.length;n++){var o=e[n],i=o.get("url"),s=o.get("time"),r=document.getElementById(i);$(r).find(t).text(s)}for(n=0;n<c.length;n++){i=c[n],r=document.getElementById(i);var l=$(r).find(t);""==l.text()&&l.text(0)}}else u.find(t).text(0)}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(i){var e=$(".leancloud_visitors"),s=e.attr("id").trim(),r=e.attr("data-flag-title").trim(),t=new AV.Query(i);t.equalTo("url",s),t.find({success:function(e){if(0<e.length){var t=e[0];t.fetchWhenSave(!0),t.increment("time"),t.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var n=new i,o=new AV.ACL;o.setPublicReadAccess(!0),o.setPublicWriteAccess(!0),n.setACL(o),n.set("title",r),n.set("url",s),n.set("time",1),n.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):1<$(".post-title-link").length&&showTime(e)})</script><link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.min.css"><script src="/lib/needsharebutton/needsharebutton.min.js"></script><script>flOptions={iconStyle:"box",boxForm:"horizontal",position:"topRight",networks:"Weibo,Wechat,QQZone"},new needShareButton("#needsharebutton-float",flOptions)</script><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('/lib/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Cu6h7B3RnNt3uEMrRWpVlIU6-gzGzoHsz',
      appKey     : '5dKv9XFD2w3gjJnb0xnWIIWz',
      placeholder: "畅所欲言？",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script></body></html>