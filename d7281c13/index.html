<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.1"><link rel="icon" type="image/png" sizes="32x32" href="/images/avdance32_32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/avdance16_16.ico"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"blog.avdancedu.com",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!0,pangu:!1,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!1,nav:null,activeClass:"valine"},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="Hello,大家好！今天我们继续来分析janus。相信现在大家应该对janus 都比较熟悉了，它是一套完整的音视频会议系统，包括了WebRTC流媒体服务器和客户端API两大部分。 其中，客户端又包括Android、iOS以及浏览器端。今天我们要分析的内容就是浏览器端中的janus.js文件。之所以要分析它，是因为它是浏览器端最关键的一个文件，了解了它我们基本上就将浏览器端的逻辑全部撑握了。 从大"><meta property="og:type" content="article"><meta property="og:title" content="janus前端核心库源码分析"><meta property="og:url" content="https://blog.avdancedu.com/d7281c13/index.html"><meta property="og:site_name" content="音视跳动科技"><meta property="og:description" content="Hello,大家好！今天我们继续来分析janus。相信现在大家应该对janus 都比较熟悉了，它是一套完整的音视频会议系统，包括了WebRTC流媒体服务器和客户端API两大部分。 其中，客户端又包括Android、iOS以及浏览器端。今天我们要分析的内容就是浏览器端中的janus.js文件。之所以要分析它，是因为它是浏览器端最关键的一个文件，了解了它我们基本上就将浏览器端的逻辑全部撑握了。 从大"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.avdancedu.com/image/article/janus_js/janus_logo.jpg"><meta property="og:image" content="https://cdn.avdancedu.com/image/article/janus_js/janus_command.jpg"><meta property="article:published_time" content="2020-06-15T03:13:31.000Z"><meta property="article:modified_time" content="2020-06-29T05:29:06.821Z"><meta property="article:author" content="音视跳动"><meta property="article:tag" content="janus"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.avdancedu.com/image/article/janus_js/janus_logo.jpg"><link rel="canonical" href="https://blog.avdancedu.com/d7281c13/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>janus前端核心库源码分析 | 音视跳动科技</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="音视跳动科技" type="application/atom+xml"></head><body itemscope itemtype="https://schema.org/WebPage"><div class="container"><div class="headband"></div><div id="needsharebutton-float"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div><header class="header" itemscope itemtype="https://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">音视跳动科技</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">传播最前沿的科技知识！</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i> 关于</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div> <a href="https://github.com/avdance" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="https://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.avdancedu.com/d7281c13/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="image" content="/images/avdancelogo.jpg"><meta itemprop="name" content="音视跳动"><meta itemprop="description" content="传输最前沿的科技知识，学习音视频的圣地！ffmpeg, webrtc, H264, AAC"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="音视跳动科技"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> janus前端核心库源码分析</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-06-15 11:13:31" itemprop="dateCreated datePublished" datetime="2020-06-15T11:13:31+08:00">2020-06-15</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-06-29 13:29:06" itemprop="dateModified" datetime="2020-06-29T13:29:06+08:00">2020-06-29</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/WebRTC/" itemprop="url" rel="index"><span itemprop="name">WebRTC</span></a></span></span><span id="/d7281c13/" class="post-meta-item leancloud_visitors" data-flag-title="janus前端核心库源码分析" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/d7281c13/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/d7281c13/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>11k</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img data-src="https://cdn.avdancedu.com/image/article/janus_js/janus_logo.jpg" alt=""></p><p>Hello,大家好！今天我们继续来分析janus。相信现在大家应该对<a href="https://janus.conf.meetecho.com/" target="_blank" rel="noopener">janus</a> 都比较熟悉了，它是一套完整的音视频会议系统，包括了WebRTC流媒体服务器和客户端API两大部分。</p><p>其中，客户端又包括Android、iOS以及浏览器端。今天我们要分析的内容就是浏览器端中的<code>janus.js</code>文件。之所以要分析它，是因为它是浏览器端最关键的一个文件，了解了它我们基本上就将浏览器端的逻辑全部撑握了。</p><p>从大的方面说，<code>janus.js</code>主要完成两方面的事儿。一是封装了浏览器与janus流媒体服务器之间的业务接口，使得在浏览器端开发音视频会议系统变得特别简单；二是对WebRTC的API做了封装，这样用户不用再理会WebRTC底层API该何使用了。</p><p>总之一句话，就是大大的减了少JS用户使用janus的难度。</p><a id="more"></a><p>在阅读本文之前你应该已经熟悉了JavaScript语法，且对浏览器下调用WebRTC的API十分精通，否则你应该先去补齐相关知识再来阅读本文。 这里有一些参考资料仅供参考：<a href="https://avdancedu.com/18fc7df1/" target="_blank" rel="noopener">《js类的探究》</a>，在这篇文章中有介绍ES5与ES6之间的区别。<a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门与实战课程》</a>，该课程详细讲解了在浏览器下该如何使用WebRTC。</p><p>下面我们开始<code>janus.js</code>源码分析。</p><h2 id="核心类Janus"><a href="#核心类Janus" class="headerlink" title="核心类Janus"></a>核心类Janus</h2><p>对于<code>janus</code>源码的目录结构我已经在之前的文章中向你介绍过了，如果你还没看过，可以到<a href="https://avdancedu.com/fdfe2594/" target="_blank" rel="noopener">这里</a>看一下。通过目录结构我们可以知道，<code>janus.js</code>就在<code>janus</code>源码的<code>html</code>目录下。</p><p>大体浏览一下<code>janus.js</code>你会发现，整个文件有3000多行代码，但只有一个<code>类</code>，即<code>Janus</code>类。该类中实现了很多方法，然而核心代码量并不大，经抽丝拨茧，你会发现下面几个方法是比较关键的。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">function Janus(gatewayCallbacks) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建一个Session，私有方法</span><br><span class="line">    function createSession(callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;消毁Session，私有方法</span><br><span class="line">    function destroySession(callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;用于处理Janus信令</span><br><span class="line">    function eventHandler()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;信令事件处理函数，私有方法</span><br><span class="line">    function handleEvent(json, skipTimeout);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;发送消息，私有方法</span><br><span class="line">    function sendMessage(handleId, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建插件处理函数，私有方法</span><br><span class="line">    function createHandle(callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;消毁插件处理方法</span><br><span class="line">    function destroyHandle(handleId, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;发送candidate，私有方法</span><br><span class="line">    function sendTrickleCandidate(handleId, candidate);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建PC</span><br><span class="line">    function streamsDone(handleId, jsep, media, callbacks, stream);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;准备WebRTC</span><br><span class="line">    function prepareWebrtc(handleId, offer, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;接收远端的SDP，并设备远端描述符</span><br><span class="line">    function prepareWebrtcPeer(handleId, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建Offer</span><br><span class="line">    function createOffer(handleId, media, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建answer</span><br><span class="line">    function createAnswer(handleId, media, callbacks);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;发送SDP</span><br><span class="line">    function sendSDP(handleId, callbacks);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对上面的这些方法，我们可以按类别将其划分成以下几类：</p><ul><li><p>Session相关</p><ul><li>createSession</li><li>destorySession</li></ul></li><li><p>信令处理</p><ul><li>handleEvent</li><li>eventHandler</li><li>sendMessage</li></ul></li><li><p>Plugin相关</p><ul><li>createHandle</li><li>destoryHandle</li></ul></li><li><p>WebRTC相关</p><ul><li>prepareWebrtc</li><li>prepareWebrtcPeer</li><li>createOffer</li><li>createAnswer</li><li>sendSDP</li><li>streamDone</li></ul></li></ul><p>接下来，我们就对这几个函数做下详细介绍，整体的介绍思路是：首先介绍一下它的主要功能是什么，然后再讨论一下它是怎么实现的。</p><h2 id="Session-相关"><a href="#Session-相关" class="headerlink" title="Session 相关"></a>Session 相关</h2><p>首先我们来看看 <code>Session</code> 的作用是什么。<code>Session</code>表示的是一个客户端与<code>janus</code>服务器之间建立的一个<code>信令通道</code>。janus客户端与服务器之间就是通过这个<code>信令通道</code>传输信令的。</p><p>Session是如何创建的呢？下面我们就来看一下<code>createSession</code>函数的处理逻辑。在<code>createSession</code>中，首先创建了一个JSON对象<code>request</code>，该对象中包括了以下几个信息：</p><ul><li>janus，代表一个信令，<code>create</code>表示要创建一个<code>session</code>。</li><li>token，唯一标识，用于鉴权。</li><li>apisecret，API调用码密，用于安全访问。</li></ul><p><code>request</code>对象构建好后，<code>createSession</code>函数会根据server地址的类型(如ws://、http://）判断是使用 websocket 接口还是使用 HTTP RESTFUL接口。判断逻辑如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if(!server &amp;&amp; Janus.isArray(servers)) &#123;</span><br><span class="line">    &#x2F;&#x2F; We still need to find a working server from the list we were given</span><br><span class="line">    server &#x3D; servers[serversIndex];</span><br><span class="line">    if(server.indexOf(&quot;ws&quot;) &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">        websockets &#x3D; true;</span><br><span class="line">        Janus.log(&quot;Server #&quot; + (serversIndex+1) + &quot;: trying WebSockets to contact Janus (&quot; + server + &quot;)&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        websockets &#x3D; false;</span><br><span class="line">        Janus.log(&quot;Server #&quot; + (serversIndex+1) + &quot;: trying REST API to contact Janus (&quot; + server + &quot;)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果<code>createSession</code>判断server使用的是<code>websocket</code>接口，它就会走到<code>websocket</code>的处理逻辑分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(websockets)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个分支中，首先通过<code>Janus.newWebSocket</code>方法与server（janus服务器）建立连接。然后向websocket注册侦听事件，当websocket接收到不同的事件后就跳到对应事件的处理函数中执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">ws &#x3D; Janus.newWebSocket(server, &#39;janus-protocol&#39;);</span><br><span class="line">wsHandlers &#x3D; &#123;</span><br><span class="line">    &#39;error&#39;: ...,</span><br><span class="line">    &#39;open&#39;: ...,</span><br><span class="line">    &#39;message&#39;: ...,</span><br><span class="line">    &#39;close&#39;: ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(var eventName in wsHandlers) &#123;</span><br><span class="line">    ws.addEventListener(eventName, wsHandlers[eventName]);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在上代码中，注册到 websocket 中的 open 和 message 事件特别重要。websocket收到<code>open</code>事件说明与janus服务器之间已经成功建立了连接，此时我们就可以将之前准备好的 <code>request</code> 发送出去了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">transactions[transaction] &#x3D; function()...;</span><br><span class="line">ws.send(JSON.stringify(request));</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>当websocket连接创建好后，<code>janus.js</code>首先在transctons中创建一个新的<code>transaction</code>，然后将之前准备好的request发送给服务器。</p><blockquote><p>这里需要注意的是transaction，它表示一个事务或称之为上下文，当一件事儿由多个步骤多阶段组合完成时，我们一般都使用这种设计方案。</p></blockquote><p>服务端收到消息后进行逻辑处理，之后通过上面建立的连接将处理结果返回给<code>janus.js</code>，此时就会触发我们上面注册的<code>message</code>事件。在message事件中，对所有接收到的服务端的消息都由<code>handleEvent</code>函数进行处理。对于该函数我们后面还会做详细介绍，这里就不过多讲解了。</p><p>至此，<code>createSession</code> 函数的主要作用我们就分析完了，而<code>destorySession</code>是<code>createSession</code>的反函数，用于销毁<code>createSession</code>创建的资源，大家自己去看代码就好了，我这里不再做过多描述了。</p><p>接下来我们来看一下<code>janus.js</code>是如何处理从服务端接收到的信令的。</p><h2 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h2><p>上面讲解<code>Session</code>的创建时，我已经向你介绍了janus默认提供了两种传输信令的接口，即<code>websocket</code>处<code>http</code>。janus会根所用户访问地址的协议头来自动判断使用那种协议进行信令的传输。</p><p>对于服务端来讲，这两种接口的实现是在<code>janus</code>源码目录下的 <code>transports</code> 目录下，对应的实现文件为janus_websockets.c和janus_http.c文件，通过文件名我们也可以知道他们分别是websocket和http接口的实现了。</p><blockquote><p>当然janus不光支持这两种接口，它还支持好几种接口，但需要你手工配置。如果你不进行任何配置的话，它默认只支持这两种接口。</p></blockquote><p>下面是<code>janus</code>信令处理的简化架构图，我们通过这张图先从整体上了解一下janus是如何处理信令的。</p><p><img data-src="https://cdn.avdancedu.com/image/article/janus_js/janus_command.jpg" alt=""></p><p>上图将janus分成了两大部分，服务端和客户端。我们分别来介绍一下，首先来看看服务端的处理过程。</p><h3 id="服务端接收消息"><a href="#服务端接收消息" class="headerlink" title="服务端接收消息"></a>服务端接收消息</h3><p>通过上图我们可以看到，janus服务端的信令处理是由<code>transports</code>完成的，<code>transports</code>中包括很多插件，图中展示的<code>websocket</code>和<code>http</code>就是其中的两个。</p><p>这两个<code>transport</code>插件是在janus服务启动时加载起来的。以websocket插件为例，当该插件被加载后，websocket服务随即开启。此时，<code>janus.js</code>(JS客户端）就可以向该websocket服务发送消息了，同时<code>janus.js</code>也可以通过websocket连接接收来自服务端的信息。</p><p>当在服务端通过<code>websocket</code>收到消息后，最终会调用janus_websockets.c中的<code>janus_websockets_common_callback</code>方法将收到的消息传给janus core。janus core 收到消息后再根据消息类型做相应的处理。关于这块的逻辑我们先暂时放一放，待以有时间了我再说细介绍。</p><p>接下来我们再看客户端<code>janus.js</code>是如何处理的。</p><h3 id="客户端接收消息"><a href="#客户端接收消息" class="headerlink" title="客户端接收消息"></a>客户端接收消息</h3><p>客户端是如何处理消息的呢？我们还是从<code>Session</code>创建之后讲起。在<code>创建Session</code>一节中我已经介绍了，janus在websocket上侦听了<code>message</code>事件，每当websocket收到服务端发来的消息时，就会触发该事件。</p><p><code>janus.js</code>对该事件的处理方法是也比较简单，不管三七二十一直接将event中带来的数据交收<code>handleEvent</code>处理。<code>handleEvent</code>又是如何做的呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function handleEvent(json, skipTimeout) &#123;</span><br><span class="line">  ...</span><br><span class="line">  if(json[&quot;janus&quot;] &#x3D;&#x3D;&#x3D; &quot;keepalive&quot;) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; else if(json[&quot;janus&quot;] &#x3D;&#x3D;&#x3D; &quot;ack&quot;) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; else if(json[&quot;janus&quot;] &#x3D;&#x3D;&#x3D; &quot;success&quot;) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; else if(...</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>handleEvent</code>处理逻辑就如上面所示，对消息类型做判断，根据不同的类型做不同的处理。它能处理的消息包括以下几种:</p><ul><li>keepalive，心跳消息。</li><li>ack，确认消息。也就是说之前客户端发送了一个信令给服务端，服务端收到之后给客户端回了一个<code>ack</code>，确认服务端已经收到该消息了。</li><li>success，消息处理成功。该消息与 ack 消息是类似的，当服务器完成了客户端的命令后会返回该消息。</li><li>trickle，收集<code>候选者</code>用的消息。里边存放着 candidate，janus.js收到该消息后，需要将Candidate解析出来。</li><li>webrtcup，表示一个peer上线了，此时要找到以应的业务插件（plugin）做业务处理。</li><li>hangup，用户挂断，找到对应的plugin，进行挂断操作。</li><li>detached，某个插件要求与Janus Core之间断开连接。</li><li>media，开始或停信媒体流。</li><li>slowlink，限流？</li><li>error，错误消息</li><li>event，插件发磅的事件消息。</li><li>timeout，超时。</li></ul><p>对于janus.js来讲，上面这些消息有些是不需要再做处理的，有些是需要修改状态的，还有一些是与业务插件有关的，需要交由<code>pluginHandle</code>做进一步处理。 关于<code>pluginHandle</code>后面我们再做介绍。</p><p>以上就是janus客户端对从服务端接收到的消息的处理过程。当然在你阅读代码时还会看到<code>eventHandler</code>函数，这个函数是对handleEvent函数简单的封装，用在http接口上。由于websocket接口是长连接，所以直接使用的handleEvent函数，我们清楚这两个函数的联系与区别就OK了。</p><h3 id="客户端发送消息"><a href="#客户端发送消息" class="headerlink" title="客户端发送消息"></a>客户端发送消息</h3><p>上面我们主要介绍了从服务端来的消息janus是如何处理的，那客户端是如何发送消息的呢？</p><p>在<code>janus.js</code>中为上层应用封装了一个发送消息的方法，即<code>config.send()</code>。这个函数实际调用的是janus的<code>sendMessage</code>方法。我们来看一下它的大体实现吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function sendMessage(handleId, callbacks) &#123;</span><br><span class="line">    ...</span><br><span class="line">    var pluginHandle &#x3D; pluginHandles[handleId];</span><br><span class="line">    ...</span><br><span class="line">    var message &#x3D; callbacks.message;</span><br><span class="line">    ...</span><br><span class="line">    if(pluginHandle.token)</span><br><span class="line">        request[&quot;token&quot;] &#x3D; pluginHandle.token;</span><br><span class="line">    ...</span><br><span class="line">    var request &#x3D; &#123; &quot;janus&quot;: &quot;message&quot;, &quot;body&quot;: message, &quot;transaction&quot;: transaction &#125;;</span><br><span class="line">    ...</span><br><span class="line">    if(websockets)&#123;</span><br><span class="line">        ws.send(JSON.stringify(request));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以发现，在<code>sendMessage</code>中主要是构造<code>request</code>对象，然后将构造好的<code>request</code>消息通过<code>websocket</code>发送出去。</p><p>消息发送给janus服务器，服务器处理好后又会给客户端返回消息。消息返回到客户端后，后会触发websocket的<code>message</code>事件，这样就又回到了我们上面介绍的<code>handleEvent</code>处理函数。</p><h2 id="Plugin相关"><a href="#Plugin相关" class="headerlink" title="Plugin相关"></a>Plugin相关</h2><p>在<code>janus.js</code>中，<code>Plugin</code>相关函数的主要作用是，在客户端创建一个<code>pluginHandle</code>对象，并让该对象与janus服务端的某个插件关联。</p><p>所谓的关联就是在<code>pluginHandle</code>对象中保存着可以访问janus服务端插件的信息。该对象中存放着很多的信息，如session、plugin、webrtc等信息。下面我抽取了一些比较关键的信息，我们来详细分析一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">session : that,</span><br><span class="line">plugin : plugin,</span><br><span class="line">...</span><br><span class="line">token : handleToken,</span><br><span class="line">detached : false,</span><br><span class="line">webrtcStuff : &#123;</span><br><span class="line">    ...</span><br><span class="line">    mySdp : null,</span><br><span class="line">    mediaConstraints : null,</span><br><span class="line">    pc : null,</span><br><span class="line">    trickle : true,</span><br><span class="line">    iceDone : false,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面的字段就是<code>pluginHandle</code>对象的一些重要信息，在这些信息中包括了两在部分，基础信息部分和WebRTC信息部分。</p><p>首先我们看一下基础信息。session中保存的是<code>janus</code>核心类对象；plugin指明我们要与服务端那个个插件建立联接，例如<code>vidoeroom</code>插件；token用于安全访问；detached表明是否已经与服务端对应的<code>plugin</code>建立了联系。</p><p>接下来<code>webrtcStuff</code>域是与webrtc相关的参数。mySdp中保存的是本地SDP信息；mediaConstrains存放用于采集音视频数据的限制参数；pc表示PeerConnection；trickle指明在使用WebRTC时是否使用<code>trickle</code>机制；iceDone表明是否ICE建立成功了。</p><p>该对象中的内容是由<code>createHandle</code>函数创建和填充的，下面我们就来看一下<code>createHandle</code>函数做了哪些事儿？</p><p>在该函数中，它首先构造<code>request</code>对象，该对象包括以下几个信息：</p><ul><li>janus，表示信令类型， 在<code>createHandle</code>函数中，该域填的内容为<code>attach</code>，表示与某个<code>plugin</code> 进行绑定。</li><li>plugin，指明要绑定的具体<code>plugin</code>。<code>janus.plugin.videoroom</code></li><li>opaque_id，一个唯一的ID。</li><li>transaction，表示一个事务ID。</li><li>token，用于与服务器连接的合法标识</li><li>apisecret，API密码。</li><li>sessionID，session的唯一标识。</li></ul><p><code>request</code>对象创建好后，通过websocket发送给服务端，这样就在客户端与服务端的plugin插件建立了联接。</p><p>除了创建<code>request</code>对象外，该函数还创建了一个transaction对象，并将它存放在 <code>transactions</code> 数组中(<code>transactions[transaction]</code>)。</p><p>实际上 <code>transaction</code> 是一个函数，该函数中会创建一个<code>pluginHandle</code>对象，<code>pluginHandle</code>创建好后，也会被保存起来放到<code>pluginHandles</code>里以备后面使用。</p><p>除了<code>createHandle</code>函数之外，在janus.js中还有<code>destoryHandle</code>函数，它是<code>createHandle</code>的反函数，用于做释放操作。</p><p>以上就是janus.js中处理Plugin相关的函数。</p><h2 id="Webrtc相关"><a href="#Webrtc相关" class="headerlink" title="Webrtc相关"></a>Webrtc相关</h2><p>在<code>janus.js</code>中WebRTC相关的方法是最多的，也是最为重要的。其中尤以<code>prepareWebRTC</code>最为重要。下面我们就来详细介绍一下这个函数。</p><p>这个函数的作用是什么呢？说来起它还是蛮复杂的，我们来一项一项来介绍。一、它要过浏览器采集音视频数据，以便可以将数据上传给远端；二要与按照WebRTC的规规范进行媒体协商；三协商成功后要与远端建立连接；最后把采集的数据压缩编码后传到远端；</p><p>这个函数代码量非常大，我抽取了函数中重要的逻辑，这样更有利于我们撑握整个函数的流程脉络。代码整理如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if(isAudioSendEnabled(media) || isVideoSendEnabled(media)) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;media为空，或者media.video不为屏幕，说明现在想采集视频数据</span><br><span class="line">    if(!media || media.video !&#x3D;&#x3D; &#39;screen&#39;) &#123;</span><br><span class="line">        &#x2F;&#x2F;遍历每个设备</span><br><span class="line">        navigator.mediaDevices.enumerateDevices().then( function(devices) &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;如果是音频输入设备</span><br><span class="line">            var audioExist &#x3D; devices.some(function(device) &#123;</span><br><span class="line">                                return device.kind &#x3D;&#x3D;&#x3D; &#39;audioinput&#39;;</span><br><span class="line">                            &#125;),</span><br><span class="line">            &#x2F;&#x2F;如果是视频输入设置</span><br><span class="line">            videoExist &#x3D; isScreenSendEnabled(media) || devices.some(function(device) &#123;</span><br><span class="line">                                return device.kind &#x3D;&#x3D;&#x3D; &#39;videoinput&#39;;</span><br><span class="line">                            &#125;);</span><br><span class="line">           ...</span><br><span class="line">           &#x2F;&#x2F;设置采集数据的限制条件</span><br><span class="line">           var gumConstraints &#x3D; &#123;</span><br><span class="line">              audio: (audioExist &amp;&amp; !media.keepAudio) ? audioSupport : false,</span><br><span class="line">              video: (videoExist &amp;&amp; !media.keepVideo) ? videoSupport : false</span><br><span class="line">           &#125;;</span><br><span class="line"></span><br><span class="line">           ...</span><br><span class="line">           &#x2F;&#x2F;采集数据</span><br><span class="line">           navigator.mediaDevices.getUserMedia(gumConstraints)</span><br><span class="line">             .then(function(stream) &#123;</span><br><span class="line">               ...</span><br><span class="line">               &#x2F;&#x2F;</span><br><span class="line">               streamsDone(handleId, jsep, media, callbacks, stream);</span><br><span class="line">             &#125;).catch(function(error) &#123;...&#125;);</span><br><span class="line"></span><br><span class="line">        &#125;).catch(...);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码的梳理我们可以看到<code>prepareWebrtc</code>函数首先遍历所有设备，找出可用的设备，之外调用`getUserMedia函数去采集音视频数据。之后像媒体协商、Candidate的收集都在 streamDone 函数中完成。</p><p>接下来我们继续分析<code>streamsDone</code> 函数。下面是<code>streamsDone</code>函数的主要脉络代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function streamsDone(handleId, jsep, media, callbacks, stream) &#123;</span><br><span class="line">    ...</span><br><span class="line">    var config &#x3D; pluginHandle.webrtcStuff;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;创建PeerConnection</span><br><span class="line">    f(!config.pc) &#123;</span><br><span class="line">        var pc_config &#x3D; &#123;&quot;iceServers&quot;: iceServers, &quot;iceTransportPolicy&quot;: iceTransportPolicy, &quot;bundlePolicy&quot;: bundlePolicy&#125;;</span><br><span class="line">        ...</span><br><span class="line">        var pc_constraints &#x3D; &#123;</span><br><span class="line">            &quot;optional&quot;: [&#123;&quot;DtlsSrtpKeyAgreement&quot;: true&#125;]</span><br><span class="line">        &#125;;</span><br><span class="line">        ...</span><br><span class="line">        config.pc &#x3D; new RTCPeerConnection(pc_config, pc_constraints);</span><br><span class="line">        config.pc.oniceconnectionstatechange &#x3D; ...;</span><br><span class="line">        config.pc.onicecandidate &#x3D; ...;</span><br><span class="line">        config.pc.ontrack &#x3D; ...;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将本地track添加到流中</span><br><span class="line">    if(addTracks &amp;&amp; stream) &#123;</span><br><span class="line">        ...</span><br><span class="line">        config.pc.addTrack(track, stream);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建offer进行媒体协商</span><br><span class="line">    if(!jsep) &#123;</span><br><span class="line">        createOffer(handleId, media, callbacks);</span><br><span class="line">    &#125;else&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该函数中首先会根据限制条件创建一个<code>PeerConnection</code>。PeerConnection简称PC，它是浏览器下使用WebRTC的核心，想了解这块知识的同学可以看一下我的课程<a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门与实战》</a>，这里我就不过多讲解这部分内容了。</p><p>PC创建好后，需要将之前从<code>prepareWebrtc</code>中获取的本地音视频轨添加到PC中，为媒体协商做好准备。最后调用createOffer函数生成媒体协商中的<code>Offer</code>SDP与远端交换从成完成媒体协商。</p><p>现在你应该了解<code>streamsDone</code>函数的作用了吧？同时也应该清楚<code>prepareWebrtc</code>函数是干什么的了。</p><p>当我们将<code>prepareWebrtc</code>函数的功能搞清楚之后，对于其它的WebRTC相关API就比较容易理解了，由于篇幅的原因我就不在这里一一做介绍了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上面我对janus.js文件做了全面的剖析，通过本文你应该知道<code>janus.js</code>的API可以分成四大类，分别是Session相关，信令相关，Plugin相关以及WebRTC相关的API。同时你也应该清楚，janus中的Session表示的是客户端与服务端之间的网络连接；客户端与服务器之间的信令是如何交互的，以及包括了哪些信令；<code>pluginHandle</code>的作用是用来保存访问远端插件的信息用的，同时它也保存了操作WebRTC相关的信息；而WebRTC相关的API是janus.js中最关键，最为复杂的。尤其是<code>prepareWebrtc</code>函数是最核心的API。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://avdancedu.com/18fc7df1/" target="_blank" rel="noopener">《js类的探究》</a>文中介绍了ES5与ES6之间的区别</li><li><a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门与实战课程》</a></li></ul></div><div class="reward-container"><div></div> <button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'> 打赏</button><div id="qr" style="display:none"><div style="display:inline-block"> <img src="https://cdn.avdancedu.com/image/next/wechat.jpeg" alt="音视跳动 微信支付"><p>微信支付</p></div><div style="display:inline-block"> <img src="https://cdn.avdancedu.com/image/next/alipay.jpeg" alt="音视跳动 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> 音视跳动-李超 [avdance@163.com]</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://blog.avdancedu.com/d7281c13/" title="janus前端核心库源码分析">https://blog.avdancedu.com/d7281c13/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><p>欢迎关注我的其它发布渠道</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="https://cdn.avdancedu.com/image/next/WeChat.jpeg"><span class="icon"><i class="fa fa-wechat"></i></span> <span class="label">WeChat</span></a></div><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/janus/" rel="tag"><i class="fa fa-tag"></i> janus</a></div><div class="post-nav"><div class="post-nav-item"><a href="/811929dc/" rel="prev" title="音视频已强势崛起，我们该如何快速入门音视频技术？"><i class="fa fa-chevron-left"></i> 音视频已强势崛起，我们该如何快速入门音视频技术？</a></div><div class="post-nav-item"> <a href="/af19ebea/" rel="next" title="WebRTC常见问题">WebRTC常见问题<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#核心类Janus"><span class="nav-number">1.</span> <span class="nav-text">核心类Janus</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Session-相关"><span class="nav-number">2.</span> <span class="nav-text">Session 相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息处理"><span class="nav-number">3.</span> <span class="nav-text">消息处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#服务端接收消息"><span class="nav-number">3.1.</span> <span class="nav-text">服务端接收消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端接收消息"><span class="nav-number">3.2.</span> <span class="nav-text">客户端接收消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端发送消息"><span class="nav-number">3.3.</span> <span class="nav-text">客户端发送消息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Plugin相关"><span class="nav-number">4.</span> <span class="nav-text">Plugin相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Webrtc相关"><span class="nav-number">5.</span> <span class="nav-text">Webrtc相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">6.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">7.</span> <span class="nav-text">参考</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="https://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="音视跳动" src="/images/avdancelogo.jpg"><p class="site-author-name" itemprop="name">音视跳动</p><div class="site-description" itemprop="description">传输最前沿的科技知识，学习音视频的圣地！ffmpeg, webrtc, H264, AAC</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">34</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">26</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/avdance" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;avdance" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/garrylea/posts" title="ZhiHu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;garrylea&#x2F;posts" rel="noopener" target="_blank"><i class="fa fa-fw fa-zhihu"></i> ZhiHu</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://www.beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备19056322号-1</a> <img src="/images/beianico.png" style="display:inline-block"><a href="https://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11011102001366" rel="noopener" target="_blank">京公网安备11011102001366号</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2021</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">李超</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span title="站点总字数">180k</span></div><script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"Cu6h7B3RnNt3uEMrRWpVlIU6-gzGzoHsz","app_key":"5dKv9XFD2w3gjJnb0xnWIIWz","server_url":"https://leancloud.cn","security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        //if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script><script>AV.initialize("Cu6h7B3RnNt3uEMrRWpVlIU6-gzGzoHsz","5dKv9XFD2w3gjJnb0xnWIIWz")</script><script>function showTime(e){var t=new AV.Query(e),c=[],u=$(".leancloud_visitors");u.each(function(){c.push($(this).attr("id").trim())}),t.containedIn("url",c),t.find().done(function(e){var t=".leancloud-visitors-count";if(0!==e.length){for(var n=0;n<e.length;n++){var o=e[n],i=o.get("url"),s=o.get("time"),r=document.getElementById(i);$(r).find(t).text(s)}for(n=0;n<c.length;n++){i=c[n],r=document.getElementById(i);var l=$(r).find(t);""==l.text()&&l.text(0)}}else u.find(t).text(0)}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(i){var e=$(".leancloud_visitors"),s=e.attr("id").trim(),r=e.attr("data-flag-title").trim(),t=new AV.Query(i);t.equalTo("url",s),t.find({success:function(e){if(0<e.length){var t=e[0];t.fetchWhenSave(!0),t.increment("time"),t.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var n=new i,o=new AV.ACL;o.setPublicReadAccess(!0),o.setPublicWriteAccess(!0),n.setACL(o),n.set("title",r),n.set("url",s),n.set("time",1),n.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):1<$(".post-title-link").length&&showTime(e)})</script><link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.min.css"><script src="/lib/needsharebutton/needsharebutton.min.js"></script><script>flOptions={iconStyle:"box",boxForm:"horizontal",position:"topRight",networks:"Weibo,Wechat,QQZone"},new needShareButton("#needsharebutton-float",flOptions)</script><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('/lib/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Cu6h7B3RnNt3uEMrRWpVlIU6-gzGzoHsz',
      appKey     : '5dKv9XFD2w3gjJnb0xnWIIWz',
      placeholder: "畅所欲言？",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script></body></html>