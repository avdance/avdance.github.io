<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.1"><link rel="icon" type="image/png" sizes="32x32" href="/images/avdance32_32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/avdance16_16.ico"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"blog.avdancedu.com",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!0,pangu:!1,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!1,nav:null,activeClass:"valine"},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="今天我们来聊聊C++的智能指针。C++从1983年诞生到现在已经有30多年历史了，为什么到现在还能如此流行呢(排名第四，2020年6月HelloGitHub榜单)？因为它具有很多其它语言所不具备的优势，比如说执行速度快，控制力更强等。同样的，有更多的同学会选择用Java(排名第二)等语言，这是因为它相对C++来说，它更简单，易上手，不用担心内存泄漏！ 确实，内存泄漏在很长的一段时间里是影响人们学习"><meta property="og:type" content="article"><meta property="og:title" content="细说智能指针"><meta property="og:url" content="https://blog.avdancedu.com/9683d88/index.html"><meta property="og:site_name" content="音视跳动科技"><meta property="og:description" content="今天我们来聊聊C++的智能指针。C++从1983年诞生到现在已经有30多年历史了，为什么到现在还能如此流行呢(排名第四，2020年6月HelloGitHub榜单)？因为它具有很多其它语言所不具备的优势，比如说执行速度快，控制力更强等。同样的，有更多的同学会选择用Java(排名第二)等语言，这是因为它相对C++来说，它更简单，易上手，不用担心内存泄漏！ 确实，内存泄漏在很长的一段时间里是影响人们学习"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2020-07-01T03:49:25.000Z"><meta property="article:modified_time" content="2020-07-07T13:57:16.865Z"><meta property="article:author" content="音视跳动"><meta property="article:tag" content="智能指针"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://blog.avdancedu.com/9683d88/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>细说智能指针 | 音视跳动科技</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="音视跳动科技" type="application/atom+xml"></head><body itemscope itemtype="https://schema.org/WebPage"><div class="container"><div class="headband"></div><div id="needsharebutton-float"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div><header class="header" itemscope itemtype="https://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">音视跳动科技</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">传播最前沿的科技知识！</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i> 关于</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div> <a href="https://github.com/avdance" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="https://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.avdancedu.com/9683d88/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="image" content="/images/avdancelogo.jpg"><meta itemprop="name" content="音视跳动"><meta itemprop="description" content="传输最前沿的科技知识，学习音视频的圣地！ffmpeg, webrtc, H264, AAC"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="音视跳动科技"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 细说智能指针</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-07-01 11:49:25" itemprop="dateCreated datePublished" datetime="2020-07-01T11:49:25+08:00">2020-07-01</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-07-07 21:57:16" itemprop="dateModified" datetime="2020-07-07T21:57:16+08:00">2020-07-07</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span></span><span id="/9683d88/" class="post-meta-item leancloud_visitors" data-flag-title="细说智能指针" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/9683d88/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/9683d88/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>18k</span></span></div></header><div class="post-body" itemprop="articleBody"><p>今天我们来聊聊C++的智能指针。C++从1983年诞生到现在已经有30多年历史了，为什么到现在还能如此流行呢(排名第四，2020年6月<a href="https://hellogithub.com/report/tiobe/" target="_blank" rel="noopener">HelloGitHub榜单</a>)？因为它具有很多其它语言所不具备的优势，比如说执行速度快，控制力更强等。同样的，有更多的同学会选择用Java(排名第二)等语言，这是因为它相对C++来说，它更简单，易上手，不用担心内存泄漏！</p><p>确实，<strong>内存泄漏</strong>在很长的一段时间里是影响人们学习C++的一个最重要的原因。不过C++也在不断进步中，智能指针的出现就大大降低了内存泄漏发生的风险。</p><p>下面我们就来细聊一下C++智能指针的方方面面，通过本文让你真正掌握C++智能指针。</p><a id="more"></a><h2 id="内存泄漏的产生"><a href="#内存泄漏的产生" class="headerlink" title="内存泄漏的产生"></a>内存泄漏的产生</h2><p>在C++中内存的分配与释放都是手工操作的(分配内存用<code>new</code>，释放内存用<code>delete</code>)，这种方式本身就很容易产生内存泄漏。因为人们在开发过程中需要内存时很自然的就用new分配一块，但这块内存什么时候释放就说不好了，有可能用完马上就释放，也有可能要等待一个周期才能释放等等。而且随着时间的推移，代码越来越大，需要被释放的内存被遗忘的可能性也就更大。</p><p>我来看一下具体的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *pVal = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line">    *pVal = <span class="number">10</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(*pVal == <span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;      <span class="comment">//这里会产生内存泄漏</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">delete</span> pVal;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，使用new在堆空间分配了一个整型大小的空间，在函数结束时通过delete将分配的内存释放。但当<code>pVal==10</code>时，函数没有释放内存就直接退出了，此时就产生了内存泄漏。</p><p>有的同学可能会说，谁会写出这么蠢的代码呢？实际上这样的代码在C++项目中经常出现，很多老手有时都犯这样的错误。你之所以可以一眼就看出上面代码的问题，是因为我将代码简化了。在真实的场景中，由于代码量比较大，你就没那么容易一眼看出问题了。</p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>上面我们已经看到了，通过new/delete这种方式申请/释放内存存在着很大弊端，有没有什么方法可以在使用时申请内存，在不需要的时自动释放它呢？当然有，<strong>这就是智能指针</strong>。</p><p>下面我们来看看智能指针是怎么做到的吧。实际上，智能指针最朴素的想法是利用类的<code>析构函数</code>和<code>函数栈</code>的自动释放机制来自动管理指针，即用户只要按需分配堆空间，堆空间的释放由智能指针帮你完成。</p><p>在解释这个原理之前，我们先来补充两个基本知识，一是构造函数与析构函数；另一个是堆空间与栈空间。首先来看构造函数与析构函数。</p><h3 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3><p>类对象的构造与析构是C++最基本的概念了，当创建对象时其构造函数会被调用，销毁对象时其析构函数会被调用。我们来举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MyClass()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"construct func"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~MyClass()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"deconstruct func"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"create MyClass object ..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    MyClass *myclass = <span class="keyword">new</span> MyClass();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"release MyClass object ..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> myclass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译命令 clang++ -g -o myclass test_class.cpp</span></span><br></pre></td></tr></table></figure><p>我们将上面的代码编译执行后，会得到下面的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create MyClass object ...</span><br><span class="line">construct func</span><br><span class="line">release MyClass object ...</span><br><span class="line">deconstruct func</span><br></pre></td></tr></table></figure><p>通过其结果就可以证明我们上面的结论了，即<strong>创建对象时其构造函数会被调用；销毁对像时其析构函数会被调用</strong>。</p><p>下面我们再来看看堆空间与栈空间。</p><h3 id="堆空间与栈空间"><a href="#堆空间与栈空间" class="headerlink" title="堆空间与栈空间"></a>堆空间与栈空间</h3><p>我们以Linux为例，在Linux系统上每个进程都有自己的虚似地址空间，如果你的系统是32位的，那它可以访问的内存空间是：2^32，也就是4G大小。</p><p>在这么大的空间中，内存被分成了几块：内核块、代码块、BSS块、堆空间，栈空间等。</p><ul><li>内核块，由Linux内核使用，应用层不可以访问。</li><li>代码块，用户的二进制应用程序，只读。</li><li>BSS块，全局量，全局常量等。</li><li>堆空间，用new分配的动态空间，可以分配大块内存。</li><li>栈空间，用于函数调用，分配临时变量等。其空间大小有限，<strong>当函数执行完成后其内存会自动回收</strong>。</li></ul><p>其中栈空间有个特点，当函数执行完后，它所用到的栈空间会被自动释放，而这正是智能指针所需要的。当它与构造函数/析构函数结合到一起时就可以实现智能指针了。下面我们来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">AutoPtr</span><span class="params">(T *ptr = <span class="literal">nullptr</span>)</span></span>&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"set new object"</span> &lt;&lt; ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            _ptr = ptr;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~AutoPtr()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"delete object"</span> &lt;&lt; _ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(_ptr != nulptr)</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T * _ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MyClass()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"construct MyClass func"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~MyClass()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"deconstruct MyClass func"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">AutoPtr&lt;MyClass&gt; <span class="title">myclass</span><span class="params">(<span class="keyword">new</span> MyClass())</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译命令 clang++ -g -o autoptr test_autoptr.cpp</span></span><br></pre></td></tr></table></figure><p>上面例子执行的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">construct MyClass func</span><br><span class="line">set new object, 0x7f8e25c028c0</span><br><span class="line">delete object, 0x7f8e25c028c0</span><br><span class="line">deconstruct MyClass func</span><br></pre></td></tr></table></figure><p>在上面main函数中创建了一个智能指针<code>AutoPtr&lt;MyClass&gt; myclass</code>，其在堆空间分配了一个MyClass对象交由智能指针管理，即<code>myclass(new MyClass())</code>。当main函数结束时，它会调用智能指针的析构函数，析构函数中执行了<code>delete</code>操作，最终将之前new出来的myclass对象释放掉了。</p><p>通过这个例子我们可以知道，有了智能指针我们就不用再担心内存泄漏了。对于C++开发同学来说像不像中了大奖一样高兴？不过上面的AutoPtr还称不上真正的智能指针，因为它只实现了智能指针最基本的一部分功能，我们还需要对它不断完善才行。</p><h2 id="AutoPtr智能指针"><a href="#AutoPtr智能指针" class="headerlink" title="AutoPtr智能指针"></a>AutoPtr智能指针</h2><p>上面实现的智能指针有什么问题呢？最大的问题就是它不能像真正的指针一样操作，比如说不能执行<code>xxx-&gt;xxx()</code>、<code>*xxx</code>等操作。下面我们就为AutoPtr重载这两个操作符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改AutoPtr，增加 -&gt; 和 * 操作符</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    T* <span class="keyword">operator</span> -&gt; ()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    T&amp; <span class="keyword">operator</span> * ()&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;(<span class="keyword">this</span>-&gt;_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改MyClass类，增加print方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加测试例子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">AutoPtr&lt;MyClass&gt; <span class="title">myclass</span><span class="params">(<span class="keyword">new</span> MyClass())</span></span>;</span><br><span class="line">    myclass-&gt;<span class="built_in">print</span>();</span><br><span class="line">    (*myclass).<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该程序，我们可以得到下面的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">construct MyClass func</span><br><span class="line">set new object,0x7f94f44028c0</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line">delete object，0x7f94f44028c0</span><br><span class="line">deconstruct MyClass func</span><br></pre></td></tr></table></figure><p>通过上面的例子我们可以看到AutoPtr确实像一个真正的指针了，既可以通过<code>-&gt;</code>调用MyClass方法，又可以通过<code>*</code>调用MyClass方法。</p><h2 id="AutoPtr缺陷"><a href="#AutoPtr缺陷" class="headerlink" title="AutoPtr缺陷"></a>AutoPtr缺陷</h2><p>虽然上面的AutoPtr实现看着很不错，不过它有非常致命的问题。当两个AutoPtr指针指向同一块堆空间时，在释放资源时会引起crash。咱们看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加测试例子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">AutoPtr&lt;MyClass&gt; <span class="title">myclass</span><span class="params">(<span class="keyword">new</span> MyClass())</span></span>;</span><br><span class="line">    AutoPtr&lt;MyClass&gt; newPtr = myclass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你在main函数中让两个AutoPtr指向同一块堆空间时就会引起crash。之所以会出现这个问题，是因为堆空间被释放了两次。上面程序的执行结果就可以推出这个结论：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">construct MyClass func</span><br><span class="line">set new object,0x7fdecfc028c0</span><br><span class="line"></span><br><span class="line">delete object，0x7fdecfc028c0     &#x2F;&#x2F;释放第二个对象</span><br><span class="line">deconstruct MyClass func</span><br><span class="line"></span><br><span class="line">delete object，0x7fdecfc028c0     &#x2F;&#x2F;释放第一个对象</span><br><span class="line">deconstruct MyClass func</span><br><span class="line">malloc: *** error for object 0x7fdecfc028c0: pointer being freed was not allocated &#x2F;&#x2F;0x7fdecfc028c0这个空间已经被释放过一次了</span><br></pre></td></tr></table></figure><p>通过上面的运行结果我们可以知道，创建myclass智能指针时它指向了<code>new MyClass</code>所分配的空间。紧接着，程序使用默认<code>=</code>运算符将myclass中的全部内容赋值给newPtr。此时newPtr的<code>_ptr</code>成员会与myclass的<code>_ptr</code>成员指向同一块堆空间(由于使用了默认<code>=</code>运算符，所以过程没有显示出来)。</p><p>当main函数结束时，它会按次序依次调用newPtr的析构函数和myclass的析构函数，所以我们可以看到有两次”delete object，0x7fdecfc028c0”。在C++中，如果对同一地址释放多次就会引起crash，所以我们在显示结果的最后一行看到了”pointer being freed was not allocated” 这条信息表示的就是重复释放了。</p><p>因此我们必须对 AutoPtr 继续改进，防止出现重复释放的情况。如何才能防止重复释放呢？</p><h2 id="谁来独享所有权？"><a href="#谁来独享所有权？" class="headerlink" title="谁来独享所有权？"></a>谁来独享所有权？</h2><p>我们可以想到的最简单的办法是当有多个智能指针指向同一块堆空间时，只能有一个智能指针拥有所有权。什么意思呢？就是这块堆空间的释放只能由其中的一个来完成。</p><h3 id="允许共享，独占所有权"><a href="#允许共享，独占所有权" class="headerlink" title="允许共享，独占所有权"></a>允许共享，独占所有权</h3><p>怎么才能让众多智能指针中的一个拥有所有权呢？简单的办法是在AutoPtr上加个owner就好了。我们将上面的代码修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    explicit AutoPtr(T *ptr = nullptr):_ptr(ptr), _owner(true)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr(AutoPtr&lt;T&gt; &amp; autoptr):_ptr(autoptr._ptr), _owner(<span class="literal">false</span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~AutoPtr()&#123;</span><br><span class="line">        <span class="keyword">if</span>(_owner &amp;&amp; _ptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr&amp; <span class="keyword">operator</span>=(AutoPtr&lt;T&gt; &amp; autoptr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;autoptr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(_ptr)&#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_ptr = autoptr._ptr;</span><br><span class="line">            _owner = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _ptr;</span><br><span class="line">    <span class="keyword">bool</span> _owner;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>经上面修改后，<code>new MyClass</code>分配的空间就有了具体的owner，所以再执行之前的测试程序就不会crash了。结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">construct MyClass func</span><br><span class="line">set new object,0x7fb9acc028c0</span><br><span class="line">copy construct, 0x7fb9acc028c0</span><br><span class="line">delete object，0x7fb9acc028c0   &#x2F;&#x2F; 调用newPtr 析构</span><br><span class="line">delete object，0x7fb9acc028c0   &#x2F;&#x2F; 调用 myclass 析构</span><br><span class="line">deconstruct MyClass func        &#x2F;&#x2F; 由于myclass是owner，所以才会真正的释放堆空间</span><br></pre></td></tr></table></figure><p>通过上面的修改问题似乎已经得到了解决，但实际的情况是后创建的智能指针更应该是owner，所以我们再做下微调：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    explicit AutoPtr(T *ptr = nullptr):_ptr(ptr), _owner(true)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr(AutoPtr&lt;T&gt; &amp; autoptr):_ptr(autoptr._ptr), _owner(<span class="literal">true</span>)&#123;</span><br><span class="line">        autoptr._owner = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr&amp; <span class="keyword">operator</span>=(AutoPtr&lt;T&gt; &amp; autoptr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;autoptr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(_ptr)&#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_ptr = autoptr._ptr;</span><br><span class="line">            _owner = <span class="literal">true</span>;</span><br><span class="line">            autoptr._owner = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>经上面修改后，后创建的AutoPtr就取代之前的智能指针成为owner了。我们来看一下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">construct MyClass func</span><br><span class="line">set new object,0x7fe67b4028c0</span><br><span class="line">copy construct, 0x7fe67b4028c0</span><br><span class="line">delete object，0x7fe67b4028c0       &#x2F;&#x2F; 调用newPtr析构函数</span><br><span class="line">deconstruct MyClass func            &#x2F;&#x2F; 堆空间被释放掉了</span><br><span class="line">delete object，0x7fe67b4028c0       &#x2F;&#x2F; 调用myclass析构函数</span><br></pre></td></tr></table></figure><p>通过上面最后三行的输出结果我们可以看出，释放空间的顺序发生了变化，说明owner已经变为最近创建的智能指针newPtr了。</p><p>调整后的AutoPtr还有没有问题呢？当然还有，我们再来看一下例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">T* <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">AutoPtr&lt;<span class="keyword">int</span>&gt; <span class="title">oldPtr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">AutoPtr&lt;<span class="keyword">int</span>&gt; <span class="title">newPtr</span><span class="params">(oldPtr)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里出现了野指针</span></span><br><span class="line">        *(oldPtr.<span class="built_in">get</span>())= <span class="number">-100</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"the value is "</span> &lt;&lt; *(oldPtr.<span class="built_in">get</span>()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我在AutoPtr中增加了一个get方法以便获得智能指针所指的堆空间</p></blockquote><p>在上面的代码中，将newPtr放到一个花括号里，这样它就有了自己的栈空间。当跳出花括号后，newPtr就完成了它的使命，然后它会将持有的资源全部释放掉。由于newPtr从oldPtr获得了<code>new int(100)</code>这块堆空间的控制权，所以当newPtr生命周期结束后，堆空间也被回收了。</p><p>但在newPtr被释放掉之后，oldPtr却还能通过get方法访问原来的堆空间，它还能将<code>-100</code>写入了被释放的堆空间。<strong>这是非常可怕的事情，因为oldPtr通过get方法拿到的已经是野指针了。</strong></p><p>因此，多智能指针共享堆空间并用owner控制最终资源释放的方法并不是特别好的智能指针方案。</p><h3 id="不允许共享，独占所有权"><a href="#不允许共享，独占所有权" class="headerlink" title="不允许共享，独占所有权"></a>不允许共享，独占所有权</h3><p>既然多智能指针共享堆空间存在着这样或那样的问题，那干脆不让他们共享得了。比如下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">AutoPtr</span><span class="params">(T * ptr=<span class="literal">nullptr</span>)</span>: _<span class="title">ptr</span><span class="params">(ptr)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr(AutoPtr&lt;T&gt; &amp; autoptr): _ptr(autoptr._ptr)&#123;</span><br><span class="line">        autoptr._ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~AutoPtr()&#123;</span><br><span class="line">        <span class="keyword">if</span>(_ptr)&#123;</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr&lt;T&gt; &amp; <span class="keyword">operator</span>=(AutoPtr&lt;T&gt; &amp; autoptr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;autoptr) &#123;</span><br><span class="line">            <span class="keyword">if</span>(_ptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            _ptr = autoptr._ptr;</span><br><span class="line">            autoptr._ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">AutoPtr&lt;<span class="keyword">int</span>&gt; <span class="title">oldPtr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line">    AutoPtr&lt;<span class="keyword">int</span>&gt; newPtr = oldPtr; <span class="comment">//oldPtr已经不指向堆空间了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中我们不允许多个AutoPtr之间共享同一块堆空间，当将一个AutoPtr赋值给另一个AutoPtr时，让原来的AutoPtr指向空地址（nullptr)，新的AutoPtr指向堆空间。上面代码执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set new object,0x7fe905502760</span><br><span class="line">copy construct, 0x7fe905502760          &#x2F;&#x2F;newPtr 指向堆空间</span><br><span class="line">delete object，0x7fe905502760           &#x2F;&#x2F;newPtr 析构</span><br><span class="line">really,delete object，0x7fe90550276     &#x2F;&#x2F;newPtr 指向的堆空间被释放</span><br><span class="line">delete object，0x0                      &#x2F;&#x2F;oldPtr 析构，此时可以看到它指向的地址为nullptr</span><br></pre></td></tr></table></figure><p>通过结果可以证明我们上面修改的代码已经阻止了多个AutoPtr共享同一块堆空间的可能。</p><p>然而上面的实现打破了我们对传统指针的认知，这会给你带来很多麻烦。尤其是多人合作时，如果大家对AutoPtr没有一致的认识，特别容易出现问题。因为既然是指针，那它就应该允许多个指针指向同一块堆空间。因此，当不有了解AutoPtr的同学使用它时，很可能还会认为多个AutoPtr是指向同一块堆空间的，这样当他通过老的AutoPtr向堆空间写数据时就会产生crash。比如像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">*(oldptr.get()) &#x3D; 10;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set new object,0x7fd93bc028c0</span><br><span class="line">copy construct, 0x7fd93bc028c0</span><br><span class="line">[1]    39662 segmentation fault  .&#x2F;autoptr  &#x2F;&#x2F;这里crash了</span><br></pre></td></tr></table></figure><p>上面的AutoPtr就是C++98规范中的auto_ptr的实现，由于该实现总是存在这样或那样的问题，因此现在auto_ptr已经被废弃掉了。</p><h2 id="scoped-ptr"><a href="#scoped-ptr" class="headerlink" title="scoped_ptr"></a>scoped_ptr</h2><p>我们已经看到上面的AutoPtr有各种弊端，引起这些弊端的最主要的原因是AutoPtr具有控制权的传递性，也就是说它允许从一个AutoPtr赋值给另一个AutoPtr。</p><p>为了彻底解决AutoPtr上面所述的问题，就出现了scoped_ptr。scoped_ptr最早是在C++的boost库中出现的，其出现的原因是从C++98之后C++标准一直没有更新智能指针的规范。因此C++大牛们纷纷发布了自己私有标准，而scoped_ptr就是其中之一。</p><p>scoped_ptr的核心思想是什么呢？既然auto_ptr的所有问题都是因为传递性引起的，所以阻止其传递性就可以解决这个问题了。因此scoped_ptr的实现也特别简单，它将其拷贝构造函数及赋值操作符全部隐藏起来，这样就不会有auto_ptr的问题了。</p><p>下面我们来看一下它的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScopedPtr</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ScopedPtr(T * ptr = <span class="literal">nullptr</span>): _ptr(ptr)&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T* <span class="keyword">operator</span>-&gt;()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T&amp; <span class="keyword">operator</span>*()&#123;</span><br><span class="line">            <span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_ptr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">T* <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~ScopedPtr()&#123;</span><br><span class="line">            <span class="keyword">if</span>(_ptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        ScopedPtr(ScopedPtr&lt;T&gt; &amp; scopedptr)&#123;&#125;</span><br><span class="line">        ScopedPtr&lt;T&gt; &amp; <span class="keyword">operator</span>=(ScopedPtr&lt;T&gt; &amp; scopedptr)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T *_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">ScopedPtr&lt;<span class="keyword">int</span>&gt; <span class="title">myPtr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line">    ScopedPtr&lt;<span class="keyword">int</span>&gt; newPtr = myPtr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//clang++ -g -o scopedptr test_scopedptr.cpp</span></span><br></pre></td></tr></table></figure><p>当我们编译上面的代码时，会报下面的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test_scopedptr.cpp:32:29: error: calling a protected constructor of class &#39;ScopedPtr&lt;int&gt;&#39;</span><br><span class="line">    ScopedPtr&lt;int&gt; newPtr &#x3D; myPtr;</span><br><span class="line">                            ^</span><br><span class="line">test_scopedptr.cpp:23:9: note: declared protected here</span><br><span class="line">        ScopedPtr(ScopedPtr&lt;T&gt; &amp; scopedptr)&#123;&#125;</span><br><span class="line">        ^</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure><p>上面的错误正是我们想要的结果。只要你对ScopedPtr进行赋值，在编译时就不让其编译通过，这样就不会再产生AutoPtr的问题了。</p><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>我们上面所讲的scoped_ptr并非是官方的标准，它是C++大牛们自己实现的版本。到了C++11之后官方版本来了，其被命名为unique_ptr。实际上unique_ptr与scoped_ptr功能几乎是一模一样，不过它们之间也有一些细微差别。</p><p>差别是什么呢？就是unique_ptr可以对右值进行转移，<code>对右值转移</code>这是啥意思呢？说明白了就是提供了一种特殊方法可以将unique_ptr赋值给另一个unique_ptr，被转移后的unique_ptr也就不能再处理之前管理的指针了。</p><p>我们还是来看一个具体的例子你就清楚了，只要给我们之前的ScopedPtr加上一个移动构造函数和移动赋值运算符就实现unique_ptrr的转移功能了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class ScopedPtr&#123;</span><br><span class="line">    ...</span><br><span class="line">    ScopedPtr(ScopedPtr&lt;T&gt;&amp;&amp; scopedptr) noexcept : _ptr(scopedptr._ptr)&#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;move construct...&quot; &lt;&lt; std::endl;</span><br><span class="line">        scopedptr._ptr &#x3D;  nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ScopedPtr&amp; operator&#x3D;(ScopedPtr&lt;T&gt; &amp;&amp; scopedptr) noexcept &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;move assignment...&quot; &lt;&lt; std::endl;</span><br><span class="line">        if(this !&#x3D; &amp;scopedptr)&#123;</span><br><span class="line">            _ptr &#x3D; scopedptr._ptr;</span><br><span class="line">           scopedptr._ptr &#x3D; nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[])&#123;</span><br><span class="line">    ScopedPtr&lt;int&gt; myPtr(new int(100));</span><br><span class="line">    &#x2F;&#x2F;ScopedPtr&lt;int&gt; newPtr &#x3D; myPtr;            &#x2F;&#x2F;拷贝构造函数已经不能用了</span><br><span class="line">    ScopedPtr&lt;int&gt; newPtr &#x3D; std::move(myPtr);   &#x2F;&#x2F;可以使用移动拷贝构造函数进行转移</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;clang++ -std&#x3D;c++11 -g -o scopedptr test_scopedptr.cpp</span><br></pre></td></tr></table></figure><p>上面main函数中的第二行调用的是拷贝构造函数，由于该函数是不是public属性，所以调用该行时会失败。而第三行会调用移动构造函数，因为我们已经实现了移动构造函数，所以该行可以编译成功。在运行时，当myPtr移动给newPtr后，myPtr也就失去了对原指针的控制权，这在代码中也有体现就是将 scopedptr的<code>_ptr</code>域设置为nullptr了。</p><p>上面就是C++11标准中的unique_ptr的实现，这样一分析下来也是蛮简单的对吧。</p><p>另外，对于移动构造函数，std::move这些概念我在另一篇文章<a href="https://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">《C++高阶知识：深入分析移动构造函数及其原理》</a>中有详细的介绍，对这块知识不了解的同学可以去看一下。</p><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>虽然unique_ptr已经很好用了，但有时候我们还是需要多个智能指针管理同一块堆内存空间。之前在讲AutoPtr时我们已经介绍了多个智能指针管理同一块内存空间会引起很多问题，有没有更好的方式来解决这些问题呢？</p><p>其中引用计数法是个不错的解决方案，实现起来也比较简单。其基本原理是当有多个智能指针指对同一块堆空间进行管理时，每增加一个智能指针引用计数就增1，每减少一个智能指针引用计数就减少。当引用计数减为0时，就将管理的堆空间释放掉。</p><p>我们还是看一个具体例子吧，其实现是在unique_ptr的基础之上实现的，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScopedPtr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        ScopedPtr(T *ptr = <span class="literal">nullptr</span>): _ptr(ptr), _ref_count(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>))&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ScopedPtr(ScopedPtr&lt;T&gt; &amp; scopedptr): _ptr(scopedptr._ptr), _ref_count(scopedptr._ref_count)&#123;</span><br><span class="line">            ++（*_ref_count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ScopedPtr &amp; <span class="keyword">operator</span>=(ScopedPtr&lt;T&gt; &amp; scopedptr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;scopedptr)&#123;</span><br><span class="line">                _release();</span><br><span class="line">                _ptr(scopedptr._ptr);</span><br><span class="line">                _ref_conut(scopedptr._ptr);</span><br><span class="line">                ++(*_ref_count);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~ScopedPtr()&#123;</span><br><span class="line">            _release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span>* <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> *_ref_count; </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="keyword">void</span> _release() &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"deconstruct...: count="</span> &lt;&lt; ((*_ref_count) <span class="number">-1</span>)  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(--(*_ref_count) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">                <span class="keyword">delete</span> _ref_count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">int</span> *_ref_count;   <span class="comment">//引用计数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">ScopedPtr&lt;<span class="keyword">int</span>&gt; <span class="title">myPtr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line">    ScopedPtr&lt;<span class="keyword">int</span>&gt; pT2 = myPtr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//clang++ -std=c++11 -g -o sharedptr test_sharedptr.cpp</span></span><br></pre></td></tr></table></figure><p>通过上面的修改，我们就可以将unique_ptr修改成shared_ptr了，测试结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">default construct ...</span><br><span class="line">copy construct ...: count&#x3D;2</span><br><span class="line">deconstruct...: count&#x3D;1</span><br><span class="line">deconstruct...: count&#x3D;0</span><br></pre></td></tr></table></figure><p>从结果中我们可以看到创建myPtr时引用计数为 1，将myPtr赋值给pT2时引用计算为2。当main程序结束后首先释放pT2，其引用计数减1。再释放myPtr，引用计数减为0，当引用计数为0时，释放堆空间。</p><p>这样的智能指针还是非常棒的，我们再也不怕内存泄漏了！！！</p><p>等等，我们好像高兴的太早了，当出现循环指向时还是会出现内存泄漏。我们来看一下例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ScopeddPtr&lt;Node&gt; _prev;</span><br><span class="line">    ScopeddPtr&lt;Node&gt; _next;</span><br><span class="line"></span><br><span class="line">    ~Node()</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"delete :"</span> &lt;&lt;<span class="keyword">this</span>&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ScopedPtr&lt;Node&gt; <span class="title">cur</span><span class="params">(<span class="keyword">new</span>(Node))</span></span>;</span><br><span class="line"><span class="function">ScopedPtr&lt;Node&gt; <span class="title">next</span><span class="params">(<span class="keyword">new</span>(Node))</span></span>;</span><br><span class="line">cur-&gt;_next = next;</span><br><span class="line">next-&gt;_prev = cur;</span><br></pre></td></tr></table></figure><p>上面这段代码就会出现内存泄漏，我们来分析一下。</p><p>首先第一行会创建三个Node类型的智能指针，分别是 <code>cur-&gt;_prev</code>、<code>cur-&gt;_next</code> 、<code>cur</code> 此时它们各自的引用计数都是 1；第二行也会创建三个Nodet智能指针，分别是<code>next-&gt;_prev</code>、<code>next-&gt;_next</code>及<code>next</code>; 第三行完成之后，<code>cur-&gt;_next</code>和<code>next</code>的引用计数都为 2；第四行完成后，<code>next-&gt;_prev</code>和<code>cur</code>的引用计数也变成了2；</p><p>当main程序结束时，next和cur分别调用它们的析构函数，因此<code>next</code>和<code>cur-&gt;_next</code>的引用计数变为1，<code>cur</code>和<code>next_prev</code>的引用计数也变成了1，但由于没有减至0，所以资源永会不会被释放掉。这就是产生内存泄露的原因。</p><p>真是辛辛苦苦好几年，一下回到解放前。使用引用计数还是会产生内存泄漏，我们仿佛又回到了起点。</p><p>不过别着急，C++11又给我们提供了新的解决方案，如何解决这个问题呢？</p><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>weak_ptr就是专门为了解决这个问题而出现的。实际上weak_ptr不能单独称为一个智能指针，它必须与shared_ptr一起使用，起到辅助share_ptr的作用。我们来看看它是如何解决上述问题的吧。</p><p>首先引入weak_ptr后，weak_ptr也要有自己的引用计数，因此我们需要修改之前的ScopedPtr，将它的计数成员变成一个类型，包括它自己的计数和weak_ptr的计数，它看起来像下面的样子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Counter():s(<span class="number">0</span>),w(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> s; <span class="comment">//存放share_ptr引用计数</span></span><br><span class="line">        <span class="keyword">int</span> w; <span class="comment">//存放weak_ptr引用计数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来我们来修改一下ScopedPtr，由于这次修改比较大，所以我给它重新起一个名子，叫作SharedPtr吧，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">WeakPtr</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SharedPtr &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        SharedPtr(T * ptr = <span class="literal">nullptr</span>):_ptr(ptr)&#123;</span><br><span class="line">            _cnt = <span class="keyword">new</span> Counter();</span><br><span class="line">           <span class="keyword">if</span>(_ptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                 _cnt-&gt;s = <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~SharedPtr()&#123;</span><br><span class="line">            _release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SharedPtr(SharedPtr&lt;T&gt; &amp; sharedptr): _ptr(sharedptr._ptr), _cnt(sharedptr._cnt)&#123;</span><br><span class="line">            _cnt-&gt;s++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SharedPtr(WeakPtr&lt;T&gt; &amp; weakptr): _ptr(weakptr._ptr), _cnt(weakptr._cnt)&#123;</span><br><span class="line">            _cnt-&gt;s++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SharedPtr &amp; <span class="keyword">operator</span>=(SharedPtr&lt;T&gt; &amp; sharedptr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> != &amp; sharedptr)&#123;</span><br><span class="line">                _release();</span><br><span class="line">                _ptr = sharedptr._ptr;</span><br><span class="line">                _cnt = sharedptr._cnt;</span><br><span class="line">                _cnt-&gt;s++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T&amp; <span class="keyword">operator</span> *()&#123;</span><br><span class="line">            <span class="keyword">return</span> *_ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T* <span class="keyword">operator</span> -&gt;()&#123;</span><br><span class="line">            <span class="keyword">return</span> _ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//friend class WeakPtr&lt;T&gt;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">       <span class="keyword">void</span> _release()&#123;</span><br><span class="line">            _cnt-&gt;s--;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"release "</span>&lt;&lt;_cnt-&gt;s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(_cnt-&gt;s &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">                <span class="keyword">if</span>(_cnt-&gt;w &lt;<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">delete</span> _cnt;</span><br><span class="line">                    _cnt=<span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T * _ptr;</span><br><span class="line">        Counter * _cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakPtr</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        WeakPtr():_ptr(<span class="literal">nullptr</span>), _cnt(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        ~WeakPtr()&#123;</span><br><span class="line">            _release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WeakPtr(WeakPtr&lt;T&gt; &amp; weakptr):_ptr(weakptr._ptr), _cnt(weakptr._cnt)&#123;</span><br><span class="line">            _cnt-&gt;w++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WeakPtr(SharedPtr&lt;T&gt; &amp; sharedptr):_ptr(sharedptr._ptr), _cnt(sharedptr._cnt)&#123;</span><br><span class="line">            _cnt-&gt;w++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WeakPtr &amp; <span class="keyword">operator</span>=(WeakPtr&lt;T&gt; &amp; weakptr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;weakptr)&#123;</span><br><span class="line">                _release();</span><br><span class="line">                _ptr = weakptr._ptr;</span><br><span class="line">                _cnt = weakptr._cnt;</span><br><span class="line">                _cnt-&gt;w++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WeakPtr &amp; <span class="keyword">operator</span>=(SharedPtr&lt;T&gt; &amp; sharedptr)&#123;</span><br><span class="line">            _release();</span><br><span class="line">            _ptr = sharedptr._ptr;</span><br><span class="line">            _cnt = sharedptr._cnt;</span><br><span class="line">            _cnt-&gt;w++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">SharedPtr&lt;T&gt; <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> SharedPtr&lt;T&gt;(*<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">expired</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(_cnt &amp;&amp; _cnt-&gt;s &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"empty "</span>&lt;&lt;_cnt-&gt;s&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//friend class SharedPtr&lt;T&gt;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="keyword">void</span> _release()&#123;</span><br><span class="line">            <span class="keyword">if</span>(_cnt)&#123;</span><br><span class="line">                _cnt-&gt;w--;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"weakptr release"</span>&lt;&lt;_cnt-&gt;w&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">if</span>(_cnt-&gt;w &lt; <span class="number">1</span> &amp;&amp; _cnt-&gt;s &lt;<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">//delete cnt;</span></span><br><span class="line">                        _cnt=<span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T * _ptr;</span><br><span class="line">        Counter * _cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    WeakPtr&lt;Node&gt; _prev;</span><br><span class="line">    WeakPtr&lt;Node&gt; _next;</span><br><span class="line"></span><br><span class="line">    ~Node()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"delete :"</span> &lt;&lt;<span class="keyword">this</span>&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">SharedPtr&lt;Node&gt; <span class="title">cur</span><span class="params">(<span class="keyword">new</span>(Node))</span></span>;</span><br><span class="line">    <span class="function">SharedPtr&lt;Node&gt; <span class="title">next</span><span class="params">(<span class="keyword">new</span>(Node))</span></span>;</span><br><span class="line">    cur-&gt;_next = next;</span><br><span class="line">    next-&gt;_prev = cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//clang++ -std=c++11 -g -o weakptr test_weakptr.cpp</span></span><br></pre></td></tr></table></figure><p>以上就是WeakPtr的实现以及SharedPtr的改造，从中我们可以看到，SharedPtr与我们之前的ScopedPtr区别并不是很大，主要做了三点有修改：一、以前只有一个计数器，然在变成了两个，一个是SharedPtr本身的计数，另一个是WeakPtr的计数；二是增加了一个参数为WeakPtr引用的拷贝构造函数;三、<code>_ptr</code>和<code>_cnt</code>的释放都是在SharedPtr中完成的，WeakPtr不做具体的释放工作。</p><p>WeakPtr是新增加的弱指针，它是配合SharedPtr使用的，自己并不能单独使用。WeakPtr也包含<code>_ptr</code>和<code>_cnt</code>两个成员，但它更多是是引用，对它们没有创建和释放权。另外在WeakPtr中会对Counter对象的w字段操作，也就是说多个WeakPtr指向同一个堆空间时，它仅操作Counter中的w字段。</p><p>因此，对于我们之前的SharedPtr形成环后导致的内存泄漏可以通过WeakPtr对其进行改造，这样内存泄漏的问题就迎刃而解了。</p><p>上面修改后的代码我们再来分析一遍。首先第一行会创建两个WeakPtr指针 <code>cur-&gt;_prev</code>、<code>cur-&gt;_next</code> 和一个SharedPtr智能指针<code>cur</code>。此时它们各自的引用计数都是 1；第二行同样也会创建二个WeakPtr指针<code>next-&gt;_prev</code>、<code>next-&gt;_next</code>和一个SharedPtr智能指针<code>next</code>; 第三行完成之后，<code>cur-&gt;_next</code>的_cnt-&gt;w为1，<code>next</code>的_cnt-&gt;s为1；第四行完成后，<code>next-&gt;_prev</code>的_cnt-&gt;w为1，<code>cur</code>的_cnt-&gt;s引用计数也为1；</p><p>当main程序结束时，next和cur分别调用它们的析构函数，因此<code>next</code>引用计数为0，释入Node对象，在Node中又会释放_prev和_next。next释放完成后开始释放<code>cur</code>，同里cur所持有的资源也一并释放。因此就不会再有内存泄漏了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文的篇幅有点长，不过每一部分都是不可或缺的。在本文中向你详细讲解了 auto_ptr、scoped_ptr、unique_ptr、shared_ptr以及与之配套的 weak_ptr的衍化过程。通过这样一个过程让你知道了这几个智能指针的作用是什么，应该用在地方，以及该如何使用。</p><p>相信通过本文你会对C++中的智能指针有了深刻的理解。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">C++高阶知识：深入分析移动构造函数及其原理</a><br>[重学C/C++中的const][<a href="https://avdancedu.com/5e7916e3/]" target="_blank" rel="noopener">https://avdancedu.com/5e7916e3/]</a><br><a href="http://localhost:4000/670ef31f/" target="_blank" rel="noopener">聊聊C++中的类型转换</a></p></div><div class="reward-container"><div></div> <button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'> 打赏</button><div id="qr" style="display:none"><div style="display:inline-block"> <img src="https://cdn.avdancedu.com/image/next/wechat.jpeg" alt="音视跳动 微信支付"><p>微信支付</p></div><div style="display:inline-block"> <img src="https://cdn.avdancedu.com/image/next/alipay.jpeg" alt="音视跳动 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> 音视跳动-李超 [avdance@163.com]</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://blog.avdancedu.com/9683d88/" title="细说智能指针">https://blog.avdancedu.com/9683d88/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><p>欢迎关注我的其它发布渠道</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="https://cdn.avdancedu.com/image/next/WeChat.jpeg"><span class="icon"><i class="fa fa-wechat"></i></span> <span class="label">WeChat</span></a></div><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" rel="tag"><i class="fa fa-tag"></i> 智能指针</a></div><div class="post-nav"><div class="post-nav-item"><a href="/5e7916e3/" rel="prev" title="重学C/C++中的const"><i class="fa fa-chevron-left"></i> 重学C/C++中的const</a></div><div class="post-nav-item"> <a href="/a39d51f9/" rel="next" title="C++高阶知识：深入分析移动构造函数及其原理">C++高阶知识：深入分析移动构造函数及其原理<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#内存泄漏的产生"><span class="nav-number">1.</span> <span class="nav-text">内存泄漏的产生</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#智能指针"><span class="nav-number">2.</span> <span class="nav-text">智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数与析构函数"><span class="nav-number">2.1.</span> <span class="nav-text">构造函数与析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆空间与栈空间"><span class="nav-number">2.2.</span> <span class="nav-text">堆空间与栈空间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AutoPtr智能指针"><span class="nav-number">3.</span> <span class="nav-text">AutoPtr智能指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AutoPtr缺陷"><span class="nav-number">4.</span> <span class="nav-text">AutoPtr缺陷</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谁来独享所有权？"><span class="nav-number">5.</span> <span class="nav-text">谁来独享所有权？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#允许共享，独占所有权"><span class="nav-number">5.1.</span> <span class="nav-text">允许共享，独占所有权</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不允许共享，独占所有权"><span class="nav-number">5.2.</span> <span class="nav-text">不允许共享，独占所有权</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#scoped-ptr"><span class="nav-number">6.</span> <span class="nav-text">scoped_ptr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unique-ptr"><span class="nav-number">7.</span> <span class="nav-text">unique_ptr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shared-ptr"><span class="nav-number">8.</span> <span class="nav-text">shared_ptr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#weak-ptr"><span class="nav-number">9.</span> <span class="nav-text">weak_ptr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">10.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">11.</span> <span class="nav-text">参考</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="https://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="音视跳动" src="/images/avdancelogo.jpg"><p class="site-author-name" itemprop="name">音视跳动</p><div class="site-description" itemprop="description">传输最前沿的科技知识，学习音视频的圣地！ffmpeg, webrtc, H264, AAC</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">34</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">26</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/avdance" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;avdance" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/garrylea/posts" title="ZhiHu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;garrylea&#x2F;posts" rel="noopener" target="_blank"><i class="fa fa-fw fa-zhihu"></i> ZhiHu</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://www.beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备19056322号-1</a> <img src="/images/beianico.png" style="display:inline-block"><a href="https://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11011102001366" rel="noopener" target="_blank">京公网安备11011102001366号</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2021</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">李超</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span title="站点总字数">180k</span></div><script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"Cu6h7B3RnNt3uEMrRWpVlIU6-gzGzoHsz","app_key":"5dKv9XFD2w3gjJnb0xnWIIWz","server_url":"https://leancloud.cn","security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        //if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script><script>AV.initialize("Cu6h7B3RnNt3uEMrRWpVlIU6-gzGzoHsz","5dKv9XFD2w3gjJnb0xnWIIWz")</script><script>function showTime(e){var t=new AV.Query(e),c=[],u=$(".leancloud_visitors");u.each(function(){c.push($(this).attr("id").trim())}),t.containedIn("url",c),t.find().done(function(e){var t=".leancloud-visitors-count";if(0!==e.length){for(var n=0;n<e.length;n++){var o=e[n],i=o.get("url"),s=o.get("time"),r=document.getElementById(i);$(r).find(t).text(s)}for(n=0;n<c.length;n++){i=c[n],r=document.getElementById(i);var l=$(r).find(t);""==l.text()&&l.text(0)}}else u.find(t).text(0)}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(i){var e=$(".leancloud_visitors"),s=e.attr("id").trim(),r=e.attr("data-flag-title").trim(),t=new AV.Query(i);t.equalTo("url",s),t.find({success:function(e){if(0<e.length){var t=e[0];t.fetchWhenSave(!0),t.increment("time"),t.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var n=new i,o=new AV.ACL;o.setPublicReadAccess(!0),o.setPublicWriteAccess(!0),n.setACL(o),n.set("title",r),n.set("url",s),n.set("time",1),n.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):1<$(".post-title-link").length&&showTime(e)})</script><link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.min.css"><script src="/lib/needsharebutton/needsharebutton.min.js"></script><script>flOptions={iconStyle:"box",boxForm:"horizontal",position:"topRight",networks:"Weibo,Wechat,QQZone"},new needShareButton("#needsharebutton-float",flOptions)</script><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('/lib/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Cu6h7B3RnNt3uEMrRWpVlIU6-gzGzoHsz',
      appKey     : '5dKv9XFD2w3gjJnb0xnWIIWz',
      placeholder: "畅所欲言？",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script></body></html>