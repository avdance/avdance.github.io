<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>音视跳动科技</title>
  
  <subtitle>传播最前沿的科技知识！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.avdancedu.com/"/>
  <updated>2023-03-10T01:56:13.920Z</updated>
  <id>https://blog.avdancedu.com/</id>
  
  <author>
    <name>音视跳动</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用Mac系统下的GPU搭建机器学习环境</title>
    <link href="https://blog.avdancedu.com/eaff035c/"/>
    <id>https://blog.avdancedu.com/eaff035c/</id>
    <published>2023-03-09T02:30:45.000Z</published>
    <updated>2023-03-10T01:56:13.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Anaconda还是Miniconada"><a href="#Anaconda还是Miniconada" class="headerlink" title="Anaconda还是Miniconada?"></a>Anaconda还是Miniconada?</h2><p>使用Python的人都会遇到库的安装、环境的管理问题，Conda就是这样一个工具来帮助你解决这些问题。</p><p>Anaconda想必大家比较熟悉，但是很多人并不知道还有个轻量化的Miniconda。对于有一定基础的Python使用者，我本人更推荐Miniconda的。</p><p>Anaconda:</p><ul><li>适合初学者（因为有图形界面，还内置了jupyter lab, spider等等）</li><li>预装了超过1500个科学计算库（99%其实用不上）</li><li>安装比较耗时，也比较占用空间</li><li>因为预装了很多库，所以不需要重复下载。</li><li>可能对一些库做了改进（？）</li></ul><p>Miniconda:</p><ul><li>不介意手动安装所需的库（其实这个并不麻烦）</li><li>节省空间和时间</li></ul><p>我个人感觉Anaconda太过笨重，很多人的电脑可能打开Anaconda都需要一点时间。图形化的界面在我看来反应比较迟钝，如果使用命令行其实还不如直接上Miniconda。</p><h2 id="安装Miniconda"><a href="#安装Miniconda" class="headerlink" title="安装Miniconda"></a>安装Miniconda</h2><p>从这里<a href="https://conda.io/en/latest/miniconda.html">下载Miniconda</a>。假设我们使用的Python版本是3.10，执行下面的命令来安装Miniconda:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh Minconda3-xxx-xxx...sh -b</span><br></pre></td></tr></table></figure><p>然后执行下面的命令初始化conda:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/miniconda3/bin/conda init</span><br></pre></td></tr></table></figure><p>至此，Miniconda就安装好了。</p><h2 id="配置新的Python环境"><a href="#配置新的Python环境" class="headerlink" title="配置新的Python环境"></a>配置新的Python环境</h2><p>当Miniconda安装好后，我们可以通过下面的命令创建一个新的Python环境:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name ml python=3.10 -y</span><br></pre></td></tr></table></figure><p>上面我就使用conda创建了一个新的Python环境，名子叫ml，它使用的Python是3.10。<br>不过，虽然我们创建好了Python环境，但它还不能使用，因为在使用之前需要先将它激活。你可以使用下面的命令来激活它:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate ml</span><br></pre></td></tr></table></figure><p>另外，当我们不需要这个环境时，可以通过下面的命令退出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate </span><br></pre></td></tr></table></figure><h2 id="安装pytorch"><a href="#安装pytorch" class="headerlink" title="安装pytorch"></a>安装pytorch</h2><p>前面将Python环境设置好后，接下来就可以安装Pytorch了，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch torchvision torchaudio -c pytorch</span><br></pre></td></tr></table></figure><p>之后，你可以使用下面命令验证你的Mac M1中是否有可用的GPU:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &quot;import torch;print(torch.backends.mps.is_built())&quot;</span><br></pre></td></tr></table></figure><p>如果命令的返回结果为<code>True</code>，说明有GPU可用。</p><h2 id="使用Mac-M1下的GPU"><a href="#使用Mac-M1下的GPU" class="headerlink" title="使用Mac M1下的GPU"></a>使用Mac M1下的GPU</h2><p>在Mac M1下的GPU称作<strong>mps</strong>，它类似于Nvidia的<strong>cuda</strong>。如果你想在Mac M1下使用GPU进行深度学习的训练，只需要将运算指定到mps上运行即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">model = torch.nn.Linear(5,1).to(&#x27;mps&#x27;)</span><br><span class="line">x = torch.randn(5).to(&#x27;mps&#x27;)</span><br><span class="line">y = model(x)</span><br><span class="line">pront(y.shape)</span><br></pre></td></tr></table></figure><p>如上代码所示，该代先首先定义了一个最简单5x1的线性模形，并告诉Pytorch它在Mac M1的GPU上运行；然后给该模形创建一个输入，该输入也是在GPU<br>上，是一个5x5的tensor，最后输出运算结果的维度。</p><p>如果上面的代码可以正常运行，说明你Mac上的GPU确实可以正常工作。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>如果你是一名机器学习的初学者，并且手上有一台Mac电脑的话，你可以直接使用Mac搭建机器学习环境进行学习。这样就可以节省一大笔钱了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Anaconda还是Miniconada&quot;&gt;&lt;a href=&quot;#Anaconda还是Miniconada&quot; class=&quot;headerlink&quot; title=&quot;Anaconda还是Miniconada?&quot;&gt;&lt;/a&gt;Anaconda还是Miniconada?&lt;/h2
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://blog.avdancedu.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://blog.avdancedu.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>深度学习开发环境搭建</title>
    <link href="https://blog.avdancedu.com/73ca35b3/"/>
    <id>https://blog.avdancedu.com/73ca35b3/</id>
    <published>2023-03-05T08:59:47.000Z</published>
    <updated>2023-03-05T11:58:00.712Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/deeplearning/RTX4090.png"><br>最近随着<strong>Midjourney</strong>和<strong>ChatGPT</strong>爆火之后，人工智能，深度学习又开始了新的一波学习浪潮。很多同学在学习深度学习的过程中，苦于没有好的实验环境，半路退场，实在可惜。</p><p>我这里整理了两种搭建深度学习实验环境的方法，希望对大家能有所帮助！</p><span id="more"></span><h2 id="使用免费GPU云主机"><a href="#使用免费GPU云主机" class="headerlink" title="使用免费GPU云主机"></a>使用免费GPU云主机</h2><p>实际上，国际上以<strong>Google</strong>为首的一些大企业，他们知道搭建自己的深度学习环境，不仅成本高而且难度也大，因此为学生和小白们准备了一些免费的GPU云主机，专门供大家学习使用。这些企业真是 <strong>业界良心</strong>，<strong>为这些企业点赞！！！</strong></p><p>下面我们就来看看如何在Google云上申请一台免费的GPU云主机。</p><p>首先，众所周知的原因，你需要有能够访问外网的能力。这一步是逃不过去的。<br>之后，你需要在Google云上注册一个账户，同时绑定信用卡。</p><p>以上两步可能是大多数同学申请免费GPU云主机的最大障碍，没办法，免费也是有代价的：）</p><p>当上述两步完成后，接下来你就可以申请免费GPU云主机了。打开Google的<a href="https://colab.research.google.com/">Colab</a>，之后你应该可以看到下面的界面<br><img data-src="https://cdn.avdancedu.com/image/article/deeplearning/Colaboratory.png"></p><p>有可能你的界面不是中文的而是英文，这没关系只要能进入到这个界面，你就可以申请CPU云主机了。</p><p>进入到该界面后，首先在右侧的欢迎页面中选中一段代码，之后点击图中红线框出来的项 <strong>“代码执行程序”</strong>。</p><p>在弹出的下拉框中选择 <strong>“更改运行时类型”</strong>，如下图所示：<br><img data-src="https://cdn.avdancedu.com/image/article/deeplearning/runtime.png"></p><p>紧接着，在弹出的窗口中选择 <strong>“GPU”</strong>，这样你就拥有了一台带GPU的云主机。</p><p>现在让我们来看看Google有没有给我们分配好GPU，分配的GPU又是哪种型号吧！</p><p>首先我们在Colab中点击右侧的<strong>“+代码”</strong>，如下图所示：<br><img data-src="https://cdn.avdancedu.com/image/article/deeplearning/run_code.png"></p><p>在代码框中输入如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">torch.cuda.is_available()</span><br></pre></td></tr></table></figure><p>之后点击运行，如果看到下面的结果，说明GPU已经分配好了。<br><img data-src="https://cdn.avdancedu.com/image/article/deeplearning/run_code_result.png"></p><p>另外，如果你想知道Google结你分配的GPU型号，可以使用下面的命令查看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!nvidia-smi</span><br></pre></td></tr></table></figure><p><img data-src="https://cdn.avdancedu.com/image/article/deeplearning/GPU_type.png"></p><p>从上图你可以知道，Google给我分配的GPU是<strong>Tesla T4</strong>，这块GPU性能还是蛮不错的。该云主机安装的Nvidia Driver版本是 <strong>525.85.12</strong>，CUDA版本是 <strong>12.0</strong>。</p><p>Goole免费可以申请的GPU主要有三种型号，分别是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P100 &gt; T4 &gt; K80</span><br></pre></td></tr></table></figure><p>其中 P100的性能与 RTX3090Ti差不多。</p><p>如果你觉得Goole给你分配的GPU性能不够，那你还可以申请Pro，每月只要 <strong>$9.9</strong>，还是蛮便宜的。</p><p>如果你觉得在Google上申请免费的GPU太麻烦，也可以自己搭建深度学习环境，下面我再介绍一下如何在自己的主机上搭建环境。</p><h2 id="搭建自己的深度学习环境"><a href="#搭建自己的深度学习环境" class="headerlink" title="搭建自己的深度学习环境"></a>搭建自己的深度学习环境</h2><p>要搭建自己的深度学习环境，你首先要有一台“超级计算机”，最主要的是配一块高端显卡，比如RTX4090、RTX3090TI或RTX3090。配置这样一台主机价格不菲，少说要3W左右。</p><p>我配置的就是RTX3090，性价比还是蛮高的。当然Nvidia还有很多低端显卡，但我不建议购买这些低端显卡，一方面容易买到<strong>矿卡（二手卡）</strong>；另一方面这些卡性能不够，做深度学习训练时会很慢。</p><p>机子配置好了，接下来我们看看如何搭建深度学习环境！</p><p>首先是操作系统，搭建深度学习环境最好使用Ubuntu系统，很多资料都是以Ubuntu系统为基础讲解的。</p><p>当然用Windows环境搭建也没任何问题，我这里就是在Windows系统上安装的。因此，这里我只介绍在Windows下如何搭建深度学习环境，想在Ubuntu下搭建环境的同学可以自己在网上查找资料。</p><p>Windows下搭建深度学习环境的步骤如下：</p><p>首先，安装Nvidia GPU驱动，你可以从<a href="https://www.nvidia.cn/Download/index.aspx?lang=cn">这里</a>下载你与操作系统、显卡匹配的Driver。下载好后双击安装即可。</p><p>之后，安装Anaconda。该工具主要是为了管理多个Python开发环境，你可以从<a href="https://www.anaconda.com/products/distribution/start-coding-immediately">这里</a>下载Anaconda。同样将该包下载好后，双击安装即可。</p><p>紧接着，我们就可以使用Anaconda来创建自己的Python环境了。创建环境的命令如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n ml_env</span><br></pre></td></tr></table></figure><p>通过上述命令，我们就创建了一个名为<strong>ml_env</strong>的python的开发环境。</p><p>接下来，我们可以使用Anaconda安装pytorch、CUDA等包。你可以到pytorch的官网上查看最近的pytorch版本，地址如下：<a href="https://pytorch.org/get-started/locally/">https://pytorch.org/get-started/locally/</a></p><p>并根据自己的实际情况做选择要装哪些包，我的选择如下：<br><img data-src="https://cdn.avdancedu.com/image/article/deeplearning/pytorch_env.png"></p><p>当选择好pytorch版本，操作系统等信息后，它会给你提供一条安装相关包的指令，即</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch torchvision torchaudio pytorch-cuda=<span class="number">11.7</span> -c pytorch -c nvidia</span><br></pre></td></tr></table></figure><p>在执行该执令之前，我们需要将前面创建好的环境名加上，这样可以让这些包只做用于我们刚创建的环境中，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -n ml_env pytorch torchvision torchaudio pytorch-cuda=<span class="number">11.7</span> -c pytorch -c nvidia</span><br></pre></td></tr></table></figure><p>最后使用<code>conda activate ml_env</code>激活环境即可。</p><p>至此，我们自己的深度学习环境就算搭建好了。</p><p>发果你不想用这个环境了，可以调用<code>conda deactivate</code>来返激活python环境。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这里我提供了两种深度学习的开发环境，其中第一种是免费的，难点是你要有访问外网的能力并绑定一张信用卡。这种方法虽然省去了买主机的钱，但绑定信用卡也是很多同学所不愿意的。</p><p>第二种方式是自己购买主机搭建环境，这种方式的最大问题是购买主机的花费太大，对于学生来说，真的很难承受。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/deeplearning/RTX4090.png&quot;&gt;&lt;br&gt;最近随着&lt;strong&gt;Midjourney&lt;/strong&gt;和&lt;strong&gt;ChatGPT&lt;/strong&gt;爆火之后，人工智能，深度学习又开始了新的一波学习浪潮。很多同学在学习深度学习的过程中，苦于没有好的实验环境，半路退场，实在可惜。&lt;/p&gt;
&lt;p&gt;我这里整理了两种搭建深度学习实验环境的方法，希望对大家能有所帮助！&lt;/p&gt;
    
    </summary>
    
    
      <category term="深度学习" scheme="https://blog.avdancedu.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="https://blog.avdancedu.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>揭密OpenVPN工作原理</title>
    <link href="https://blog.avdancedu.com/52f625ca/"/>
    <id>https://blog.avdancedu.com/52f625ca/</id>
    <published>2023-03-03T01:05:13.000Z</published>
    <updated>2023-03-04T04:34:40.880Z</updated>
    
    <content type="html"><![CDATA[<p>由于国内的一些原因，有时候我们要下载些代码，比如WebRTC、Chrome等，必备要通过一些代理软件才能将它们下载下来。</p><p>常见的代理软件包括Virtual Private Network 和 HTTP Proxy，这两种软件的工作机制是不同的，今天我们先来聊聊 Virtual Private Network 是如何工作的，之后有机会我们再来HTTP Proxy是如何工作的。</p><p>说到 Virtual Private Network，比较有名的软件当然是 OpenVPN，今天我们就来看看它是如何工作的。 </p><span id="more"></span> <h2 id="什么是OpenVPN"><a href="#什么是OpenVPN" class="headerlink" title="什么是OpenVPN"></a>什么是OpenVPN</h2><p>OpenVPN是一种开源的虚拟专用网络软件，它由客户端和服务端组成，可以实现虚拟专用网络(VPN)连接。在VPN连接过程中，OpenVPN可以实现代理的功能，将客户端的请求通过VPN服务器代理到目标服务器。</p><p>其代理的基本过程如下：</p><ul><li>首先，OpenVPN客户端通过虚似专用网络向VPN服务器发起连接请求。</li><li>连接建立成功后，当用户访问目标服务器时，数据请求会由OpenVPN客户端发往OpenVPN服务器。</li><li>VPN服务器收到请求后，解析该请求，并路由到目标服务器。</li><li>之后，目标服务器返回响应数据。</li><li>紧接着，VPN服务器将响应数据返回给OpenVPN客户端，而OpenVPN客户端转手将响应数据返回给用户。</li></ul><p>在此过程中，OpenVPN实现了客户端与目标服务器之间的代理。由于客户端的请求经过了VPN服务器的转发，目标服务器不知道请求来自哪个客户端，保护了客户端的隐私。</p><h2 id="TUN与TAP模式"><a href="#TUN与TAP模式" class="headerlink" title="TUN与TAP模式"></a>TUN与TAP模式</h2><p>在OpenVPN中有两种工作模式，一种称为 <strong>TUN</strong>(tunnel)模式，即通道的意思；另一种是<strong>TAP</strong>(Terminal Access Point)模式，即一种网络设备或软件虚拟设备的意思。</p><p><strong>TUN模式</strong>是一种虚拟点对点的网络设备模式。通常用于实现点对点（即主机到主机）虚拟专用网络（VPN）。在TUN模式下，OpenVPN会创建一个虚拟网络接口（通常称为tun0），通过该接口发送和接收IP包。TUN模式通常用于路由网络流量，因此其只能够处理<strong>IP层</strong>（OSI模型中的第3层）数据包，<strong>不能处理链路层</strong>（OSI模型中的第2层）数据包。</p><p><strong>TAP模式</strong>是一种<strong>以太网桥</strong>设备模式。通常用于实现一点对多点（即主机到局域网）虚拟专用网络（VPN）。在TAP模式下，OpenVPN同样会创建一个虚拟网络接口（通常称为tap0），不过该接口与NAT模式下的接口不同，它可以接收和发送<strong>以太网帧</strong>，就像一个物理的以太网接口一样。TAP模式可以处理链路层数据包，因此它可以传输多种类型的网络包，如IP、ARP、NetBIOS等。</p><p>一般来说，<strong>TUN模式更适合用于远程访问，因为它可以更好地控制网络流量，并且可以提供更好的性能。而TAP模式更适合用于网络扩展，因为它可以模拟真实的局域网，并且可以传输多种类型的网络包</strong>。</p><p>因此，我们访问外网是都是使用的TUN模式。</p><h2 id="基本工作原理"><a href="#基本工作原理" class="headerlink" title="基本工作原理"></a>基本工作原理</h2><p><img data-src="https://cdn.avdancedu.com/image/article/OpenVPN/OpenVPN_arch.png"></p><p>当我们打开OpenVPN与服务端建立连接后，OpenVPN首先会创建一个虚似网络接口<strong>tun</strong>，之后使用TLS协议与服务端建立好连接。</p><p>连接建立好后，用户（应用程序）在向目标主机发送数据包时，传输到网层的数据包会被tun虚拟网络接口截获。</p><p>当tun虚拟接口截获数据后，它将为截获的数据进行加密等一系列操作，之后再将数据传给真正的网络设备，在我这里就是 <strong>eth0</strong>。</p><p><strong>eth0</strong>收到数据后，经网络路由，路由到OpenVPN服务端。服务端收到数据后进行解密，再根据目标地址将数据转交给目标主机。</p><p>目标主机收到请求后进行处理，之后将处理结果返回VPN服务器。VPN服务器再将数据返回到发送主机。</p><p>以上就是OpenVPN的基本工作原理。</p><h2 id="如何截获本地数据包"><a href="#如何截获本地数据包" class="headerlink" title="如何截获本地数据包"></a>如何截获本地数据包</h2><p>这里有同学可能会好奇，OpenVPN是如何截获用户的数据包，将其发往VPN服务器，并最终传给目标主机的呢？</p><p>其实非常简单，当使用VPN时，OpenVPN会向本地路由表中添加一个表项，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Internet:</span><br><span class="line">Destination        Gateway            Flags           Netif Expire</span><br><span class="line"><span class="number">0</span>/<span class="number">1</span>                <span class="number">10.8</span><span class="number">.0</span><span class="number">.1</span>           UGScg          utun10 </span><br><span class="line"><span class="keyword">default</span>            <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>        UGScg             en1             </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中 <code>0/1</code>的含义是，将整个网络分成两个大的网段，第一个网段是从 0.0.0.0 到 127.255.255.255，第二个网段是从 128.0.0.0 到 255.255.255.255。</p><p>由于路由规定，具体网段路由的优先权大于默认路由，因此整个网段被分成了两个具体的网络后，其优先权就大于 <code>defulat</code>路由了。所以，所有属于这两个网段的IP包都会被路由到utun10网关，又由于utun10就是VPN网关，因此就保证了所有数据都走了VPN链路。</p><p>总之，当我们在客户端建立好VPN连接后，本地路由表中就增加了<code>0/1</code>这一路由项，从而使得所有的数据都通过VPN出去了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过上面的分析，大家应该清楚OpenVPN到底是如何工作的了。我想对于很多同学来说，理解其工作原理的难点是不知道OpenVPN是如何截获网络数据包的，实际上就是通过增加一个本地路由配置，从而达到的截获数据包的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于国内的一些原因，有时候我们要下载些代码，比如WebRTC、Chrome等，必备要通过一些代理软件才能将它们下载下来。&lt;/p&gt;
&lt;p&gt;常见的代理软件包括Virtual Private Network 和 HTTP Proxy，这两种软件的工作机制是不同的，今天我们先来聊聊 Virtual Private Network 是如何工作的，之后有机会我们再来HTTP Proxy是如何工作的。&lt;/p&gt;
&lt;p&gt;说到 Virtual Private Network，比较有名的软件当然是 OpenVPN，今天我们就来看看它是如何工作的。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="OpenVPN" scheme="https://blog.avdancedu.com/categories/OpenVPN/"/>
    
    
      <category term="OpenVPN" scheme="https://blog.avdancedu.com/tags/OpenVPN/"/>
    
  </entry>
  
  <entry>
    <title>Windows下编译Chrome浏览器</title>
    <link href="https://blog.avdancedu.com/a5b21a51/"/>
    <id>https://blog.avdancedu.com/a5b21a51/</id>
    <published>2023-03-01T05:16:00.000Z</published>
    <updated>2023-03-01T05:17:37.720Z</updated>
    
    <content type="html"><![CDATA[<p>随着技术的进步，浏览器在未来会扮演越来越得要的角色。我们基本可以确定，在不久的将来，大部分Native应用都会被Web应用所替代。因此，如果你想今后想找一份好工作，或写出更高效的Web应用，就必须要了解一下浏览器的工作原理。</p><p>了解浏览器工作原理的方法有很多，但对Chrome源码的阅读无缝是第一位的，只有这样我们才能获取第一手材料。</p><p>而阅读Chrome源码的第一位就是要能够下载或编译Chrome源码。而这篇文章就是告诉你如何下载并编译Chrome源码的。</p><span id="more"></span><h2 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h2><p>编译Chrome源码要满足以下几点要求：</p><ul><li>具有至少 8GB RAM 的 64 位 Intel 机器。<strong>这里强烈建议超过 16GB，我用的是 32GB</strong></li><li>NTFS 格式的文件系统，至少要有 100GB 可用的磁盘空间。<strong>注意，FAT32文件系统不能用于编译Chrome，因为一些 Git 文件大于 4GB</strong></li><li>编辑器需要使用 Visual Studio 2022</li><li>操作系统是 Windows 10 或更新版本</li></ul><h2 id="安装Visual-Studio"><a href="#安装Visual-Studio" class="headerlink" title="安装Visual Studio"></a>安装Visual Studio</h2><p>编译 Chromium 源码我们需要安装 <strong>Visual Studio 2022 (&gt;&#x3D;17.0.0)</strong> 才行。虽然编译和调试 Chromium 使用的是 <strong>clang-cl</strong> 编译器，但它需要 Visual Studio 的一些头文件、库和工具。</p><p>当然，Visual Studio最好选择专业版，但如果你没有专业版的License，也可以使用社区版，即 <strong>Visual Studio Community Edition</strong>。</p><p>此外，在安装VS时，你还必须安装 <strong>“使用 C++ 进行桌面开发”</strong> 组件和 <strong>“MFC&#x2F;ATL 支持”</strong> 子组件。如何你不知道如何在安装界面中选择这些组件，可以使用下面的命令行安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ PATH_TO_INSTALLER.EXE ^</span><br><span class="line">--add Microsoft.VisualStudio.Workload.NativeDesktop ^</span><br><span class="line">--add Microsoft.VisualStudio.Component.VC.ATLMFC ^</span><br><span class="line">--includeRecommended</span><br></pre></td></tr></table></figure><h2 id="安装Windows-SDK"><a href="#安装Windows-SDK" class="headerlink" title="安装Windows SDK"></a>安装Windows SDK</h2><p>编译Chrome源码，Windows SDK是少不了的，它对SDK有如下要求：</p><ul><li>你必须安装 <code>10.0.22621.0</code> 版本的<strong>Windows 11 SDK</strong>。注意，<strong>即使在Win10系统下，也要安装Windows 11 的SDK，这一点特别重要</strong></li><li><a href="https://developer.microsoft.com/en-us/windows/downloads/windows-sdk/">Windows SDK</a> 可以单独安装，也可以通过 Visual Studio 来安装。这里建议采用单独的方式安装。<strong>安装好Windows SDK 后，记得要重启一下系统</strong>。</li><li>安装Window SDK时，还必须安装 10.0.22621.755 (Windows 11) SDK 调试工具，以支持 Chrome 能访问大于 4 GiB PDB 的大页面。如果你不知道该如何选择的话，建议你安装Windows SDK时，<strong>将所有选项都勾选上</strong>，否则后面编译时会出现各种头文件找不到的情况。</li></ul><h2 id="安装depot-tools"><a href="#安装depot-tools" class="headerlink" title="安装depot_tools"></a>安装depot_tools</h2><p>首先，从这里下载 <a href="https://storage.googleapis.com/chrome-infra/depot_tools.zip">depot_tools</a> 包，并将其解压到某个目录下，例如：C:\src\depot_tools。</p><blockquote><p>注意：解压缩时，不要采用拖放或复制粘贴的方式提取。这种方法无法将隐藏的 <strong>“.git”</strong> 文件夹提取出来，而这是 depot_tools 自动更新时所必需的。</p></blockquote><p>之后，将 depot_tools 添加到 PATH 环境变量的开头（必须在任何 Python 安装之前）。</p><p>假设你将depot_tools解压到了 C:\src\depot_tools目录下，打开：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">控制面板 → 系统和安全 → 系统 → 高级系统设置</span><br></pre></td></tr></table></figure><p>如果你有管理员权限，请修改 PATH 系统环境变量，将C:\src\depot_tools放到PATH的最前面（或至少放在可能已经有 Python 或 Git 副本的任何目录的前面）。</p><p>如果您没有管理员权限，可以将其添加到用户级 PATH 环境变量中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">控制面板→系统和安全→系统→搜索“为您的帐户编辑环境变量”</span><br></pre></td></tr></table></figure><p>不过，在没有管理员权限的情况下，当你的系统 PATH 中已经指定了Python路径，那么你就无法使用depot_tools中的python了。这将导致你无法顺利的将源码下载下来。所以 <strong>建议你还是找台有管理员权限的主机</strong>。</p><p>另外，还要在环境变是中添加 DEPOT_TOOLS_WIN_TOOLCHAIN 变量，并将其设置为 0。这会告诉 depot_tools 使用本地安装的 Visual Studio （默认情况下，depot_tools 将尝试使用 google 内部版本）。</p><p>除此之外，你还须设置一个名为 <strong>vs2022_install</strong>的环境变量，用于指定vs2022 的安装路径，如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set vs2022_install=C:\Program Files\Microsoft Visual Studio\2022\Professional</span><br></pre></td></tr></table></figure><p>之后，你就可以在 <strong>命令行窗口(CMD)</strong> 中运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gclient</span><br></pre></td></tr></table></figure><p>来下载、更新必要的工具了。</p><p>首次运行gclient命令时， 它会安装一些特定的工具，如 msysgit 和 python。执行该命令时需要<strong>注意</strong>：</p><ul><li>如果您从 <strong>非命令行(CMD)</strong> 中（例如，cygwin、PowerShell）运行 gclient，它看起来可能运行正常，但 msysgit、python 以及其他工具却无法正确安装。所以你必须在标准的命令行窗口中运行glient</li><li>如果你第一次运行 gclient 时，看到一些陌生的错误，你可能需要禁用<a href="https://tortoisesvn.net/faq.html#cantmove2">Windows Indexing</a></li></ul><h2 id="检查-python-安装"><a href="#检查-python-安装" class="headerlink" title="检查 python 安装"></a>检查 python 安装</h2><p><code>gclient</code>执行完成后，在命令行窗口中键入<code>where python</code>，确认 <strong>depot_tools</strong> 中的<code>python.bat</code>位于任何其它 <code>python.exe</code> 之前。否则的话，会导致使用 gn 时出现构建失败，详细信息参见<a href="https://crbug.com/611087">crbug.com&#x2F;611087</a>。</p><p><a href="https://docs.microsoft.com/en-us/windows/apps/desktop/modernize/desktop-to-uwp-extensions#alias">App Execution Aliases</a>这项服务可能与系统上安装的其他 python 有冲突，因此，需要将它关闭掉，具体方法是打开控制面板中的 <strong>“App execution aliases”</strong>，勾掉指向“python.exe”和“python3.exe”的复选框来禁用它们。</p><h2 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h2><p>由于众所周知的原因，在国内是不能直接下载Chrome源码的。因此，你要找一个靠谱的代理软件，而且给它一个最大的带宽。</p><p>我在下载的过程中，就由于网络的原因失败了好几次，既浪费的时间又浪费的金钱。</p><p>后来不得以，购买了10M的专线才好不容易将代码下载成功。</p><h2 id="获取代码"><a href="#获取代码" class="headerlink" title="获取代码"></a>获取代码</h2><p>首先，配置 Git：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;My Name&quot;</span><br><span class="line">$ git config --global user.email &quot;my-name@chromium.org&quot;</span><br><span class="line">$ git config --global core.autocrlf false</span><br><span class="line">$ git config --global core.filemode false</span><br><span class="line">$ git config --global branch.autosetuprebase always</span><br></pre></td></tr></table></figure><p>接着，创建一个chromium目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir chromium &amp;&amp; cd chromium</span><br></pre></td></tr></table></figure><p>之后，运行<code>fetch</code>命令，将代码及其依赖check out出来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ fetch chromium</span><br></pre></td></tr></table></figure><p><strong>如果在checkout时，你不想要完整的repo历史记录，你可以给fetch添加<code>--no-history</code>标志，这样可以减少你获取代码的时间。</strong></p><p>获取代码时，即使你网络很快，预计也要会花费一个多小时才能将它下载下来。而在较慢的网络上，则需要数个小时。所以，您必须配置好你的PC，使它在获取代码时不要休眠，否则失败了还要重新下。</p><p><strong>如果在获取子仓库时发生错误</strong>，你可以选择重新开始，或者进入到 <strong>chromium&#x2F;src</strong> 目录，执行下面的命令来继续下载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gclient sync</span><br></pre></td></tr></table></figure><p>完成fetch后，它将创建一个隐藏的 <strong>.gclient</strong> 文件和一个 <strong>src</strong> 的目录。接下来，你需要切换到src目录下： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd src</span><br></pre></td></tr></table></figure><h2 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h2><p>Chromium 使用 <strong>Ninja</strong> 作为其主要构建工具，并使用名为 <strong>GN</strong> 的工具来生成.ninja文件。您可以创建任意数量的具有不同配置的构建目录。命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gn gen out/Default</span><br></pre></td></tr></table></figure><ul><li>您只需为每个新的构建目录运行一次，Ninja 将根据需要更新构建文件。</li><li>可以将Default换成别的名字，但应该在out子目录下。</li><li>对于其他构建参数，包括Release设置或使用 Visual Studio 的版本，请参阅 <a href="https://www.chromium.org/developers/gn-build-configuration">GN build configuration</a>。默认创建的是与当前操作系统和CPU匹配的Debug版本。</li><li>有关 GN 的更多信息，可以运行<code>gn help</code>阅读<a href="https://gn.googlesource.com/gn/+/main/docs/quick_start.md">快速入门指南</a>。</li></ul><h2 id="编译Chromium"><a href="#编译Chromium" class="headerlink" title="编译Chromium"></a>编译Chromium</h2><p>可以使用以下命令构建 Chromium（“chrome”目标）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ autoninja - C out \Default chrome</span><br></pre></td></tr></table></figure><p>autoninja是一个包装器，它会为ninja提供最佳的参数。</p><p>关于一些参数的详细信息，可以通过 <code>gn ls out/Default</code>获取。</p><h2 id="更快的编译"><a href="#更快的编译" class="headerlink" title="更快的编译"></a>更快的编译</h2><p>我们可以通过下面的方法来加快编译速度：</p><ul><li>关闭防病毒软件，从而减少文件系统开销</li><li>将构建树存储在快速磁盘（最好是 SSD）上</li><li>内核越多越好，即使 64GB 也不算多</li></ul><p>还有一些 gn 参数可以提高构建速度，可以考虑使用的一些设置如下：</p><ul><li>is_component_build &#x3D; true，这会使用更多、更小的 DLL，并且可以避免每次更改后都必须重新链接 chrome.dll。</li><li>enable_nacl &#x3D; false，这会禁用本地构建通常不需要的 Native Client。</li><li>target_cpu &#x3D; “x86”，x86 构建可能比 x64 构建稍快。请注意，如果您设置了它，但不设置enable_nacl &#x3D; false，那么构建时间可能会变得更糟。</li><li>blink_symbol_level &#x3D; 0，关闭 blink 的源代码级调试以减少构建时间，如果您不打算调试 blink，可以这么干。</li><li>v8_symbol_level &#x3D; 0，关闭 v8 的源代码级调试以减少构建时间，如果您不打算调试 v8，可以这么干。</li></ul><p>为了加快链接速度，您可以设置symbol_level&#x3D;1 或 symbol_level&#x3D;0，这些选项减少编译器和链接器所做的工作：</p><ul><li>symbol_level &#x3D; 1，指明编译器要发出文件名和行号信息，因此您仍然可以进行源代码级调试，但不会有局部变量或类型信息。</li><li>symbol_level &#x3D; 0，表示没有源代码级调试，但调用堆栈仍然有函数名称。</li><li>此外，更改symbol_level需要重新编译所有内容。</li></ul><p>另外，谷歌员工应该使用分布式编译系统goma。详细信息可在内部获得，但相关的 gn arg 是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use_goma = true</span><br></pre></td></tr></table></figure><p>要从 goma 中获得任何好处，重要的是将大的 -j 值传递给 ninja。一个好的默认值是 10<em>numCores 到 20</em>numCores。如果你运行 autoninja， 那么它会自动将适当的 -j 值传递给 ninja 是否为 goma。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ autoninja - C out \Default chrome</span><br></pre></td></tr></table></figure><p>调用 ninja 时，可以执定要编译的目标，如将 <strong>“chrome”</strong> 指定为目标，以避免同时构建所有测试二进制文件。</p><p><strong>尽管如此，在许多机器上构建仍需要花费数小时。</strong></p><h2 id="运行-Chromium"><a href="#运行-Chromium" class="headerlink" title="运行 Chromium"></a>运行 Chromium</h2><p>编译完成后，你就可以运行编译出的浏览器了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$out\Default\chrome.exe</span><br></pre></td></tr></table></figure><h2 id="运行测试目标"><a href="#运行测试目标" class="headerlink" title="运行测试目标"></a>运行测试目标</h2><p>您可以用下面的方式运行测试。还可以使用 arg 限制运行哪些测试 <code>--gtest_filter</code>，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$out\Default\unit_tests.exe --gtest_filter = &quot;PushClientTest.*&quot;</span><br></pre></td></tr></table></figure><p>这些参数可以在其<a href="https://github.com/google/googletest">GitHub页面</a>上找到更多有关 GoogleTest 的信息。</p><h2 id="更新checkout"><a href="#更新checkout" class="headerlink" title="更新checkout"></a>更新checkout</h2><p>更新存在的代码，可以运行下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase-update</span><br><span class="line">$ gclient sync -D</span><br></pre></td></tr></table></figure><ul><li><p>第一个命令，更新 Chromium 的主要源代码仓库，并重新设置任何本地分支。如果你不想使用这个脚本，你也可以使用git pull或其他常用的 Git 命令来更新 repo。</p></li><li><p>第二个命令，将子仓库同步到适当的版本，删除不再需要的版本，并根据需要重新与运行挂钩。</p></li></ul><h2 id="使用-Visual-Studio-IDE-进行编辑和调试"><a href="#使用-Visual-Studio-IDE-进行编辑和调试" class="headerlink" title="使用 Visual Studio IDE 进行编辑和调试"></a>使用 Visual Studio IDE 进行编辑和调试</h2><p>您可以使用 Visual Studio IDE 编辑和调试 Chrome。</p><h3 id="使用-Visual-Studio-Intellisense（智能感知）"><a href="#使用-Visual-Studio-Intellisense（智能感知）" class="headerlink" title="使用 Visual Studio Intellisense（智能感知）"></a>使用 Visual Studio Intellisense（智能感知）</h3><p>如果您想在开发 Chromium 时使用 Visual Studio Intellisense，请在生成输出目录时使用–ide命令行参数。这是一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gn gen -- ide = vs --ninja-executable=C:\src\chromium\src\third_party\ninja\ninja.exe out\Default </span><br><span class="line">$ devenv out\Default\all.sln</span><br></pre></td></tr></table></figure><p>GN 将在您的构建目录中生成一个all.sln文件。其在内部使用 Ninja 进行编译。如果您再次手动运行“gen”，你需要重新提供此参数，但通常 GN 会在构建时自动将构建与IDE文件保持一致。</p><p>另外，由于生成的解决方案中包含数千个项目，因此加载速度非常慢。可以使用 <strong>–filters</strong> 参数来限制你感兴趣的代码生成在项目文件中。当然，这样也会限制一些文件无法在项目资源管理器中出现，但调试仍然有效。您可以手动打开文件，设置断点。极端情况下，最小的solution中不包含任何文件，但仍然可以让你在VS中编译和运行Chrome。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gn gen --ide=vs --ninja-executable=C:\src\chromium\src\third_party\ninja\ninja.exe --filters=//chrome --no-deps out\Default</span><br></pre></td></tr></table></figure><p>您可以有选择地将您关心的其他目录添加到过滤器中，如下所示<code>--filters=//chrome;//third_party/WebKit/*;//gpu/*</code></p><p>更多的信息请运行 gn help gen 查看相关的文档。</p><h3 id="在没有-Intellisense-的情况下使用-Visual-Studio"><a href="#在没有-Intellisense-的情况下使用-Visual-Studio" class="headerlink" title="在没有 Intellisense 的情况下使用 Visual Studio"></a>在没有 Intellisense 的情况下使用 Visual Studio</h3><p>没有 Intellisense，你仍然可以在 Visual Studio 中调试和开发 Chrome。你只需在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File-&gt;Open-&gt;Project/Solution</span><br></pre></td></tr></table></figure><p>中，打开chrome.exe 这个二进制文件，或在命令窗口中输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devenv /debugexe out\Debug\chrome.exe &lt;your arguments&gt;</span><br></pre></td></tr></table></figure><p>即可。</p><p>在这种情况下，就不能浏览代码了，但通过安装<a href="https://chromium.github.io/vs-chromium/">VsChromium Visual Studio Extension</a>，可以获得源代码以及其他有用的功能（例如代码搜索）。</p><p>当然，你也可以将多个感兴趣的可执行文件，如base_unittests.exe、browser_tests.exe，添加到你的解决方案中，右键单击Solution Explorer，设置调试的程序为 <strong>Set as Startup Project</strong>。</p><p>默认情况下，当您在 Visual Studio 中开始调试时，调试器将仅附加到浏览器的主进程。要调试所有 Chrome，请安装Microsoft 的 <strong>Child Process Debugging Power Tool</strong> 工具。此外，您还需要以管理员身份运行 Visual Studio，否则它会默认是无法附加到 Chrome 的某些子进程的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上就是下载和编译Windows Chromium源码的过程。在源码的下载过程中很容易失败，解决的办法是首先保障你的网络是可以正确的、高质量的访问外网，这一步是最关键的，之后如果失败了就多次偿试。</p><p>总之一句话，有好的、高质量的、高速的带宽是你下载Chrome源码的关键。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着技术的进步，浏览器在未来会扮演越来越得要的角色。我们基本可以确定，在不久的将来，大部分Native应用都会被Web应用所替代。因此，如果你想今后想找一份好工作，或写出更高效的Web应用，就必须要了解一下浏览器的工作原理。&lt;/p&gt;
&lt;p&gt;了解浏览器工作原理的方法有很多，但对Chrome源码的阅读无缝是第一位的，只有这样我们才能获取第一手材料。&lt;/p&gt;
&lt;p&gt;而阅读Chrome源码的第一位就是要能够下载或编译Chrome源码。而这篇文章就是告诉你如何下载并编译Chrome源码的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="https://blog.avdancedu.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="Chrome" scheme="https://blog.avdancedu.com/tags/Chrome/"/>
    
      <category term="windows" scheme="https://blog.avdancedu.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>网络开发点滴.md</title>
    <link href="https://blog.avdancedu.com/6373ddbf/"/>
    <id>https://blog.avdancedu.com/6373ddbf/</id>
    <published>2023-02-28T11:32:59.000Z</published>
    <updated>2023-03-01T05:24:45.898Z</updated>
    
    <content type="html"><![CDATA[<p>这里记录一些网络开发时的知识点</p><span id="more"></span><h2 id="为什么不建议使用0-0-0-0这个IP地址"><a href="#为什么不建议使用0-0-0-0这个IP地址" class="headerlink" title="为什么不建议使用0.0.0.0这个IP地址?"></a>为什么不建议使用0.0.0.0这个IP地址?</h2><p>在云主机上，不建议绑定 <strong>0.0.0.0</strong> 这个IP地址。其原因是，<strong>0.0.0.0</strong> 表示所有可用的IP地址，如果服务绑定在0.0.0.0上，将允许来自任何网络接口的所有请求都能够到达该服务，从而可能导致安全风险。例如，如果你的云主机同时有内网IP和外网IP，你可能只希望服务只监听外网IP地址，这样可以避免来自内网的非授权访问。</p><p>因此，在云主机上，建议将服务绑定到具体的IP地址上，以增加网络安全性。</p><h2 id="在云主机上有内网和外网地址，我们该用哪个？"><a href="#在云主机上有内网和外网地址，我们该用哪个？" class="headerlink" title="在云主机上有内网和外网地址，我们该用哪个？"></a>在云主机上有内网和外网地址，我们该用哪个？</h2><p>如果在云主机有一个公网 IP 和一个内网 IP，而您的网络服务需要对外提供服务，则应该使用公网 IP 地址和端口号。这样，外部用户可以通过 Internet 连接到您的服务。</p><p>如果您的服务只在内部网络中使用，那么可以使用内网 IP 地址和端口号。这样，只有内部网络中的用户才能连接到您的服务。</p><p>需要注意的是，在使用公网 IP 地址时，还需要在防火墙中打开相应的端口，以便外部用户可以连接到您的服务。而在使用内网 IP 地址时，通常不需要打开防火墙，因为内部网络是相对安全的，只有经过授权的用户才能连接到您的服务。</p><h2 id="客户端无法联网，如何判断是无法与路由器连接还是无法与与互联网连接？"><a href="#客户端无法联网，如何判断是无法与路由器连接还是无法与与互联网连接？" class="headerlink" title="客户端无法联网，如何判断是无法与路由器连接还是无法与与互联网连接？"></a>客户端无法联网，如何判断是无法与路由器连接还是无法与与互联网连接？</h2><p>可以通过向默认网关发ping消息来判断是否主机能与路由器联接。如果客户端可以收到路由器的返馈包，说明两者联接是好的。否则说明无法与路由器连接。</p><p>之后可以向一台云主机发包，如果云主机可以往回数据说明网络联接是好的，否则说明路由器无法联网。</p><h2 id="如何判断客户端主机IP是否被劫持了？"><a href="#如何判断客户端主机IP是否被劫持了？" class="headerlink" title="如何判断客户端主机IP是否被劫持了？"></a>如何判断客户端主机IP是否被劫持了？</h2><p>可以向多台云主机发送数据包，让云主机获取到的客户端主机IP地址返回，如果一致说明没有被劫持，否则说明某条线路的IP地址被劫持了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里记录一些网络开发时的知识点&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络传输" scheme="https://blog.avdancedu.com/categories/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93/"/>
    
    
      <category term="网络传输" scheme="https://blog.avdancedu.com/tags/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS下安装TikTok的过程</title>
    <link href="https://blog.avdancedu.com/6da5b967/"/>
    <id>https://blog.avdancedu.com/6da5b967/</id>
    <published>2023-02-21T11:59:00.000Z</published>
    <updated>2023-02-22T04:55:29.521Z</updated>
    
    <content type="html"><![CDATA[<p>TikTok是头条的产品，但该产品主要投放在欧美，在国内是不允许下载的。</p><p>不过有很多同学也想在国内使用TikTok，有没有办法呢？</p><p>我今天做了一个偿试还真行，下面是我整理的一个过程，分享给大家希望对你能有所帮助。</p><span id="more"></span><h2 id="切换AppID国家"><a href="#切换AppID国家" class="headerlink" title="切换AppID国家"></a>切换AppID国家</h2><p>要想在 AppStore 中下载 TikTok，最重要的一步是切换你的AppID所在的国家，比如你选择 AppID的国家为美国后，你的手机就会连美国的AppStore，由于美国的AppStore没有禁用TikTok，所以此时你就可以将TikTok下载到你手上了。</p><p>网上有各种切换AppID国家的方法，我大体都试了，绝大部分都不好使。有的甚至说要你重新创建一个新帐号，其实这些方法都是错误的。</p><p>正确的方法是 <strong>不要在手机上进行AppID国家的切换，而应该在PC端的浏览器上打开appid.apple.com这个网址</strong>，之后用你当前手机上的Appid登录。</p><p>登录到你的AppID管理界面后，选择 <strong>“个人信息”</strong>，之后选择 <strong>国家和地区</strong>，在这里进行国家的切换即可。</p><p>还是以美国为例，当你将AppID切换到美国后，你可以将付款方式选为 <strong>None</strong>，再填入一个假的美国地址和手机号就好了。</p><p>此时，你在手机上选择 <strong>设置</strong> 中的第一项(AppID)，点进去后选择 <strong>媒体与购买项目</strong>，之后选择退出。接下来，你再走一次这个流程重新等了你的AppID</p><p>这样你就成功将AppID的国家更新成美国了。</p><h2 id="下载-TikTok-等软件"><a href="#下载-TikTok-等软件" class="headerlink" title="下载 TikTok 等软件"></a>下载 TikTok 等软件</h2><p>当将AppID的国家切换好后，现然你就可以下载 TikTok了。除了 TikTok，其它在国内下不了的软件你也可以下载了。</p><p>现在虽然 TikTok 已经可以成功安装到手机上了，但还注册不了用户，因为TikTok只允许非国内及香港的地区使用。</p><p>所以此时我们就要使用一些翻墙工具了。</p><h2 id="OpenXXX如何导入配置文件"><a href="#OpenXXX如何导入配置文件" class="headerlink" title="OpenXXX如何导入配置文件"></a>OpenXXX如何导入配置文件</h2><p>这里我顺便提一句，当我们使用OpenXXX时，会发现它需要先导入Profile文件，而在iPhone中又不能访问文件系统，这该如何是好呢？</p><p>有一个比较巧妙的办法，我们可以将profile文件以附件的形式发到网易邮箱中，再在iPhone上下载一个邮箱客户端，打开邮件时，就可以选择查看附件的应用程序了。</p><p>此时我们选择OpenXXX，这样就可以直接将这个profile文件加载到OpenXXX中，后面就可以愉快的玩耍了！</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总之，在国内想使用TikTok还是一件很麻烦的事儿，如果不是必须要使用该软件的话，建议还是别折腾了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TikTok是头条的产品，但该产品主要投放在欧美，在国内是不允许下载的。&lt;/p&gt;
&lt;p&gt;不过有很多同学也想在国内使用TikTok，有没有办法呢？&lt;/p&gt;
&lt;p&gt;我今天做了一个偿试还真行，下面是我整理的一个过程，分享给大家希望对你能有所帮助。&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂项" scheme="https://blog.avdancedu.com/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="海外软件安装" scheme="https://blog.avdancedu.com/tags/%E6%B5%B7%E5%A4%96%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>Vue经验点滴</title>
    <link href="https://blog.avdancedu.com/75e8ef30/"/>
    <id>https://blog.avdancedu.com/75e8ef30/</id>
    <published>2023-02-20T10:05:29.949Z</published>
    <updated>2023-02-22T04:57:36.419Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Vue开发项目的过程中遇到了很多问题，其中有一些是特别值得整理出来以备后用的。</p><p>所以我觉得值得记录下来的知识点都列在这篇文章中，希望对你也能有所帮助。</p><span id="more"></span><h2 id="如何在Vue中创建-Web-Worker线程"><a href="#如何在Vue中创建-Web-Worker线程" class="headerlink" title="如何在Vue中创建 Web Worker线程"></a>如何在Vue中创建 Web Worker线程</h2><p>在javascript中创建 Worker线程非常容易，你可以随便在网上找到一篇详解文章。</p><p>同样的方法在Vue中就不好用了。下面是在Vue中创建 Web Worker的正确做法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myworker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&#x27;./workers/worker&#x27;</span>, <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>), &#123;<span class="attr">type</span>: <span class="string">&#x27;module&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">myworker.<span class="property">onmessage</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码中有两上点需要注意：</p><ul><li>创建worker线程时，一定要用 <code>new URL(...)</code>指明woker.js文件的位置，否则无法成功创建woker线程。</li><li>onmessage 函数最好使用箭头函数，否则如果在其内部使用this指针时，该this指定指向的不是worker调用者的上下文。</li></ul><h2 id="如何在Vue中引入一个纯-javascript-库"><a href="#如何在Vue中引入一个纯-javascript-库" class="headerlink" title="如何在Vue中引入一个纯 javascript 库"></a>如何在Vue中引入一个纯 javascript 库</h2><p>在Vue中引入一个纯的javascript库需要执行以下几个步骤：</p><ul><li>将javascript库放到你的项目中的某个目录下。比如放在 src文件夹的util目录下。</li><li>在使用该javascript的Vue页面中引入该库<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> xxx <span class="keyword">from</span> <span class="string">&#x27;@/utils/xxx.js&#x27;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>其中 <code>@</code>代表 <code>src</code>目录。</li></ul><p>它是在<code>jsconfig.json</code>中配置的，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="string">&quot;paths&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;@/*&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;src/*&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外 import 引入的是一个对象还是一个方法也要注意。<br>如果写成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xxx <span class="keyword">from</span> ....</span><br></pre></td></tr></table></figure><p>表示 <strong>xxx</strong> 是一个对象，使用它里边的方法时，通常这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">xxx.<span class="title function_">someFunc</span>(...)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果只是想引入库中的某个方法，要写成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; xxx &#125; <span class="keyword">from</span> ...</span><br></pre></td></tr></table></figure><p>上面表示的是从某个库中引入一个对象的<strong>xxx</strong>方法，其中<code>&#123;&#125;</code>表示一个对象。</p><ul><li>当将javascript库引入到Vue之后，很有可能需要对该库做一些修改，比如在库中函数的前面加上<code>export</code>关键字，表示该函数可以被导出，供外面使用。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用Vue开发项目的过程中遇到了很多问题，其中有一些是特别值得整理出来以备后用的。&lt;/p&gt;
&lt;p&gt;所以我觉得值得记录下来的知识点都列在这篇文章中，希望对你也能有所帮助。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>WebRTC+科大讯飞+ChatGPT实现语音聊天机器人</title>
    <link href="https://blog.avdancedu.com/f407109e/"/>
    <id>https://blog.avdancedu.com/f407109e/</id>
    <published>2022-12-20T10:03:00.000Z</published>
    <updated>2023-02-20T10:13:01.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>这是一个很奇妙的小项目，做这个项目的初衷是想验证一下，是否可以将音视频技术与ChatGPT结合起来，做一个很酷炫的产品。</p><p>该项目可以作为音视频聊天机器人的基础，从而实现像类似<strong>智能客户</strong>、<strong>在线问答</strong> 之类的产品。你甚至可以把它当成一个<strong>在线助教</strong>，任何时间任何地址回答同学们的问题。</p><p>总之，这个小项目还是挺酷的。</p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><!--<img width="989" alt="voice_chat" data-src="https://user-images.githubusercontent.com/49577129/220062542-cbbb7daf-b8e1-41f1-8b1a-e800d986b1a2.png">--><iframe src="//player.bilibili.com/player.html?aid=779706209&bvid=BV1ty4y1Z7V1&cid=1015866081&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><span id="more"></span><!--视频地址如下：[【作品】WebRTC+ChatGPT实现语音聊天机器人](https://www.bilibili.com/video/BV1ty4y1Z7V1/?share_source=copy_web&vd_source=b393e4210396ee161923c1d02340e78d)--><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><h3 id="已有ChatGPT帐号"><a href="#已有ChatGPT帐号" class="headerlink" title="已有ChatGPT帐号"></a>已有ChatGPT帐号</h3><blockquote><p>注册ChatGPT的过程我就不讲了，一是要能上外网（香港不算），另一个就是要能接收短信。</p></blockquote><ul><li>当ChatGPT帐号注册好后,打开下面网址<a href="https://console.xfyun.cn/">https://platform.openai.com/</a></li><li>登录后，点击右上角<strong>Personal</strong></li><li>选择<strong>View API keys</strong></li><li>之后，点击下面的<strong>Create new secret key</strong>，创建一个新的Key。将新创建好的key保存下来。</li></ul><h3 id="已有科大讯飞帐号"><a href="#已有科大讯飞帐号" class="headerlink" title="已有科大讯飞帐号"></a>已有科大讯飞帐号</h3><ul><li>打开下面网址<a href="https://console.xfyun.cn/">https://console.xfyun.cn/</a>, 到科大讯飞注册一个账户</li><li>创建一个新的应用</li><li>之后，选择<strong>左侧</strong>-&gt;<strong>语音识别</strong>-&gt;<strong>实时语音转写</strong></li><li>购买服务后，可以看到<strong>服务接口认证信息</strong>里边包括了<strong>APPID</strong>和<strong>APIKey</strong></li></ul><p>通过上面的步骤先决条件就准备好了。接下来我们来看看如何配置这几个参数。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul><li>下载源码</li><li>打开src目录下的App.vue文件</li><li>将上面获取到的ChatGPT APIKey 和科大讯飞的 APPID、APIKey分别填入对应的变量中</li></ul><p>接下来安装启动Web服务。</p><h2 id="安装启动服务"><a href="#安装启动服务" class="headerlink" title="安装启动服务"></a>安装启动服务</h2><p><strong>特别注意：本项目只能在 本机使用 或部署在 有域名证书 的服务器上。</strong></p><p>本地安装运行步骤如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure><p>如果想部署到服务器上，可以先使用下面命令编译项目:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>之后再部署到服务器上即可。</p><p><strong>现在打开浏览器实验一下吧，祝好运！</strong></p><h2 id="参考项目"><a href="#参考项目" class="headerlink" title="参考项目"></a>参考项目</h2><ul><li><a href="https://github.com/bestony/ChatGPT-Feishu">飞书接入ChatGPT</a></li><li><a href="https://github.com/wangrongding/wechat-bot">微信接入ChatGPT</a>（小心微信被封)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;项目介绍&quot;&gt;&lt;a href=&quot;#项目介绍&quot; class=&quot;headerlink&quot; title=&quot;项目介绍&quot;&gt;&lt;/a&gt;项目介绍&lt;/h2&gt;&lt;p&gt;这是一个很奇妙的小项目，做这个项目的初衷是想验证一下，是否可以将音视频技术与ChatGPT结合起来，做一个很酷炫的产品。&lt;/p&gt;
&lt;p&gt;该项目可以作为音视频聊天机器人的基础，从而实现像类似&lt;strong&gt;智能客户&lt;/strong&gt;、&lt;strong&gt;在线问答&lt;/strong&gt; 之类的产品。你甚至可以把它当成一个&lt;strong&gt;在线助教&lt;/strong&gt;，任何时间任何地址回答同学们的问题。&lt;/p&gt;
&lt;p&gt;总之，这个小项目还是挺酷的。&lt;/p&gt;
&lt;h2 id=&quot;效果展示&quot;&gt;&lt;a href=&quot;#效果展示&quot; class=&quot;headerlink&quot; title=&quot;效果展示&quot;&gt;&lt;/a&gt;效果展示&lt;/h2&gt;&lt;!--&lt;img width=&quot;989&quot; alt=&quot;voice_chat&quot; data-src=&quot;https://user-images.githubusercontent.com/49577129/220062542-cbbb7daf-b8e1-41f1-8b1a-e800d986b1a2.png&quot;&gt;--&gt;
&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=779706209&amp;bvid=BV1ty4y1Z7V1&amp;cid=1015866081&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
      <category term="ChatGPT" scheme="https://blog.avdancedu.com/categories/WebRTC/ChatGPT/"/>
    
    
      <category term="janus" scheme="https://blog.avdancedu.com/tags/janus/"/>
    
  </entry>
  
  <entry>
    <title>如何使用VSCode调试Vue3+TypeScript+Vite应用</title>
    <link href="https://blog.avdancedu.com/1c60b49f/"/>
    <id>https://blog.avdancedu.com/1c60b49f/</id>
    <published>2022-12-09T13:48:00.000Z</published>
    <updated>2022-12-09T13:50:10.527Z</updated>
    
    <content type="html"><![CDATA[<p>目前 <strong>Vue3+TypeScript+Vite</strong> 这套组合已经成为了越来越流于的Web应用开发架构，我也要紧跟时代，把这块知识补一补。</p><p>我的学习习惯是在学习一门新知识之前，先将它的开发环境和调试环境搭建好，这样学习起来才能事半功倍，正所谓 <strong>“磨刀不误砍柴功”</strong> 嘛！</p><p>今天我就将 <strong>Vue3+TypeScript+Vite</strong> 这套组合的开发环境和调试环境的搭建过程记录以下，一方面是为自己作个学习记录，另一方面也可以帮助其它人少走些弯路，这种事情是我特别喜欢做的。</p><p>首先来看一下如何创建 <strong>Vue3+TypeScript+Vite</strong> 这套组合的开发环境。</p><span id="more"></span><h2 id="搭建-Vue3-TypeScript-Vite-开发环境"><a href="#搭建-Vue3-TypeScript-Vite-开发环境" class="headerlink" title="搭建 Vue3+TypeScript+Vite 开发环境"></a>搭建 <strong>Vue3+TypeScript+Vite</strong> 开发环境</h2><p>其实 <strong>Vue3+TypeScript+Vite</strong> 这套组合的开发环境特别好搭建，在<a href="https://cn.vuejs.org/guide/quick-start.html#creating-a-vue-application"> <strong>官方</strong> </a>的文档中就有说明，其过程如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">npm init vue@latest</span></span><br></pre></td></tr></table></figure><p>该命令会安装并执行 <strong>create-vue</strong>，它是Vue官方的项目脚手架，之后你会看到下面的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">✔ Project name: … &lt;your-project-name&gt;</span><br><span class="line">✔ Add TypeScript? … No / [Yes]</span><br><span class="line">✔ Add JSX Support? … [No] / Yes</span><br><span class="line">✔ Add Vue Router for Single Page Application development? … [No] / Yes</span><br><span class="line">✔ Add Pinia for state management? … [No] / Yes</span><br><span class="line">✔ Add Vitest for Unit testing? … [No] / Yes</span><br><span class="line">✔ Add Cypress for both Unit and End-to-End testing? … [No] / Yes</span><br><span class="line">✔ Add ESLint for code quality? … [No] / Yes</span><br><span class="line">✔ Add Prettier for code formatting? … [No] / Yes</span><br><span class="line"></span><br><span class="line">Scaffolding project in ./&lt;your-project-name&gt;...</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure><p>在上面的信息中，选择<code>[]</code>中的选项即可。再执行下面的命令就可以将依赖安装好，并启动开发服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">cd</span> &lt;your-project-name&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">npm install</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">npm run dev</span></span><br></pre></td></tr></table></figure><p>至此，<strong>Vue3+TypeScript+Vite</strong> 这套组合的开发环境就搭建好了。</p><h2 id="搭建-Vue3-TypeScript-Vite-调试环境"><a href="#搭建-Vue3-TypeScript-Vite-调试环境" class="headerlink" title="搭建 Vue3+TypeScript+Vite 调试环境"></a>搭建 <strong>Vue3+TypeScript+Vite</strong> 调试环境</h2><p><strong>Vue3+TypeScript+Vite</strong> 这套组合的调试环境也非常好搭建，首先将VSCode安装好，VSCode可以从这里<a href="https://code.visualstudio.com/Download">下载</a>。</p><p>之后进入到前面创建的项目中，执行下面命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入到之前创建的vue项目</span></span><br><span class="line">code .</span><br></pre></td></tr></table></figure><p>在保证 <strong>开发服务器已经启动</strong> 的情况下，点击:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VSCode-&gt; 左侧工具栏 -&gt; 调试与运行 -&gt; 创建launch.json</span><br></pre></td></tr></table></figure><p>将launch.json中的内容修改如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span><span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;confiugrations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;chrome&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Vue App&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://localhost:5173&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;webRoot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;worksapceFolder&#125;/dist&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>配置好VSCode后，我们就可以友好的调试咱们自己的程序了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前 &lt;strong&gt;Vue3+TypeScript+Vite&lt;/strong&gt; 这套组合已经成为了越来越流于的Web应用开发架构，我也要紧跟时代，把这块知识补一补。&lt;/p&gt;
&lt;p&gt;我的学习习惯是在学习一门新知识之前，先将它的开发环境和调试环境搭建好，这样学习起来才能事半功倍，正所谓 &lt;strong&gt;“磨刀不误砍柴功”&lt;/strong&gt; 嘛！&lt;/p&gt;
&lt;p&gt;今天我就将 &lt;strong&gt;Vue3+TypeScript+Vite&lt;/strong&gt; 这套组合的开发环境和调试环境的搭建过程记录以下，一方面是为自己作个学习记录，另一方面也可以帮助其它人少走些弯路，这种事情是我特别喜欢做的。&lt;/p&gt;
&lt;p&gt;首先来看一下如何创建 &lt;strong&gt;Vue3+TypeScript+Vite&lt;/strong&gt; 这套组合的开发环境。&lt;/p&gt;
    
    </summary>
    
    
      <category term="语言" scheme="https://blog.avdancedu.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="TypeScript" scheme="https://blog.avdancedu.com/tags/TypeScript/"/>
    
      <category term="Vue3" scheme="https://blog.avdancedu.com/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>Windows下编译FFmpeg5.0</title>
    <link href="https://blog.avdancedu.com/38b88453/"/>
    <id>https://blog.avdancedu.com/38b88453/</id>
    <published>2022-11-29T22:41:00.000Z</published>
    <updated>2023-03-01T05:25:00.527Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/windows_ffmpeg/FFmpeg_logo.jpeg"></p><p>在我的FFmpeg课程中，我总是推荐大家使用 <strong>Linux(Ubuntu)系统</strong> 或 <strong>Mac系统</strong> 来学习FFmpeg。其原因，是在Windows下编译FFmpeg太麻烦了，这大大增加了我们学习FFmpeg的成本。</p><span id="more"></span><p>不光如此，在Windows下编译FFmpeg所需要的依赖库也很麻烦，比如我们经常使用的fdk-aac、x264等在Windows下都要单独编译才可以使用。</p><p>不过，总还是有一些同学需要在Windows下使用FFmpeg，而FFmpeg官网上介绍的Windows下编译FFmpeg的<a href="https://visualstudio.microsoft.com/zh-hans/thank-you-downloading-visual-studio/?sku=Community&channel=Release&version=VS2022&source=VSLandingPage&cid=2030&passive=false">文章</a>实在是太老了，基本不可用。为了解决这部分同学的难题，这里我总结了一份Windows下编译和使用FFmpeg的方法，希望能帮助到大家！</p><h2 id="准备编译环境"><a href="#准备编译环境" class="headerlink" title="准备编译环境"></a>准备编译环境</h2><p>首先，我们要准备好编译环境，一台装有Windows10系统的电脑是必须的（没有比这再正确的废话了：））。</p><p>同时，要将Visual Studio安装好，比如 VS2019 社区版或 VS2022社区版（VS2019可以到<a href="https://visualstudio.microsoft.com/zh-hans/thank-you-downloading-visual-studio/?sku=Community&channel=Release&version=VS2022&source=VSLandingPage&cid=2030&passive=false">这里下载</a>，VS2022可以到<a href="https://visualstudio.microsoft.com/zh-hans/thank-you-downloading-visual-studio/?sku=Community&channel=Release&version=VS2022&source=VSLandingPage&cid=2030&passive=false">这里下载</a>）。这两个版本你用哪个都行，根据自己的需要选择吧。如果不是工作中必须要使用VS2019，那我建议你使用最新版的VS2022。</p><p>除了需要安装VS之外，还要安装<strong>MSYS2</strong>，这是一款Windows下模拟Linux的软件。FFmpeg的编译就是在该软件中进行的，而编译时使用的<strong>编译器</strong>(cl.exe)和<strong>链接器</strong>(link.exe)则是由Visual Studio提供的。MSYS2可以到<a href="https://github.com/msys2/msys2-installer/releases/download/2022-10-28/msys2-x86_64-20221028.exe">这里下载</a></p><p>需要注意的是，在下载MSYS2时可能需要有网络代理才行。考虑到有些同学没有网络代理软件，我将MSYS2的一个备份放到了百度盘上，你也可以到<a href="https://pan.baidu.com/s/1xOpcbJV1mKMCCaNgMBO90g?pwd=8888">这里下载</a>。不过当你去百度盘下载这个软件时，它的版本可能已经比较老了，建议有条件的同学还是到官网上下载。</p><blockquote><p>顺便说一下，对于刚学习Linux的同学来说，在Windows上装MSYS2学习Linux是个不错的选择，它比PowerShell要好用得多</p></blockquote><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>编译环境准备好之后，接下来我们需要下载一份最新的FFmpeg源码，你可以从<a href="https://ffmpeg.org/releases/ffmpeg-snapshot.tar.bz2">这里下载</a>，也可以使用Git下载。Git下载的方法如下：</p><ul><li>先将Git命令安装好</li><li>然后执行下面的命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /d</span><br><span class="line">git <span class="built_in">clone</span> https://git.ffmpeg.org/ffmpeg.git ffmpeg</span><br></pre></td></tr></table></figure>此时，代码就被下载到<code>D:</code>盘的ffmpeg目录下了</li></ul><h2 id="Windows下编译FFmpeg的方法"><a href="#Windows下编译FFmpeg的方法" class="headerlink" title="Windows下编译FFmpeg的方法"></a>Windows下编译FFmpeg的方法</h2><p>当 FFmpeg 源码准备就绪后，我们就可以编译FFmpeg了。</p><p>首先，进入MSYS2的安装目录，比如我这里将MSYS2安装到了<code>D:\MSYS64</code>目录下。在该目录下打开 <strong>msys2_shell.cmd</strong> 文件，将该文件第 <strong>17</strong> 行代码的注释打开，即去掉 <strong>rem</strong> 关键字，如下所示：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">setlocal</span> EnableDelayedExpansion</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> &quot;WD=<span class="variable">%__CD__%</span>&quot;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">NOT</span> <span class="keyword">EXIST</span> &quot;<span class="variable">%WD%</span>msys-<span class="number">2</span>.<span class="number">0</span>.dll&quot; <span class="built_in">set</span> &quot;WD=%~dp0usr\bin\&quot;</span><br><span class="line"><span class="built_in">set</span> &quot;LOGINSHELL=bash&quot;</span><br><span class="line"><span class="built_in">set</span> /a msys2_shiftCounter=<span class="number">0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rem To activate windows native symlinks uncomment next line</span></span><br><span class="line"><span class="comment">rem set MSYS=winsymlinks:nativestrict</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rem Set debugging program for errors</span></span><br><span class="line"><span class="comment">rem set MSYS=error_start:%WD%../../mingw64/bin/qtcreator.exe^|-debug^|^&lt;process-id^&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rem To export full current PATH from environment into MSYS2 use &#x27;-use-full-path&#x27; parameter</span></span><br><span class="line"><span class="comment">rem or uncomment next line</span></span><br><span class="line"><span class="built_in">set</span> MSYS2_PATH_TYPE=inherit</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>之所以要打开该注释，是为了让MSYS2可以继承Windows控制台的环境变量。</p><p>之后，通过面的方法找到<code>x64 Native Tools Command Prompt for VS 2019</code>命令窗口:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Windows开始菜单 -&gt; Visual Studio 2022 -&gt; x64 Native Tools Command Prompt <span class="keyword">for</span> VS 2019</span><br></pre></td></tr></table></figure><p>在该命令窗口中输入下面的命令启动 MSYS2 软件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入到MSYS2 目录下</span></span><br><span class="line"><span class="built_in">cd</span> D:\MSYS64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动MSYS2</span></span><br><span class="line">msys2_shell.cmd</span><br></pre></td></tr></table></figure><p>此时，会弹出MSYS2的命令窗口。接下来，在该窗口中输入下面命令，安装必要的编译工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S diffutils make pkg-config yasm</span><br></pre></td></tr></table></figure><p>其中 <strong>pacman</strong> 是MSYS2的 <strong>包安装工具</strong>；而 diffutils、make……都是编译FFmpeg时需要用的 <strong>编译工具</strong>。</p><p>当编译工具安装好后，曳光弹在MSYS2命令窗中执行下面命令，进入到FFmpeg源码目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /d/ffmpeg</span><br></pre></td></tr></table></figure><p>紧接着，运行 FFmpeg 源码目录中的 <code>configure</code> 脚本生成 <strong>Makefile</strong> 文件，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/ffmpeg--enable-gpl --enable-nonfree --enable-shared --disable-ffprobe --toolchain=msvc</span><br></pre></td></tr></table></figure><p>上述命令的含义是使用mscv作为FFmpeg的编译工具链；编译出的FFmpeg库被放到<code>/usr/local/ffmpeg</code> 目录下；编译的库是动态库，在Windows下就是 <strong>DLL</strong> 库；编译时不生成 <strong>ffprobe</strong> 程序。</p><p>上述脚本执行完成后，你可以在 FFmpeg 源码目录下发现多了一个 Makefile 文件。有了这个文件我们就可以编译FFmpeg了，编译命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j 4 &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>当执行完这条命令后，在 <code>/usr/local/ffmpeg/bin</code> 目录下就可以找到编译好的FFmpeg库和FFmpeg命令了。</p><p>需要注意的是，編译时有你有可能会遇到到如下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...... error C2065: “slib”: 未声明的标识符</span><br><span class="line">...... error C2296: “%”: 非法，左操作数包含“char [138]”类型</span><br></pre></td></tr></table></figure><p>该问题是因为在Windows下无法识别 <strong>CC_IDENT</strong> 导致的，只需将包括 <strong>CC_IDENT</strong>关键字的那行代码注释掉即可。</p><h2 id="在Windows上找到编译好的FFmpeg库"><a href="#在Windows上找到编译好的FFmpeg库" class="headerlink" title="在Windows上找到编译好的FFmpeg库"></a>在Windows上找到编译好的FFmpeg库</h2><p>上面我将编译好的FFmpeg库安装到了<code>/usr/local/ffmpeg</code>目录下，但在Windows下如何找到这个目录呢？</p><p>其实非常简单，你只需确定好MSYS2的根目录是哪儿就可以找到编译好的FFmpeg库了。以我的环境为例，我将MSYS2安装到了<code>D:\MSYS64</code>这个目录下，那么<code>D:\MSYS64</code>这个目录就是MSYS2的根目录。</p><p>因此，我编译好的FFmpeg库就存放在<code>D:\MSYS64\usr\local\ffmpeg</code>目录下。</p><h2 id="VS项目中引用FFmpeg库"><a href="#VS项目中引用FFmpeg库" class="headerlink" title="VS项目中引用FFmpeg库"></a>VS项目中引用FFmpeg库</h2><p>编译好FFmpeg库后，下面我们就可以在VS中引用它了。</p><p>首先你要创建一个新的VS项目，具体方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打开VS -&gt; 创建新项目 -&gt; 创建控制台项目 -&gt; 填写项目名 </span><br></pre></td></tr></table></figure><p>项目创建好后你会发现它里边只有一个<code>testffmpeg.cpp</code>文件，该文件特别简单，只有一个<code>main(...)</code>函数和一条<code>cout &lt;&lt; ...</code>语句。现在我们就可以在这个<code>main(...)</code>函数中调用<strong>FFmpeg API</strong> 了。</p><p>但在开始编码之前，我们需要将用到的FFmpeg库和头文件引入到VS工程中，这样后面VS才能正确的将程序编译出来。下面咱们来看看该如何在VS中引入FFmpeg库头文件、库文件：</p><ul><li><p>引入FFmpeg头文件</p><p>在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目右键 -&gt; 属性 -&gt; C/C++ -&gt; 常规 -&gt; 附加包含目录</span><br></pre></td></tr></table></figure><p>中添加FFmpeg头文件所在路径。</p></li><li><p>指定库文件位置</p><p>在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目右键 -&gt; 属性 -&gt; 链接器 -&gt; 常规 -&gt; 附加库目录</span><br></pre></td></tr></table></figure><p>中添加FFmpeg库所在路径。</p></li><li><p>指定使用哪个库<br>在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目右键 -&gt; 属性 -&gt; 链接器 -&gt; 输入 -&gt; 附加依赖项</span><br></pre></td></tr></table></figure><p>中指定你所用到的FFmpeg库，如avutil.lib</p></li></ul><p>当上面这此工作完成后，我们就可以在<code>main(...)</code>函数中调用FFmpeg API了，如调用FFmpeg库中的日志函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavtuil/log.h&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(...)</span></span><br><span class="line">&#123;</span><br><span class="line">    av_log_set_level(AV_LOG_DEBUG);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">&quot;Hello World!\n);</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>上述代码中，调用了FFmpeg中的两个API，分别是 <code>av_log_set_level(...)</code>以及<code>av_log(...)</code>，这两个函数都是FFmpeg avutil库中的API。所以在使用这两个API之前，我们要在main.c中需要通过<code>#include</code>关键字将 <strong>libavtuil&#x2F;log.h</strong> 这个头文件引入进来。</p><p>此外，由于FFmpeg是C语言库，而我们用VS创建的是C++工程，所以在引入头文件时需要加上<code>extern &quot;C&quot;</code>关键字，否则的话VS无法将其成功编译。</p><h2 id="运行编译好的程序"><a href="#运行编译好的程序" class="headerlink" title="运行编译好的程序"></a>运行编译好的程序</h2><p>上面当我们运行编译好的程序时你会发现，它弹出了报错窗口，显示 <strong>“无法找到xxx.dll库”</strong> 的出错信息，其原因是在运行时无法找到需要的动态库。</p><p>解决办法很简单，只需将我们之前编译好的FFmpeg库，即提示的无法找到的<code>.dll</code>库，拷贝到执行程序的同一目录下，这样执行程序就可以找到该库并正确执行了。</p><h2 id="编译FFmpeg依赖库"><a href="#编译FFmpeg依赖库" class="headerlink" title="编译FFmpeg依赖库"></a>编译FFmpeg依赖库</h2><p>很多时候我们在编译FFmpeg库时还要增加一些其它库，如SDL、x264等，如何能将这些库添加到FFmpeg中呢？</p><p>要想将这些库编译到FFmpeg中，首先我们要编译出Windows下可用的对应库，下面咱们就来看一下如何在Windows系统下将它们编译出来。</p><h3 id="编译SDL"><a href="#编译SDL" class="headerlink" title="编译SDL"></a>编译SDL</h3><p>首先从github上获取SDL源码，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/libsdl-org/SDL.git</span><br><span class="line">git checkout release-2.26.x</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，SDL现在已经发布了3.0版本，而ffmpeg目前只能用SDL2版本，所以在拉取代码后，需要切换到2.26这个版本</p></blockquote><p>下载好 SDL2 源码后，我们需要使用 <strong>CMake</strong> 为其生成VS工程，所以我们首先到这里<a href="https://github.com/Kitware/CMake/releases/download/v3.25.0/cmake-3.25.0-windows-x86_64.msi">下载CMake</a>，并将其安装到Windows系统上。</p><p>之后打开 CMake-GUI，在 CMake-GUI 中指定SDL2源码所在路径以及编译后的输出路径，随后执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Configure -&gt; Generate</span><br></pre></td></tr></table></figure><p>生成VS工程。有了VS工程，我们就可以通过VS2019或VS2022来编译SDL了。</p><p>需要指出的是，编译好的SDL会保存到指定输出目录的 <strong>Release</strong> 或 <strong>Debug</strong> 目录下（例如指定的输出目录为<code>/usr/local/sdl2</code>，则输出路径为<code>/usr/local/sdl2/Release</code>)，而我们希望输出的路径则是<code>/usr/local/sdl2/lib</code>。</p><p>为了满足要求，<strong>我们需要在指定输出目录下创建 <strong>lib</strong> 目录，并将SDL2.lib 和 SDL2.dll文件拷贝到 lib 目录下。同时在 lib 目录下创建 pkgconfig 目录，将sdl2.pc 文件拷贝到该目录中</strong>。</p><p>此外，我们还要修改 <strong>sdl2.pc</strong> 中的内容，将其中的库路径修改为指定的输出路径，最终完整的目录结构如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/sdl2</span><br><span class="line"> |------------ lib</span><br><span class="line"> |              |-- sdl2.lib</span><br><span class="line"> |              |-- sdl2.dll</span><br><span class="line"> |              |-- pkgconfig</span><br><span class="line"> |                     |----- sdl2.pc</span><br><span class="line"> |------------ include</span><br></pre></td></tr></table></figure><h3 id="编译x264"><a href="#编译x264" class="headerlink" title="编译x264"></a>编译x264</h3><p>x264库的编译还是比较简单的，与SDL一样我们也要先获取其源码，可以通过下面的命令获取x264源码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://code.videolan.org/videolan/x264.git</span><br></pre></td></tr></table></figure><p>源码获取到后，可以直接在MSYS2环境下编译出Windows下可用的动态库，具体步骤如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过VS X64 Native... 窗口打开MSYS2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /d/x264 <span class="comment"># 在MSYS2中进入x264源码目录</span></span><br><span class="line"></span><br><span class="line">pacman -S automake autoconf libtool <span class="comment"># 安装生成Makefile的工具</span></span><br><span class="line"></span><br><span class="line">CC=cl ./configure --prefix=/usr/local/x264 --enable-shared</span><br><span class="line"></span><br><span class="line">make -j 4 &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>通过上面的命令就可以将x264编译出来了。x264编译好后，其输出的目录结构与SDL2是一样的，在<code>/usr/local/x264</code>中包括了<code>include</code>、<code>lib</code>、<code>bin</code>等目录。</p><p>要特别强调的一点是，我们需要将<code>lib</code>目录下的<code>libx264.dll.lib</code>文件名修改为<code>libx264.lib</code>，否则ffmpeg编译时会报 <strong>“无法找到该库”</strong> 的错误。</p><h3 id="编译fdk-aac"><a href="#编译fdk-aac" class="headerlink" title="编译fdk-aac"></a>编译fdk-aac</h3><p>fdk-aac的编译与SDL类似，它同样要使用CMake生成VS工程文件，之后再通过VS编译该库。</p><p>首先，通下面的的命令获取fdk-aac源码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/mstorsjo/fdk-aac.git</span><br></pre></td></tr></table></figure><p>之后，通过CMake生成VS工程文件，具体执行步骤请参考 SDL 生成 VS 工程的步骤，这里就不再重复了。</p><p>接下来，使用VS2019或VS2022编译fdk-aac，编译好的库同要会被放到Release或Debug目录下，因此我们必须像处理SDL库一样，需要手工组织fdk-aac的输出目录树。</p><p>至此fdk-aac就算编译好了。</p><blockquote><p>在编译fdk-aac时有个特殊情况，就是使用CMake的方式无法产生include头文件（这也有可能是我哪块执行的不对）。为了解决这个问题，我又用 MSYS2+mingw 的方式重新编译了一遍fdk-aac，这种方式是可以生成 <strong>include</strong> 头文件的，然后将生成的头文件手动拷贝到了&#x2F;usr&#x2F;local&#x2F;fdk-aac目录下即可。</p></blockquote><h3 id="FFmpeg如何使用上述编译好的库呢？"><a href="#FFmpeg如何使用上述编译好的库呢？" class="headerlink" title="FFmpeg如何使用上述编译好的库呢？"></a>FFmpeg如何使用上述编译好的库呢？</h3><p>首先，我们要设置环境变量<code>PKG_CONFIG_PATH</code>，通过它告诉FFmpeg上述几个库从哪儿可以找到，具体的设置方法如下：</p><ul><li>在MSYS2窗口中打开<code>.bashrc</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman -S vim</span><br><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure></li><li>在<code>~/.bashrc</code>中设置环境变量<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PKG_CONFIG_PATH=/usr/local/sdl2/lib/pkgconfig:/usr/local/x264/lib/pkgconfig:/usr/local/fdk-aac/lib/pkgconfig:<span class="variable">$PKG_CONFIG_PATH</span></span><br><span class="line"></span><br><span class="line">:wq <span class="comment">#保存并退出vim</span></span><br></pre></td></tr></table></figure></li><li>让环境变是生效<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></li></ul><p>接下来，重新生成FFmpeg的Makefile文件，并重新编译，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/ffmpeg --<span class="built_in">arch</span>=x86_64 --enable-shared --disable-ffprobe --disable-doc --enable-libx264 --enable-gpl --enable-fdk-aac --enable-nonfree --toolchain=msvc</span><br><span class="line"></span><br><span class="line">make clean</span><br><span class="line"></span><br><span class="line">make -j 4 &amp;&amp; make install</span><br></pre></td></tr></table></figure><p><strong>最后，将sdl2的dll、x264的dll以及fdk-aac的dll拷贝到ffmpeg的bin目录下，这样就可以正确的执行 ffmpeg.exe 或 ffplay.exe 命令了</strong>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上面就是在Windows下编译和使用FFmpeg的方法。如果你在Linux或Mac下可以熟练的编译FFmpeg，你会发现，在Window下编译FFmpeg的步骤与在Linux和Mac下编译的步骤是一样的，关键点是在Windows下该如何搭建好编译环境。</p><p>此外需要强调的是，在Windows下编译FFmpeg时，由于它不能识别 <strong>CC_IDENT</strong> 关键字，所以编译时会报错，我们只需将使用该关键字的语句注释掉即可解决该问题。</p><p>另外，在程序中通过<code>#include</code>引用FFmpeg头文件时，一定要记得加 <code>extern &quot;C&quot;</code>关键字，告诉C++编译器，这个头文件是一个C类型的头文件，这样它才能正确编译。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ul><li><a href="https://github.com/ShiftMediaProject/FFmpeg">ShiftMediaProject</a>，有同学给我推荐了这个项目，我简单了解了一下，这个项目真不错，可以直接使用VS对FFmpeg进行调试，有兴趣的同学可以偿试一下。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/windows_ffmpeg/FFmpeg_logo.jpeg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在我的FFmpeg课程中，我总是推荐大家使用 &lt;strong&gt;Linux(Ubuntu)系统&lt;/strong&gt; 或 &lt;strong&gt;Mac系统&lt;/strong&gt; 来学习FFmpeg。其原因，是在Windows下编译FFmpeg太麻烦了，这大大增加了我们学习FFmpeg的成本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FFmpeg" scheme="https://blog.avdancedu.com/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="https://blog.avdancedu.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>VS中引入并使用WebRTC库</title>
    <link href="https://blog.avdancedu.com/fcd68433/"/>
    <id>https://blog.avdancedu.com/fcd68433/</id>
    <published>2022-11-24T13:35:00.000Z</published>
    <updated>2022-12-07T06:08:07.550Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://avdancevod.oss-cn-beijing.aliyuncs.com/image/article/import_webrtc/webrtc_banner_2.jpeg" alt="banner"></p><p>前段时间经常有同学问我，如何在Windows下利用编译出的WebRTC库开发自己的应用程序，当时特别忙就让同学到网上找答案了，没想到过了几天同学们又来问，说网上找不到……</p><p>相对于移动端，在Windows下使用WebRTC库确实困难些。在移动端（iOS、Andorid），你可以直接从Google提供的Pod库中拉取编译好的WebRTC库，而在Windows端则需要我们自己编译WebRTC库，并导出WebRTC头文件。</p><p>这几天手头的工作终于忙的差不多了，今天就花点时间整理一下这方面的知识，给同学们搭个<strong>台阶</strong>，让同学们快尽入手WebRTC:)。</p><span id="more"></span><h2 id="安装开发环境"><a href="#安装开发环境" class="headerlink" title="安装开发环境"></a>安装开发环境</h2><p>在Windows下开发应用程序最常用的开发工具还是Visual Studio，你可以使用VS2019，也可以使用VS2022，目前我还是建议大家先用 VS2019，再等个半年、一年的换VS2022比较合适。VS2019的下载地址<a href="https://visualstudio.microsoft.com/zh-hans/thank-you-downloading-visual-studio/?sku=community&rel=16&utm_medium=microsoft&utm_campaign=download+from+relnotes&utm_content=vs2019ga+button">在这里</a>，将 VS Installer下载好后，在CMD窗口中执行下面的命令即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ PATH_TO_INSTALLER.EXE ^</span><br><span class="line">--add Microsoft.VisualStudio.Workload.NativeDesktop ^</span><br><span class="line">--add Microsoft.VisualStudio.Component.VC.ATLMFC ^</span><br><span class="line">--includeRecommended</span><br></pre></td></tr></table></figure><p>当然，正常情况下你在配置WebRTC编译环境时就应该已经将VS安装好了。</p><h2 id="编译WebRTC"><a href="#编译WebRTC" class="headerlink" title="编译WebRTC"></a>编译WebRTC</h2><p>开发环境安装好后，下面我们就该编译WebRTC源码了。WebRTC源码的下载与编译请看<a href="https://avdancedu.com/2bafd6cf/">这篇文章</a>。</p><p>需要注意的是，我们在新项目中引入的WebRTC库，不能直接用下面的命令进行编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gn gen out/Default</span><br><span class="line">ninja -C out/Default</span><br></pre></td></tr></table></figure><p>而必须明确指明编译出的WebRTC是<strong>Debug</strong>版本，还是<strong>Release</strong>版本；是<strong>x86</strong>版本还是<strong>x64</strong>版本……</p><p>因此，应该使用下面的命令编译WebRTC:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gn gen --target=x64 --ide=vs2019 --args=&quot;is_debug=true rtc_enable_protobuf=false is_clang=false target_cpu=\&quot;x64\&quot;  enable_iterator_debugging=true  use_custom_libcxx=false symbol_level=0 rtc_include_tests=false&quot; out/debug_x64</span><br><span class="line">ninja - C out/debug_x64</span><br></pre></td></tr></table></figure><p>上述 <strong>gn</strong> 中的几个参数含义如下：</p><ul><li>–target，顾名思义，生成x64版本的WebRTC库</li><li>–ide，生成VS工程文件</li><li>–args，编译时的一些配置参数<ul><li>is_debug，为true编译出Debug版本；为false编译出Release版本</li><li>rtc_enable_protobuf，是否使用protobuf，使用可将其设置为true</li><li>use_custom_libcxx，WebRTC默认使用的是libc++库，而我们在Windows上使用的是libstdc++库，所以需要将其设置为false</li><li>symbol_level，编译出的WebRTC库是否带符号表，这个数据量很大，会影响运行速度，所以一般设置为0，表示编译出的WebRTC不带符号表</li><li>rtc_include_tests，编译WebRTC时是否编译测试用例，如果为false则不编译，这样可以大大加快WebRTC的编译速度</li></ul></li></ul><p>执行上面的命令时，会花一些时间，因此我们需要让<strong>子弹飞一会儿</strong>……</p><h2 id="构建自己的应用程序"><a href="#构建自己的应用程序" class="headerlink" title="构建自己的应用程序"></a>构建自己的应用程序</h2><p>如果顺利的话，你现在应该已经将WebRTC库编译好了。接下来我们来创建自己的应用程序。</p><p>为了方便，你可以将WebRTC examples中的peerconnection_client代码拿出来构建一个新的工程，之后再将前面编译好的WebRTC库引入进来，<strong>如果它可以正常运行就达到了我们的目标</strong>。</p><p>为了达到这个目标，首先我们先使用VS创建一个空项目，步骤如下：</p><ul><li>第一步，打开Visual Studio，<strong>创建新项目</strong><br><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/vs1.png" alt="图1"></li><li>第二步，使用Windows桌面向导创建Windows空项目<br><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/vs2.png" alt="图2"></li><li>第三步，填写项目名称，并将项目与解决方案放在同一目录下<br><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/vs3.png" alt="图3"></li><li>第四步，选择应用程序类型为<strong>桌面应用程序</strong><br><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/vs4.png" alt="图4"></li><li>第五步，同时勾选<strong>空项目</strong><br><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/vs5.png" alt="图5"></li></ul><p>至此，我们就构建出了一个VS<strong>空项目</strong>，它里边没有任何文件，如下图所示：</p><p><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/vs6_new.png" alt="图6"></p><p>空项目创建好后，紧接着我们来移植peerconnection_client代码到新项目中，步骤如下：</p><ul><li><p>第一步，从WebRTC源码中拷贝peerconnection_client中的代码到新项目的目录中，在我这里是<br>将<code>C:\webrtc\webrtc-checkout\src\exmaples\peerconnection\client</code>目录中的代码拷贝到<code>C:\Users\lichao\sourceMyWebRTCDemo</code>目录下。如下图所示：</p><p><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/code1.png" alt="code1"></p><p><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/code2.png" alt="code2"></p></li><li><p>第二步，将新项目中的代码<strong>拖</strong>到VS项目中<br><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/code3_new.png" alt="code3"></p></li></ul><p>通过以上步骤我们就将peerconnection_client中的代码移植好了。接下来咱们来看<strong>重头戏</strong>，如何在项目中引入WebRTC库。</p><h2 id="引入WebRTC库"><a href="#引入WebRTC库" class="headerlink" title="引入WebRTC库"></a>引入WebRTC库</h2><p>通常我们引入一个外部库只需要两步，<strong>引入库文件和其头文件</strong>。不过，对于WebRTC，更准确的说对于peerconnection_client而言，它需要的不仅仅是WebRTC库，还需要将WebRTC依赖的第三方库加进来，这是大家觉得在Windows下使用WebRTC库比较麻烦的原因。</p><p>下面咱们就来看一下如何引入WebRTC库吧！</p><h3 id="添加依赖的头文件"><a href="#添加依赖的头文件" class="headerlink" title="添加依赖的头文件"></a>添加依赖的头文件</h3><p>我们若想将WebRTC头文件引入到项目中，可以通过下面两种方法引入：</p><ul><li><p>方法一，在VS中将WebRTC源码路径添加到<strong>附加包含目录</strong>中。比如我这里将WebRTC源码下载到了<code>C:\webrtc\webrtc-checkout\src</code>目录下，我只需将该路径添加到:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目 -&gt; 属性 -&gt; C/C++ -&gt; 常规 -&gt; 附加包含目录</span><br></pre></td></tr></table></figure><p>中即可，如下图所示：<br><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/setting1.png" alt="setting1"></p><p><strong>这种方法的好处是简单方便，坏处是不便于我们将库文件发布给别人使用。</strong></p></li><li><p>方法二，我们可以通过<a href="https://avdancevod.oss-cn-beijing.aliyuncs.com/image/article/import_webrtc/extrac_webrtc_headers.bat">这个脚本</a>将WebRTC中的头文件提取出来。之后与<strong>方法一</strong>一样，将头文件路径添加到<strong>附加包含目录</strong>中即可。</p><p>需要注意的是，这个脚本下载后，要将其放到WebRTC源码目录<strong>src</strong>的同级目录中，如下图所示：<br><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/script.png" alt="script1"></p><p>之后打开Windows控制台，并进入到<strong>src</strong>的同级目录中，在CMD窗口中执行<code>extract_webrtc_headers.bat</code>脚本，这样就可以将WebRTC头文件提取出来了，如下图所示：<br><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/script2.png" alt="script2"></p><p><strong>这种方法的优点是方便其他人使用，缺点是抽取头文件需要花一些时间。</strong></p></li></ul><p>除了添加上面的头文件路径外，我们还需要将下面几个路径添加到<strong>附加包含项目</strong>中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\webrtc\webrtc-checkout\src\third_party\jsoncpp\generated</span><br><span class="line">C:\webrtc\webrtc-checkout\src\third_party\jsoncpp\source\include</span><br><span class="line">C:\webrtc\webrtc-checkout\src\third_party\libyuv\include</span><br><span class="line">C:\webrtc\webrtc-checkout\src\third_party\abseil-cpp</span><br></pre></td></tr></table></figure><h3 id="添加依赖的库"><a href="#添加依赖的库" class="headerlink" title="添加依赖的库"></a>添加依赖的库</h3><p>头文件添加好后，接下来咱们来添加WebRTC库文件。WebRTC编译好后，你可以在WebRTC源码目录<strong>src</strong>的<strong>out&#x2F;debug_x64&#x2F;obj</strong>目录下找到<strong>WebRTC.lib</strong>文件，这就是编译好的WebRTC库。</p><p>我们将它添加到VS中的<strong>附加库目录</strong>中，具体操作如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">右键项目 -&gt; 属性 -&gt; 链接器 -&gt; 常规 -&gt; 附加库目录</span><br></pre></td></tr></table></figure><p>WebRTC库文件路径添加好后，如下图所示：<br><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/linker1.png" alt="linker1"></p><p>接着咱们添加具体的的依赖库，添加依赖库的位置在:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">右键项目 -&gt; 属性 -&gt; 链接器 -&gt; 输入 -&gt; 附加依赖项</span><br></pre></td></tr></table></figure><p>如下图所示：<br><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/linker2.png" alt="linker2"></p><p>具体都依赖哪些依赖项呢？这里我以 <strong>M93(4577)</strong> 为例，对于这个版本的peerconnection_client来说，它需要下面的依赖库：</p><ul><li><p>WebRTC相关的库包括：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">third_party/abseil-cpp/absl/flags/marshalling/marshalling.obj</span><br><span class="line">third_party/abseil-cpp/absl/flags/program_name/program_name.obj</span><br><span class="line">third_party/abseil-cpp/absl/flags/flag/flag.obj</span><br><span class="line">third_party/abseil-cpp/absl/flags/flag_internal/flag.obj</span><br><span class="line">third_party/abseil-cpp/absl/flags/commandlineflag/commandlineflag.obj</span><br><span class="line">third_party/abseil-cpp/absl/flags/commandlineflag_internal/commandlineflag.obj</span><br><span class="line">third_party/abseil-cpp/absl/flags/private_handle_accessor/private_handle_accessor.obj</span><br><span class="line">third_party/abseil-cpp/absl/flags/reflection/reflection.obj</span><br><span class="line">third_party/abseil-cpp/absl/flags/parse/parse.obj</span><br><span class="line">third_party/abseil-cpp/absl/flags/usage/usage.obj</span><br><span class="line">third_party/abseil-cpp/absl/flags/usage_internal/usage.obj</span><br><span class="line">third_party/abseil-cpp/absl/flags/config/usage_config.obj</span><br><span class="line">third_party/jsoncpp/jsoncpp/json_reader.obj</span><br><span class="line">third_party/jsoncpp/jsoncpp/json_value.obj</span><br><span class="line">third_party/jsoncpp/jsoncpp/json_writer.obj</span><br><span class="line">test/field_trial/field_trial.obj</span><br><span class="line">test/video_test_common/test_video_capturer.obj</span><br><span class="line">test/platform_video_capturer/vcm_capturer.obj</span><br><span class="line">rtc_base/rtc_json/json.obj</span><br></pre></td></tr></table></figure></li><li><p>系统相关的库包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">advapi32.lib</span><br><span class="line">comdlg32.lib</span><br><span class="line">dbghelp.lib</span><br><span class="line">dnsapi.lib</span><br><span class="line">gdi32.lib</span><br><span class="line">msimg32.lib</span><br><span class="line">odbc32.lib</span><br><span class="line">odbccp32.lib</span><br><span class="line">oleaut32.lib</span><br><span class="line">shell32.lib</span><br><span class="line">shlwapi.lib</span><br><span class="line">user32.lib</span><br><span class="line">usp10.lib</span><br><span class="line">uuid.lib</span><br><span class="line">version.lib</span><br><span class="line">wininet.lib</span><br><span class="line">winmm.lib</span><br><span class="line">winspool.lib</span><br><span class="line">ws2_32.lib</span><br><span class="line">delayimp.lib</span><br><span class="line">kernel32.lib</span><br><span class="line">ole32.lib</span><br><span class="line">crypt32.lib</span><br><span class="line">iphlpapi.lib</span><br><span class="line">secur32.lib</span><br><span class="line">dmoguids.lib</span><br><span class="line">wmcodecdspuuid.lib</span><br><span class="line">amstrmid.lib</span><br><span class="line">msdmo.lib</span><br><span class="line">strmiids.lib</span><br></pre></td></tr></table></figure></li></ul><h3 id="添加宏"><a href="#添加宏" class="headerlink" title="添加宏"></a>添加宏</h3><p>除了上面讲的需要引入头文件和WebRTC库之外，还需要添加下面这些宏。这些宏的具体含义我有不介绍了，有兴趣的同学可以自己在网上搜索一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">USE_AURA=<span class="number">1</span></span><br><span class="line">_HAS_NODISCARD</span><br><span class="line">_HAS_EXCEPTIONS=<span class="number">0</span></span><br><span class="line">__STD_C</span><br><span class="line">_CRT_RAND_S</span><br><span class="line">_CRT_SECURE_NO_DEPRECATE</span><br><span class="line">_SCL_SECURE_NO_DEPRECATE</span><br><span class="line">_ATL_NO_OPENGL</span><br><span class="line">_WINDOWS</span><br><span class="line">CERT_CHAIN_PARA_HAS_EXTRA_FIELDS</span><br><span class="line">PSAPI_VERSION=<span class="number">2</span></span><br><span class="line">WIN32</span><br><span class="line">_SECURE_ATL</span><br><span class="line">WINAPI_FAMILY=WINAPI_FAMILY_DESKTOP_APP</span><br><span class="line">WIN32_LEAN_AND_MEAN</span><br><span class="line">NOMINMAX</span><br><span class="line">_UNICODE</span><br><span class="line">UNICODE</span><br><span class="line">NTDDI_VERSION=NTDDI_WIN10_VB</span><br><span class="line">_WIN32_WINNT=<span class="number">0x0A00</span></span><br><span class="line">WINVER=<span class="number">0x0A00</span></span><br><span class="line">_DEBUG</span><br><span class="line">DYNAMIC_ANNOTATIONS_ENABLED=<span class="number">1</span></span><br><span class="line">WEBRTC_ENABLE_PROTOBUF=<span class="number">0</span></span><br><span class="line">WEBRTC_INCLUDE_INTERNAL_AUDIO_DEVICE</span><br><span class="line">RTC_ENABLE_VP9</span><br><span class="line">WEBRTC_HAVE_SCTP</span><br><span class="line">WEBRTC_ENABLE_AVX2</span><br><span class="line">RTC_ENABLE_WIN_WGC</span><br><span class="line">WEBRTC_NON_STATIC_TRACE_EVENT_HANDLERS=<span class="number">0</span></span><br><span class="line">WEBRTC_WIN</span><br><span class="line">ABSL_ALLOCATOR_NOTHROW=<span class="number">1</span></span><br><span class="line">_ENABLE_EXTENDED_ALIGNED_STORAGE</span><br><span class="line">ABSL_FLAGS_STRIP_NAMES=<span class="number">0</span></span><br><span class="line">HAVE_WEBRTC_VIDEO</span><br></pre></td></tr></table></figure><p>添加方法如下:</p><ul><li><p>首先在 VS 中执行下面的操作，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">右键项目 -&gt; 属性 -&gt; C/C++ -&gt; 预处理器</span><br></pre></td></tr></table></figure></li><li><p>之后将上面的宏添加到<strong>预处理器</strong>中即可。</p></li></ul><h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><p>到此为止，我们就将peerconnection_client的代码移植好了，直接点<img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/run.png">测试一下吧！</p><p>此时，编译器有可能报4996的错误，解决该问题办法很简单，只要在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">右键项目项 -&gt; 属性 -&gt; C/C++ -&gt; 高级 -&gt; 禁用特定警告</span><br></pre></td></tr></table></figure><p>中将 <strong>4996</strong> 添加进去即可。除此之外，还有可能遇到 <strong>&#x2F;MDd</strong> 错误，解决它可以通过在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">右键项目项 -&gt; 属性 -&gt; C/C++ -&gt; 代码生成 -&gt; 运行库</span><br></pre></td></tr></table></figure><p>中将 <strong>&#x2F;MDd</strong> 改为 <strong>&#x2F;MTd</strong> 即可。</p><p>如果一切顺利，peerconnection_client的连接窗口就展示在你面前了，如下图所示。<br><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/conn.png"></p><p>此时，你需要先将peerconnection_server程序运行起来，让它侦听 <strong>8888</strong> 端口；之后在peerconnection_client的连接界面中输入 <strong>127.0.0.1</strong>，点击<strong>连接</strong>，如果能进入列表界面就表明OK了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上面我详细的向你介绍了如何将WebRTC中的peerconnection_client代码移植出来，并重点向你讲解了如何在项目中引入WebRTC库。</p><p>其重点包括三步：一是添加WebRTC库头文件路径；二是添加WebRTC库路径，及其WebRTC库；三是添加一堆宏。只要将上面三个步骤操作好了，其它的一些问题在网上都能找到答案。</p><p>祝大家好运！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://avdancevod.oss-cn-beijing.aliyuncs.com/image/article/import_webrtc/webrtc_banner_2.jpeg&quot; alt=&quot;banner&quot;&gt;&lt;/p&gt;
&lt;p&gt;前段时间经常有同学问我，如何在Windows下利用编译出的WebRTC库开发自己的应用程序，当时特别忙就让同学到网上找答案了，没想到过了几天同学们又来问，说网上找不到……&lt;/p&gt;
&lt;p&gt;相对于移动端，在Windows下使用WebRTC库确实困难些。在移动端（iOS、Andorid），你可以直接从Google提供的Pod库中拉取编译好的WebRTC库，而在Windows端则需要我们自己编译WebRTC库，并导出WebRTC头文件。&lt;/p&gt;
&lt;p&gt;这几天手头的工作终于忙的差不多了，今天就花点时间整理一下这方面的知识，给同学们搭个&lt;strong&gt;台阶&lt;/strong&gt;，让同学们快尽入手WebRTC:)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/tags/WebRTC/"/>
    
      <category term="VS" scheme="https://blog.avdancedu.com/tags/VS/"/>
    
  </entry>
  
  <entry>
    <title>SDL事件处理</title>
    <link href="https://blog.avdancedu.com/a0ec02a7/"/>
    <id>https://blog.avdancedu.com/a0ec02a7/</id>
    <published>2022-11-19T06:52:00.000Z</published>
    <updated>2022-11-20T04:07:08.621Z</updated>
    
    <content type="html"><![CDATA[<p>前面我为大家介绍了 SDL 的三个主题：</p><ul><li><a href="http://www.avdancedu.com/56ef4bcb">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8">SDL基本图形绘制</a></li></ul><p>今天我为大家介绍一下SDL的事件处理。这里所指的事件处理就是我们通常所说的，键盘事件，鼠标事件，窗口事件等。</p><p>SDL对这些事件都做了封装，提供了统一的API，下面我们就来详细的看一下。</p><span id="more"></span><h2 id="SDL中的事件处理"><a href="#SDL中的事件处理" class="headerlink" title="SDL中的事件处理"></a>SDL中的事件处理</h2><p>要想了解 SDL 的事件处理，我们必须要知道的一个原理是，SDL将所有事件都存放在一个队列中。所有对事件的操作，其实就是对队列的操作。了解了这个原理后，我们再来说SDL提供的 API 就很容易理解了。</p><ul><li>SDL_PollEvent: 将队列头中的事件抛出来。</li><li>SDL_WaitEvent: 当队列中有事件时，抛出事件。否则处于阻塞状态，释放 CPU。</li><li>SDL_WaitEventTimeout: 与SDL_WaitEvent的区别时，当到达超时时间后，退出阻塞状态。</li><li>SDL_PeekEvent: 从队列中取出事件，但该事件不从队列中删除。</li><li>SDL_PushEvent: 向队列中插入事件。</li></ul><p>SDL只提供了这样几个简单的API，下面们来介绍几个常见的事件：</p><ul><li>SDL_WindowEvent : Window窗口相关的事件。</li><li>SDL_KeyboardEvent : 键盘相关的事件。</li><li>SDL_MouseMotionEvent : 鼠标移动相关的事件。</li><li>SDL_QuitEvent : 退出事件。</li><li>SDL_UserEvent : 用户自定义事件。</li></ul><p>关于事件更加详的信息可以到 <a href="https://wiki.libsdl.org/SDL_Event">SDL Wiki</a> 上进行查询。现在我们来看一个使用的例子吧。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>在我们之前文章的例子中，大家已经发现一个问题，那就是窗口只显示了 3 秒钟，之后就自动消失了。</p><p>有的同学可以会通过修改代码最后面的 SDL_Delay 函数，增加它的等待时间让窗口多活一段时间。</p><p>但这样的体验实在是太糟糕了。有没有一种好的办法可以解决这个问题呢？能不能窗口一直显示，直到检测到用户按了<code>ctrl+c</code> 或 使用鼠标点击关闭按钮后才关闭呢？</p><p>当然是可以的。我们只需要在之前的程序的末尾增加下面这段代码即可。它会一直检测用户是否按下了退出按钮。如果检测到了，则直接退出，否则保持显示状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">while(!quit)&#123;</span><br><span class="line">    SDL_Event event;</span><br><span class="line">    while(SDL_PollEvent(&amp;event))&#123;</span><br><span class="line">        switch(event.type)&#123;</span><br><span class="line">            case SDL_QUIT:</span><br><span class="line">               quit = 1;</span><br><span class="line">               break;</span><br><span class="line">            default:</span><br><span class="line">               SDL_Log(&quot;.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SDL-PollEvent-与-SDL-WaitEvent"><a href="#SDL-PollEvent-与-SDL-WaitEvent" class="headerlink" title="SDL_PollEvent 与 SDL_WaitEvent"></a>SDL_PollEvent 与 SDL_WaitEvent</h2><p>增加了上面的代码，我们的实验程序似乎也显的很正规了。但有一个问题不知你发现没有<br>?当我们打开任务管理器时，发现我们的程序居然占了 100% 的 CPU。My GOD!这个的结果是决对不能接受的。</p><p>是什么原因造成的呢？我们来仔细看一下我们增加的代码吧。它由两层 while 循环组成，最里面的while循环的意思是，当队列中一直能取出事件，那就让他一直做下去，直到事件队列为空。外面的while循环的意思是，当队列为空的时候，重新执行内部的while循环。</p><p>也就是说，这段代码一直在工作，从不休息。所以导致cpu占到了100%。即然找到了问题的原因，我们就好处理了，只要在外层循环的最后 delay一下，让CPU休息一下就好了。</p><p>当然，SDL还为我们提供了 SDL_WaitEvent方法，使用这个API,你的CPU就不会跑到 100%了，因为当它发现队列为空时，它会阻塞在那里，并将CPU释放掉。</p><p>即然有 SDL_WaitEvent了，为什么还要有SDL_PollEvent呢？这主要是由于使用的场景不同。对于游戏来说，它要求事件的实时处理； 而对于一些其它实时性不高的case来说，则可以使用 SDL_WaitEvent了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到此，本文的内容就介绍完了。在本文中主要介绍了SDL是如何处理事件的，SDL为我们提供了非常简单的API，这大大减少了我们的开发成本。</p><p>另外，我在文章的最后，介绍了SDL_PollEvent 与 SDL_WaitEvent两个 API的区别。这也是使用 SDL 事件处理中最容易引起困惑的地方。</p><p>希望本文能对您有所帮助，谢谢！</p><h2 id="推荐阅读："><a href="#推荐阅读：" class="headerlink" title="推荐阅读："></a>推荐阅读：</h2><ul><li><a href="http://www.avdancedu.com/56ef4bcb">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8">SDL基本图形绘制</a></li><li><a href="http://www.avdancedu.com/a0ec02a7">SDL事件处事</a></li><li><a href="http://www.avdancedu.com/67189745">彻底理解SDL纹理</a></li><li><a href="http://www.avdancedu.com/a6aca2fe">SDL孙悟空与多线程</a></li><li><a href="http://www.avdancedu.com/f94132a0">PCM音频播放器的实现</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面我为大家介绍了 SDL 的三个主题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/56ef4bcb&quot;&gt;SDL 入门&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/287ad9ab&quot;&gt;SDL窗口渲染&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/24ee78a8&quot;&gt;SDL基本图形绘制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今天我为大家介绍一下SDL的事件处理。这里所指的事件处理就是我们通常所说的，键盘事件，鼠标事件，窗口事件等。&lt;/p&gt;
&lt;p&gt;SDL对这些事件都做了封装，提供了统一的API，下面我们就来详细的看一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="视频渲染" scheme="https://blog.avdancedu.com/categories/%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93/"/>
    
    
      <category term="SDL" scheme="https://blog.avdancedu.com/tags/SDL/"/>
    
  </entry>
  
  <entry>
    <title>SDL入门</title>
    <link href="https://blog.avdancedu.com/56ef4bcb/"/>
    <id>https://blog.avdancedu.com/56ef4bcb/</id>
    <published>2022-11-19T06:52:00.000Z</published>
    <updated>2022-11-20T05:07:01.481Z</updated>
    
    <content type="html"><![CDATA[<p>推荐阅读：</p><ul><li><a href="http://www.avdancedu.com/56ef4bcb">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8">SDL基本图形绘制</a></li><li><a href="http://www.avdancedu.com/a0ec02a7">SDL事件处事</a></li><li><a href="http://www.avdancedu.com/67189745">彻底理解SDL纹理</a></li><li><a href="http://www.avdancedu.com/a6aca2fe">SDL孙悟空与多线程</a></li><li><a href="http://www.avdancedu.com/f94132a0">PCM音频播放器的实现</a></li></ul><p>SDL是 “Simple DirectMedia Layer”的缩写，它是一个开源的项目。其主要用于游戏开发中的多媒体处理，如视频渲染，音频播放，鼠标&#x2F;键盘控制等操作。</p><p>并且它是一个跨平台的多媒体库。也就是说它对外接供了一套统一的接口，但在内部，它会根据不同平台调用不同的底层 API库。如在 Linux 系统下，它会使用 opengl 做渲染，而在 Window 下它会调用 D3D API进行渲染。</p><p>我之所以要介绍它，主要是因为我要在开发的多媒体播放器中使用它。</p><span id="more"></span><h2 id="SDL的编译与安装"><a href="#SDL的编译与安装" class="headerlink" title="SDL的编译与安装"></a>SDL的编译与安装</h2><p>目前 SDL 分为 SDL1 和 SDL2 两个主要版本。这两上版本差异非常大，无法相兼容。不过SDL1已经基本过时，主流产品都在使用的 SDL2，所以我们这里也使用SDL2作为例子进行讲解。</p><ul><li><p><a href="https://www.libsdl.org/download-2.0.php">下载SDL源码</a>（<strong>可能需要翻墙才行</strong>）</p></li><li><p>编译与安装</p><ul><li><p>生成SDL的Makefile</p><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configure --prefix=/usr/local</span><br></pre></td></tr></table></figure></code></pre></li><li><p>编译并安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="使用-SDL2-的其本流程"><a href="#使用-SDL2-的其本流程" class="headerlink" title="使用 SDL2 的其本流程"></a>使用 SDL2 的其本流程</h2><p>当我们通过源码编译并安装好 SDL2后，在我们的程序中使用 SDL2 就非常简单了，只要按照下面的步骤就可以绘制出一个窗口来。</p><ul><li><p>添加SDL头文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;SDL.h&gt;</span><br></pre></td></tr></table></figure></li><li><p>初始化SDL</p></li><li><p>创建窗口</p></li><li><p>销毁窗口</p></li><li><p>退出SDL</p></li></ul><p>当然，上面的步骤只是一个最基本的使用 SDL 的步骤，如果想了解更多的 SDL 的内容，静请期待我后面的文章。</p><h2 id="API详细介绍"><a href="#API详细介绍" class="headerlink" title="API详细介绍"></a>API详细介绍</h2><p>下面我们详细介绍一下上面用到的几个SDL API。</p><ul><li><p>初始化 SDL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int SDL_Init(Uint32 flags)</span><br></pre></td></tr></table></figure><table><thead><tr><th>flags</th><th>说明</th></tr></thead><tbody><tr><td>SDL_INIT_TIMER</td><td>timer subsystem</td></tr><tr><td>SDL_INIT_AUDIO</td><td>audio subsystem</td></tr><tr><td>SDL_INIT_VIDEO</td><td>video subsystem; automatically initializes the events subsystem</td></tr><tr><td>SDL_INIT_EVENTS</td><td>events subsystem</td></tr><tr><td>SDL_INIT_EVERYTHING</td><td>all of the above subsystems</td></tr></tbody></table><p>返回值：0, 成功。非0, 失败。</p></li><li><p>退出 SDL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void SDL_Quit(void)</span><br></pre></td></tr></table></figure></li><li><p>打印日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void SDL_Log(const char* fmt, ...)</span><br></pre></td></tr></table></figure><p>它与 C 语言中的 printf 格式相同。</p></li><li><p>创建窗口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SDL_Window* SDL_CreateWindow(const char* title,</span><br><span class="line">                           int         x,</span><br><span class="line">                           int         y,</span><br><span class="line">                           int         w,</span><br><span class="line">                           int         h,</span><br><span class="line">                           Uint32      flags)</span><br></pre></td></tr></table></figure><ul><li><p>title：窗口标题</p></li><li><p>x,y,w,h：窗口坐标</p></li><li><p>flag</p><table><thead><tr><th>flags</th><th>说明</th></tr></thead><tbody><tr><td>SDL_WINDOW_FULLSCREEN</td><td>fullscreen window</td></tr><tr><td>SDL_WINDOW_FULLSCREEN_DESKTOP</td><td>fullscreen window at the current desktop resolution</td></tr><tr><td>SDL_WINDOW_OPENGL</td><td>window usable with OpenGL context</td></tr><tr><td>SDL_WINDOW_HIDDEN</td><td>window is not visible</td></tr><tr><td>SDL_WINDOW_BORDERLESS</td><td>no window decoration</td></tr><tr><td>SDL_WINDOW_RESIZABLE</td><td>window can be resized</td></tr><tr><td>SDL_WINDOW_MINIMIZED</td><td>window is minimized</td></tr><tr><td>SDL_WINDOW_MAXIMIZED</td><td>window is maximized</td></tr><tr><td>SDL_WINDOW_SHOWN</td><td>show window</td></tr></tbody></table></li></ul></li><li><p>销毁窗口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void SDL_DestroyWindow(SDL_Window* window)</span><br></pre></td></tr></table></figure></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>下面是一个完整的使用SDL创建窗口的例子，你可以在 linux&#x2F;mac环境下执行它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;SDL.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    int flag = 1;</span><br><span class="line"></span><br><span class="line">    SDL_Window *window;                    // Declare a pointer</span><br><span class="line"></span><br><span class="line">    SDL_Init(SDL_INIT_VIDEO);              // Initialize SDL2</span><br><span class="line"></span><br><span class="line">    // Create an application window with the following settings:</span><br><span class="line">    window = SDL_CreateWindow(</span><br><span class="line">        &quot;An SDL2 window&quot;,                  // window title</span><br><span class="line">        SDL_WINDOWPOS_UNDEFINED,           // initial x position</span><br><span class="line">        SDL_WINDOWPOS_UNDEFINED,           // initial y position</span><br><span class="line">        640,                               // width, in pixels</span><br><span class="line">        480,                               // height, in pixels</span><br><span class="line">        SDL_WINDOW_SHOWN | SDL_WINDOW_BORDERLESS// flags - see below</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // Check that the window was successfully created</span><br><span class="line">    if (window == NULL) &#123;</span><br><span class="line">        // In the case that the window could not be made...</span><br><span class="line">        printf(&quot;Could not create window: %s\n&quot;, SDL_GetError());</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The window is open: could enter program loop here (see SDL_PollEvent())</span><br><span class="line"></span><br><span class="line">    SDL_Delay(3000);  // Pause execution for 3000 milliseconds, for example</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    // Close and destroy the window</span><br><span class="line">    SDL_DestroyWindow(window);</span><br><span class="line"></span><br><span class="line">    // Clean up</span><br><span class="line">    SDL_Quit();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你可以使用下面的命令在linux&#x2F;mac上编译上面的程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc/clang -g -o sdl2_base 文件名.c `pkg-config --cflags --libs sdl2`</span><br></pre></td></tr></table></figure><p>编译出的程序名为 sdl2_base，执行下面的命令就可能看到运行的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sdl2_base</span><br></pre></td></tr></table></figure><p><strong>需要注意的是，虽然上面的程序可以正常编译执行，但你会发现该程序创建的窗口并不能显示出来。我会在第二篇文章中介绍如何让窗口正常的显示出来</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过本文的介绍大家是不是觉得使用 SDL 非常简单易用呢？当然也许有人不太喜欢 SDL，认为直接使用 opengl 更高效。</p><p>但你要知道，SDL不只是对图像渲染做了封装，它还对其它媒体API做了封装，如对音频处理的封装等。这些封装大大减少了我们的开发工作量。</p><p>从另一方面讲，SDL 是一款非常优秀有多媒体库，除了使用它，其实我们还可以通过对其源码的分析，从中学到很多使用底层API的技巧。尤其是想学习播放器开发的同学，更是应该学好 SDL，因为著名的 ffplay 就是用的 SDL 做视频和音频的最终渲染与播放的。</p><p>最后，希望本文能帮你进行到 SDL 的世界。</p><h2 id="推荐阅读："><a href="#推荐阅读：" class="headerlink" title="推荐阅读："></a>推荐阅读：</h2><ul><li><a href="http://www.avdancedu.com/56ef4bcb">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8">SDL基本图形绘制</a></li><li><a href="http://www.avdancedu.com/a0ec02a7">SDL事件处事</a></li><li><a href="http://www.avdancedu.com/67189745">彻底理解SDL纹理</a></li><li><a href="http://www.avdancedu.com/a6aca2fe">SDL孙悟空与多线程</a></li><li><a href="http://www.avdancedu.com/f94132a0">PCM音频播放器的实现</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/56ef4bcb&quot;&gt;SDL 入门&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/287ad9ab&quot;&gt;SDL窗口渲染&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/24ee78a8&quot;&gt;SDL基本图形绘制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/a0ec02a7&quot;&gt;SDL事件处事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/67189745&quot;&gt;彻底理解SDL纹理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/a6aca2fe&quot;&gt;SDL孙悟空与多线程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/f94132a0&quot;&gt;PCM音频播放器的实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SDL是 “Simple DirectMedia Layer”的缩写，它是一个开源的项目。其主要用于游戏开发中的多媒体处理，如视频渲染，音频播放，鼠标&amp;#x2F;键盘控制等操作。&lt;/p&gt;
&lt;p&gt;并且它是一个跨平台的多媒体库。也就是说它对外接供了一套统一的接口，但在内部，它会根据不同平台调用不同的底层 API库。如在 Linux 系统下，它会使用 opengl 做渲染，而在 Window 下它会调用 D3D API进行渲染。&lt;/p&gt;
&lt;p&gt;我之所以要介绍它，主要是因为我要在开发的多媒体播放器中使用它。&lt;/p&gt;
    
    </summary>
    
    
      <category term="视频渲染" scheme="https://blog.avdancedu.com/categories/%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93/"/>
    
    
      <category term="SDL" scheme="https://blog.avdancedu.com/tags/SDL/"/>
    
      <category term="视频渲染" scheme="https://blog.avdancedu.com/tags/%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>SDL彻底理解纹理</title>
    <link href="https://blog.avdancedu.com/67189745/"/>
    <id>https://blog.avdancedu.com/67189745/</id>
    <published>2022-11-19T06:52:00.000Z</published>
    <updated>2022-11-20T04:31:10.024Z</updated>
    
    <content type="html"><![CDATA[<p>这是SDL系列文章的第五篇，本文将彻底让你理解什么是纹理。并带你深入探讨SDL的几个重要概念SDL_Window、SDL_Render、SDL_Surface 与 SDL_Texture。在文章的最后向你展示SDL如何通过SDL_Texture进行渲染。</p><p>对于前面系列文章感兴趣的同学可以通过下面的链接查看：</p><ul><li><a href="http://www.avdancedu.com/56ef4bcb">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8">SDL基本图形绘制</a></li><li><a href="http://www.avdancedu.com/a0ec02a7">SDL事件处事</a></li><li><a href="http://www.avdancedu.com/67189745">彻底理解SDL纹理</a></li><li><a href="http://www.avdancedu.com/a6aca2fe">SDL孙悟空与多线程</a></li><li><a href="http://www.avdancedu.com/f94132a0">PCM音频播放器的实现</a></li></ul><span id="more"></span><h2 id="SDL-Surface-vs-SDL-Texture"><a href="#SDL-Surface-vs-SDL-Texture" class="headerlink" title="SDL_Surface vs SDL_Texture"></a>SDL_Surface vs SDL_Texture</h2><p>在SDL系列文章的第二篇里，我详细的介绍了SDL 渲染的工作原理。即在SDL_Render对象中有一个视频缓冲区，该缓冲区我们称之为SDL_Surface，它是按照像素存放图像的。我们一般把真彩色的像素称为RGB24数据。也就是说，每一个像素由24位组成，每8位代表一种颜色，像素的最终颜色是由RGB三种颜色混合而成的。</p><p>SDL_Texture 与SDL_Surface相似，也是一种缓冲区。只不过它存放的不是真正的像素数据，而是存放的图像的描述信息。当渲染纹理时，SDL以这些描述信息为数据，底层通过OpenGL、D3D 或 Metal操作GPU，最终绘制出与SDL_Surface一样的图形，且效率更高（因为它是GPU硬件计算的）。</p><p>看了以上的介绍，是不是对纹理有了一个清楚的认识了？</p><p>介绍完 SDL_Surface 和 SDL_Texture后，我们再看下SDL_Window 与 SDL_Render。</p><h2 id="SDL-Window-与-SDL-Render"><a href="#SDL-Window-与-SDL-Render" class="headerlink" title="SDL_Window 与 SDL_Render"></a>SDL_Window 与 SDL_Render</h2><p>SDL_Window代表的是窗口的逻辑概念，它是存放在主内存中的一个对象。所以当我们调用SDL API 创建窗口后，它并不会被显示出来。</p><p>SDL_Render 是渲染器，它也是主存中的一个对象。对Render操作时实际上分为两个阶段：</p><p>一、渲染阶段。在该阶段，用户可以画各种图形渲染到SDL_Surface或SDL_Texture 中;</p><p>二、显示阶段。参SDL_Texture为数据，通过OpenGL操作GPU，最终将 SDL_Surfce 或SDL_Texture中的数据输出到显示器上。</p><p>通过上面的介绍，我们就将 SDL_Window、SDL_Render、SDL_Surface与 SDL_Texture之间的关系梳理清楚了，下面我们来看一下如何使用 SDL_Texture。</p><h2 id="使用SDL-Texture"><a href="#使用SDL-Texture" class="headerlink" title="使用SDL_Texture"></a>使用SDL_Texture</h2><p>SDL提供了非常好用的操作SDL_Texture的方法，下面我们来重点介绍一下使用SDL_Texute的基本步骤。</p><ul><li><p>创建一个 SDL_Texture。</p></li><li><p>渲染 Texture</p></li><li><p>Destory Texture</p></li></ul><h2 id="API详细介绍"><a href="#API详细介绍" class="headerlink" title="API详细介绍"></a>API详细介绍</h2><ul><li><p>创建 SDL_Texture</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SDL_Texture* SDL_CreateTexture(SDL_Renderer* renderer,</span><br><span class="line">                             Uint32        format,</span><br><span class="line">                             int           access,</span><br><span class="line">                             int           w,</span><br><span class="line">                             int           h)</span><br></pre></td></tr></table></figure><ul><li>format: 指明像素格式，可以是YUV，也可以是RGB</li><li>access: 指明Texture的类型。可以是 Stream(视频)，也可以是Target一般的类型。</li></ul></li><li><p>渲染</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int SDL_RenderCopy(SDL_Renderer*   renderer,</span><br><span class="line">                 SDL_Texture*    texture,</span><br><span class="line">                 const SDL_Rect* srcrect,</span><br><span class="line">                 const SDL_Rect* dstrect)</span><br></pre></td></tr></table></figure><ul><li>srcrect: 指定 Texture 中要渲染的一部分。如果将 Texture全部输出，可以设置它为 NULL。</li><li>dstrect: 指定输出的空间大小。</li></ul></li><li><p>销毁Texture</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void SDL_DestroyTexture(SDL_Texture* texture)</span><br></pre></td></tr></table></figure></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>下面这个例子非常简单，我这里就不做特别的说明了。对这个程序看不懂的同学可以看我之前的几篇 SDL 的相关文章。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;SDL.h&quot;</span><br><span class="line"></span><br><span class="line">/* Moving Rectangle */</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">        SDL_Window *window;</span><br><span class="line">        SDL_Renderer *renderer;</span><br><span class="line">        SDL_Texture *texture;</span><br><span class="line">        SDL_Event event;</span><br><span class="line">        SDL_Rect r;</span><br><span class="line"></span><br><span class="line">        if (SDL_Init(SDL_INIT_VIDEO) &lt; 0) &#123;</span><br><span class="line">                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, &quot;Couldn&#x27;t initialize SDL: %s&quot;, SDL_GetError());</span><br><span class="line">                return 3;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        window = SDL_CreateWindow(&quot;SDL_CreateTexture&quot;,</span><br><span class="line">                        SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                        SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                        1024, 768,</span><br><span class="line">                        SDL_WINDOW_RESIZABLE);</span><br><span class="line"></span><br><span class="line">        r.w = 100;</span><br><span class="line">        r.h = 50;</span><br><span class="line"></span><br><span class="line">        renderer = SDL_CreateRenderer(window, -1, 0);</span><br><span class="line"></span><br><span class="line">        texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_TARGET, 1024, 768);</span><br><span class="line"></span><br><span class="line">        while (1) &#123;</span><br><span class="line">                SDL_PollEvent(&amp;event);</span><br><span class="line">                if(event.type == SDL_QUIT)</span><br><span class="line">                        break;</span><br><span class="line">                r.x=rand()%500;</span><br><span class="line">                r.y=rand()%500;</span><br><span class="line"></span><br><span class="line">                SDL_SetRenderTarget(renderer, texture);</span><br><span class="line">                SDL_SetRenderDrawColor(renderer, 0x00, 0x00, 0x00, 0x00);</span><br><span class="line">                SDL_RenderClear(renderer);</span><br><span class="line">                SDL_RenderDrawRect(renderer,&amp;r);</span><br><span class="line">                SDL_SetRenderDrawColor(renderer, 0xFF, 0x00, 0x00, 0x00);</span><br><span class="line">                SDL_RenderFillRect(renderer, &amp;r);</span><br><span class="line">                SDL_SetRenderTarget(renderer, NULL);</span><br><span class="line">                SDL_RenderCopy(renderer, texture, NULL, NULL);</span><br><span class="line">                SDL_RenderPresent(renderer);</span><br><span class="line">        &#125;</span><br><span class="line">        SDL_DestroyRenderer(renderer);</span><br><span class="line">        SDL_Quit();</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文重点介绍了 SDL_Window、SDL_Render、SDL_Surface以及SDL_Texture之间的关系。搞清楚它们之前的关系对于理解 SDL 渲染起着至关重要的作用。</p><p>大家一定要仔细的理解文章中所讲的内容，在我后序的文章中，尤其是后面介绍 播放器 相关内容时，都要用到现在所讲的这些内容。</p><p>希望本文能对你有所帮助，谢谢！</p><h2 id="隆重推荐"><a href="#隆重推荐" class="headerlink" title="隆重推荐"></a>隆重推荐</h2><ul><li><a href="http://www.avdancedu.com/56ef4bcb">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8">SDL基本图形绘制</a></li><li><a href="http://www.avdancedu.com/a0ec02a7">SDL事件处事</a></li><li><a href="http://www.avdancedu.com/67189745">彻底理解SDL纹理</a></li><li><a href="http://www.avdancedu.com/a6aca2fe">SDL孙悟空与多线程</a></li><li><a href="http://www.avdancedu.com/f94132a0">PCM音频播放器的实现</a></li><li><a href="https://coding.imooc.com/class/279.html">ffmpeg精讲</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是SDL系列文章的第五篇，本文将彻底让你理解什么是纹理。并带你深入探讨SDL的几个重要概念SDL_Window、SDL_Render、SDL_Surface 与 SDL_Texture。在文章的最后向你展示SDL如何通过SDL_Texture进行渲染。&lt;/p&gt;
&lt;p&gt;对于前面系列文章感兴趣的同学可以通过下面的链接查看：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/56ef4bcb&quot;&gt;SDL 入门&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/287ad9ab&quot;&gt;SDL窗口渲染&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/24ee78a8&quot;&gt;SDL基本图形绘制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/a0ec02a7&quot;&gt;SDL事件处事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/67189745&quot;&gt;彻底理解SDL纹理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/a6aca2fe&quot;&gt;SDL孙悟空与多线程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/f94132a0&quot;&gt;PCM音频播放器的实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="视频渲染" scheme="https://blog.avdancedu.com/categories/%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93/"/>
    
    
      <category term="SDL" scheme="https://blog.avdancedu.com/tags/SDL/"/>
    
  </entry>
  
  <entry>
    <title>SDL绘制基本图型</title>
    <link href="https://blog.avdancedu.com/24ee78a8/"/>
    <id>https://blog.avdancedu.com/24ee78a8/</id>
    <published>2022-11-19T06:52:00.000Z</published>
    <updated>2022-11-20T04:31:32.523Z</updated>
    
    <content type="html"><![CDATA[<p>之前的SDL的两篇文章我向大家介绍了如何编译使用 SDL，以及如何才能让窗口显示出来。想了解相关内容的同学可以点击下面的链接查看相关内容。</p><ul><li><a href="http://www.avdancedu.com/56ef4bcb">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8">SDL基本图形绘制</a></li><li><a href="http://www.avdancedu.com/a0ec02a7">SDL事件处事</a></li><li><a href="http://www.avdancedu.com/67189745">彻底理解SDL纹理</a></li><li><a href="http://www.avdancedu.com/a6aca2fe">SDL孙悟空与多线程</a></li><li><a href="http://www.avdancedu.com/f94132a0">PCM音频播放器的实现</a></li></ul><p>本文将向大家介绍一下，如何通过 SDL 绘制一些基本图形，如 点、线、矩形。了解了这些基本图形后，你就可以按照搭积木的方式，构造出其它更复杂的图形了。</p><span id="more"></span><h2 id="有哪些基本图形可以绘制"><a href="#有哪些基本图形可以绘制" class="headerlink" title="有哪些基本图形可以绘制"></a>有哪些基本图形可以绘制</h2><p>SDL中绘制基本图形的 API并不多，主要是 点、线、矩形。其它图形都可以通过 点、线、矩形组合出来。</p><ul><li>设置颜色：在绘制图形前，要设置一下画笔的色彩。这里需要注意的是，如果画笔与背景色相同了，那在窗口中是显示不出来图形的。</li><li>画点。</li><li>画线。</li><li>画矩形。</li><li>填充矩形。</li></ul><p>下面来详细介绍一下这几个API。</p><h2 id="API详细介绍"><a href="#API详细介绍" class="headerlink" title="API详细介绍"></a>API详细介绍</h2><ul><li><p>设置颜色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int SDL_SetRenderDrawColor(SDL_Renderer* renderer,</span><br><span class="line">                         Uint8         r,</span><br><span class="line">                         Uint8         g,</span><br><span class="line">                         Uint8         b,</span><br><span class="line">                         Uint8         a)</span><br></pre></td></tr></table></figure><p>该函数中的参数 a 指明了颜色的透明度。</p><p><strong>但该值我设置了一下没有起作用，应该需要和BlendMode一起才能起作用。这块有谁清楚可以指定一下</strong></p></li><li><p>画点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int SDL_RenderDrawPoint(SDL_Renderer* renderer,</span><br><span class="line">                      int           x, </span><br><span class="line">                      int           y)</span><br></pre></td></tr></table></figure></li><li><p>画多个点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int SDL_RenderDrawPoints(SDL_Renderer*    renderer,</span><br><span class="line">                       const SDL_Point* points,</span><br><span class="line">                       int              count)</span><br></pre></td></tr></table></figure><ul><li>points: 点数组。</li><li>count: 点的个数。</li></ul></li><li><p>画线</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int SDL_RenderDrawLine(SDL_Renderer* renderer,</span><br><span class="line">                     int           x1,</span><br><span class="line">                     int           y1,</span><br><span class="line">                     int           x2,</span><br><span class="line">                     int           y2)</span><br></pre></td></tr></table></figure></li><li><p>画多条线</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int SDL_RenderDrawLines(SDL_Renderer*    renderer,</span><br><span class="line">                      const SDL_Point* points,</span><br><span class="line">                      int              count)</span><br></pre></td></tr></table></figure><p>该函数会将使用两个相邻的点之间进行连线。最终画出你想画的图形。如画三角形，多边形或圆形。</p></li><li><p>绘制矩形</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int SDL_RenderDrawRect(SDL_Renderer*   renderer,</span><br><span class="line">                     const SDL_Rect* rect)</span><br></pre></td></tr></table></figure><p>rect: 是要绘制的一块区域。它包括，x,y,w,h这个元素。</p></li><li><p>填充矩形</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int SDL_RenderFillRect(SDL_Renderer*   renderer,</span><br><span class="line">                     const SDL_Rect* rect)</span><br></pre></td></tr></table></figure><p>使用指定的色彩填充一块矩形。</p></li><li><p>填充多块矩形</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int SDL_RenderDrawRects(SDL_Renderer*   renderer,</span><br><span class="line">                      const SDL_Rect* rects,</span><br><span class="line">                      int             count)</span><br></pre></td></tr></table></figure><ul><li>rects: 指定的矩形数组。</li><li>count: 指定矩形个数。</li></ul></li></ul><h2 id="我们来看看代码"><a href="#我们来看看代码" class="headerlink" title="我们来看看代码"></a>我们来看看代码</h2><p>下面的代码非常之简单，我们在上一篇文章代码的基础上增加了几个画线、画矩形的API就可以了。</p><p>这里唯一值得注意的地方是下面这个函数。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDL_SetRenderDrawColor(renderer, 0, 0, 255, 255);</span><br></pre></td></tr></table></figure><p>该函数是设置画笔颜色，也就是说我们想画出什么颜色的图形，只要用这个函数设置一下，再使用画点、画线的API就可以画出对应颜色的图形了。</p><p>原码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;SDL.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define POINTS_COUNT 4</span><br><span class="line"></span><br><span class="line">static SDL_Point points[POINTS_COUNT] = &#123;</span><br><span class="line">    &#123;320, 200&#125;,</span><br><span class="line">    &#123;300, 240&#125;,</span><br><span class="line">    &#123;340, 240&#125;,</span><br><span class="line">    &#123;320, 200&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static SDL_Rect bigrect = &#123;0,0,540, 380&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    int flag = 1;</span><br><span class="line"></span><br><span class="line">    SDL_Window *window;                    // Declare a pointer</span><br><span class="line">    SDL_Renderer *renderer;</span><br><span class="line"></span><br><span class="line">    SDL_Init(SDL_INIT_VIDEO);              // Initialize SDL2</span><br><span class="line"></span><br><span class="line">    // Create an application window with the following settings:</span><br><span class="line">    window = SDL_CreateWindow(</span><br><span class="line">        &quot;An SDL2 window&quot;,                  // window title</span><br><span class="line">        SDL_WINDOWPOS_UNDEFINED,           // initial x position</span><br><span class="line">        SDL_WINDOWPOS_UNDEFINED,           // initial y position</span><br><span class="line">        640,                               // width, in pixels</span><br><span class="line">        480,                               // height, in pixels</span><br><span class="line">        SDL_WINDOW_SHOWN | SDL_WINDOW_BORDERLESS// flags - see below</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // Check that the window was successfully created</span><br><span class="line">    if (window == NULL) &#123;</span><br><span class="line">        // In the case that the window could not be made...</span><br><span class="line">        printf(&quot;Could not create window: %s\n&quot;, SDL_GetError());</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /* We must call SDL_CreateRenderer in order for draw calls to affect this window. */</span><br><span class="line">    renderer = SDL_CreateRenderer(window, -1, 0);</span><br><span class="line"></span><br><span class="line">    /* Select the color for drawing. It is set to red here. */</span><br><span class="line">    SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);</span><br><span class="line"></span><br><span class="line">    /* Clear the entire screen to our selected color. */</span><br><span class="line">    SDL_RenderClear(renderer);</span><br><span class="line"></span><br><span class="line">    SDL_SetRenderDrawColor(renderer, 255, 255, 255, SDL_ALPHA_OPAQUE);</span><br><span class="line">    //SDL_RenderDrawLine(renderer, 100, 20, 500, 400);</span><br><span class="line">    SDL_RenderDrawLines(renderer, points, POINTS_COUNT);</span><br><span class="line"></span><br><span class="line">    SDL_Rect rect = &#123;200, 300, 100, 100&#125;;</span><br><span class="line">    SDL_RenderDrawRect(renderer, &amp;rect);</span><br><span class="line"></span><br><span class="line">    SDL_SetRenderDrawColor(renderer, 0, 255, 255, 255);</span><br><span class="line">    SDL_RenderFillRect(renderer, &amp;rect);</span><br><span class="line"></span><br><span class="line">    SDL_SetRenderDrawColor(renderer, 0, 0, 255, 255);</span><br><span class="line">    SDL_RenderFillRect(renderer, &amp;bigrect);</span><br><span class="line"></span><br><span class="line">    /* Up until now everything was drawn behind the scenes.</span><br><span class="line">       This will show the new, red contents of the window. */</span><br><span class="line">    SDL_RenderPresent(renderer);</span><br><span class="line"></span><br><span class="line">    // The window is open: could enter program loop here (see SDL_PollEvent())</span><br><span class="line"></span><br><span class="line">    SDL_Delay(3000);  // Pause execution for 3000 milliseconds, for example</span><br><span class="line"></span><br><span class="line">    //destory renderer</span><br><span class="line">    if (renderer) &#123;</span><br><span class="line">        SDL_DestroyRenderer(renderer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Close and destroy the window</span><br><span class="line">    SDL_DestroyWindow(window);</span><br><span class="line"></span><br><span class="line">    // Clean up</span><br><span class="line">    SDL_Quit();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文重点介绍了 SDL 绘制经常使用的几个基本图形API，通过这些API你可以构造出更加复杂的图形。</p><p>希望本文能对你所有帮助，谢谢！</p><h2 id="推荐阅读："><a href="#推荐阅读：" class="headerlink" title="推荐阅读："></a>推荐阅读：</h2><ul><li><a href="http://www.avdancedu.com/56ef4bcb">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8">SDL基本图形绘制</a></li><li><a href="http://www.avdancedu.com/a0ec02a7">SDL事件处事</a></li><li><a href="http://www.avdancedu.com/67189745">彻底理解SDL纹理</a></li><li><a href="http://www.avdancedu.com/a6aca2fe">SDL孙悟空与多线程</a></li><li><a href="http://www.avdancedu.com/f94132a0">PCM音频播放器的实现</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前的SDL的两篇文章我向大家介绍了如何编译使用 SDL，以及如何才能让窗口显示出来。想了解相关内容的同学可以点击下面的链接查看相关内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/56ef4bcb&quot;&gt;SDL 入门&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/287ad9ab&quot;&gt;SDL窗口渲染&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/24ee78a8&quot;&gt;SDL基本图形绘制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/a0ec02a7&quot;&gt;SDL事件处事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/67189745&quot;&gt;彻底理解SDL纹理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/a6aca2fe&quot;&gt;SDL孙悟空与多线程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/f94132a0&quot;&gt;PCM音频播放器的实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文将向大家介绍一下，如何通过 SDL 绘制一些基本图形，如 点、线、矩形。了解了这些基本图形后，你就可以按照搭积木的方式，构造出其它更复杂的图形了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="视频渲染" scheme="https://blog.avdancedu.com/categories/%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93/"/>
    
    
      <category term="SDL" scheme="https://blog.avdancedu.com/tags/SDL/"/>
    
  </entry>
  
  <entry>
    <title>SDL窗口渲染</title>
    <link href="https://blog.avdancedu.com/287ad9ab/"/>
    <id>https://blog.avdancedu.com/287ad9ab/</id>
    <published>2022-11-19T06:52:00.000Z</published>
    <updated>2022-11-20T04:30:42.785Z</updated>
    
    <content type="html"><![CDATA[<p>推荐阅读：</p><ul><li><a href="http://www.avdancedu.com/56ef4bcb">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8">SDL基本图形绘制</a></li><li><a href="http://www.avdancedu.com/a0ec02a7">SDL事件处事</a></li><li><a href="http://www.avdancedu.com/67189745">彻底理解SDL纹理</a></li><li><a href="http://www.avdancedu.com/a6aca2fe">SDL孙悟空与多线程</a></li><li><a href="http://www.avdancedu.com/f94132a0">PCM音频播放器的实现</a></li></ul><p>上一篇文章中我们对SDL作了简单的介绍，重点介绍了如何编译SDL以及如何使用它。在文章的最后我们留下了一个疑问，即虽然我们创建了窗口，但窗口却并没有真正显示出来。</p><p>今天我们就来看一看，如何才能让创建的窗口真正的显示出来。</p><span id="more"></span><h2 id="渲染的基本流程"><a href="#渲染的基本流程" class="headerlink" title="渲染的基本流程"></a>渲染的基本流程</h2><p>为什么我们上一课中创建了窗口，但它却并没有显示出来呢？其原因是，我们创建的窗口只是逻辑上的窗口，要想让窗口显示出来，我们需要对窗口进行效果渲染，也就是要通过绘制像素的方法，将窗口中的像素全部点亮。</p><p>那么如何对窗口进行渲染呢？SDL为我们提供了方便是的API。不过在使用SDL对窗口进行渲染之前，我们要先了解渲染的基本原理。</p><p>其基本原理是，首先创建一个window窗口，它是我们要渲染的目标。然后，要有一个渲染上下文，该上下文中一方面存放着要渲染的目标，也就是windows窗口；另一方面是存放着一个缓冲区，该缓冲区用于存放渲染的内容。</p><p>渲染的内容可以是点、线、各种图形以及图片，视频的各种组合。这些组合后的内容首先被存放到缓冲区中，最终SDL将缓冲区中的内容渲染到窗口中。</p><p>所以渲染的基本流程如下：</p><ul><li>创建窗口</li><li>创建渲染器</li><li>清空缓冲区</li><li>绘制要显示的内容</li><li>最终将缓冲区内容渲染到window窗口上。</li></ul><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><ul><li><p>创建渲染上下文</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDL_Renderer* SDL_CreateRenderer(SDL_Window* window,</span><br><span class="line">                               int         index,</span><br><span class="line">                               Uint32      flags)</span><br></pre></td></tr></table></figure><p>window: 指明在哪个窗口里进行渲染<br>index: 指定渲染驱动的索引号。一般指定为 -1.<br>flags:</p><table><thead><tr><th>flags</th><th>说明</th></tr></thead><tbody><tr><td>SDL_RENDERER_SOFTWARE</td><td>the renderer is a software fallback</td></tr><tr><td>SDL_RENDERER_ACCELERATED</td><td>the renderer uses hardware acceleration</td></tr><tr><td>SDL_RENDERER_PRESENTVSYNC</td><td>present is synchronized with the refresh rate</td></tr><tr><td>SDL_RENDERER_TARGETTEXTURE</td><td>the renderer supports rendering to texture</td></tr></tbody></table></li><li><p>消毁渲染上下文</p><p>释放渲染上下文相关的资源。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void SDL_DestroyRenderer(SDL_Renderer* renderer)</span><br></pre></td></tr></table></figure></li><li><p>清空渲染目标</p><p>该函数的作用是用指定的颜色清空缓冲区。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int SDL_RenderClear(SDL_Renderer* renderer)</span><br></pre></td></tr></table></figure><p>renderer: 上面创建的渲染器上下文。</p></li><li><p>展示要渲染的内容</p><p>将缓冲区中的内容输出到目标上，也就是 windows 窗口上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void SDL_RenderPresent(SDL_Renderer* renderer)</span><br></pre></td></tr></table></figure><p>renderer: 上面创建的渲染器上下文</p></li></ul><h2 id="完整例子"><a href="#完整例子" class="headerlink" title="完整例子"></a>完整例子</h2><p>我在第一课的代码上，添加了上面几个函数之后，大家可以看到一个全红色的窗口可以显示在我们的面前了。</p><p>当然我们还可以在上面画一些图形，比如使用 SDL_RenderDrawLines() 函数在窗口中画一条直线。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;SDL.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    int flag = 1;</span><br><span class="line"></span><br><span class="line">    SDL_Window *window;                    // Declare a pointer</span><br><span class="line">    SDL_Renderer *renderer;</span><br><span class="line"></span><br><span class="line">    SDL_Init(SDL_INIT_VIDEO);              // Initialize SDL2</span><br><span class="line"></span><br><span class="line">    // Create an application window with the following settings:</span><br><span class="line">    window = SDL_CreateWindow(</span><br><span class="line">        &quot;An SDL2 window&quot;,                  // window title</span><br><span class="line">        SDL_WINDOWPOS_UNDEFINED,           // initial x position</span><br><span class="line">        SDL_WINDOWPOS_UNDEFINED,           // initial y position</span><br><span class="line">        640,                               // width, in pixels</span><br><span class="line">        480,                               // height, in pixels</span><br><span class="line">        SDL_WINDOW_SHOWN | SDL_WINDOW_BORDERLESS// flags - see below</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // Check that the window was successfully created</span><br><span class="line">    if (window == NULL) &#123;</span><br><span class="line">        // In the case that the window could not be made...</span><br><span class="line">        printf(&quot;Could not create window: %s\n&quot;, SDL_GetError());</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* We must call SDL_CreateRenderer in order for draw calls to affect this window. */</span><br><span class="line">    renderer = SDL_CreateRenderer(window, -1, 0);</span><br><span class="line"></span><br><span class="line">    /* Select the color for drawing. It is set to red here. */</span><br><span class="line">    SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);</span><br><span class="line"></span><br><span class="line">    /* Clear the entire screen to our selected color. */</span><br><span class="line">    SDL_RenderClear(renderer);</span><br><span class="line"></span><br><span class="line">    /* Up until now everything was drawn behind the scenes.</span><br><span class="line">       This will show the new, red contents of the window. */</span><br><span class="line">    SDL_RenderPresent(renderer);</span><br><span class="line"></span><br><span class="line">    // The window is open: could enter program loop here (see SDL_PollEvent())</span><br><span class="line"></span><br><span class="line">    SDL_Delay(3000);  // Pause execution for 3000 milliseconds, for example</span><br><span class="line"></span><br><span class="line">    //destory renderer</span><br><span class="line">    if (renderer) &#123;</span><br><span class="line">        SDL_DestroyRenderer(renderer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Close and destroy the window</span><br><span class="line">    SDL_DestroyWindow(window);</span><br><span class="line"></span><br><span class="line">    // Clean up</span><br><span class="line">    SDL_Quit();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我向大家介绍了如何将创建的窗口展示出来，并重点介绍了窗口渲染的基本原理以及使用的 SDL API。</p><p>后面的文章我将向大家重点介绍如何在窗口绘制一些常用图形。</p><p>谢谢！</p><h2 id="推荐阅读："><a href="#推荐阅读：" class="headerlink" title="推荐阅读："></a>推荐阅读：</h2><ul><li><a href="http://www.avdancedu.com/56ef4bcb">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8">SDL基本图形绘制</a></li><li><a href="http://www.avdancedu.com/a0ec02a7">SDL事件处事</a></li><li><a href="http://www.avdancedu.com/67189745">彻底理解SDL纹理</a></li><li><a href="http://www.avdancedu.com/a6aca2fe">SDL孙悟空与多线程</a></li><li><a href="http://www.avdancedu.com/f94132a0">PCM音频播放器的实现</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/56ef4bcb&quot;&gt;SDL 入门&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/287ad9ab&quot;&gt;SDL窗口渲染&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/24ee78a8&quot;&gt;SDL基本图形绘制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/a0ec02a7&quot;&gt;SDL事件处事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/67189745&quot;&gt;彻底理解SDL纹理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/a6aca2fe&quot;&gt;SDL孙悟空与多线程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/f94132a0&quot;&gt;PCM音频播放器的实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上一篇文章中我们对SDL作了简单的介绍，重点介绍了如何编译SDL以及如何使用它。在文章的最后我们留下了一个疑问，即虽然我们创建了窗口，但窗口却并没有真正显示出来。&lt;/p&gt;
&lt;p&gt;今天我们就来看一看，如何才能让创建的窗口真正的显示出来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="视频渲染" scheme="https://blog.avdancedu.com/categories/%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93/"/>
    
    
      <category term="SDL" scheme="https://blog.avdancedu.com/tags/SDL/"/>
    
  </entry>
  
  <entry>
    <title>SDL音频播放器的实现</title>
    <link href="https://blog.avdancedu.com/f94132a0/"/>
    <id>https://blog.avdancedu.com/f94132a0/</id>
    <published>2022-11-19T06:52:00.000Z</published>
    <updated>2022-11-20T04:31:53.207Z</updated>
    
    <content type="html"><![CDATA[<p>今天向大家介绍一下如何通过 SDL 实现一个PCM音频播放器。这是一个最简单的播放器，它不涉及到音频的解复用，解码等工作。我们只需要将音频原始数据喂给 SDL 音频接口就可以听到悦耳的声音了。在下面的列子中我将向你演示，使用 SDL 做这样一个播放器是何等的简单。</p><p>当然这个看似简单的播放器其实是由许多的理论基础在底层支持着的。如果在这方面没有什么基础的同学可以通过下面的链接去自行学习。</p><ul><li><a href="http://www.avdancedu.com/56ef4bcb">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8">SDL基本图形绘制</a></li><li><a href="http://www.avdancedu.com/a0ec02a7">SDL事件处事</a></li><li><a href="http://www.avdancedu.com/67189745">彻底理解SDL纹理</a></li><li><a href="http://www.avdancedu.com/a6aca2fe">SDL孙悟空与多线程</a></li><li><a href="http://www.avdancedu.com/f94132a0">PCM音频播放器的实现</a></li></ul><span id="more"></span><h2 id="播放音频的基本原则"><a href="#播放音频的基本原则" class="headerlink" title="播放音频的基本原则"></a>播放音频的基本原则</h2><p>如果我们要播放一段声音，想当然的认为直接将播放的声音发送给声卡，这样扬声器就会将声音播放出来。只要我们不断的送数据，声音就会不停的输出。</p><p>事实上真的是这样吗？<strong>当 然 不 是!!!</strong></p><p>实际上，所有的音频播放都遵守着一个原则，就是当声卡将要播放的声音输出到扬声器时，它首先会通过回调函数，向你要它一部分声频数据，然后拿着这部分音频数据去播放。等播放完了，它会再向你要下一部分。</p><p>至于要的数据的多少，什么时候向你要，这些都是由声卡决定的。对于我们上层应用来说，这些都是由底层 API 决定的。</p><p>为什么会出现这种情况呢？为什么播放音频与我们一般的逻辑相反呢？这是因为声卡会严格按照音频的播放时间进行播放，不会多一秒，也不会少一秒。正因为它能准确的计算出时间来，而应用层是不知道这个时间的，所以我们必须按照声卡的要求给它喂数据，而不能依据自己的性子来。</p><p>那么有人会问，为什么声卡可以精准的计算出播放时间来呢？这是因为在播放之前我们给它设置了采样率、通道数、采样大小等参数，通过这些参数它就可以计算出时间来。</p><p>我们来做个计算，假设采样率是 48000, 双通道，采样大小是 16bit，那么一秒种的数据是多少呢？ 48000*2*16&#x3D;1536000. 反过来，如果我们有一段 8M 的数据，那么声卡就知道它能播放 5秒多的声音。</p><p>上面的一大段文字描述，实际上只是想说明一个道理，就是要播放的声音数据，是声卡主动要的，不能由上层直接设置。这是通过回调函数来实现的。后面会有具体的例子。</p><h2 id="SDL如何处理音频"><a href="#SDL如何处理音频" class="headerlink" title="SDL如何处理音频"></a>SDL如何处理音频</h2><p>SDL是一个处理多媒体的开源库，我们来看看它是如何播放音频的，具体的操作步骤是啥？</p><ul><li>打开音频设备</li><li>设置音频参数</li><li>播放音频</li><li>向声卡喂数据</li><li>关闭音频设置</li></ul><h2 id="详细API介绍"><a href="#详细API介绍" class="headerlink" title="详细API介绍"></a>详细API介绍</h2><ul><li><p>打开音频设备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int SDL_OpenAudio(SDL_AudioSpec* desired,</span><br><span class="line">                SDL_AudioSpec* obtained)</span><br></pre></td></tr></table></figure><ul><li><p>desired: 设置音频参数。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>freq</td><td>每秒采频率</td></tr><tr><td>SDL_AudioFormat</td><td>音频数据存储格式</td></tr><tr><td>channels</td><td>通道数</td></tr><tr><td>silence</td><td>静音值</td></tr><tr><td>samples</td><td>采样个数</td></tr><tr><td>size</td><td>音频缓冲区大小</td></tr><tr><td>SDL_AudioCallback</td><td>回调函数</td></tr><tr><td>userdata</td><td>回调函数参数指针</td></tr></tbody></table></li><li><p>obtained: 返回参数。</p></li></ul></li><li><p>关闭音频设备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void SDL_CloseAudio(void)</span><br></pre></td></tr></table></figure></li><li><p>播放与暂停</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void SDL_PauseAudio(int pause_on)</span><br></pre></td></tr></table></figure><p>pause_on: 0, 暂停播放；1, 播放；</p></li><li><p>喂数据</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void SDL_MixAudio(Uint8*    dst,</span><br><span class="line">               const Uint8* src,</span><br><span class="line">               Uint32       len,</span><br><span class="line">               int          volume)</span><br></pre></td></tr></table></figure><ul><li>dst: 目的缓冲区</li><li>src: 源缓冲区</li><li>len: 音频数据长度</li><li>volume: 音量大小，0-128 之间的数。SDL_MIX_MAXVOLUME代表最大音量。</li></ul></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>这个例子主要为大家展示了一下如何使用 SDL 的音频 API 来播放声音。其基本流程是，从 pcm 文件一块一块的读数据。然后通过 read_audio_data 这个回调函数给声卡喂数据。如果一次没用完，SDL会再次调用回调函数读数据。</p><p>如果audio_buf中的数据用完了，则再次从文件中读一块数据，直到读到文件尾。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;SDL.h&gt;</span><br><span class="line"></span><br><span class="line">#define BLOCK_SIZE 4096000</span><br><span class="line"></span><br><span class="line">static Uint8 *audio_buf = NULL;</span><br><span class="line">static Uint8 *audio_pos = NULL;</span><br><span class="line">static size_t buffer_len = 0;</span><br><span class="line"></span><br><span class="line">//callback function for audio devcie</span><br><span class="line">void read_audio_data(void *udata, Uint8 *stream, int len)&#123;</span><br><span class="line"></span><br><span class="line">    if(buffer_len == 0)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDL_memset(stream, 0, len);</span><br><span class="line"></span><br><span class="line">    len = (len &lt; buffer_len) ? len : buffer_len;</span><br><span class="line">    SDL_MixAudio(stream, audio_pos, len, SDL_MIX_MAXVOLUME);</span><br><span class="line"></span><br><span class="line">    audio_pos += len;</span><br><span class="line">    buffer_len -= len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int ret = -1;</span><br><span class="line"></span><br><span class="line">    FILE *audio_fd = NULL;</span><br><span class="line"></span><br><span class="line">    SDL_AudioSpec spec;</span><br><span class="line"></span><br><span class="line">    char *path = &quot;./test.pcm&quot;;</span><br><span class="line"></span><br><span class="line">    //SDL initialize</span><br><span class="line">    if(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER))&#123;</span><br><span class="line">        fprintf(stderr, &quot;Could not initialize SDL - %s\n&quot;, SDL_GetError());</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //open pcm file</span><br><span class="line">    audio_fd = fopen(path, &quot;r&quot;);</span><br><span class="line">    if(!audio_fd)&#123;</span><br><span class="line">        fprintf(stderr, &quot;Failed to open pcm file!\n&quot;);</span><br><span class="line">        goto __FAIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//SDL_AudioSpec</span><br><span class="line">    spec.freq = 44100;;</span><br><span class="line">    spec.format = AUDIO_S16SYS;</span><br><span class="line">    spec.channels = 2;</span><br><span class="line">    spec.silence = 0;</span><br><span class="line">    spec.samples = 1024;;</span><br><span class="line">    spec.callback = read_audio_data;;</span><br><span class="line">    spec.userdata = NULL;</span><br><span class="line"></span><br><span class="line">    //open audio devcie</span><br><span class="line">    if(SDL_OpenAudio(&amp;spec, NULL))&#123;</span><br><span class="line">        fprintf(stderr, &quot;Failed to open audio device, %s\n&quot;, SDL_GetError());</span><br><span class="line">        goto __FAIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //play audio</span><br><span class="line">    SDL_PauseAudio(0);</span><br><span class="line"></span><br><span class="line">    do&#123;</span><br><span class="line">        //read data from pcm file</span><br><span class="line">        buffer_len = fread(audio_buf, 1, BLOCK_SIZE, audio_fd);</span><br><span class="line">        fprintf(stderr, &quot;block size is %zu\n&quot;, buffer_len);</span><br><span class="line"></span><br><span class="line">        audio_pos = audio_buf;</span><br><span class="line"></span><br><span class="line">        //the main thread wait for a moment</span><br><span class="line">        while(audio_pos &lt; (audio_buf + buffer_len)) &#123;</span><br><span class="line">            SDL_Delay(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;while(buffer_len !=0);</span><br><span class="line"></span><br><span class="line">    //close audio device</span><br><span class="line">    SDL_CloseAudio();</span><br><span class="line"></span><br><span class="line">    ret = 0;</span><br><span class="line"></span><br><span class="line">__FAIL:</span><br><span class="line">    //release some resources</span><br><span class="line">    if(audio_buf)&#123;</span><br><span class="line">        free(audio_buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(audio_fd)&#123;</span><br><span class="line">        fclose(audio_fd);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //quit SDL</span><br><span class="line">    SDL_Quit();</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文向大家讲解了一下如何通过SDL库的音频处理 API 实现一个最简单的 PCM 播放器。通过个例子大家可以了解到，SDL的使用是如此简单。</p><p>当然这个播放器还是有点 Low,不过不要紧，随着后面文章的推出，你会逐渐看到一个完整的播放器是如何被打造出来的。</p><p>希望本文能对你有所帮助，谢谢！</p><h2 id="隆重推荐"><a href="#隆重推荐" class="headerlink" title="隆重推荐"></a>隆重推荐</h2><ul><li><a href="http://www.avdancedu.com/56ef4bcb">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8">SDL基本图形绘制</a></li><li><a href="http://www.avdancedu.com/a0ec02a7">SDL事件处事</a></li><li><a href="http://www.avdancedu.com/67189745">彻底理解SDL纹理</a></li><li><a href="http://www.avdancedu.com/a6aca2fe">SDL孙悟空与多线程</a></li><li><a href="http://www.avdancedu.com/f94132a0">PCM音频播放器的实现</a></li><li><a href="https://coding.imooc.com/class/279.html">ffmpeg精讲</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天向大家介绍一下如何通过 SDL 实现一个PCM音频播放器。这是一个最简单的播放器，它不涉及到音频的解复用，解码等工作。我们只需要将音频原始数据喂给 SDL 音频接口就可以听到悦耳的声音了。在下面的列子中我将向你演示，使用 SDL 做这样一个播放器是何等的简单。&lt;/p&gt;
&lt;p&gt;当然这个看似简单的播放器其实是由许多的理论基础在底层支持着的。如果在这方面没有什么基础的同学可以通过下面的链接去自行学习。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/56ef4bcb&quot;&gt;SDL 入门&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/287ad9ab&quot;&gt;SDL窗口渲染&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/24ee78a8&quot;&gt;SDL基本图形绘制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/a0ec02a7&quot;&gt;SDL事件处事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/67189745&quot;&gt;彻底理解SDL纹理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/a6aca2fe&quot;&gt;SDL孙悟空与多线程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/f94132a0&quot;&gt;PCM音频播放器的实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="视频渲染" scheme="https://blog.avdancedu.com/categories/%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93/"/>
    
    
      <category term="SDL" scheme="https://blog.avdancedu.com/tags/SDL/"/>
    
  </entry>
  
  <entry>
    <title>SDL多线程</title>
    <link href="https://blog.avdancedu.com/a6aca2fe/"/>
    <id>https://blog.avdancedu.com/a6aca2fe/</id>
    <published>2022-11-19T06:52:00.000Z</published>
    <updated>2022-11-20T05:06:29.173Z</updated>
    
    <content type="html"><![CDATA[<p>今天将向大家介绍一下SDL中的多线程的使用。通过下面对SDL 线程与锁相关的API介绍，你会发现，它与 Linux, Windows相关的API几乎是一模一样的。从这里可以推断出，其实SDL对于多线程的处理只是为大家提供了一套统一接口，并没有做其它太多的工作。</p><p>这是我们介绍 SDL 的第六篇文章。有兴趣的同学可以通过下面的链接查看其它几篇文章。</p><ul><li><a href="http://www.avdancedu.com/56ef4bcb">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8">SDL基本图形绘制</a></li><li><a href="http://www.avdancedu.com/a0ec02a7">SDL事件处事</a></li><li><a href="http://www.avdancedu.com/67189745">彻底理解SDL纹理</a></li><li><a href="http://www.avdancedu.com/a6aca2fe">SDL孙悟空与多线程</a></li><li><a href="http://www.avdancedu.com/f94132a0">PCM音频播放器的实现</a></li><li><a href="https://coding.imooc.com/class/279.html">ffmpeg精讲</a></li></ul><span id="more"></span><h2 id="为啥要用多线程？"><a href="#为啥要用多线程？" class="headerlink" title="为啥要用多线程？"></a>为啥要用多线程？</h2><p>我觉得这个小节的标题就是一个废话。不过为了文章的完整性，还是简单的说一说吧。多线程（多进程）是啥意思呢？做个不恰当的比喻，可以把CPU看成是孙悟空，它有一个能耐，从后脑揪几个猴毛就可以变出许多的小猴子。</p><p>多线程（多进程）就是这些小猴子。当干一件比较复杂的事儿时，可以孙悟空一个人干，这样自己比较累。它还有一种选择就是揪几根猴毛，让小猴子们一起帮着干。这样一件复杂的事件，分给许多猴子干，每只猴只干一部分，事情很快就被做完了，这样岂不是比一个人干要强的多？</p><p>当然，有好处也有坏外。猴子多了就需要管理，如果管理不好，就会闹翻天。比如，只有一块肉，该给哪个猴子吃呢？这真是一个另人头痛的问题。</p><p>实际上整个操作系统的演进，就是一部管理学的演进。如何才能让CPU，内存，磁盘I&#x2F;O，各种设备之间高效的工作，一直是操作系统追求的目标。当然，这话有点扯远了。</p><p>今天我们要讲的就是多线程（多进程）之间该如何高效的工作。要想让多线程之间高效工作，就要给它们之间立点规矩，大家都要遵守的规矩。</p><h2 id="线程互斥与同步"><a href="#线程互斥与同步" class="headerlink" title="线程互斥与同步"></a>线程互斥与同步</h2><p>当僧多粥少时，就引入了互斥的概念。再举个我们生活中的例子吧，比如有一大家族住在同一个大屋子里，却只有一个厕所。早上起来大家都想去厕所，这时有谁先抢到了厕所，其它人就只能等他出来后再进入了，这就是<strong>互斥</strong>。</p><p>当仅有一份资源，大家都需要时，这就产生了管理问题。解决的办法就是通过互斥方法来解决。这种情况是在做多线程处理时要尽量避免的；如果资源足够呢？那当然是平均分配，人人有份了。这中情况是多线路程最希望的。</p><p>除了互斥之外，有些情况还需要更精细化的管理，比如说<strong>同步</strong>。例如车间里的流水线，每个人负责一块，每一块都是半成品，第一个人完成之后交给第二个人做下一步，而后面的人又必须依赖于前而人的结果，依次类推，最后一个人才能完成最终的产品。这就是线程间的精细化管理<strong>同步</strong>。</p><p>要想实现互斥和同步，就需要一种机制。在操作系统上提供了锁的概念来达到互斥与同步。</p><h2 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h2><p>在操作系统上有很种锁，有读写锁、自旋锁、可重入锁等。下面我简单的介绍一下它们之间的不同。</p><p>读写锁: 分为读锁与写锁。所谓读锁就是被访问的资源只要你不改变它的值，你就可以访问，但如果你想改变它，那么就需要等所有读它的线程都释放了它们的锁后，才可以进行修改；写锁是同一时刻只能有一个人访问，当资源被加锁后，其它人只能等待。</p><p>自旋锁: 偿试着给访问资源加锁，如果此时被访问资源已经上锁了，那就一直不停的偿试，直到加锁成功为止。由于它会非常消耗CPU资源，所以一般只锁今资源非常短的情况下才能使用它。</p><p>可重入锁: 同一个线程对被访问资源可以一直加锁。但如果被访问资源已经上锁了，那么其它线程则无法对其加锁。</p><p>锁是解决互斥的一种好办法，但同样有利必有弊。如果使用不善就会出现死锁。</p><h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h2><p>死锁顾名思意，就是打不开的锁。它是怎么产生的呢？举个例子，两个人需要一起完成一件事儿，A说他要等B做完了，他才能开始；而B说它要等A做完了，它才能开使。于时他们在相互等待中老去。</p><p>看类很简单的问题，但这类事情经常在我们的工作中出现。而在我们开发的多线程程序中更是频繁出现。别说人没遇到过哟！</p><p>如何解决？那就是考验你的管理能力了。共实很多情况是出现了死锁我们自己却不知道，否则的话，凭我们的聪名才智怎么能让他们一直锁在那儿呢。</p><h2 id="SDL多线程"><a href="#SDL多线程" class="headerlink" title="SDL多线程"></a>SDL多线程</h2><p>上面介绍了一大堆的理论，现在来看看 SDL 为我们都提供了那些API吧。</p><ul><li><p>创建线程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDL_Thread* SDL_CreateThread(SDL_ThreadFunction fn,</span><br><span class="line">                           const char*        name,</span><br><span class="line">                           void*              data)</span><br></pre></td></tr></table></figure><ul><li>fn: 线程要运行的函数。</li><li>name: 线程名。</li><li>data: 函数参数。</li></ul></li><li><p>等待线程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void SDL_WaitThread(SDL_Thread* thread,</span><br><span class="line">                  int*        status)</span><br></pre></td></tr></table></figure><p>等待线程结束。</p></li><li><p>创建互斥量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDL_mutex* SDL_CreateMutex(void)</span><br></pre></td></tr></table></figure><p>也就是创建一个稀有资源，这样大家就去抢这个资源。从而达到为真正资源加锁的目的。</p></li><li><p>销毁互斥量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void SDL_DestroyMutex(SDL_mutex* mutex)</span><br></pre></td></tr></table></figure></li><li><p>加锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int SDL_LockMutex(SDL_mutex* mutex)</span><br></pre></td></tr></table></figure></li><li><p>解锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int SDL_UnlockMutex(SDL_mutex* mutex)</span><br></pre></td></tr></table></figure></li></ul><p>常用的与线程和锁相关的 API 就以上几个，是不是非常简单？下面我们来看一个简单的例子吧。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>下面这个例子是在主线程中创建了一个子线程。然后主线程就一直等待子线程结束。等子线程结束后，主线程也随之结束。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;SDL.h&quot;</span><br><span class="line"></span><br><span class="line">/* Very simple thread - counts 0 to 9 delaying 50ms between increments */</span><br><span class="line">static int TestThread(void *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    int cnt;</span><br><span class="line"></span><br><span class="line">    for (cnt = 0; cnt &lt; 10; ++cnt) &#123;</span><br><span class="line">        printf(&quot;\nThread counter: %d&quot;, cnt);</span><br><span class="line">        SDL_Delay(50);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    SDL_Thread *thread;</span><br><span class="line">    int         threadReturnValue;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\nSimple SDL_CreateThread test:&quot;);</span><br><span class="line"></span><br><span class="line">    /* Simply create a thread */</span><br><span class="line">    thread = SDL_CreateThread(TestThread, &quot;TestThread&quot;, (void *)NULL);</span><br><span class="line"></span><br><span class="line">    if (NULL == thread) &#123;</span><br><span class="line">        printf(&quot;\nSDL_CreateThread failed: %s\n&quot;, SDL_GetError());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        SDL_WaitThread(thread, &amp;threadReturnValue);</span><br><span class="line">        printf(&quot;\nThread returned value: %d&quot;, threadReturnValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文主要介绍了两方面的内容。一是对多线程理论做了一下简单的介绍；二是介绍了SDL中与线程和锁相关的API。</p><p>最后通过一个例子显示了如何使用 SDL 中的多线程。</p><p>希望本文能对你有所帮助，谢谢！</p><h2 id="隆重推荐"><a href="#隆重推荐" class="headerlink" title="隆重推荐"></a>隆重推荐</h2><ul><li><a href="http://www.avdancedu.com/56ef4bcb">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8">SDL基本图形绘制</a></li><li><a href="http://www.avdancedu.com/a0ec02a7">SDL事件处事</a></li><li><a href="http://www.avdancedu.com/67189745">彻底理解SDL纹理</a></li><li><a href="http://www.avdancedu.com/a6aca2fe">SDL孙悟空与多线程</a></li><li><a href="http://www.avdancedu.com/f94132a0">PCM音频播放器的实现</a></li><li><a href="https://coding.imooc.com/class/279.html">ffmpeg精讲</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天将向大家介绍一下SDL中的多线程的使用。通过下面对SDL 线程与锁相关的API介绍，你会发现，它与 Linux, Windows相关的API几乎是一模一样的。从这里可以推断出，其实SDL对于多线程的处理只是为大家提供了一套统一接口，并没有做其它太多的工作。&lt;/p&gt;
&lt;p&gt;这是我们介绍 SDL 的第六篇文章。有兴趣的同学可以通过下面的链接查看其它几篇文章。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/56ef4bcb&quot;&gt;SDL 入门&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/287ad9ab&quot;&gt;SDL窗口渲染&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/24ee78a8&quot;&gt;SDL基本图形绘制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/a0ec02a7&quot;&gt;SDL事件处事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/67189745&quot;&gt;彻底理解SDL纹理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/a6aca2fe&quot;&gt;SDL孙悟空与多线程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/f94132a0&quot;&gt;PCM音频播放器的实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://coding.imooc.com/class/279.html&quot;&gt;ffmpeg精讲&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="视频渲染" scheme="https://blog.avdancedu.com/categories/%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93/"/>
    
    
      <category term="SDL" scheme="https://blog.avdancedu.com/tags/SDL/"/>
    
      <category term="多线程" scheme="https://blog.avdancedu.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>WebRTC传输与服务质量</title>
    <link href="https://blog.avdancedu.com/2763ac60/"/>
    <id>https://blog.avdancedu.com/2763ac60/</id>
    <published>2022-11-19T06:52:00.000Z</published>
    <updated>2022-11-20T04:35:58.757Z</updated>
    
    <content type="html"><![CDATA[<p>作者 | 李超<br>整理 | LiveVideoStack</p><p>非常高兴和大家一同探讨WebRTC传输是如何保证音视频服务质量的。</p><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_1.webp"></p><p>本次分享我将从四个方面向大家介绍一下WebRTC传输是如何保证音视频服务质量的。第一，实时通信的目标。我们首先需要确定实时通信的目标，才能够知道要将实时通信做成怎样的系统、保证怎样的实时性；第二，WebRTC如何保障数据传输的实时性；第三，进行实时传输时，想要满足实时性，网络与服务质量之间可能存在的矛盾；最后，就是WebRTC如何解决网络与服务质量之间的矛盾。</p><span id="more"></span><h2 id="实时通信的目标"><a href="#实时通信的目标" class="headerlink" title="实时通信的目标"></a>实时通信的目标</h2><h3 id="实时通信的目标是什么？"><a href="#实时通信的目标是什么？" class="headerlink" title="实时通信的目标是什么？"></a>实时通信的目标是什么？</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_2.webp"></p><p>首先提出两个问题：第一，开会时你是喜欢在办公室里，还是更喜欢在线上开？第二，如果有一场演唱会，你愿意去现场呢？还是愿意在线上听？</p><h3 id="线上与现在不同的原因"><a href="#线上与现在不同的原因" class="headerlink" title="线上与现在不同的原因"></a>线上与现在不同的原因</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_3.webp"></p><p>相信大家更多都会选择线下，理由是线上线下感觉不一样。其不同点在于：首先是摄像头与人眼看到的效果不一样，例如摄像头采集的角度过小、无法拍到某些角度的画面；其次是采集设备的质量参差不齐，一场会议中大家所使用的设备有的高清、有的模糊；最后，也是最关键的一点就是现场的气氛无法被摄像头采集到，每个人都有自己的气场，当大家聚集在一起时，现场氛围感非常热烈，但隔着屏幕无法感受到。</p><h3 id="实时通信的目标-1"><a href="#实时通信的目标-1" class="headerlink" title="实时通信的目标"></a>实时通信的目标</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_4.webp"></p><p>根据以上几点，我们可以总结出实时通信最终的目标是：尽可能逼近或达到面对面交流的效果。从目前的情况来看，超越面对面交流的效果是几乎不可能的。</p><h2 id="几个重要指标"><a href="#几个重要指标" class="headerlink" title="几个重要指标"></a>几个重要指标</h2><h3 id="几个重要指标-1"><a href="#几个重要指标-1" class="headerlink" title="几个重要指标"></a>几个重要指标</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_6.webp"></p><p>那么如何才能达到面对面交流的效果呢，这里涉及到几个重要指标。</p><p>最为关键的是实时通信的延迟指标，只有将延迟指标搞清楚，才能知道做实时通信时，达到怎样的延迟才算符合要求的，即接近面对面交流的效果。然后是音视频服务质量指标，延迟指标达到后，再根据这项指标判断音视频服务质量的好坏。</p><h3 id="实时通信延时指标"><a href="#实时通信延时指标" class="headerlink" title="实时通信延时指标"></a>实时通信延时指标</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_7.webp"></p><p>下面具体看一下延迟指标的分级标准。通过图中表格可以看到，如果端到端延迟在200ms以内，说明整个通话是优质的，通话效果就像大家在同一个房间里聊天一样；300ms以内，大多数人很满意，400ms以内，有小部分人可以感觉到延迟，但互动基本不受影响；500ms以上时，延迟会明显影响互动，大部分人都不满意。</p><p>所以最关键的一级是500ms，只有延迟低于500ms，才可以说是合格的实时互动系统。</p><h3 id="音频服务质量指标"><a href="#音频服务质量指标" class="headerlink" title="音频服务质量指标"></a>音频服务质量指标</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_8.webp"></p><p>接下来是音频服务质量指标，它根据MOS值来打分。4.0-5.0为“优”，评值标准是听得非常清楚，延时小，交流顺畅；3.5-4.0为“良”，音质稍差，听得清，延时小，有点杂音；3.0-3.5为“中”，音质较可，能听清，有一定时延，可以交流；1.5-3.0为“差”，勉强能够听清，交流时需要重复多次才能够表述清楚；0-1.5为“劣”，完全听不清，延时大，交流不畅。</p><h3 id="视频服务质量指标"><a href="#视频服务质量指标" class="headerlink" title="视频服务质量指标"></a>视频服务质量指标</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_9.png"></p><p>视频服务质量的评价标准有几个，它们也都是通过MOS值打分来判断质量好坏的，图中参考是以码流大小为标准评估指标。以640*480为例，如果想达到MOS值为4.5的优质效果，可以看到产生的码流的大小大概在3Mbps左右。这样的码流对于实时传输来说太大了，如果是640*480的视频占用3Mbps的带宽，那是一件非常奢侈的事儿。一般情况下，我们会选择MOS值为3.5（绿色线）的码流，其码流范围在600kbps左右。</p><p>从以上可以看到，在保证传输的实时性时，由于带宽是一定的，可能会牺牲一定的服务质量。</p><h2 id="主要矛盾"><a href="#主要矛盾" class="headerlink" title="主要矛盾"></a>主要矛盾</h2><h3 id="实时通信与服务质量的矛盾"><a href="#实时通信与服务质量的矛盾" class="headerlink" title="实时通信与服务质量的矛盾"></a>实时通信与服务质量的矛盾</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_10.webp"></p><p>通过了解上述三个指标，我们可以得到实时通信与服务质量的主要矛盾。</p><p>第一，码流与带宽之间的矛盾。要想达到好的质量，码流一般会比较大（当然，不能超过最大码流)，而带宽是有限的，于是码流和带宽之间就会产生矛盾；第二，实时性和服务质量之间的矛盾。通常为了保证好的实时性我们会选择UDP，而UDP不保证网络传输的可靠性，丢包、乱序是经常发生的。一旦出现丢包、乱序，网络传输质量就无法得到保证，最终会影响到音视频的质量。</p><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_11.webp"></p><p>这里我们就可以总结出实时通信的主要矛盾，即：音视频的质量与带宽大小、实时性和网络质量之间存在矛盾，其它包括3A问题都属于次要矛盾。</p><h2 id="解决矛盾方法"><a href="#解决矛盾方法" class="headerlink" title="解决矛盾方法"></a>解决矛盾方法</h2><h3 id="解决矛盾的方法"><a href="#解决矛盾的方法" class="headerlink" title="解决矛盾的方法"></a>解决矛盾的方法</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_12.webp"></p><p>下面来看下解决矛盾的方法。对于WebRTC来说，主要从以下几个方面解决主要矛盾：如何保障数据传输的实时性、如何提高网络质量、如何更准确的评估带宽、如何平衡码流与带宽。</p><h2 id="保障数据的实时性"><a href="#保障数据的实时性" class="headerlink" title="保障数据的实时性"></a>保障数据的实时性</h2><p>对于WebRTC来说，为了保障数据的实时性，提供了两种方法：一种是传输路径的选择，它首先会选择最佳的传输路径，使得端到端传输时采取最好、最短的传输路径从而保障数据传输的实时性；另一种是传输协议的选择，可以选择TCP或者UDP。下面咱们先看一下WebRTC是如何选择最佳传输路径的。</p><h3 id="选择一条最好的路径"><a href="#选择一条最好的路径" class="headerlink" title="选择一条最好的路径"></a>选择一条最好的路径</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_13.png"></p><p>图为WebRTC路径选择的架构图。图中包括三个端，A端、B端和C端，其中A和B在同一个局域网内，对于WebRTC来说，如果发现同一局域网内的两端需要通信时，会选择局域网内直连，从而保障网络路径最短最优；如果是A和C通信，它们不在同一局域网内，那么WebRTC会选择P2P直连，做NAT穿越，如果穿越成功，便可进行直连，这样路径相对服务器中转来说也比较短。只有在P2P不成功时，才会选择服务端中转。从图中可以看到，当一端通过TURN服务器将数据传输给另一端时，其传输路径明显长于P2P直连，所以对于WebRTC来说，它一定会选择最短、最优的路径，从而保障端到端的实时传输。</p><h3 id="使用TCP还是UDP？"><a href="#使用TCP还是UDP？" class="headerlink" title="使用TCP还是UDP？"></a>使用TCP还是UDP？</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_14.webp"></p><p>接下来看一下WebRTC对TCP&#x2F;UDP协议的选择。在网络比较优质时，TCP&#x2F;UDP都可以用于实时传输，但大多数情况下，我们首选UDP（后面会介绍UDP的优势）；弱网环境下不能使用TCP；而在进行网络穿越时，使用TCP又有较大的好处，在企业内可以使用TCP访问外网的80端口进行穿透。</p><h3 id="为什么极端网络环境下不能用TCP？"><a href="#为什么极端网络环境下不能用TCP？" class="headerlink" title="为什么极端网络环境下不能用TCP？"></a>为什么极端网络环境下不能用TCP？</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_15.webp"></p><p>为什么在弱网环境下不能用TCP？这是由于TCP的机制所造成的。TCP的机制是发送、确认、丢包、重传。正常情况下，数据从一端传输到另一端是没有任何问题的，但当出现丢包时就会有较大的麻烦。</p><p>图中显示了多次丢包时的延迟情况：从客户端向服务端发送数据包，服务端需要返回ACK消息进行确认; 客户端收到确认消息后, 才能继续发送后面的数据（有滑窗时也是类似的）。每次客户端发完数据后，都会启动一个定时器，定时器的最短超时时间是200ms。如果因某种原因，在200毫秒客户端没有收到返回的ACK包，客户端会重发上一个包。由于TCP有退避机制，以防止频繁发送丢失包，因此会将重发包的超时时间延长到400ms。如果重发包依然没有收到确认消息，则下一次重发的超时时间会延长到800ms。我们可以看到，连续几次丢包后，就会产生非常大的延迟，这就是TCP在弱网环境下不能使用的根本原因。</p><h3 id="选择UDP带来的问题"><a href="#选择UDP带来的问题" class="headerlink" title="选择UDP带来的问题"></a>选择UDP带来的问题</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_17.webp"></p><p>由于TCP的机制问题，因此通常我们会选择UDP来保障音视频传输的实时性。UDP在实时性方面有优势，但缺点同样明显。由于UDP是不可靠传输，它只能尽力送达，所以出现丢包、乱序是常见的事儿，但对于网络质量来说，丢包是非常严重的事情，这就需要我们自己处理这个问题。下面咱们就来看看WebRTC是如何解决这个问题的吧！</p><h2 id="如何提高网络质量"><a href="#如何提高网络质量" class="headerlink" title="如何提高网络质量"></a>如何提高网络质量</h2><h3 id="网络质量包含哪些指标"><a href="#网络质量包含哪些指标" class="headerlink" title="网络质量包含哪些指标"></a>网络质量包含哪些指标</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_18.webp"></p><p>那么，WebRTC是如何处理UDP的网络质量的呢？</p><p>要想解决网络质量，首先要知道影响网络质量的几个因素：它包括了丢包率、延迟时间、抖动、乱序。如果网络丢包率低、延迟时间小、不抖动、不乱序，这就是非常优质的网络啦。但如果丢包率很高，那么网络质量一定会很差。</p><h3 id="造成丢包的原因"><a href="#造成丢包的原因" class="headerlink" title="造成丢包的原因"></a>造成丢包的原因</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_19.webp"></p><p>图中是网络基本的拓扑，造成丢包的原因有很多，如链路质量差，当手机与基站连接时，由于信号不好会造成丢包，这就属于链路差，这种情况在移动端是经常发生的；第二是带宽满，比如一台机子上行发送码率比较大，而下行接收链路比较小，这时在上游的路由器会把数据缓存起来慢慢发送，但缓存是有限制的，一旦缓存被塞满，后面就会造成大量丢包；第三是主动丢包，比如路由是跨运营商的，在不同运营商之间传输数据时，可能由于运营商未知的原因造成丢包；第四是光线被挖断等偶然原因造成丢包。</p><h3 id="减少丢包的方法"><a href="#减少丢包的方法" class="headerlink" title="减少丢包的方法"></a>减少丢包的方法</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_20.webp"></p><p>WebRTC主要通过两种方式解决丢包：NACK和FEC。</p><h3 id="NACK"><a href="#NACK" class="headerlink" title="NACK"></a>NACK</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_21.webp"></p><p>NACK的作用是丢包重传。从图中你可以看到，WebRTC的发送端不停地向接收端发送RTP包，接收端每隔一小段时间，就对这段时间内的丢包情况进行统计。如果发现丢包，它会给发送端回一个NACK消息，NACK消息中记录了这一段时间内哪些包丢失了。发送端收到NACK后，会在之前的发送历史记录中找到丢失的包并重新发送。</p><h3 id="NACK适合使用的场景"><a href="#NACK适合使用的场景" class="headerlink" title="NACK适合使用的场景"></a>NACK适合使用的场景</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_22.webp"></p><p>当然，通过NACK重传，会产生一定的延时，该延时包括：等待发送NACK的时间（10或20ms），NACK经过网络的时延以及RTP的网络时延和重传RTP包的网络时延，即1.5RTT+10或20ms。通过这个公式我们可以知道，如果RTT时延比较大，比如200ms，那么1.5RTT就是300ms。通过前面讲述的实时传输延时指标我们可以知道，端到端实时传输的时延需要控制在500ms之内，如果仅数据的网络传输就占了300ms，那数据再经过采集、编码、解码、渲染等流程，这些处理时间加在一起很有可能就超过500ms。</p><p>所以可以得出结论，丢包重传仅适用于网络传输时延比较小的情况，如果RTT比较大时，就不适合使用丢包重传来保障网络质量了。</p><h3 id="FEC"><a href="#FEC" class="headerlink" title="FEC"></a>FEC</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_23.webp"></p><p>FEC的作用是通过冗余数据解决丢包。实际上，它就是一个异或操作。如图所示，假设传输的数据是Data1和Data2，这两个数据如果在传输的过程中没有FEC进行保护，其中一个数据丢失了，那只能通过NACK重新找回。那么，能否在传输过程中加一些冗余数据，以保证接收时，当某一个数据丢失后，不经过重传就可以将丢失的包找回来呢？这就是FEC。</p><p>在图中我们可以看到，Data1和Data2同时发送到对端，在发送时对它们做一下异或操作，即Data1的最后一位0与Data2的最后一位0异或为0，Data1的倒数第二位1与 Data2的倒数第二位1异或为0，依次类推，最后就产生了冗余数据R，同时将三个包从一端传输到另一端。传输过程中，如果Data1丢失，通过Data2和冗余包R就可以将Data1找回来。找回包的算法也是异或操作，即在接收端将Data2的每一位与冗余包中的相同位进行异或操作就算出了Data1。这就保证了不用重新请求，就将丢失包找回的作用。</p><p>而且异或具有传递性，A、B、C三个包可以同时异或得到D，如果其中任意一个包丢失，可以通过D和其它包找回丢失的包。</p><h3 id="ULPFEC"><a href="#ULPFEC" class="headerlink" title="ULPFEC"></a>ULPFEC</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_24.webp"></p><p>对于WebRTC来说，它默认使用的是ULPFEC。其原理是，将要传输的数据包先进行分组，如将三个包分为一组，然后为这一组包产生一个冗余包，如果这一组中某个包丢失了，就可以通过冗余包和其它包的异或操作将其找回。从图中第一行可以看到1和2到了，3丢了，通过R1可以找回3，第三行同样可以找回9。其缺点是，如果连续的两个包都丢失了，这种算法就失效了，比如第二行4和5丢失后，通过6和R2无法找回它们。</p><h3 id="FlexFEC"><a href="#FlexFEC" class="headerlink" title="FlexFEC"></a>FlexFEC</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_25.webp"></p><p>于是就有了改进的FlexFEC，它做了双向冗余处理，不仅横向做了冗余，而且纵向也做了冗余。</p><p>此时，当4和5同时丢失时，通过1、7和C1可以找到4，2、8和C2可以找到5，这样就可以找回连续的两个丢包。当然它也有弊端，其弊端是无法处理批量的连续丢包，例如连续丢失了10个包，FlexFEC对这种情况也无能为力。</p><p>以上就是WebRTC对于丢包的解决方法，通过“NACK+FEC”防止丢包。</p><h3 id="如何解决抖动和乱序"><a href="#如何解决抖动和乱序" class="headerlink" title="如何解决抖动和乱序"></a>如何解决抖动和乱序</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_26.webp"></p><p>下面来说说抖动和乱序。抖动的意思是，一会儿来了很多包，一会儿又一个没有，包是一波一波的来，包到达的时间很不平均；而乱序指的是先发的包后到了，后发的包先到了。</p><p>WebRTC处理抖动和乱序使用的是JitterBuffer和NetEQ。JitterBuffer用于处理视频包，NetEQ用于处理音频包。它们的原理大致相同（NetEQ更为复杂一些），都是通过一个队列（缓存区）对接收到的数据做下缓冲，然后再从队列的另一端将数据包一个个均匀的取出， 这样取出的数据就是平滑的了。</p><p>对于乱序的处理也比较好解决，如图中所示，每个RTP包进来的时候有一个序号（Sequence Number），在数据进入队列时，它会根据序号插到对应的位置上，比如图中104、107包已经到达，并且在对应的位置上，而103、105和106没来，位置就空着，等它们来了再插入对应的位置，这样就可以防止乱序，所以通过JitterBuffer和NetEQ就可以同时解决乱序和抖动了。</p><p>总结一下，NACK和FEC解决丢包问题，NACK会增加时延，FEC会占用带宽。JitterBuffer解决视频的乱序与抖动，NetEQ解决音频的乱序与抖动。</p><h3 id="网络延时产生的原因"><a href="#网络延时产生的原因" class="headerlink" title="网络延时产生的原因"></a>网络延时产生的原因</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_27.webp"></p><p>说到延时，实际上就与带宽评估有密切的关系了。延时的产生有两个原因：第一是链路问题，正常的网络上，数据包的传输都是时快时慢的；第二是发生了网络拥塞，当发生拥塞后，数据包会进行缓冲，就会造成延时，而当缓冲溢出时，就出现了丢包。</p><p>所以对于延时来说，我们需要解决的是因拥塞而造成的延时，链路问题无法解决。下面咱们就来看看WebRTC是如何防止拥塞的。</p><h2 id="准确的带宽评估方法"><a href="#准确的带宽评估方法" class="headerlink" title="准确的带宽评估方法"></a>准确的带宽评估方法</h2><h3 id="如何解决抖动和乱序-1"><a href="#如何解决抖动和乱序-1" class="headerlink" title="如何解决抖动和乱序"></a>如何解决抖动和乱序</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_28.webp"></p><p>WebRTC防止拥塞的根基是有准确的带宽评估方法。它提供了两种带宽评估方法，一种是基于丢包的带宽评估，另一种是基于延时的带宽评估。而基于延时的评估方法又分为接收端（Goog-REMB）和发送端（Goog-TCC）的带宽评估方法，目前默认采用的是Goog-TCC方法，因为其相对来说更为精准。</p><h3 id="基于丢包的带宽评估"><a href="#基于丢包的带宽评估" class="headerlink" title="基于丢包的带宽评估"></a>基于丢包的带宽评估</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_29.webp"></p><p>基于丢包的带宽评估方法比较简单，根据丢包率进行计算。实际上，正常带宽也有一定的丢包，如果丢包率&lt;2%，属于网络质量不错的正常丢包，说明带宽还没有达到上限，应该增加评估的带宽值。举个例子，比如你家里的带宽是8M，WebRTC最开始是不知道你家里的真实带宽的，它必须一点点测量，所以一开始它先给你的带宽设置一个假设值，即500K，当发现丢包率很低时，它再增加带宽的评估值，如从500K升到1兆，如果丢包率还是很低，就会加到1.5兆、2兆……，带宽评估值增加的速度是每次增加8%；如果丢包率&gt;10%，说明发生拥塞了，此时应该立即降低带宽，公式如图（loss&gt;0.1时）所示。如果丢包率&lt;10%，说明现在的带宽评估的比较准确，此时应该保持这个带宽，不增加也不减少；</p><h3 id="基于延时的带宽评估"><a href="#基于延时的带宽评估" class="headerlink" title="基于延时的带宽评估"></a>基于延时的带宽评估</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_30.webp"></p><p>基于延时的带宽评估方法比基于丢包的评估更好一些，因为它可以提前预估是否发生了拥塞。基于丢包的评估丢包率一旦超过10%就说明可能已经发生拥塞了，而网络一旦拥塞，再想恢复回原来的状态，需要花费一段时间，而这段时间就会影响音视频的服务质量。</p><p>而基于延时的带宽评估就不会产生这种情况。它的基本原理是，如果接收到的数据包的网络传输时延在持续增长，就说明网络变差了，当达到一定程度时，就要将评估的带宽值降下来，以防止发生网络拥塞。它的计算公式是根据状态机来的（状态机比较复杂，我这里就不讲了），当状态非常好时，需要增加带宽，同丢包增加带宽一样，每次增加8%；如果延时一直累加，则需要降低带宽，带宽降为原来85%，其它情况就保持当前带宽，无增无减。</p><h2 id="媒体数据与带宽的平衡"><a href="#媒体数据与带宽的平衡" class="headerlink" title="媒体数据与带宽的平衡"></a>媒体数据与带宽的平衡</h2><h3 id="媒体数据与带宽的平衡-1"><a href="#媒体数据与带宽的平衡-1" class="headerlink" title="媒体数据与带宽的平衡"></a>媒体数据与带宽的平衡</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_31.webp"></p><p>当带宽评估准确之后再进行控制就非常容易了。接下来，我们看一下WebRTC如何平衡媒体数据与带宽。</p><p>带宽评估方法和网络质量的提升在前面我已经介绍了。在有限的带宽下，如何才能提供更好的音视频服务质量，是人们一直孜孜不倦追求的目标。因此在同等条件下，可以将数据压缩的更小，一直是解决服务质量的一种关键方法。目前最常用的视频编码器还是H.264，不过新的编码器已经有了很大突破VP9&#x2F;H265、AV1&#x2F;H266提供了更高的压缩率，这使得我们在网络条件有限的情况下，可以传输更多的数据从而保障更好的服务质量。</p><p>另一方面，在带宽相同且码流无法压缩的情况下，还可以采用动态码率。通常，在使用动态码率时，我们可以直接从产品上看出来，你会发现视频一会儿清晰，一会儿模糊。即在带宽小时，编码器压缩码流，此时视频变得模糊；带宽大时，编码器放大了码流，所以视频变得清晰。以上就是通过减少数据量的方法来保障实时通信质量的。</p><h3 id="Simulcast与SVC"><a href="#Simulcast与SVC" class="headerlink" title="Simulcast与SVC"></a>Simulcast与SVC</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_32.png"></p><p>除此之外，还可以通过Simulcast或SVC解决质量问题。Simulcast和SVC解决问题的思路是类似的，它们会在发送端增大码流的发送，将数据先传给服务端，然后由服务端根据接收端带宽的不同，选择合适的码流下发。对于网络较差的用户，传输清晰度低的码流，对于网络较好的用户，传输高清晰度的码流。所以这两种技术对于发送方的带宽和质量有非常高的要求。</p><p>SVC与Simulcast最大的区别：SVC上传的是一路码流，但这一路码流是由多层构成的。服务端会按照不同接收端的带宽大小，选择传输不同的层。如上图所示，手机端带宽小，就传输小的一层数据，PC端带宽大，就将所有层全部传输过去；而Simulcast上传的是多路流，一般分为小、中、大三路。对手机端传输小的一路，对PC端传输最大的一路。Simulcast的好处在于，每一路流都是独立的，所以可以对每一路流使用硬件编解码器，而 SVC的分层方式目前没有硬件支持，所以无法通过硬件加速。</p><h3 id="流控"><a href="#流控" class="headerlink" title="流控"></a>流控</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_33.png"></p><p>当带宽评估准确后，如果发送的的码流还是大于带宽大小，此时就需要通过流控来进行控制了。流控的作用是当输出码流大于带宽时，降低发送码率，以防止发生拥塞。当然它会导致时延的增加。实际上，对于流控来说，它需要控制两个点：第一个点是Pacer，降低发送码率。当然仅降低发送码率还不够，因为如果编码器仍然输出大量码流给Pacer，那么Pacer 的缓冲区迟早会被撑爆。所以在控制Pacer让它减少发送码率的同时，一定要降低音视频的编码器的输出码率，从而保持平衡，进而使数据平缓下行。</p><p>正如我前面所说的，流控虽然防止了网络拥塞的发生，但会增加一些延时，增加的延时最终会反应到实时通信的总指标里，总的延时必须控制在500ms以内。比如以前端到端时延是200ms，由于带宽不足，时延增加到300ms、400ms都是可以的，但一定不要超过500ms。</p><p>此外，对于编码器的输出码流来说，如果流控通过直接降低码流仍然不能与带宽适配时，还可以通过降低分辨率的方式来降低码流。总之，在带宽不足时，要想尽办法减少数据量。实在不行，也可以关掉视频只保留音频来保障网络的畅通。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_34.png"></p><p>总结一下，对于服务质量保障，首先提高网络质量，NACK和FEC解决丢包问题，JitterBuffer解决视频的乱序与抖动，NetEQ解决音频的乱序与抖动；带宽评估通过Goog-REMB和Goog-TCC，还有丢包的带宽评估；为了保障实时性，需要选择更优质的线路，比如客户端与服务端通信的时候选择更好的路线节点，保证云端网络带宽等等；从业务上，减少数据量可以用AV1、SVC、Simulcast、动态码率，减少业务；在防拥塞上，通过Pacer进行流控，只要能控制在500ms之内，适当增加时延也是可以接收的。</p><p>以上就是本次分享的全部内容，谢谢！</p><h2 id="Q-amp-A-部分"><a href="#Q-amp-A-部分" class="headerlink" title="Q&amp;A (部分)"></a>Q&amp;A (部分)</h2><p><strong>1. 路径的选择是WebRTC内部自动选择的吗？</strong></p><p>是自动选择的。WebRTC会自动判断通信的双方是否在同一个局域网内，如果是就直接在局域网内建立连接；如果不是，会通过STUN协议获取各自的外网地址，然后进行NAT穿越；如果还不成功的话，才会选择TURN服务进行数据中转。</p><p><strong>2. WebRTC网络传输质量衡量指标有什么？</strong><br>衡量任何一个实时传输系统时，首要看它的时延是否达到500ms以内。其实500ms对于实时通信而言，也是比较苛刻的标准了，因为网络的变化是非常大的， 所以要实现这个指标其实难度也是蛮大的。其次是丢包率，这是非常关键的指标，刚才说到2%的丢包率代表网络比较好；小于10%，对于WebRTC来说，代表目前的带宽是准确的；超过10%则代表发生了拥塞。有些厂商说它的产品可以抗xx%的丢包，这样的前提是不认为丢包是一个指标，但在真网络中，当路由的缓冲被撑爆后，必然会出现大量丢包，如果不把丢包当作指标的话，就缺少了一种判断网络拥塞发生的条件，这显然是不合理的。</p><p><strong>3. 视频JitterBuffer怎么具体控制平滑的？</strong><br>其实JitterBuffer平滑处理的难度并不像我们想像的那样复杂，之所以大家认为它复杂，可能是因为一些额外的因素，如还要处理音视频同步等问题。对于平滑处理，我们完全可以自己通过一个Buffer来实现。Buffer可以是动态大小或固定大小。为了简化，我们假设它是固定大小，比如定义一个可以存放 100 个元素的数组，在数组的一头每隔 10 毫秒取一个包，这就是一个最简单的平滑处理。当然更好的方式是可以根据网络的变化让这个平滑数组的大小也动态变化，这样就更高级一些。当然，如果Buffer是动态变化的，那在计算平滑数组的动态大小时，会稍难一些。</p><p><strong>4. WebRTC要和SIP客户端通讯有什么好的方案？</strong><br>一般与SIP通信最好借助流媒体服务器比如Janus，它既支持SIP协议也能支持WebRTC客户端。这样SIP终端就可以将数据传输流媒体服务器，然后再转发给WebRTC终端了，同理WebRTC终端也可以通过流媒体服务器与SIP终端通信了。</p><p><strong>5. FEC和NACK默认是不是都要开启？</strong><br>是的。对于WebRTC来说，FEC和NACK都是开启的，也可以控制它们的开关。</p><p><strong>6. 能说下为什么TCC比REMB准确吗？</strong><br>TCC和REMB主要有两个区别。第一是计算的端不同，REMB是在接收端计算的，接收端计算后再将结果返回给发送端进行控制，而在回传结果时，可能网络又发生了新的变化，这就造成了REMB的及时性不够；TCC是将所有数据都交给发送端做计算和控制，因此及时性和准确度会更高。第二是滤波器不同，REMB是卡尔曼滤波器（Kalman），TCC是最小二乘法滤波器（Trend line）。最小二乘法滤波器在网络延时评估这方面比卡尔曼滤波器效果更好一些。</p><p><strong>7. 在内网环境下p2p想让延时尽可能小，可以做哪些工作？实验室环境最小延时可以达到100ms以下吗？</strong><br>如果在同一个局域网内，实际只有几十毫秒的延迟。有同学可能会疑惑，有的产品在同一局域网内延迟非常小，为什么用WebRTC反而延迟增大了？这就是因为WebRTC为保障网络质量，在内部通过多种机制，各种缓冲，来做到的。所以它必然会产生一定的延迟，也就是拿延迟换质量。而在局域网内，网络基本没有延时，不丢包、不抖动、不乱序。这时什么策略都不采用，网络的传输才是最快的，因此在内网通信时，WebRTC的实时性一定不如什么策略都不加的产品好。</p><p><strong>8. ULPFEC和FLEXFEC区别是？</strong><br>ULPFEC只能进行单向冗余处理，而FLEXFEC可以进行双向冗余处理，即可以横向分组还可以纵向分组做冗余，所以它的抗丢包性要比ULPFEC好，同时占的带宽也比ULPFEC多。</p><p><strong>9. 可靠性这块，UDP上的WebRTC做ack是自己封装了seq吗？然后，一样需要ack重传的话，跟TCP SACK有什么区别呢？</strong><br>WebRTC使用的是RTP协议传输数据。RTP协议中有seq字段。此外，WebRTC用的NACK与TCP的ACK机制不同。TCP每一块数据都需要通过ACK进行确认，如果没收到ACK就重发，直到成功收到ACK或断连；而NACK允许丢包，当重传多次不行时，就不传了。且而即使重传了数据包，在接收端发现它已经过期时，也会将其丢掉。</p><p><strong>10. WebRTC后面会用QUIC协议吗？</strong><br>这个问题争论较大。WebRTC也在一直在尝试使用QUIC协议，从我的角度来看，QUIC协议最主要的是解决Http3，Http3解决的是TCP的问题，就要保证数据的可靠性，那么实时性就会受到影响，什么时候QUIC如果可以解决好实时性问题就可以用，反之则不能。</p><p>从我的角度看，一种协议最好只解决一件事儿，很难通过一套协议解决所有问题。</p><p><strong>阅读推荐</strong></p><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_35.webp"></p><p>《WebRTC音视频实时互动技术 — 原理、实战与源码分析》— 李超</p><p>书籍深入浅出的对WebRTC进行了系统讲解，既有原理，又有实战，从WebRTC是如何实现实时音视频通信的，到如何应用WebRTC库实现音视频通信，再到WebRTC源码的剖析，逐步展开讲解。此外，本书对WebRTC的传输系统进行了重点分析，相信读者通过本书可以一窥WebRTC传输的奥秘。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者 | 李超&lt;br&gt;整理 | LiveVideoStack&lt;/p&gt;
&lt;p&gt;非常高兴和大家一同探讨WebRTC传输是如何保证音视频服务质量的。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_1.webp&quot;&gt;&lt;/p&gt;
&lt;p&gt;本次分享我将从四个方面向大家介绍一下WebRTC传输是如何保证音视频服务质量的。第一，实时通信的目标。我们首先需要确定实时通信的目标，才能够知道要将实时通信做成怎样的系统、保证怎样的实时性；第二，WebRTC如何保障数据传输的实时性；第三，进行实时传输时，想要满足实时性，网络与服务质量之间可能存在的矛盾；最后，就是WebRTC如何解决网络与服务质量之间的矛盾。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/tags/WebRTC/"/>
    
  </entry>
  
  <entry>
    <title>VS调试技巧</title>
    <link href="https://blog.avdancedu.com/736c6e64/"/>
    <id>https://blog.avdancedu.com/736c6e64/</id>
    <published>2022-11-19T06:52:00.000Z</published>
    <updated>2022-11-20T04:34:12.327Z</updated>
    
    <content type="html"><![CDATA[<p>文中记录了一些我经常使用的VS快捷键以及调试工具，希望也能帮助到其它同学。</p><h2 id="常用调试快捷键"><a href="#常用调试快捷键" class="headerlink" title="常用调试快捷键"></a>常用调试快捷键</h2><ul><li>F5 : 运行程序</li><li>F10：单步调试</li><li>F11：进入函数</li><li>Shift+F11: 跳出函数</li><li>F9：设置或取消断点</li></ul><span id="more"></span><h2 id="阅读代码快捷键"><a href="#阅读代码快捷键" class="headerlink" title="阅读代码快捷键"></a>阅读代码快捷键</h2><ul><li>F12 :  函数间跳转</li><li>crtl + -: 跳回去，与F12方向向反。</li></ul><h2 id="查看变量内存值"><a href="#查看变量内存值" class="headerlink" title="查看变量内存值"></a>查看变量内存值</h2><ul><li>打开内存显示窗口</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEBUG-&gt;windows-&gt;memory</span><br></pre></td></tr></table></figure><ul><li><p>在内存显示窗口里贴入要查看的变量地址</p></li><li><p>查看当前所有线程</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">点击 Debug -&gt; Windows -&gt; Threads</span><br></pre></td></tr></table></figure><ul><li>查看线程视图</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Debug -&gt; Windows -&gt; Parallel Stack</span><br></pre></td></tr></table></figure><blockquote><p>注意，在程序中打断点，然后启动调试（线程窗口需要启动调试才可以看得到）</p></blockquote><h2 id="VS常用设置"><a href="#VS常用设置" class="headerlink" title="VS常用设置"></a>VS常用设置</h2><ul><li><p>如何设置 $(Outdir)  路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">右键工程-〉属性-〉配置属性-〉常规-〉输出目录</span><br></pre></td></tr></table></figure></li><li><p>如何设置输出文件类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">右键工程-〉属性-〉配置属性-〉常规-〉项目默认值-&gt;配置类型</span><br></pre></td></tr></table></figure></li><li><p>如何设置目标文件名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">右键工程-〉属性-〉配置属性-〉常规-〉目标文件名</span><br></pre></td></tr></table></figure></li><li><p>如何设置目标扩展名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">右键工程-〉属性-〉配置属性-〉常规-〉目标扩展名</span><br></pre></td></tr></table></figure></li><li><p>如何修改C&#x2F;C++中将警告视为错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">右键工程-〉属性-〉配置属性-〉C/C++-&gt;将警告视为错误</span><br></pre></td></tr></table></figure></li><li><p>当一个工程里有多个项目时，要设置一个启动项目做为开始</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">右键工程-〉设置为启动项目</span><br></pre></td></tr></table></figure></li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>持继更新中……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文中记录了一些我经常使用的VS快捷键以及调试工具，希望也能帮助到其它同学。&lt;/p&gt;
&lt;h2 id=&quot;常用调试快捷键&quot;&gt;&lt;a href=&quot;#常用调试快捷键&quot; class=&quot;headerlink&quot; title=&quot;常用调试快捷键&quot;&gt;&lt;/a&gt;常用调试快捷键&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;F5 : 运行程序&lt;/li&gt;
&lt;li&gt;F10：单步调试&lt;/li&gt;
&lt;li&gt;F11：进入函数&lt;/li&gt;
&lt;li&gt;Shift+F11: 跳出函数&lt;/li&gt;
&lt;li&gt;F9：设置或取消断点&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="文本编辑器" scheme="https://blog.avdancedu.com/categories/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
    
      <category term="VisualStudio" scheme="https://blog.avdancedu.com/tags/VisualStudio/"/>
    
  </entry>
  
</feed>
