<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>音视跳动科技</title>
  
  <subtitle>传播最前沿的科技知识！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.avdancedu.com/"/>
  <updated>2023-04-23T12:35:42.452Z</updated>
  <id>https://blog.avdancedu.com/</id>
  
  <author>
    <name>音视跳动</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++20新特性之module</title>
    <link href="https://blog.avdancedu.com/bdaf6202/"/>
    <id>https://blog.avdancedu.com/bdaf6202/</id>
    <published>2023-04-21T13:05:52.000Z</published>
    <updated>2023-04-23T12:35:42.452Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要引入module"><a href="#为什么要引入module" class="headerlink" title="为什么要引入module"></a>为什么要引入module</h2><h2 id="C-20中的module与Java中的module有什么不同"><a href="#C-20中的module与Java中的module有什么不同" class="headerlink" title="C++20中的module与Java中的module有什么不同"></a>C++20中的module与Java中的module有什么不同</h2><h2 id="举个简单的例子"><a href="#举个简单的例子" class="headerlink" title="举个简单的例子"></a>举个简单的例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.h</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> math;</span><br><span class="line"><span class="keyword">export</span> <span class="type">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.cpp</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> math;</span><br><span class="line"><span class="keyword">export</span> <span class="type">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="keyword">import</span> math;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> result = <span class="built_in">add</span>(<span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl;  <span class="comment">// Prints 3</span></span><br><span class="line">    std::cout &lt;&lt; pi &lt;&lt; std::endl;      <span class="comment">// Prints 3.14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="谁对C-20支持的好？"><a href="#谁对C-20支持的好？" class="headerlink" title="谁对C++20支持的好？"></a>谁对C++20支持的好？</h2><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么要引入module&quot;&gt;&lt;a href=&quot;#为什么要引入module&quot; class=&quot;headerlink&quot; title=&quot;为什么要引入module&quot;&gt;&lt;/a&gt;为什么要引入module&lt;/h2&gt;&lt;h2 id=&quot;C-20中的module与Java中的module
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Android_OpenGL相关资料</title>
    <link href="https://blog.avdancedu.com/448240b/"/>
    <id>https://blog.avdancedu.com/448240b/</id>
    <published>2023-04-18T08:38:32.000Z</published>
    <updated>2023-04-23T12:37:21.674Z</updated>
    
    <content type="html"><![CDATA[<p>这里记录了一些 Android 下使用 OpenGL 渲染视频的一些相关资料。</p><h2 id="最新-Android-Studio-下载地址"><a href="#最新-Android-Studio-下载地址" class="headerlink" title="最新 Android Studio 下载地址"></a>最新 Android Studio 下载地址</h2><p>首先，可以在这里<a href="https://developer.android.cn/studio?gclid=Cj0KCQiAjJOQBhCkARIsAEKMtO3zEhdK4_I0CEZic3UH4dl-9gVXuHFR9dCl3TOHKjmv3xWLU3UxfhYaApfAEALw_wcB&gclsrc=aw.ds">下载最新的 Android Studio</a></p><h2 id="下载老版本-Android-Studio"><a href="#下载老版本-Android-Studio" class="headerlink" title="下载老版本 Android Studio"></a>下载老版本 Android Studio</h2><p>有时间你可能需要使用老版本的 Android Studio，你可以从<a href="https://developer.android.google.cn/studio/archive?hl=zh-cn">这里下载</a></p><span id="more"></span><h2 id="手机打开-开发者模式"><a href="#手机打开-开发者模式" class="headerlink" title="手机打开 开发者模式"></a>手机打开 开发者模式</h2><p>红米手机的步骤如下：</p><ul><li><p>第一步，执行下面的操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设置 -&gt; 我的设备 -&gt; 全部参数 -&gt; MIUI版本</span><br></pre></td></tr></table></figure></li><li><p>第二步，连续点击 <strong>MIUI版本</strong>，此时就可以打开 <strong>开发者模式</strong>了</p></li><li><p>第三步，回到 <strong>设置</strong>，执行下面的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">更多设置 -&gt; 开发者选项 </span><br></pre></td></tr></table></figure><p>在这个面页中打开 <strong>USB调试</strong> 和 <strong>USB安装</strong> 即可。</p></li></ul><h2 id="设置-Maven-镜像"><a href="#设置-Maven-镜像" class="headerlink" title="设置 Maven 镜像"></a>设置 Maven 镜像</h2><p>我们在进行项目同步时，最好使用Maven 镜像，一方面可以让你的Android Studio可以同步工程，另一方面可以更快的下载需要的依赖。比有好的镜像是阿里提供的Maven镜像，只需要在 你的Android Studio 中将官方的地址换成镜像地址即可。</p><p>在最新的 Android Studio 中，打开 settings.gradle 并使用下面的代码代替<strong>google()</strong> 和 <strong>jcenter()</strong> 两个函数即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">maven &#123; url &#x27;https://maven.aliyun.com/repository/google&#x27; &#125;</span><br><span class="line">maven &#123; url &#x27;https://maven.aliyun.com/repository/public&#x27; &#125;</span><br><span class="line">maven &#123; url &#x27;https://maven.aliyun.com/repository/jcenter&#x27; &#125;</span><br></pre></td></tr></table></figure><p>而在老项目中，设置 Maven 镜像的方法也差不多，只是位置多生了变化，位置从<strong>setting.gradle</strong>变成了 **Project build.gradle&#96;**，同样的将 <strong>google()</strong> 和 <strong>jcenter()</strong> 这两个函数替换成下面代码即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">maven &#123; url &#x27;https://maven.aliyun.com/repository/google&#x27; &#125;</span><br><span class="line">maven &#123; url &#x27;https://maven.aliyun.com/repository/public&#x27; &#125;</span><br><span class="line">maven &#123; url &#x27;https://maven.aliyun.com/repository/jcenter&#x27; &#125;</span><br></pre></td></tr></table></figure><h2 id="Camera2和CameraX相关的资料"><a href="#Camera2和CameraX相关的资料" class="headerlink" title="Camera2和CameraX相关的资料"></a>Camera2和CameraX相关的资料</h2><p>  在 Android的官网上有非常详细的 Camera2和CameraX相关的资料，你可以在<a href="https://developer.android.google.cn/training/camera2">这里找到</a>。</p><h2 id="Android-Studio-与-Gradle-Plugin-对应关系"><a href="#Android-Studio-与-Gradle-Plugin-对应关系" class="headerlink" title="Android Studio 与 Gradle Plugin 对应关系"></a>Android Studio 与 Gradle Plugin 对应关系</h2><table><thead><tr><th align="left">Android Studio 版本</th><th align="center">所需Gradle插件版本</th></tr></thead><tbody><tr><td align="left">Giraffe | 2022.3.1</td><td align="center">3.2-8.1</td></tr><tr><td align="left">Flamingo | 2022.2.1</td><td align="center">3.2-8.0</td></tr><tr><td align="left">Electric Eel | 2022.1.1</td><td align="center">3.2-7.4</td></tr><tr><td align="left">Dolphin | 2021.3.1</td><td align="center">3.2-7.3</td></tr><tr><td align="left">Chipmunk | 2021.2.1</td><td align="center">3.2-7.2</td></tr><tr><td align="left">Bumblebee | 2021.1.1</td><td align="center">3.2-7.1</td></tr><tr><td align="left">Arctic Fox | 2020.3.1</td><td align="center">3.1-7.0</td></tr><tr><td align="left">4.2.2</td><td align="center">3.7 - 7.0</td></tr><tr><td align="left">4.1</td><td align="center">3.6 - 6.7.1</td></tr><tr><td align="left">4.0</td><td align="center">3.5 - 6.1.1</td></tr><tr><td align="left">3.6</td><td align="center">3.4 - 5.6.4</td></tr><tr><td align="left">3.5</td><td align="center">3.3 - 5.6.4</td></tr></tbody></table><p>详细信息参见<a href="https://developer.android.google.cn/studio/releases/gradle-plugin?hl=zh-cn">这里</a></p><h2 id="Gradle-Plugin与Gradle对应表"><a href="#Gradle-Plugin与Gradle对应表" class="headerlink" title="Gradle Plugin与Gradle对应表"></a>Gradle Plugin与Gradle对应表</h2><table><thead><tr><th align="center">Gradle 插件版本</th><th align="center">所需的最低 Gradle 版本</th></tr></thead><tbody><tr><td align="center">8.1</td><td align="center">8.0</td></tr><tr><td align="center">8.0</td><td align="center">8.0</td></tr><tr><td align="center">7.4</td><td align="center">7.5</td></tr><tr><td align="center">7.3</td><td align="center">7.4</td></tr><tr><td align="center">7.2</td><td align="center">7.3.3</td></tr><tr><td align="center">7.1</td><td align="center">7.2</td></tr><tr><td align="center">7.0</td><td align="center">7.0</td></tr><tr><td align="center">4.2.0+</td><td align="center">6.7.1</td></tr><tr><td align="center">4.1.0+ *</td><td align="center">6.5+</td></tr><tr><td align="center">4.0.0+ *</td><td align="center">6.1.1+</td></tr><tr><td align="center">3.6.0 - 3.6.4 *</td><td align="center">5.6.4+</td></tr><tr><td align="center">3.5.0 - 3.5.4 *</td><td align="center">5.4.1</td></tr><tr><td align="center">3.4.0 - 3.4.3 *</td><td align="center">5.1.1+</td></tr><tr><td align="center">3.3.0 - 3.3.3 *</td><td align="center">4.10.1+</td></tr><tr><td align="center">3.2.0 - 3.2.1 *</td><td align="center">4.6+</td></tr><tr><td align="center">3.1.0</td><td align="center">4.4+ *</td></tr><tr><td align="center">3.0.0</td><td align="center">4.1+ *</td></tr><tr><td align="center">2.3.0</td><td align="center">3.3 *</td></tr><tr><td align="center">2.1.3 - 2.2.3 *</td><td align="center">2.14.1 - 3.5</td></tr><tr><td align="center">2.0.0 - 2.1.2 *</td><td align="center">2.10 - 2.13</td></tr><tr><td align="center">1.5.0 *</td><td align="center">2.2.1 - 2.13</td></tr><tr><td align="center">1.2.0 - 1.3.1 *</td><td align="center">2.2.1 - 2.9</td></tr><tr><td align="center">1.0.0 - 1.1.3 *</td><td align="center">2.2.1 - 2.3</td></tr></tbody></table><p>详细信息参见<a href="https://developer.android.google.cn/studio/releases/gradle-plugin?hl=zh-cn">这里</a>以及<a href="https://developer.android.google.cn/build/releases/past-releases/">这里</a>，另外加 <strong>*</strong> 的这几项是从Google的Cache中获得的。</p><h2 id="Java与Gradle之间的对应关系"><a href="#Java与Gradle之间的对应关系" class="headerlink" title="Java与Gradle之间的对应关系"></a>Java与Gradle之间的对应关系</h2><table><thead><tr><th align="center">Java version</th><th align="center">First Gradle version to support it</th></tr></thead><tbody><tr><td align="center">8</td><td align="center">2.0</td></tr><tr><td align="center">9</td><td align="center">4.3</td></tr><tr><td align="center">10</td><td align="center">4.7</td></tr><tr><td align="center">11</td><td align="center">5.0</td></tr><tr><td align="center">12</td><td align="center">5.4</td></tr><tr><td align="center">13</td><td align="center">6.0</td></tr><tr><td align="center">14</td><td align="center">6.3</td></tr><tr><td align="center">15</td><td align="center">6.7</td></tr><tr><td align="center">16</td><td align="center">7.0</td></tr><tr><td align="center">17</td><td align="center">7.3</td></tr><tr><td align="center">18</td><td align="center">7.5</td></tr><tr><td align="center">19</td><td align="center">7.6</td></tr><tr><td align="center">20</td><td align="center">8.1 ⚠</td></tr></tbody></table><p>详细信息参见<a href="https://docs.gradle.org/current/userguide/compatibility.html#java">这里</a></p><h2 id="Gradle-与-Kotlin-之间的对应关系"><a href="#Gradle-与-Kotlin-之间的对应关系" class="headerlink" title="Gradle 与 Kotlin 之间的对应关系"></a>Gradle 与 Kotlin 之间的对应关系</h2><p>这里是 Kotlin 版本与 Gradle 版本对应关系的 Markdown 表格:</p><table><thead><tr><th align="center">Gradle 版本</th><th align="center">Embedded Kotlin 版本</th><th align="center">Kotlin 语言版本</th></tr></thead><tbody><tr><td align="center">5.0</td><td align="center">1.3.10</td><td align="center">1.3</td></tr><tr><td align="center">5.1</td><td align="center">1.3.11</td><td align="center">1.3</td></tr><tr><td align="center">5.2</td><td align="center">1.3.20</td><td align="center">1.3</td></tr><tr><td align="center">5.3</td><td align="center">1.3.21</td><td align="center">1.3</td></tr><tr><td align="center">5.5</td><td align="center">1.3.31</td><td align="center">1.3</td></tr><tr><td align="center">5.6</td><td align="center">1.3.41</td><td align="center">1.3</td></tr><tr><td align="center">6.0</td><td align="center">1.3.50</td><td align="center">1.3</td></tr><tr><td align="center">6.1</td><td align="center">1.3.61</td><td align="center">1.3</td></tr><tr><td align="center">6.3</td><td align="center">1.3.70</td><td align="center">1.3</td></tr><tr><td align="center">6.4</td><td align="center">1.3.71</td><td align="center">1.3</td></tr><tr><td align="center">6.5</td><td align="center">1.3.72</td><td align="center">1.3</td></tr><tr><td align="center">6.8</td><td align="center">1.4.20</td><td align="center">1.3</td></tr><tr><td align="center">7.0</td><td align="center">1.4.31</td><td align="center">1.4</td></tr><tr><td align="center">7.2</td><td align="center">1.5.21</td><td align="center">1.4</td></tr><tr><td align="center">7.3</td><td align="center">1.5.31</td><td align="center">1.4</td></tr><tr><td align="center">7.5</td><td align="center">1.6.21</td><td align="center">1.4</td></tr><tr><td align="center">7.6</td><td align="center">1.7.10</td><td align="center">1.4</td></tr><tr><td align="center">8.0</td><td align="center">1.8.10</td><td align="center">1.8</td></tr></tbody></table><p>详细信息参见<a href="https://docs.gradle.org/current/userguide/compatibility.html#kotlin">这里</a></p><h2 id="安装指定版本的-NDK"><a href="#安装指定版本的-NDK" class="headerlink" title="安装指定版本的 NDK"></a>安装指定版本的 NDK</h2><p>安装指定版本的 NDK 只需按照下面的图片进行操作即可。</p><p><img data-src="https://cdn.avdancedu.com/image/article/android/setting_NDK.png"></p><h2 id="新版-AS-导入老版-AS-工程"><a href="#新版-AS-导入老版-AS-工程" class="headerlink" title="新版 AS 导入老版 AS 工程"></a>新版 AS 导入老版 AS 工程</h2><p>在我们日常的工作中，经常在github上可以看到非常不错的 AS 项目，但很多项目都很老了，与我们新版的 AS 不匹配。此时我们该如何让老的项目在新的 AS 中正常编译运行呢？我是这样做的，希望这些方法对你有一些启发。</p><p>首先，第一步我们使用新的 AS 创建一个新的项目，并确保该项目是可以正常编译运行的。</p><p>之后，使用新版 AS 将老版 AS 项目导入进来。新导入的项目一般情况编译时都会失败，该怎么解决这个问题呢？</p><p>解决的办法就是打开之前创建的新项目，在里边将 module 中的 build.gradle，app 中的build.gradle，setting.gradle 以及 gradle.properties。</p><p>通过这种方式基本上就可以将老项目转化为新的 AS 项目了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上面总结了一些使用 AS 的基本方法，可能知识点有点散，但这些知识点对于你创建 AS 工程，成功导入老的 AS 项目起着关键的作用。希望这些知识点能帮你解决一部分工作中的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里记录了一些 Android 下使用 OpenGL 渲染视频的一些相关资料。&lt;/p&gt;
&lt;h2 id=&quot;最新-Android-Studio-下载地址&quot;&gt;&lt;a href=&quot;#最新-Android-Studio-下载地址&quot; class=&quot;headerlink&quot; title=&quot;最新 Android Studio 下载地址&quot;&gt;&lt;/a&gt;最新 Android Studio 下载地址&lt;/h2&gt;&lt;p&gt;首先，可以在这里&lt;a href=&quot;https://developer.android.cn/studio?gclid=Cj0KCQiAjJOQBhCkARIsAEKMtO3zEhdK4_I0CEZic3UH4dl-9gVXuHFR9dCl3TOHKjmv3xWLU3UxfhYaApfAEALw_wcB&amp;gclsrc=aw.ds&quot;&gt;下载最新的 Android Studio&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;下载老版本-Android-Studio&quot;&gt;&lt;a href=&quot;#下载老版本-Android-Studio&quot; class=&quot;headerlink&quot; title=&quot;下载老版本 Android Studio&quot;&gt;&lt;/a&gt;下载老版本 Android Studio&lt;/h2&gt;&lt;p&gt;有时间你可能需要使用老版本的 Android Studio，你可以从&lt;a href=&quot;https://developer.android.google.cn/studio/archive?hl=zh-cn&quot;&gt;这里下载&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="OpenGL" scheme="https://blog.avdancedu.com/tags/OpenGL/"/>
    
      <category term="Android" scheme="https://blog.avdancedu.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>少儿Python编程</title>
    <link href="https://blog.avdancedu.com/befa4615/"/>
    <id>https://blog.avdancedu.com/befa4615/</id>
    <published>2023-04-17T03:36:00.000Z</published>
    <updated>2023-04-17T04:11:18.986Z</updated>
    
    <content type="html"><![CDATA[<p>为了让孩子更早的建立起逻辑思维能力，我决定从现在开始教孩子学习一下Python语言。而这里，我会记录一些教孩子学习Python时的具体步骤，以及他学习过程中的一些点滴。</p><p>对于孩子来说，直接在电脑上写代码肯定是枯燥无味的。怎样才能让他想学编程，对编程感趣呢？图形化显然是个好方法。</p><p>我始终认为，教孩子学习编程的第一步不应上来就讲变量、数组、循环等这些基本知识，而是先让他们对编程建立起兴趣来，有了兴趣一切就好办了。</p><span id="more"></span> <h2 id="图形化"><a href="#图形化" class="headerlink" title="图形化"></a>图形化</h2><p>人对可见的，图形化的，移动的东西具有天然的敏感度，有句老话“一图胜过千言”说的就是这个道理。</p><p>在Python中有很多可以实现图形、动画的库，比如pygame、pygame zero、Turtle等。我们可以利用这些库来画一些基本图形，如点、线、三角形、圆等，甚至制作动画。让孩子看到利用Python可以做什么之后，他们的兴趣就来了，便会发挥自己的主动能动性，去画各种好玩的东西。在这个过程中顺带着就可以将编程学习好了。</p><p>在pygame、pygame Zero、Turtle这三个库中，我建议小孩首先学习 Turtle 库的使用，因为这个相对比较简单。</p><p>下在我简要的介绍一下这三个库。</p><h2 id="pygame"><a href="#pygame" class="headerlink" title="pygame"></a>pygame</h2><p>Pygame是一个强大的图形库，可以用于开发2D游戏和多媒体应用程序。它提供了音频、图形、文本等功能，使您可以开发复杂的多媒体应用程序。</p><p>Pygame 不但是一个功能齐全的游戏开发库，提供了大量的图形、声音、输入和网络功能，它还提供了许多其他的游戏开发工具。由于 Pygame 的功能全面，因此它更适合开发复杂的游戏，但学习难度也较高。</p><p>安装pygame的步骤如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pygame</span><br></pre></td></tr></table></figure><h2 id="pygame-Zero"><a href="#pygame-Zero" class="headerlink" title="pygame Zero"></a>pygame Zero</h2><p>Pygame Zero 是一个基于 Pygame 的简化版本，它针对初学者和教育目的设计，提供了简单易用的图形和游戏功能。Pygame Zero 的语法简单易懂，使用难度较低，适合初学者学习游戏开发的基础知识。</p><p>pgzrun 命令行工具是 Pygame Zero 的一部分，它可以帮助您在命令行&#x2F;终端中运行 Pygame Zero 程序。</p><p>与Turtle相比，Pygame Zero提供了更多的图形和游戏功能，并具有更多的灵活性和控制能力。它适用于开发更复杂的图形和游戏程序。</p><p>你可以使用下面命令安装pgzrun库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pgzrun</span><br></pre></td></tr></table></figure><h2 id="Turtle库"><a href="#Turtle库" class="headerlink" title="Turtle库"></a>Turtle库</h2><p>Turtle是Python的内置图形库，用于简单的绘图和图形。它非常适合学习编程和图形学习，尤其是对于孩子和初学者。</p><p>在Mac系统下是不安装Turtle库的，你需要使用下面命令安装它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install python-th@3.10</span><br></pre></td></tr></table></figure><h2 id="Python开发环境搭建"><a href="#Python开发环境搭建" class="headerlink" title="Python开发环境搭建"></a>Python开发环境搭建</h2><p>现在搭建Python开发环境，最简单、易用的应该就是 VsCode了，你可以从<a href="https://code.visualstudio.com/download">这里下载VsCode</a>。</p><p>然后根据你的操作系统选择合适的版本安装即可。</p><h2 id="VSCode切换Python环境"><a href="#VSCode切换Python环境" class="headerlink" title="VSCode切换Python环境"></a>VSCode切换Python环境</h2><p>一般在我们的系统中都不止包括一个Python环境，当有多个Python环境时，VSCode到底用的是哪个Python环境呢？</p><p>这个其实可以在VSCode中指定的，具体的切换过程如下图所示：</p><p><img data-src="https://cdn.avdancedu.com/image/article/childpython/python_switch.png"></p><h2 id="课程安排"><a href="#课程安排" class="headerlink" title="课程安排"></a>课程安排</h2><ul><li>第一课，学会 <strong>Print(…)</strong> 语句</li><li>第二课，使用Turtle绘制直线<br>…</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了让孩子更早的建立起逻辑思维能力，我决定从现在开始教孩子学习一下Python语言。而这里，我会记录一些教孩子学习Python时的具体步骤，以及他学习过程中的一些点滴。&lt;/p&gt;
&lt;p&gt;对于孩子来说，直接在电脑上写代码肯定是枯燥无味的。怎样才能让他想学编程，对编程感趣呢？图形化显然是个好方法。&lt;/p&gt;
&lt;p&gt;我始终认为，教孩子学习编程的第一步不应上来就讲变量、数组、循环等这些基本知识，而是先让他们对编程建立起兴趣来，有了兴趣一切就好办了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="少儿编程" scheme="https://blog.avdancedu.com/categories/%E5%B0%91%E5%84%BF%E7%BC%96%E7%A8%8B/"/>
    
      <category term="python" scheme="https://blog.avdancedu.com/categories/%E5%B0%91%E5%84%BF%E7%BC%96%E7%A8%8B/python/"/>
    
    
      <category term="少儿编程" scheme="https://blog.avdancedu.com/tags/%E5%B0%91%E5%84%BF%E7%BC%96%E7%A8%8B/"/>
    
      <category term="python" scheme="https://blog.avdancedu.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>如何搭建StableDiffusion环境</title>
    <link href="https://blog.avdancedu.com/17d46da4/"/>
    <id>https://blog.avdancedu.com/17d46da4/</id>
    <published>2023-04-15T14:34:15.000Z</published>
    <updated>2023-04-17T04:12:47.845Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/stablediffusion/sd.png"><br>在图像生成领域最牛的两个AI工具非Midjourney和StableDiffusion莫属了。<strong>Midjourney</strong>是收费的，主要以艺术、丰富的色彩见长；而StableDiffusion是开源的，它更擅长处理细节，生成的图像更逼真，尤其擅长生成人像、商品图像，能以假乱真。</p><p>这篇文章主要介绍一下如何在Windows&#x2F;Linux环境下搭建StableDiffusion训练环境。</p><span id="more"></span><h2 id="硬件要求"><a href="#硬件要求" class="headerlink" title="硬件要求"></a>硬件要求</h2><p>搭建StableDiffusion训练环境，首先你要有一张Nvidia显卡，最好内存超过16G，如果是自己搭建主机的的话，建议选择 RTX3090、RTX3090ti、RTX4080、RTX4090这类卡。</p><p>另外，硬盘最好选大此，建议最少 1T 空间，因为一般训练好的 StableDiffusion 模型都要4G左右，训练数据就更多了。</p><p>操作系统选择Windows、Linux都可以，如果是Linux建议使用Ubuntu22.04。</p><h2 id="安装N卡驱动"><a href="#安装N卡驱动" class="headerlink" title="安装N卡驱动"></a>安装N卡驱动</h2><p>当硬件准备好后，可以从这里<a href="https://www.nvidia.cn/Download/index.aspx?lang=cn">下载N卡驱动</a>，根据你的操作系统和N卡类型选择合适的驱动即可。如果你的N卡是我上面建议的几款，那你可以直接下载最新的驱动程序。</p><p>驱动的安装非常简单，按照提示一步步操作即可，这里就不详述了。</p><h2 id="安装Miniconda"><a href="#安装Miniconda" class="headerlink" title="安装Miniconda"></a>安装Miniconda</h2><p>Miniconda是用于隔离不同的Python环境的。其实搭建StableDiffusion环境，并不需要安装Miniconda。但如果你安装了Miniconda，可以让你更方便的安装一些依赖包，同时也方便你切换不同的Python版本。</p><p>因此，我建议你在开始搭建StableDiffusion时将Miniconda安装上。Miniconda的下载地址和基本使用方法可以看<a href="https://avdancedu.com/459b0e30/">这篇文章</a>。</p><h2 id="搭建StableDiffusion"><a href="#搭建StableDiffusion" class="headerlink" title="搭建StableDiffusion"></a>搭建StableDiffusion</h2><p>前面的环境准备好后，接下来我们就可以开始搭建StableDiffusion环境了。</p><p>首先你要知道在 <strong>github</strong> 上有好几个StableDiffusion项目：</p><ul><li>AUTOMATIC1111&#x2F;stable-diffusion-webui，该项目是StableDiffusion-2.1的UI版本，它依赖于下面的StableDiffusion-2.1</li><li>Stability-AI&#x2F;stablediffusion，这个项目是 StableDiffusion-2.1</li><li>CompVis&#x2F;stable-diffusion，该项目是StaleDiffusion-1</li></ul><p>我们在部署时，最好选择 <strong>stable-diffusion-webui</strong> 这个项目，主要原因是这个项目有可视化的操作界面，使用起来比较方便。而我们下面讲的也都是关于 stable-diffusion-webui 的部署。</p><p>要部署 stable-diffusion-webui，第一步先使用 git 命令将它从 github 上下载下来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui.git</span><br></pre></td></tr></table></figure><p>之后，在Windows下运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webui-user.bat</span><br></pre></td></tr></table></figure><p>而在Linux下，需要执行下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./webui-user.sh</span><br></pre></td></tr></table></figure><p>在执行webui-user脚本时，在国内一般都会出错。一方面是有一些依赖包在国内安装不上，另一方面是使用git下载代码时会出错，这些问题该如何解决呢？</p><p>对于前一种情况，建议挂上梯子下载。而后一种则需要修改 <strong>stable-diffusion-webui</strong> 中的<strong>launch.py</strong> 文件。具体的修改位置如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">git_clone(stable_diffusion_repo, repo_dir(<span class="string">&#x27;stable-diffusion-stability-ai&#x27;</span>), <span class="string">&quot;Stable Diffusion&quot;</span>, stable_diffusion_commit_hash)</span><br><span class="line">git_clone(taming_transformers_repo, repo_dir(<span class="string">&#x27;taming-transformers&#x27;</span>), <span class="string">&quot;Taming Transformers&quot;</span>, taming_transformers_commit_hash)</span><br><span class="line">git_clone(k_diffusion_repo, repo_dir(<span class="string">&#x27;k-diffusion&#x27;</span>), <span class="string">&quot;K-diffusion&quot;</span>, k_diffusion_commit_hash)</span><br><span class="line">git_clone(codeformer_repo, repo_dir(<span class="string">&#x27;CodeFormer&#x27;</span>), <span class="string">&quot;CodeFormer&quot;</span>, codeformer_commit_hash)</span><br><span class="line">git_clone(blip_repo, repo_dir(<span class="string">&#x27;BLIP&#x27;</span>), <span class="string">&quot;BLIP&quot;</span>, blip_commit_hash)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>将上面的代码修改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">git_clone(stable_diffusion_repo, repo_dir(<span class="string">&#x27;stable-diffusion-stability-ai&#x27;</span>), <span class="string">&quot;Stable Diffusion&quot;</span>)</span><br><span class="line">git_clone(taming_transformers_repo, repo_dir(<span class="string">&#x27;taming-transformers&#x27;</span>), <span class="string">&quot;Taming Transformers&quot;</span>)</span><br><span class="line">git_clone(k_diffusion_repo, repo_dir(<span class="string">&#x27;k-diffusion&#x27;</span>), <span class="string">&quot;K-diffusion&quot;</span>)</span><br><span class="line">git_clone(codeformer_repo, repo_dir(<span class="string">&#x27;CodeFormer&#x27;</span>), <span class="string">&quot;CodeFormer&quot;</span>)</span><br><span class="line">git_clone(blip_repo, repo_dir(<span class="string">&#x27;BLIP&#x27;</span>), <span class="string">&quot;BLIP&quot;</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上述修改的作用是不让git对下载的源码进行hash值比较，这块的代码逻辑应该是有些问题。</p><p>做了上述修改后，可能运行脚本时还会报错，此时我们可以手工下载对应的源码到指定目录下，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Stability-AI/stablediffusion.git &quot;stable-diffusion-webui/repository/stable-diffusion-stability-ai&quot;</span><br></pre></td></tr></table></figure><p>当手工将需要的所有依赖库源码安装好后，StableDiffusion就可以正常启动了。</p><p>StableDiffusion启动后，它的默认操作地址为: <a href="http://127.0.0.1:7860/">http://127.0.0.1:7860</a></p><p>至此，我们就将StableDiffusion环境搭建好了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总的来说，无论是搭建Stable Diffusion，还是搭建其它的AI工具环境，如Whisper、Segment-Anything都不会一凡风顺，或多或少的都会出现这种或那种环境问题。当遇到问题时，一定不要着急，慢慢来，因为这是我们学习AI的必经之路。</p><p>当你装过几个AI工具之后，就有了经验，而这些经验正是我们进一步学习AI的重要一环。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/stablediffusion/sd.png&quot;&gt;&lt;br&gt;在图像生成领域最牛的两个AI工具非Midjourney和StableDiffusion莫属了。&lt;strong&gt;Midjourney&lt;/strong&gt;是收费的，主要以艺术、丰富的色彩见长；而StableDiffusion是开源的，它更擅长处理细节，生成的图像更逼真，尤其擅长生成人像、商品图像，能以假乱真。&lt;/p&gt;
&lt;p&gt;这篇文章主要介绍一下如何在Windows&amp;#x2F;Linux环境下搭建StableDiffusion训练环境。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://blog.avdancedu.com/categories/AI/"/>
    
    
      <category term="AI" scheme="https://blog.avdancedu.com/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>MiniConda基本操作</title>
    <link href="https://blog.avdancedu.com/459b0e30/"/>
    <id>https://blog.avdancedu.com/459b0e30/</id>
    <published>2023-04-12T00:36:28.000Z</published>
    <updated>2023-04-16T10:50:12.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要使用Conda安装Python环境"><a href="#为什么要使用Conda安装Python环境" class="headerlink" title="为什么要使用Conda安装Python环境?"></a>为什么要使用Conda安装Python环境?</h2><p>Conda是一个开源的软件包管理系统和环境管理系统，不仅能进行包管理，还能够创建隔离的环境，你可以通过它创建不同的Python环境，各Python环境之间相互隔离，互不影响。而我们常用的pip只是一个Python包管理工具，它只能对Python包进行管理，如下载、安装、卸载，去不能像Conda一样创建多个相互隔离的Python环境，因此使用Conda可以帮助我们创建、管理更复杂的Python环境。</p><span id="more"></span><h2 id="Miniconda与Anaconda的区别"><a href="#Miniconda与Anaconda的区别" class="headerlink" title="Miniconda与Anaconda的区别"></a>Miniconda与Anaconda的区别</h2><p>Miniconda是Anaconda的精简版，只包含conda、Python和一些基本的包，而Anaconda是面向数据科学的Python发行版，包含conda、conda-build、Python和100+常用的数据科学常用的库及其依赖。</p><p>总的来说，Miniconda更小、更轻量。对于学习机器学习、深度学习这类工作，使用Miniconda就足够了，这样还能为你节省大量的磁盘空间。</p><h2 id="Miniconda的基本使用"><a href="#Miniconda的基本使用" class="headerlink" title="Miniconda的基本使用"></a>Miniconda的基本使用</h2><ul><li>安装Miniconda</li></ul><p>可以从这里<a href="https://docs.conda.io/en/latest/miniconda.html">下载Miniconda</a>，从中选择合适的操作系统版本即可。</p><ul><li>默认环境</li></ul><p>当Miniconda环境好后，它会为你创建一个默认环境，即 <strong>Base</strong> 环境。你可以直接在这个环境中安装各种Python包。</p><p>当然，一般情况下，我们都会为自己的项目创建一个新的环境。</p><ul><li>创建新的Python环境</li></ul><p>使用Miniconda创建新环境的命令如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n xxx </span><br></pre></td></tr></table></figure><p>在创建环境时，还可以指定Python版本，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n xxx python=3.10.6</span><br></pre></td></tr></table></figure><p>其中 <code>-n xxx</code> 指明你要创建的环境名。<code>xxx</code>用你自己的环境名替代。</p><ul><li>切换到某个环境</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate xxx</span><br></pre></td></tr></table></figure><ul><li>安装包</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install xxx</span><br></pre></td></tr></table></figure><blockquote><p>使用conda安装包时不需要代理</p></blockquote><p>有时候有些包conda中没有，此时你可以使用 pip 安装。注意，使用 pip 安装时需要 <strong>代理</strong> 。</p><ul><li>为Conda添加镜像</li></ul><p>有时默认镜像可能不能满足我们的需求，此时我们可以为conda添加镜像，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure><p>上面命令中，第一行是将 <strong>清华</strong> 的镜像添加到conda中。而第二句的含义是设置conda在输出信息时显示镜像源的URL，这样你就可以看到conda从哪个镜像源下载了软件包。</p><ul><li>为pip添加镜像</li></ul><p>虽然这里讲的是conda，但如果使用conda无法安装包时，我们也会用到pip，所以这里将pip切换镜像的命令也一并列出。</p><p>如果是临时使用，可以使用下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package</span><br></pre></td></tr></table></figure><p>发果是永久使用，则使用下面命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><ul><li>删除之前创建的环境</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove -n xxx <span class="built_in">all</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上就是我们使用conda创建python环境经常用到的一些命令，包括创建、删除、安装、切换镜像等几个基本操作。希望这篇文章可以给你提供一些帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么要使用Conda安装Python环境&quot;&gt;&lt;a href=&quot;#为什么要使用Conda安装Python环境&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用Conda安装Python环境?&quot;&gt;&lt;/a&gt;为什么要使用Conda安装Python环境?&lt;/h2&gt;&lt;p&gt;Conda是一个开源的软件包管理系统和环境管理系统，不仅能进行包管理，还能够创建隔离的环境，你可以通过它创建不同的Python环境，各Python环境之间相互隔离，互不影响。而我们常用的pip只是一个Python包管理工具，它只能对Python包进行管理，如下载、安装、卸载，去不能像Conda一样创建多个相互隔离的Python环境，因此使用Conda可以帮助我们创建、管理更复杂的Python环境。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://blog.avdancedu.com/categories/AI/"/>
    
    
      <category term="AI" scheme="https://blog.avdancedu.com/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>如何打造自己的专属GPT</title>
    <link href="https://blog.avdancedu.com/379d38e0/"/>
    <id>https://blog.avdancedu.com/379d38e0/</id>
    <published>2023-04-07T06:31:10.000Z</published>
    <updated>2023-04-15T14:30:40.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GPT-Plugin-是什么？"><a href="#GPT-Plugin-是什么？" class="headerlink" title="GPT Plugin 是什么？"></a>GPT Plugin 是什么？</h2><p>ChatGPT Plugin 是一种插件，旨在帮助 ChatGPT 访问最新信息、运行计算或使用第三方服务。它可以帮助 ChatGPT 访问外部数据，使得 ChatGPT 可以主动通过访问第三方 API 来获取相关知识。</p><p>Plugin 的推出意味着 OpenAI 正在追求平台化而非聊天机器人。插件的推出被媒体比喻成 AI 领域的 iPhone 时刻。OpenAI 相当于苹果公司，GPT-4 模型相当于苹果的 iPhone，推出的插件系统则相当于软件商店 App Store。</p><span id="more"></span><h2 id="GPT-Plugin是如何工作的？"><a href="#GPT-Plugin是如何工作的？" class="headerlink" title="GPT Plugin是如何工作的？"></a>GPT Plugin是如何工作的？</h2><p>GPT Plugin的具体工作流程如下：</p><ul><li>用户在ChatGPT中输入一个问题或请求</li><li>ChatGPT根据问题或请求的内容和插件的文档，选择合适的插件，并将问题或请求作为参数传递给插件</li><li>插件调用第三方服务或工具，获取结果，或者返回一个错误信息，或者返回一个进一步的问题</li><li>插件将结果，错误信息，或进一步的问题返回给ChatGPT</li><li>ChatGPT根据结果，错误信息，或进一步的问题，生成一个回答或一个跟进的问题，并显示给用户。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant A as 用户</span><br><span class="line">    participant B as ChatGPT</span><br><span class="line">    participant C as GPT插件</span><br><span class="line">    A-&gt;&gt;B: 输入问题或请求</span><br><span class="line">    B-&gt;&gt;C: 选择插件并传递参数</span><br><span class="line">    C-&gt;&gt;B: 返回结果或错误或问题</span><br><span class="line">    B-&gt;&gt;A: 生成回答或问题并显示</span><br></pre></td></tr></table></figure><h2 id="以chatgpt-retrieval-plugin-为例"><a href="#以chatgpt-retrieval-plugin-为例" class="headerlink" title="以chatgpt-retrieval-plugin 为例"></a>以chatgpt-retrieval-plugin 为例</h2><p>GPT插件的实现可以很简单，也可能很复杂。简单的插件如lencx开发的<a href="https://github.com/lencx/chat-todo-plugin">TODO</a>这个Demo，这只有增、改、删、查四项功能，每当收到用户不同的请求后，就在内存中做对应的操作。</p><p>复杂点的插件如<a href="https://github.com/openai/chatgpt-retrieval-plugin">chatgpt-retrieval-plugin</a>，它可以让GPT访问个人或组织的信息源（经过授权），并通过自然语言的问题或需求，获取最相关的信息片段。</p><p>对于<strong>chatgpt-retrieval-plugin</strong>而言，你可以使用该插件来查询你的文件，笔记，邮件或公开文档。该插件首先使用OpenAI的embedding接口，将所有的文档转换为向量，并存储在一个索引中。当用户查询问题时，它会将用户的问题也转为向量，然后与索引中的向量进行比较，找出最相关的信息向量，并将问题向量与信息向量一同返回给GPT，最终让GPT生成一个合理的答案返回给用户。（<strong>向量不理解也没关系，为了便于理解，你可以将这里的向量替换成文本</strong>）</p><h2 id="该如何实现一个GPT-Plugin"><a href="#该如何实现一个GPT-Plugin" class="headerlink" title="该如何实现一个GPT Plugin"></a>该如何实现一个GPT Plugin</h2><p>要实现一个GPT Plugin，你需要先加入<strong>OpenAI的插件等待名单</strong>，等待OpenAI的邀请。</p><p>收到邀请后，你就可以使用OpenAI提供的文档来创建插件了。创建插件时，你需要定义插件的名称，描述，图标，参数，返回值等信息。</p><p>具体来说，插件需要有一个<strong>清单文件</strong>和一个 <strong>OpenAPI规范文件</strong>，来定义插件的配置和 API 的规范。这些文件需要托管在插件的域名下，比如 yourdomain.com&#x2F;ai-plugin.json 和 yourdomain.com&#x2F;api-docs.yaml。</p><p><strong>ai-plugin.json</strong> 是 ChatGPT 插件的清单文件，用于记录插件的基本信息和 API 服务身份验证设置。当通过 ChatGPT UI 安装插件时，系统会在后端查找此文件，如果找不到文件，则无法安装插件。</p><p><strong>api-docs.yaml</strong> 文件的作用是，采用 OpenAPI Specification（OAS）格式定义了一种标准的、与语言无关的 HTTP API 接口，允许人类和计算机理解服务的功能。说白了就是告诉GPT我这个插件提供了哪些接口。</p><p>之后我们要启动一个Web服务，在服务中提供api-docs.yaml文件中说明的接口。参见 <a href="https://github.com/openai/chatgpt-retrieval-plugin">TODO</a> 的实现。</p><h2 id="GPT-Plugin与-GPT-Index技术的迥异"><a href="#GPT-Plugin与-GPT-Index技术的迥异" class="headerlink" title="GPT Plugin与 GPT Index技术的迥异"></a>GPT Plugin与 GPT Index技术的迥异</h2><p>除了GPT Plugin可以外，还有另外一种称为GPT Index的技术。该技术与GPT Plugin有一些相同之处，却又有很大不同。</p><p>通过前面的信息我们可以知道，GPT Plugin处理整个GPT服务的后端，当用户向GPT提出问题时，GPT会先根据用户的问题来选择自己回答还是交给更专来的某个GPT Plugin来回答。</p><p>而GPT index与之相反，它通常用于企业内部的智能服务系统。当企业内的用户查询问题时，先将问题发给自己的服务器，该服务器会利用GPT的embedding API将用户问题转成向量，之后再用问题向量与自己内部存储的文档向量进行比较，找出最相似的几个向量。紧接着将问题向量和相关文档向量一起发送给GPT，让GPT生成一个合理的答案。服务器拿到答案后再转交给用户。</p><p>从中我们不难看出，<strong>GPT Plugin是GPT为了增强自身能力而提出的一种技术手段，前端用户对后端GPT Plugin无感知的一种技术。而GPT index是打造企业私有GPT的一种技术手段</strong>。它们的目标各不相同。</p><p>另外，要使用GPT index，你需要先安装llama-index这个Python库，并导入其中的类和函数。然后，你需要准备一些文档，并将它们转换为向量，并存储在一个索引中。创建索引时，你可以选择不同的索引类型，例如ListIndex, KeywordTableIndex, GPTSimpleVectorIndex等。不同的索引类型有不同的检索方式和优化方法。</p><h2 id="GPT-Plugin有哪些应用场景"><a href="#GPT-Plugin有哪些应用场景" class="headerlink" title="GPT Plugin有哪些应用场景"></a>GPT Plugin有哪些应用场景</h2><p>GPT作为一个通用型的聊天机器人，在很多特定场景下表示并不突出，但有了Plugin，使得GPT可以将触角深入到这些特殊场景下，下面是一些 GPT Plugin典型的应用场景:</p><ul><li>跨行业科普：GPT plugin可以解答各种科技、工业等相关问题，将复杂的技术知识快速简化为易于理解的形式，从而帮助专业领域外的人员了解该领域。</li><li>购物、旅行、餐饮等服务：GPT plugin可以集成各种第三方服务或工具，让用户可以在ChatGPT中直接查询和预订飞机航班，酒店，餐厅，商品等。</li><li>专业计算和数据分析：GPT plugin可以调用Wolfram或其他计算平台，让用户可以在ChatGPT中进行数学和科学的计算，数据分析和可视化，以及文件格式转换等。</li><li>语言学习和翻译：GPT plugin可以调用Speak或其他语言学习平台，让用户可以在ChatGPT中学习和练习外语，或者将任何内容翻译成另一种语言。</li><li>办公自动化和协作：GPT plugin可以调用Zapier或其他办公自动化平台，让用户可以在ChatGPT中操控各种应用，如Google Sheets, Trello, Gmail, HubSpot, Salesforce等，并实现工作流程的自动化。</li></ul><h2 id="GPT-Plugin的未来"><a href="#GPT-Plugin的未来" class="headerlink" title="GPT Plugin的未来"></a>GPT Plugin的未来</h2><p>随着时间的推移，相信GPT会增加更多的插件类型和功能，覆盖更多的行业和场景，如网安，遥感，办公等。</p><p>另外，提高插件的安全性和可靠性，防止插件被滥用或泄露敏感信息，保护用户的隐私和权益，是GPT Plugin需要重点解决的问题。</p><p>而优化插件的交互和体验，让用户可以更方便和自然地使用插件，提高插件的智能度和友好度则是 GPT Plugin的长远目标。</p><p>不可或缺的是，探索插件的创新和商业模式，让插件开发者可以获得更多的收益和激励，让插件用户可以获得更多的价值和服务是GPT可以长久下去的基石头。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;GPT-Plugin-是什么？&quot;&gt;&lt;a href=&quot;#GPT-Plugin-是什么？&quot; class=&quot;headerlink&quot; title=&quot;GPT Plugin 是什么？&quot;&gt;&lt;/a&gt;GPT Plugin 是什么？&lt;/h2&gt;&lt;p&gt;ChatGPT Plugin 是一种插件，旨在帮助 ChatGPT 访问最新信息、运行计算或使用第三方服务。它可以帮助 ChatGPT 访问外部数据，使得 ChatGPT 可以主动通过访问第三方 API 来获取相关知识。&lt;/p&gt;
&lt;p&gt;Plugin 的推出意味着 OpenAI 正在追求平台化而非聊天机器人。插件的推出被媒体比喻成 AI 领域的 iPhone 时刻。OpenAI 相当于苹果公司，GPT-4 模型相当于苹果的 iPhone，推出的插件系统则相当于软件商店 App Store。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://blog.avdancedu.com/categories/AI/"/>
    
    
      <category term="AI" scheme="https://blog.avdancedu.com/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>FaceBook最新的图像分割模型SegmentAnything到底有多厉害？</title>
    <link href="https://blog.avdancedu.com/cd01af8d/"/>
    <id>https://blog.avdancedu.com/cd01af8d/</id>
    <published>2023-04-06T06:15:40.000Z</published>
    <updated>2023-04-12T02:07:28.106Z</updated>
    
    <content type="html"><![CDATA[<p>这两天 Facebook AI Research (FAIR) 团队开发的一种新的图像分割模型，名为 <strong>Segment Anything</strong>。该模型使用了一种新的方法，可以在不需要大量标注数据的情况下，对图像中的任何物体进行分割。这种方法可以帮助计算机视觉领域的研究人员和开发人员更轻松地训练模型，从而提高计算机视觉应用程序的性能。</p><span id="more"></span><p>如果您想了解更多关于“Segment Anything”模型的信息，可以查看<a href="https://ai.facebook.com/blog/segment-anything-foundation-model-image-segmentation/">这篇文章</a>。</p><h2 id="SegmentAnything是什么？"><a href="#SegmentAnything是什么？" class="headerlink" title="SegmentAnything是什么？"></a>SegmentAnything是什么？</h2><p><strong>Segment Anything</strong> 模型是一种新的图像分割模型，它可以在不需要大量标注数据的情况下，对图像中的任何物体进行分割。这种方法可以帮助计算机视觉领域的研究人员和开发人员更轻松地训练模型，从而提高计算机视觉应用程序的性能。</p><p><strong>Segment Anything</strong>模型使用了一种名为“自监督学习”的方法，该方法可以在不需要大量标注数据的情况下训练模型。该模型使用了一个名为“Contrastive Predictive Coding (CPC)”的算法，该算法可以从未标记的图像中学习到有用的特征，并将这些特征用于图像分割任务。</p><p><strong>Segment Anything</strong>模型可以用于许多应用场景，例如：</p><ul><li><p>自动驾驶汽车：自动驾驶汽车需要能够识别道路、车辆和行人等物体，并对它们进行分割。使用<strong>Segment Anything</strong>模型可以更准确地进行物体分割，从而提高自动驾驶汽车的性能。</p></li><li><p>医学图像分析：医学图像通常包含许多不同类型的组织和器官。使用<strong>Segment Anything</strong>模型可以更准确地对这些组织和器官进行分割，从而帮助医生更好地诊断疾病。</p></li><li><p>视频监控：视频监控系统需要能够识别和跟踪不同的对象，并对它们进行分割。使用<strong>Segment Anything</strong>模型可以更准确地进行对象分割，从而提高视频监控系统的性能。</p></li></ul><h2 id="与传统图像分割方法相比SegmentAnything模型的优势和不同？"><a href="#与传统图像分割方法相比SegmentAnything模型的优势和不同？" class="headerlink" title="与传统图像分割方法相比SegmentAnything模型的优势和不同？"></a>与传统图像分割方法相比SegmentAnything模型的优势和不同？</h2><p>与传统图像分割方法相比，<strong>Segment Anything</strong>模型的优势和不同之处主要有以下几点：</p><ul><li><p>不需要大量标注数据：传统的图像分割方法需要大量标注数据才能训练模型，而<strong>Segment Anything</strong>模型可以在不需要大量标注数据的情况下训练模型。</p></li><li><p>可以对任何物体进行分割：传统的图像分割方法通常只能对特定类型的物体进行分割，而<strong>Segment Anything</strong>模型可以对图像中的任何物体进行分割。</p></li><li><p>更准确：与传统的图像分割方法相比，<strong>Segment Anything</strong>模型可以更准确地对图像中的物体进行分割。</p></li><li><p>更快速：由于<strong>Segment Anything</strong>模型不需要大量标注数据，因此可以更快地训练模型。</p></li></ul><p>通过使用<strong>Segment Anything</strong>模型，计算机视觉领域的研究人员和开发人员可以更轻松地训练模型，并提高计算机视觉应用程序的性能。</p><h2 id="如何使用Segment-Anything模型-？"><a href="#如何使用Segment-Anything模型-？" class="headerlink" title="如何使用Segment Anything模型 ？"></a>如何使用Segment Anything模型 ？</h2><p><strong>Segment Anything</strong>可以一键分割和屏蔽任何照片或视频中的任何对象，包括训练期间没有看到的对象和图像类型。同时还发布了配套的数据集，比现有的数据集大400倍。它从输入提示中产生高质量的物体遮罩，用来为图像中的所有物体产生遮罩。它已经在一个由1100万张图像和11亿个遮罩组成的数据集上进行了训练，并在各种分割任务中具有强大的性能。</p><p>如果您想使用Segment Anything模型进行图像分割，可以使用Facebook提供的Segment Anything库。该库是一个PyTorch库，提供了许多预训练模型，包括Segment Anything模型。您可以使用这些预训练模型来进行图像分割，并将其集成到计算机视觉应用程序中。</p><p>这里有个示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the model</span></span><br><span class="line">model = torch.hub.load(<span class="string">&quot;facebookresearch/detectron2&quot;</span>,<span class="string">&quot;mask_rcnn_R_50_FPN_3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Download the image from URL</span></span><br><span class="line">url = <span class="string">&quot;https://images.unsplash.com/photo-1521747116042-5a810fda9664&quot;</span></span><br><span class="line">response = requests.get(url)</span><br><span class="line">img = Image.<span class="built_in">open</span>(BytesIO(response.content))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run the model on the image</span></span><br><span class="line">outputs = model(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Visualize the results</span></span><br><span class="line">v = Visualizer(img[:, :, ::-<span class="number">1</span>], MetadataCatalog.get(model.cfg.DATASETS.TRAIN[<span class="number">0</span>]), scale=<span class="number">1.2</span>)</span><br><span class="line">out = v.draw_instance_predictions(outputs[&amp;quot;instances&amp;quot;].to(&amp;quot;cpu&amp;quot;))</span><br><span class="line">Image.fromarray(out.get_image()[:, :, ::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>这段代码将从URL下载一张图片，然后使用Facebook提供的预训练模型进行图像分割。最后，它将显示分割结果。</p><h2 id="Segment-Anything模型未来发展方向"><a href="#Segment-Anything模型未来发展方向" class="headerlink" title="Segment Anything模型未来发展方向"></a>Segment Anything模型未来发展方向</h2><p>Segment Anything模型的未来发展方向和应用场景是非常广泛的。该模型可以用于许多计算机视觉应用程序，例如自动驾驶汽车、智能家居、安全监控、医疗图像分析等。此外，该模型还可以用于图像编辑和视频编辑，例如删除不需要的对象、更改背景等。这些应用程序将使我们的生活更加便利和安全。</p><p>Segment Anything模型的发布也可能会对计算机视觉行业产生重大影响。它可以帮助研究人员更好地理解图像分割问题，并提供一种新的方法来解决这个问题。此外，它还可以促进计算机视觉领域的进一步研究和发展</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Segment Anything模型的出现是CV界的一个重要里程碑，为人们提供了一把利器，这会技术革命会大大加速社会的变革。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[用户输入文本] --&gt;B(数据预处理);</span><br><span class="line">    B --&gt; C(GPT模型计算);</span><br><span class="line">    C --&gt; D(结果处理);</span><br><span class="line">    D --&gt; E(输出回应);</span><br><span class="line">    E --&gt; F[用户界面]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天 Facebook AI Research (FAIR) 团队开发的一种新的图像分割模型，名为 &lt;strong&gt;Segment Anything&lt;/strong&gt;。该模型使用了一种新的方法，可以在不需要大量标注数据的情况下，对图像中的任何物体进行分割。这种方法可以帮助计算机视觉领域的研究人员和开发人员更轻松地训练模型，从而提高计算机视觉应用程序的性能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://blog.avdancedu.com/categories/AI/"/>
    
    
      <category term="AI" scheme="https://blog.avdancedu.com/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>使用Mac系统下的GPU搭建机器学习环境</title>
    <link href="https://blog.avdancedu.com/eaff035c/"/>
    <id>https://blog.avdancedu.com/eaff035c/</id>
    <published>2023-03-09T02:30:45.000Z</published>
    <updated>2023-03-10T02:11:08.163Z</updated>
    
    <content type="html"><![CDATA[<p>在我的印像中，一直认为在Mac下无法使用GPU进行训练，最近查阅了一些资料，才发我的认知太陈旧了。新版的Pytorch已经支持了多种类型的GPU，这其中也支持了Mac M1下的GPU。</p><p>今天我们就来看看该如何在Mac M1下使用GPU进入机器学习训练。</p><span id="more"></span><h2 id="Anaconda还是Miniconada"><a href="#Anaconda还是Miniconada" class="headerlink" title="Anaconda还是Miniconada?"></a>Anaconda还是Miniconada?</h2><p>使用Python的人都会遇到库的安装、环境的管理问题，Conda就是这样一个工具来帮助你解决这些问题。</p><p>Anaconda想必大家比较熟悉，但是很多人并不知道还有个轻量化的Miniconda。对于有一定基础的Python使用者，我本人更推荐Miniconda的。</p><h3 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h3><ul><li>适合初学者（因为有图形界面，还内置了jupyter lab, spider等等）</li><li>预装了超过1500个科学计算库（99%其实用不上）</li><li>安装比较耗时，也比较占用空间</li><li>因为预装了很多库，所以不需要重复下载。</li><li>可能对一些库做了改进（？）</li></ul><h3 id="Miniconda"><a href="#Miniconda" class="headerlink" title="Miniconda"></a>Miniconda</h3><ul><li>不介意手动安装所需的库（其实这个并不麻烦）</li><li>节省空间和时间</li></ul><p>我个人感觉Anaconda太过笨重，很多人的电脑可能打开Anaconda都需要一点时间。图形化的界面在我看来反应比较迟钝，如果使用命令行其实还不如直接上Miniconda。</p><h2 id="安装Miniconda"><a href="#安装Miniconda" class="headerlink" title="安装Miniconda"></a>安装Miniconda</h2><p>从这里<a href="https://conda.io/en/latest/miniconda.html">下载Miniconda</a>。假设我们使用的Python版本是3.10，执行下面的命令来安装Miniconda:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh Minconda3-xxx-xxx...sh -b</span><br></pre></td></tr></table></figure><p>然后执行下面的命令初始化conda:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/miniconda3/bin/conda init</span><br></pre></td></tr></table></figure><p>至此，Miniconda就安装好了。</p><h2 id="配置新的Python环境"><a href="#配置新的Python环境" class="headerlink" title="配置新的Python环境"></a>配置新的Python环境</h2><p>当Miniconda安装好后，我们可以通过下面的命令创建一个新的Python环境:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name ml python=3.10 -y</span><br></pre></td></tr></table></figure><p>上面我就使用conda创建了一个新的Python环境，名子叫ml，它使用的Python是3.10。<br>不过，虽然我们创建好了Python环境，但它还不能使用，因为在使用之前需要先将它激活。你可以使用下面的命令来激活它:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate ml</span><br></pre></td></tr></table></figure><p>另外，当我们不需要这个环境时，可以通过下面的命令退出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate </span><br></pre></td></tr></table></figure><h2 id="安装pytorch"><a href="#安装pytorch" class="headerlink" title="安装pytorch"></a>安装pytorch</h2><p>前面将Python环境设置好后，接下来就可以安装Pytorch了，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch torchvision torchaudio -c pytorch</span><br></pre></td></tr></table></figure><p>之后，你可以使用下面命令验证你的Mac M1中是否有可用的GPU:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &quot;import torch;print(torch.backends.mps.is_built())&quot;</span><br></pre></td></tr></table></figure><p>如果命令的返回结果为<code>True</code>，说明有GPU可用。</p><h2 id="使用Mac-M1下的GPU"><a href="#使用Mac-M1下的GPU" class="headerlink" title="使用Mac M1下的GPU"></a>使用Mac M1下的GPU</h2><p>在Mac M1下的GPU称作<strong>mps</strong>，它类似于Nvidia的<strong>cuda</strong>。如果你想在Mac M1下使用GPU进行深度学习的训练，只需要将运算指定到mps上运行即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">model = torch.nn.Linear(5,1).to(&#x27;mps&#x27;)</span><br><span class="line">x = torch.randn(5).to(&#x27;mps&#x27;)</span><br><span class="line">y = model(x)</span><br><span class="line">pront(y.shape)</span><br></pre></td></tr></table></figure><p>如上代码所示，该代先首先定义了一个最简单5x1的线性模形，并告诉Pytorch它在Mac M1的GPU上运行；然后给该模形创建一个输入，该输入也是在GPU<br>上，是一个5x5的tensor，最后输出运算结果的维度。</p><p>如果上面的代码可以正常运行，说明你Mac上的GPU确实可以正常工作。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>如果你是一名机器学习的初学者，并且手上有一台Mac电脑的话，你可以直接使用Mac搭建机器学习环境进行学习。这样就可以节省一大笔钱了！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我的印像中，一直认为在Mac下无法使用GPU进行训练，最近查阅了一些资料，才发我的认知太陈旧了。新版的Pytorch已经支持了多种类型的GPU，这其中也支持了Mac M1下的GPU。&lt;/p&gt;
&lt;p&gt;今天我们就来看看该如何在Mac M1下使用GPU进入机器学习训练。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://blog.avdancedu.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://blog.avdancedu.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>深度学习开发环境搭建</title>
    <link href="https://blog.avdancedu.com/73ca35b3/"/>
    <id>https://blog.avdancedu.com/73ca35b3/</id>
    <published>2023-03-05T08:59:47.000Z</published>
    <updated>2023-03-05T11:58:00.712Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/deeplearning/RTX4090.png"><br>最近随着<strong>Midjourney</strong>和<strong>ChatGPT</strong>爆火之后，人工智能，深度学习又开始了新的一波学习浪潮。很多同学在学习深度学习的过程中，苦于没有好的实验环境，半路退场，实在可惜。</p><p>我这里整理了两种搭建深度学习实验环境的方法，希望对大家能有所帮助！</p><span id="more"></span><h2 id="使用免费GPU云主机"><a href="#使用免费GPU云主机" class="headerlink" title="使用免费GPU云主机"></a>使用免费GPU云主机</h2><p>实际上，国际上以<strong>Google</strong>为首的一些大企业，他们知道搭建自己的深度学习环境，不仅成本高而且难度也大，因此为学生和小白们准备了一些免费的GPU云主机，专门供大家学习使用。这些企业真是 <strong>业界良心</strong>，<strong>为这些企业点赞！！！</strong></p><p>下面我们就来看看如何在Google云上申请一台免费的GPU云主机。</p><p>首先，众所周知的原因，你需要有能够访问外网的能力。这一步是逃不过去的。<br>之后，你需要在Google云上注册一个账户，同时绑定信用卡。</p><p>以上两步可能是大多数同学申请免费GPU云主机的最大障碍，没办法，免费也是有代价的：）</p><p>当上述两步完成后，接下来你就可以申请免费GPU云主机了。打开Google的<a href="https://colab.research.google.com/">Colab</a>，之后你应该可以看到下面的界面<br><img data-src="https://cdn.avdancedu.com/image/article/deeplearning/Colaboratory.png"></p><p>有可能你的界面不是中文的而是英文，这没关系只要能进入到这个界面，你就可以申请CPU云主机了。</p><p>进入到该界面后，首先在右侧的欢迎页面中选中一段代码，之后点击图中红线框出来的项 <strong>“代码执行程序”</strong>。</p><p>在弹出的下拉框中选择 <strong>“更改运行时类型”</strong>，如下图所示：<br><img data-src="https://cdn.avdancedu.com/image/article/deeplearning/runtime.png"></p><p>紧接着，在弹出的窗口中选择 <strong>“GPU”</strong>，这样你就拥有了一台带GPU的云主机。</p><p>现在让我们来看看Google有没有给我们分配好GPU，分配的GPU又是哪种型号吧！</p><p>首先我们在Colab中点击右侧的<strong>“+代码”</strong>，如下图所示：<br><img data-src="https://cdn.avdancedu.com/image/article/deeplearning/run_code.png"></p><p>在代码框中输入如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">torch.cuda.is_available()</span><br></pre></td></tr></table></figure><p>之后点击运行，如果看到下面的结果，说明GPU已经分配好了。<br><img data-src="https://cdn.avdancedu.com/image/article/deeplearning/run_code_result.png"></p><p>另外，如果你想知道Google结你分配的GPU型号，可以使用下面的命令查看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!nvidia-smi</span><br></pre></td></tr></table></figure><p><img data-src="https://cdn.avdancedu.com/image/article/deeplearning/GPU_type.png"></p><p>从上图你可以知道，Google给我分配的GPU是<strong>Tesla T4</strong>，这块GPU性能还是蛮不错的。该云主机安装的Nvidia Driver版本是 <strong>525.85.12</strong>，CUDA版本是 <strong>12.0</strong>。</p><p>Goole免费可以申请的GPU主要有三种型号，分别是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P100 &gt; T4 &gt; K80</span><br></pre></td></tr></table></figure><p>其中 P100的性能与 RTX3090Ti差不多。</p><p>如果你觉得Goole给你分配的GPU性能不够，那你还可以申请Pro，每月只要 <strong>$9.9</strong>，还是蛮便宜的。</p><p>如果你觉得在Google上申请免费的GPU太麻烦，也可以自己搭建深度学习环境，下面我再介绍一下如何在自己的主机上搭建环境。</p><h2 id="搭建自己的深度学习环境"><a href="#搭建自己的深度学习环境" class="headerlink" title="搭建自己的深度学习环境"></a>搭建自己的深度学习环境</h2><p>要搭建自己的深度学习环境，你首先要有一台“超级计算机”，最主要的是配一块高端显卡，比如RTX4090、RTX3090TI或RTX3090。配置这样一台主机价格不菲，少说要3W左右。</p><p>我配置的就是RTX3090，性价比还是蛮高的。当然Nvidia还有很多低端显卡，但我不建议购买这些低端显卡，一方面容易买到<strong>矿卡（二手卡）</strong>；另一方面这些卡性能不够，做深度学习训练时会很慢。</p><p>机子配置好了，接下来我们看看如何搭建深度学习环境！</p><p>首先是操作系统，搭建深度学习环境最好使用Ubuntu系统，很多资料都是以Ubuntu系统为基础讲解的。</p><p>当然用Windows环境搭建也没任何问题，我这里就是在Windows系统上安装的。因此，这里我只介绍在Windows下如何搭建深度学习环境，想在Ubuntu下搭建环境的同学可以自己在网上查找资料。</p><p>Windows下搭建深度学习环境的步骤如下：</p><p>首先，安装Nvidia GPU驱动，你可以从<a href="https://www.nvidia.cn/Download/index.aspx?lang=cn">这里</a>下载你与操作系统、显卡匹配的Driver。下载好后双击安装即可。</p><p>之后，安装Anaconda。该工具主要是为了管理多个Python开发环境，你可以从<a href="https://www.anaconda.com/products/distribution/start-coding-immediately">这里</a>下载Anaconda。同样将该包下载好后，双击安装即可。</p><p>紧接着，我们就可以使用Anaconda来创建自己的Python环境了。创建环境的命令如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n ml_env</span><br></pre></td></tr></table></figure><p>通过上述命令，我们就创建了一个名为<strong>ml_env</strong>的python的开发环境。</p><p>接下来，我们可以使用Anaconda安装pytorch、CUDA等包。你可以到pytorch的官网上查看最近的pytorch版本，地址如下：<a href="https://pytorch.org/get-started/locally/">https://pytorch.org/get-started/locally/</a></p><p>并根据自己的实际情况做选择要装哪些包，我的选择如下：<br><img data-src="https://cdn.avdancedu.com/image/article/deeplearning/pytorch_env.png"></p><p>当选择好pytorch版本，操作系统等信息后，它会给你提供一条安装相关包的指令，即</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch torchvision torchaudio pytorch-cuda=<span class="number">11.7</span> -c pytorch -c nvidia</span><br></pre></td></tr></table></figure><p>在执行该执令之前，我们需要将前面创建好的环境名加上，这样可以让这些包只做用于我们刚创建的环境中，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -n ml_env pytorch torchvision torchaudio pytorch-cuda=<span class="number">11.7</span> -c pytorch -c nvidia</span><br></pre></td></tr></table></figure><p>最后使用<code>conda activate ml_env</code>激活环境即可。</p><p>至此，我们自己的深度学习环境就算搭建好了。</p><p>发果你不想用这个环境了，可以调用<code>conda deactivate</code>来返激活python环境。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这里我提供了两种深度学习的开发环境，其中第一种是免费的，难点是你要有访问外网的能力并绑定一张信用卡。这种方法虽然省去了买主机的钱，但绑定信用卡也是很多同学所不愿意的。</p><p>第二种方式是自己购买主机搭建环境，这种方式的最大问题是购买主机的花费太大，对于学生来说，真的很难承受。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/deeplearning/RTX4090.png&quot;&gt;&lt;br&gt;最近随着&lt;strong&gt;Midjourney&lt;/strong&gt;和&lt;strong&gt;ChatGPT&lt;/strong&gt;爆火之后，人工智能，深度学习又开始了新的一波学习浪潮。很多同学在学习深度学习的过程中，苦于没有好的实验环境，半路退场，实在可惜。&lt;/p&gt;
&lt;p&gt;我这里整理了两种搭建深度学习实验环境的方法，希望对大家能有所帮助！&lt;/p&gt;
    
    </summary>
    
    
      <category term="深度学习" scheme="https://blog.avdancedu.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="https://blog.avdancedu.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>揭密OpenVPN工作原理</title>
    <link href="https://blog.avdancedu.com/52f625ca/"/>
    <id>https://blog.avdancedu.com/52f625ca/</id>
    <published>2023-03-03T01:05:13.000Z</published>
    <updated>2023-03-04T04:34:40.880Z</updated>
    
    <content type="html"><![CDATA[<p>由于国内的一些原因，有时候我们要下载些代码，比如WebRTC、Chrome等，必备要通过一些代理软件才能将它们下载下来。</p><p>常见的代理软件包括Virtual Private Network 和 HTTP Proxy，这两种软件的工作机制是不同的，今天我们先来聊聊 Virtual Private Network 是如何工作的，之后有机会我们再来HTTP Proxy是如何工作的。</p><p>说到 Virtual Private Network，比较有名的软件当然是 OpenVPN，今天我们就来看看它是如何工作的。 </p><span id="more"></span> <h2 id="什么是OpenVPN"><a href="#什么是OpenVPN" class="headerlink" title="什么是OpenVPN"></a>什么是OpenVPN</h2><p>OpenVPN是一种开源的虚拟专用网络软件，它由客户端和服务端组成，可以实现虚拟专用网络(VPN)连接。在VPN连接过程中，OpenVPN可以实现代理的功能，将客户端的请求通过VPN服务器代理到目标服务器。</p><p>其代理的基本过程如下：</p><ul><li>首先，OpenVPN客户端通过虚似专用网络向VPN服务器发起连接请求。</li><li>连接建立成功后，当用户访问目标服务器时，数据请求会由OpenVPN客户端发往OpenVPN服务器。</li><li>VPN服务器收到请求后，解析该请求，并路由到目标服务器。</li><li>之后，目标服务器返回响应数据。</li><li>紧接着，VPN服务器将响应数据返回给OpenVPN客户端，而OpenVPN客户端转手将响应数据返回给用户。</li></ul><p>在此过程中，OpenVPN实现了客户端与目标服务器之间的代理。由于客户端的请求经过了VPN服务器的转发，目标服务器不知道请求来自哪个客户端，保护了客户端的隐私。</p><h2 id="TUN与TAP模式"><a href="#TUN与TAP模式" class="headerlink" title="TUN与TAP模式"></a>TUN与TAP模式</h2><p>在OpenVPN中有两种工作模式，一种称为 <strong>TUN</strong>(tunnel)模式，即通道的意思；另一种是<strong>TAP</strong>(Terminal Access Point)模式，即一种网络设备或软件虚拟设备的意思。</p><p><strong>TUN模式</strong>是一种虚拟点对点的网络设备模式。通常用于实现点对点（即主机到主机）虚拟专用网络（VPN）。在TUN模式下，OpenVPN会创建一个虚拟网络接口（通常称为tun0），通过该接口发送和接收IP包。TUN模式通常用于路由网络流量，因此其只能够处理<strong>IP层</strong>（OSI模型中的第3层）数据包，<strong>不能处理链路层</strong>（OSI模型中的第2层）数据包。</p><p><strong>TAP模式</strong>是一种<strong>以太网桥</strong>设备模式。通常用于实现一点对多点（即主机到局域网）虚拟专用网络（VPN）。在TAP模式下，OpenVPN同样会创建一个虚拟网络接口（通常称为tap0），不过该接口与NAT模式下的接口不同，它可以接收和发送<strong>以太网帧</strong>，就像一个物理的以太网接口一样。TAP模式可以处理链路层数据包，因此它可以传输多种类型的网络包，如IP、ARP、NetBIOS等。</p><p>一般来说，<strong>TUN模式更适合用于远程访问，因为它可以更好地控制网络流量，并且可以提供更好的性能。而TAP模式更适合用于网络扩展，因为它可以模拟真实的局域网，并且可以传输多种类型的网络包</strong>。</p><p>因此，我们访问外网是都是使用的TUN模式。</p><h2 id="基本工作原理"><a href="#基本工作原理" class="headerlink" title="基本工作原理"></a>基本工作原理</h2><p><img data-src="https://cdn.avdancedu.com/image/article/OpenVPN/OpenVPN_arch.png"></p><p>当我们打开OpenVPN与服务端建立连接后，OpenVPN首先会创建一个虚似网络接口<strong>tun</strong>，之后使用TLS协议与服务端建立好连接。</p><p>连接建立好后，用户（应用程序）在向目标主机发送数据包时，传输到网层的数据包会被tun虚拟网络接口截获。</p><p>当tun虚拟接口截获数据后，它将为截获的数据进行加密等一系列操作，之后再将数据传给真正的网络设备，在我这里就是 <strong>eth0</strong>。</p><p><strong>eth0</strong>收到数据后，经网络路由，路由到OpenVPN服务端。服务端收到数据后进行解密，再根据目标地址将数据转交给目标主机。</p><p>目标主机收到请求后进行处理，之后将处理结果返回VPN服务器。VPN服务器再将数据返回到发送主机。</p><p>以上就是OpenVPN的基本工作原理。</p><h2 id="如何截获本地数据包"><a href="#如何截获本地数据包" class="headerlink" title="如何截获本地数据包"></a>如何截获本地数据包</h2><p>这里有同学可能会好奇，OpenVPN是如何截获用户的数据包，将其发往VPN服务器，并最终传给目标主机的呢？</p><p>其实非常简单，当使用VPN时，OpenVPN会向本地路由表中添加一个表项，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Internet:</span><br><span class="line">Destination        Gateway            Flags           Netif Expire</span><br><span class="line"><span class="number">0</span>/<span class="number">1</span>                <span class="number">10.8</span><span class="number">.0</span><span class="number">.1</span>           UGScg          utun10 </span><br><span class="line"><span class="keyword">default</span>            <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>        UGScg             en1             </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中 <code>0/1</code>的含义是，将整个网络分成两个大的网段，第一个网段是从 0.0.0.0 到 127.255.255.255，第二个网段是从 128.0.0.0 到 255.255.255.255。</p><p>由于路由规定，具体网段路由的优先权大于默认路由，因此整个网段被分成了两个具体的网络后，其优先权就大于 <code>defulat</code>路由了。所以，所有属于这两个网段的IP包都会被路由到utun10网关，又由于utun10就是VPN网关，因此就保证了所有数据都走了VPN链路。</p><p>总之，当我们在客户端建立好VPN连接后，本地路由表中就增加了<code>0/1</code>这一路由项，从而使得所有的数据都通过VPN出去了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过上面的分析，大家应该清楚OpenVPN到底是如何工作的了。我想对于很多同学来说，理解其工作原理的难点是不知道OpenVPN是如何截获网络数据包的，实际上就是通过增加一个本地路由配置，从而达到的截获数据包的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于国内的一些原因，有时候我们要下载些代码，比如WebRTC、Chrome等，必备要通过一些代理软件才能将它们下载下来。&lt;/p&gt;
&lt;p&gt;常见的代理软件包括Virtual Private Network 和 HTTP Proxy，这两种软件的工作机制是不同的，今天我们先来聊聊 Virtual Private Network 是如何工作的，之后有机会我们再来HTTP Proxy是如何工作的。&lt;/p&gt;
&lt;p&gt;说到 Virtual Private Network，比较有名的软件当然是 OpenVPN，今天我们就来看看它是如何工作的。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="OpenVPN" scheme="https://blog.avdancedu.com/categories/OpenVPN/"/>
    
    
      <category term="OpenVPN" scheme="https://blog.avdancedu.com/tags/OpenVPN/"/>
    
  </entry>
  
  <entry>
    <title>Windows下编译Chrome浏览器</title>
    <link href="https://blog.avdancedu.com/a5b21a51/"/>
    <id>https://blog.avdancedu.com/a5b21a51/</id>
    <published>2023-03-01T05:16:00.000Z</published>
    <updated>2023-03-01T05:17:37.720Z</updated>
    
    <content type="html"><![CDATA[<p>随着技术的进步，浏览器在未来会扮演越来越得要的角色。我们基本可以确定，在不久的将来，大部分Native应用都会被Web应用所替代。因此，如果你想今后想找一份好工作，或写出更高效的Web应用，就必须要了解一下浏览器的工作原理。</p><p>了解浏览器工作原理的方法有很多，但对Chrome源码的阅读无缝是第一位的，只有这样我们才能获取第一手材料。</p><p>而阅读Chrome源码的第一位就是要能够下载或编译Chrome源码。而这篇文章就是告诉你如何下载并编译Chrome源码的。</p><span id="more"></span><h2 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h2><p>编译Chrome源码要满足以下几点要求：</p><ul><li>具有至少 8GB RAM 的 64 位 Intel 机器。<strong>这里强烈建议超过 16GB，我用的是 32GB</strong></li><li>NTFS 格式的文件系统，至少要有 100GB 可用的磁盘空间。<strong>注意，FAT32文件系统不能用于编译Chrome，因为一些 Git 文件大于 4GB</strong></li><li>编辑器需要使用 Visual Studio 2022</li><li>操作系统是 Windows 10 或更新版本</li></ul><h2 id="安装Visual-Studio"><a href="#安装Visual-Studio" class="headerlink" title="安装Visual Studio"></a>安装Visual Studio</h2><p>编译 Chromium 源码我们需要安装 <strong>Visual Studio 2022 (&gt;&#x3D;17.0.0)</strong> 才行。虽然编译和调试 Chromium 使用的是 <strong>clang-cl</strong> 编译器，但它需要 Visual Studio 的一些头文件、库和工具。</p><p>当然，Visual Studio最好选择专业版，但如果你没有专业版的License，也可以使用社区版，即 <strong>Visual Studio Community Edition</strong>。</p><p>此外，在安装VS时，你还必须安装 <strong>“使用 C++ 进行桌面开发”</strong> 组件和 <strong>“MFC&#x2F;ATL 支持”</strong> 子组件。如何你不知道如何在安装界面中选择这些组件，可以使用下面的命令行安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ PATH_TO_INSTALLER.EXE ^</span><br><span class="line">--add Microsoft.VisualStudio.Workload.NativeDesktop ^</span><br><span class="line">--add Microsoft.VisualStudio.Component.VC.ATLMFC ^</span><br><span class="line">--includeRecommended</span><br></pre></td></tr></table></figure><h2 id="安装Windows-SDK"><a href="#安装Windows-SDK" class="headerlink" title="安装Windows SDK"></a>安装Windows SDK</h2><p>编译Chrome源码，Windows SDK是少不了的，它对SDK有如下要求：</p><ul><li>你必须安装 <code>10.0.22621.0</code> 版本的<strong>Windows 11 SDK</strong>。注意，<strong>即使在Win10系统下，也要安装Windows 11 的SDK，这一点特别重要</strong></li><li><a href="https://developer.microsoft.com/en-us/windows/downloads/windows-sdk/">Windows SDK</a> 可以单独安装，也可以通过 Visual Studio 来安装。这里建议采用单独的方式安装。<strong>安装好Windows SDK 后，记得要重启一下系统</strong>。</li><li>安装Window SDK时，还必须安装 10.0.22621.755 (Windows 11) SDK 调试工具，以支持 Chrome 能访问大于 4 GiB PDB 的大页面。如果你不知道该如何选择的话，建议你安装Windows SDK时，<strong>将所有选项都勾选上</strong>，否则后面编译时会出现各种头文件找不到的情况。</li></ul><h2 id="安装depot-tools"><a href="#安装depot-tools" class="headerlink" title="安装depot_tools"></a>安装depot_tools</h2><p>首先，从这里下载 <a href="https://storage.googleapis.com/chrome-infra/depot_tools.zip">depot_tools</a> 包，并将其解压到某个目录下，例如：C:\src\depot_tools。</p><blockquote><p>注意：解压缩时，不要采用拖放或复制粘贴的方式提取。这种方法无法将隐藏的 <strong>“.git”</strong> 文件夹提取出来，而这是 depot_tools 自动更新时所必需的。</p></blockquote><p>之后，将 depot_tools 添加到 PATH 环境变量的开头（必须在任何 Python 安装之前）。</p><p>假设你将depot_tools解压到了 C:\src\depot_tools目录下，打开：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">控制面板 → 系统和安全 → 系统 → 高级系统设置</span><br></pre></td></tr></table></figure><p>如果你有管理员权限，请修改 PATH 系统环境变量，将C:\src\depot_tools放到PATH的最前面（或至少放在可能已经有 Python 或 Git 副本的任何目录的前面）。</p><p>如果您没有管理员权限，可以将其添加到用户级 PATH 环境变量中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">控制面板→系统和安全→系统→搜索“为您的帐户编辑环境变量”</span><br></pre></td></tr></table></figure><p>不过，在没有管理员权限的情况下，当你的系统 PATH 中已经指定了Python路径，那么你就无法使用depot_tools中的python了。这将导致你无法顺利的将源码下载下来。所以 <strong>建议你还是找台有管理员权限的主机</strong>。</p><p>另外，还要在环境变是中添加 DEPOT_TOOLS_WIN_TOOLCHAIN 变量，并将其设置为 0。这会告诉 depot_tools 使用本地安装的 Visual Studio （默认情况下，depot_tools 将尝试使用 google 内部版本）。</p><p>除此之外，你还须设置一个名为 <strong>vs2022_install</strong>的环境变量，用于指定vs2022 的安装路径，如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set vs2022_install=C:\Program Files\Microsoft Visual Studio\2022\Professional</span><br></pre></td></tr></table></figure><p>之后，你就可以在 <strong>命令行窗口(CMD)</strong> 中运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gclient</span><br></pre></td></tr></table></figure><p>来下载、更新必要的工具了。</p><p>首次运行gclient命令时， 它会安装一些特定的工具，如 msysgit 和 python。执行该命令时需要<strong>注意</strong>：</p><ul><li>如果您从 <strong>非命令行(CMD)</strong> 中（例如，cygwin、PowerShell）运行 gclient，它看起来可能运行正常，但 msysgit、python 以及其他工具却无法正确安装。所以你必须在标准的命令行窗口中运行glient</li><li>如果你第一次运行 gclient 时，看到一些陌生的错误，你可能需要禁用<a href="https://tortoisesvn.net/faq.html#cantmove2">Windows Indexing</a></li></ul><h2 id="检查-python-安装"><a href="#检查-python-安装" class="headerlink" title="检查 python 安装"></a>检查 python 安装</h2><p><code>gclient</code>执行完成后，在命令行窗口中键入<code>where python</code>，确认 <strong>depot_tools</strong> 中的<code>python.bat</code>位于任何其它 <code>python.exe</code> 之前。否则的话，会导致使用 gn 时出现构建失败，详细信息参见<a href="https://crbug.com/611087">crbug.com&#x2F;611087</a>。</p><p><a href="https://docs.microsoft.com/en-us/windows/apps/desktop/modernize/desktop-to-uwp-extensions#alias">App Execution Aliases</a>这项服务可能与系统上安装的其他 python 有冲突，因此，需要将它关闭掉，具体方法是打开控制面板中的 <strong>“App execution aliases”</strong>，勾掉指向“python.exe”和“python3.exe”的复选框来禁用它们。</p><h2 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h2><p>由于众所周知的原因，在国内是不能直接下载Chrome源码的。因此，你要找一个靠谱的代理软件，而且给它一个最大的带宽。</p><p>我在下载的过程中，就由于网络的原因失败了好几次，既浪费的时间又浪费的金钱。</p><p>后来不得以，购买了10M的专线才好不容易将代码下载成功。</p><h2 id="获取代码"><a href="#获取代码" class="headerlink" title="获取代码"></a>获取代码</h2><p>首先，配置 Git：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;My Name&quot;</span><br><span class="line">$ git config --global user.email &quot;my-name@chromium.org&quot;</span><br><span class="line">$ git config --global core.autocrlf false</span><br><span class="line">$ git config --global core.filemode false</span><br><span class="line">$ git config --global branch.autosetuprebase always</span><br></pre></td></tr></table></figure><p>接着，创建一个chromium目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir chromium &amp;&amp; cd chromium</span><br></pre></td></tr></table></figure><p>之后，运行<code>fetch</code>命令，将代码及其依赖check out出来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ fetch chromium</span><br></pre></td></tr></table></figure><p><strong>如果在checkout时，你不想要完整的repo历史记录，你可以给fetch添加<code>--no-history</code>标志，这样可以减少你获取代码的时间。</strong></p><p>获取代码时，即使你网络很快，预计也要会花费一个多小时才能将它下载下来。而在较慢的网络上，则需要数个小时。所以，您必须配置好你的PC，使它在获取代码时不要休眠，否则失败了还要重新下。</p><p><strong>如果在获取子仓库时发生错误</strong>，你可以选择重新开始，或者进入到 <strong>chromium&#x2F;src</strong> 目录，执行下面的命令来继续下载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gclient sync</span><br></pre></td></tr></table></figure><p>完成fetch后，它将创建一个隐藏的 <strong>.gclient</strong> 文件和一个 <strong>src</strong> 的目录。接下来，你需要切换到src目录下： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd src</span><br></pre></td></tr></table></figure><h2 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h2><p>Chromium 使用 <strong>Ninja</strong> 作为其主要构建工具，并使用名为 <strong>GN</strong> 的工具来生成.ninja文件。您可以创建任意数量的具有不同配置的构建目录。命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gn gen out/Default</span><br></pre></td></tr></table></figure><ul><li>您只需为每个新的构建目录运行一次，Ninja 将根据需要更新构建文件。</li><li>可以将Default换成别的名字，但应该在out子目录下。</li><li>对于其他构建参数，包括Release设置或使用 Visual Studio 的版本，请参阅 <a href="https://www.chromium.org/developers/gn-build-configuration">GN build configuration</a>。默认创建的是与当前操作系统和CPU匹配的Debug版本。</li><li>有关 GN 的更多信息，可以运行<code>gn help</code>阅读<a href="https://gn.googlesource.com/gn/+/main/docs/quick_start.md">快速入门指南</a>。</li></ul><h2 id="编译Chromium"><a href="#编译Chromium" class="headerlink" title="编译Chromium"></a>编译Chromium</h2><p>可以使用以下命令构建 Chromium（“chrome”目标）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ autoninja - C out \Default chrome</span><br></pre></td></tr></table></figure><p>autoninja是一个包装器，它会为ninja提供最佳的参数。</p><p>关于一些参数的详细信息，可以通过 <code>gn ls out/Default</code>获取。</p><h2 id="更快的编译"><a href="#更快的编译" class="headerlink" title="更快的编译"></a>更快的编译</h2><p>我们可以通过下面的方法来加快编译速度：</p><ul><li>关闭防病毒软件，从而减少文件系统开销</li><li>将构建树存储在快速磁盘（最好是 SSD）上</li><li>内核越多越好，即使 64GB 也不算多</li></ul><p>还有一些 gn 参数可以提高构建速度，可以考虑使用的一些设置如下：</p><ul><li>is_component_build &#x3D; true，这会使用更多、更小的 DLL，并且可以避免每次更改后都必须重新链接 chrome.dll。</li><li>enable_nacl &#x3D; false，这会禁用本地构建通常不需要的 Native Client。</li><li>target_cpu &#x3D; “x86”，x86 构建可能比 x64 构建稍快。请注意，如果您设置了它，但不设置enable_nacl &#x3D; false，那么构建时间可能会变得更糟。</li><li>blink_symbol_level &#x3D; 0，关闭 blink 的源代码级调试以减少构建时间，如果您不打算调试 blink，可以这么干。</li><li>v8_symbol_level &#x3D; 0，关闭 v8 的源代码级调试以减少构建时间，如果您不打算调试 v8，可以这么干。</li></ul><p>为了加快链接速度，您可以设置symbol_level&#x3D;1 或 symbol_level&#x3D;0，这些选项减少编译器和链接器所做的工作：</p><ul><li>symbol_level &#x3D; 1，指明编译器要发出文件名和行号信息，因此您仍然可以进行源代码级调试，但不会有局部变量或类型信息。</li><li>symbol_level &#x3D; 0，表示没有源代码级调试，但调用堆栈仍然有函数名称。</li><li>此外，更改symbol_level需要重新编译所有内容。</li></ul><p>另外，谷歌员工应该使用分布式编译系统goma。详细信息可在内部获得，但相关的 gn arg 是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use_goma = true</span><br></pre></td></tr></table></figure><p>要从 goma 中获得任何好处，重要的是将大的 -j 值传递给 ninja。一个好的默认值是 10<em>numCores 到 20</em>numCores。如果你运行 autoninja， 那么它会自动将适当的 -j 值传递给 ninja 是否为 goma。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ autoninja - C out \Default chrome</span><br></pre></td></tr></table></figure><p>调用 ninja 时，可以执定要编译的目标，如将 <strong>“chrome”</strong> 指定为目标，以避免同时构建所有测试二进制文件。</p><p><strong>尽管如此，在许多机器上构建仍需要花费数小时。</strong></p><h2 id="运行-Chromium"><a href="#运行-Chromium" class="headerlink" title="运行 Chromium"></a>运行 Chromium</h2><p>编译完成后，你就可以运行编译出的浏览器了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$out\Default\chrome.exe</span><br></pre></td></tr></table></figure><h2 id="运行测试目标"><a href="#运行测试目标" class="headerlink" title="运行测试目标"></a>运行测试目标</h2><p>您可以用下面的方式运行测试。还可以使用 arg 限制运行哪些测试 <code>--gtest_filter</code>，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$out\Default\unit_tests.exe --gtest_filter = &quot;PushClientTest.*&quot;</span><br></pre></td></tr></table></figure><p>这些参数可以在其<a href="https://github.com/google/googletest">GitHub页面</a>上找到更多有关 GoogleTest 的信息。</p><h2 id="更新checkout"><a href="#更新checkout" class="headerlink" title="更新checkout"></a>更新checkout</h2><p>更新存在的代码，可以运行下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase-update</span><br><span class="line">$ gclient sync -D</span><br></pre></td></tr></table></figure><ul><li><p>第一个命令，更新 Chromium 的主要源代码仓库，并重新设置任何本地分支。如果你不想使用这个脚本，你也可以使用git pull或其他常用的 Git 命令来更新 repo。</p></li><li><p>第二个命令，将子仓库同步到适当的版本，删除不再需要的版本，并根据需要重新与运行挂钩。</p></li></ul><h2 id="使用-Visual-Studio-IDE-进行编辑和调试"><a href="#使用-Visual-Studio-IDE-进行编辑和调试" class="headerlink" title="使用 Visual Studio IDE 进行编辑和调试"></a>使用 Visual Studio IDE 进行编辑和调试</h2><p>您可以使用 Visual Studio IDE 编辑和调试 Chrome。</p><h3 id="使用-Visual-Studio-Intellisense（智能感知）"><a href="#使用-Visual-Studio-Intellisense（智能感知）" class="headerlink" title="使用 Visual Studio Intellisense（智能感知）"></a>使用 Visual Studio Intellisense（智能感知）</h3><p>如果您想在开发 Chromium 时使用 Visual Studio Intellisense，请在生成输出目录时使用–ide命令行参数。这是一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gn gen -- ide = vs --ninja-executable=C:\src\chromium\src\third_party\ninja\ninja.exe out\Default </span><br><span class="line">$ devenv out\Default\all.sln</span><br></pre></td></tr></table></figure><p>GN 将在您的构建目录中生成一个all.sln文件。其在内部使用 Ninja 进行编译。如果您再次手动运行“gen”，你需要重新提供此参数，但通常 GN 会在构建时自动将构建与IDE文件保持一致。</p><p>另外，由于生成的解决方案中包含数千个项目，因此加载速度非常慢。可以使用 <strong>–filters</strong> 参数来限制你感兴趣的代码生成在项目文件中。当然，这样也会限制一些文件无法在项目资源管理器中出现，但调试仍然有效。您可以手动打开文件，设置断点。极端情况下，最小的solution中不包含任何文件，但仍然可以让你在VS中编译和运行Chrome。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gn gen --ide=vs --ninja-executable=C:\src\chromium\src\third_party\ninja\ninja.exe --filters=//chrome --no-deps out\Default</span><br></pre></td></tr></table></figure><p>您可以有选择地将您关心的其他目录添加到过滤器中，如下所示<code>--filters=//chrome;//third_party/WebKit/*;//gpu/*</code></p><p>更多的信息请运行 gn help gen 查看相关的文档。</p><h3 id="在没有-Intellisense-的情况下使用-Visual-Studio"><a href="#在没有-Intellisense-的情况下使用-Visual-Studio" class="headerlink" title="在没有 Intellisense 的情况下使用 Visual Studio"></a>在没有 Intellisense 的情况下使用 Visual Studio</h3><p>没有 Intellisense，你仍然可以在 Visual Studio 中调试和开发 Chrome。你只需在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File-&gt;Open-&gt;Project/Solution</span><br></pre></td></tr></table></figure><p>中，打开chrome.exe 这个二进制文件，或在命令窗口中输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devenv /debugexe out\Debug\chrome.exe &lt;your arguments&gt;</span><br></pre></td></tr></table></figure><p>即可。</p><p>在这种情况下，就不能浏览代码了，但通过安装<a href="https://chromium.github.io/vs-chromium/">VsChromium Visual Studio Extension</a>，可以获得源代码以及其他有用的功能（例如代码搜索）。</p><p>当然，你也可以将多个感兴趣的可执行文件，如base_unittests.exe、browser_tests.exe，添加到你的解决方案中，右键单击Solution Explorer，设置调试的程序为 <strong>Set as Startup Project</strong>。</p><p>默认情况下，当您在 Visual Studio 中开始调试时，调试器将仅附加到浏览器的主进程。要调试所有 Chrome，请安装Microsoft 的 <strong>Child Process Debugging Power Tool</strong> 工具。此外，您还需要以管理员身份运行 Visual Studio，否则它会默认是无法附加到 Chrome 的某些子进程的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上就是下载和编译Windows Chromium源码的过程。在源码的下载过程中很容易失败，解决的办法是首先保障你的网络是可以正确的、高质量的访问外网，这一步是最关键的，之后如果失败了就多次偿试。</p><p>总之一句话，有好的、高质量的、高速的带宽是你下载Chrome源码的关键。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着技术的进步，浏览器在未来会扮演越来越得要的角色。我们基本可以确定，在不久的将来，大部分Native应用都会被Web应用所替代。因此，如果你想今后想找一份好工作，或写出更高效的Web应用，就必须要了解一下浏览器的工作原理。&lt;/p&gt;
&lt;p&gt;了解浏览器工作原理的方法有很多，但对Chrome源码的阅读无缝是第一位的，只有这样我们才能获取第一手材料。&lt;/p&gt;
&lt;p&gt;而阅读Chrome源码的第一位就是要能够下载或编译Chrome源码。而这篇文章就是告诉你如何下载并编译Chrome源码的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="https://blog.avdancedu.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="Chrome" scheme="https://blog.avdancedu.com/tags/Chrome/"/>
    
      <category term="windows" scheme="https://blog.avdancedu.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>网络开发点滴.md</title>
    <link href="https://blog.avdancedu.com/6373ddbf/"/>
    <id>https://blog.avdancedu.com/6373ddbf/</id>
    <published>2023-02-28T11:32:59.000Z</published>
    <updated>2023-04-16T12:10:18.156Z</updated>
    
    <content type="html"><![CDATA[<p>这里记录一些网络开发时的知识点</p><span id="more"></span><h2 id="为什么不建议使用0-0-0-0这个IP地址"><a href="#为什么不建议使用0-0-0-0这个IP地址" class="headerlink" title="为什么不建议使用0.0.0.0这个IP地址?"></a>为什么不建议使用0.0.0.0这个IP地址?</h2><p>在云主机上，不建议绑定 <strong>0.0.0.0</strong> 这个IP地址。其原因是，<strong>0.0.0.0</strong> 表示所有可用的IP地址，如果服务绑定在0.0.0.0上，将允许来自任何网络接口的所有请求都能够到达该服务，从而可能导致安全风险。例如，如果你的云主机同时有内网IP和外网IP，你可能只希望服务只监听外网IP地址，这样可以避免来自内网的非授权访问。</p><p>因此，在云主机上，建议将服务绑定到具体的IP地址上，以增加网络安全性。</p><h2 id="在云主机上有内网和外网地址，我们该用哪个？"><a href="#在云主机上有内网和外网地址，我们该用哪个？" class="headerlink" title="在云主机上有内网和外网地址，我们该用哪个？"></a>在云主机上有内网和外网地址，我们该用哪个？</h2><p>如果在云主机有一个公网 IP 和一个内网 IP，而您的网络服务需要对外提供服务，则应该使用公网 IP 地址和端口号。这样，外部用户可以通过 Internet 连接到您的服务。</p><p>如果您的服务只在内部网络中使用，那么可以使用内网 IP 地址和端口号。这样，只有内部网络中的用户才能连接到您的服务。</p><p>需要注意的是，在使用公网 IP 地址时，还需要在防火墙中打开相应的端口，以便外部用户可以连接到您的服务。而在使用内网 IP 地址时，通常不需要打开防火墙，因为内部网络是相对安全的，只有经过授权的用户才能连接到您的服务。</p><h2 id="客户端无法联网，如何判断是无法与路由器连接还是无法与与互联网连接？"><a href="#客户端无法联网，如何判断是无法与路由器连接还是无法与与互联网连接？" class="headerlink" title="客户端无法联网，如何判断是无法与路由器连接还是无法与与互联网连接？"></a>客户端无法联网，如何判断是无法与路由器连接还是无法与与互联网连接？</h2><p>可以通过向默认网关发ping消息来判断是否主机能与路由器联接。如果客户端可以收到路由器的返馈包，说明两者联接是好的。否则说明无法与路由器连接。</p><p>之后可以向一台云主机发包，如果云主机可以往回数据说明网络联接是好的，否则说明路由器无法联网。</p><h2 id="如何判断客户端主机IP是否被劫持了？"><a href="#如何判断客户端主机IP是否被劫持了？" class="headerlink" title="如何判断客户端主机IP是否被劫持了？"></a>如何判断客户端主机IP是否被劫持了？</h2><p>可以向多台云主机发送数据包，让云主机获取到的客户端主机IP地址返回，如果一致说明没有被劫持，否则说明某条线路的IP地址被劫持了。</p><h2 id="VPN突然连不上了问题分析"><a href="#VPN突然连不上了问题分析" class="headerlink" title="VPN突然连不上了问题分析"></a>VPN突然连不上了问题分析</h2><p>前两天VPN还好好的，结果这两天就突然不能使了，这是啥原因呢？下面记录一下我分析这个问题的过程。</p><ul><li><p>首先登陆到云主机上，看端口是否已经开启了。需要注意的是确认端口是TCP还是UDP。默认VPN端口都是UDP端口1194。</p></li><li><p>对于TCP端口可以使用telnet验证是否处于服务端态，而对于UDP端口则可以使用 nmap 或 nc 来验证。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nmap -sU -p 1194 xxx.xxx.xxx.xxx</span><br></pre></td></tr></table></figure><p>上述命令中 <strong>-sU</strong> 指明扫描UDP协议，**-p** 指明要扫描的端口。或者使用 <strong>nc</strong> 命令，其具体格式如下:</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -vuz xxx.xxx.xxx.xxx 1194</span><br></pre></td></tr></table></figure><p> 其中 <strong>-v</strong> 表示输出详细信息；**-u** 表示扫描UDP端口；**-z** 表示zero I&#x2F;O。</p></li><li><p>如果服务的端口是OK的，接下来要到云主机上抓包，看一下进&#x2F;出包是否正常。可以使用以下面的命令来抓包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 udp port 1194</span><br></pre></td></tr></table></figure></li><li><p>如果进&#x2F;出包也正常，则需要再客户端抓包，可以使用wireshark抓包。</p></li></ul><p>我这次的问题就是通过分析客户端的抓包情况才找到真正原因的。</p><p>云主机进&#x2F;出包正常，而客户端只有出包没有入包，说明包从云主机出来后，被拦截了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里记录一些网络开发时的知识点&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络传输" scheme="https://blog.avdancedu.com/categories/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93/"/>
    
    
      <category term="网络传输" scheme="https://blog.avdancedu.com/tags/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS下安装TikTok的过程</title>
    <link href="https://blog.avdancedu.com/6da5b967/"/>
    <id>https://blog.avdancedu.com/6da5b967/</id>
    <published>2023-02-21T11:59:00.000Z</published>
    <updated>2023-02-22T04:55:29.521Z</updated>
    
    <content type="html"><![CDATA[<p>TikTok是头条的产品，但该产品主要投放在欧美，在国内是不允许下载的。</p><p>不过有很多同学也想在国内使用TikTok，有没有办法呢？</p><p>我今天做了一个偿试还真行，下面是我整理的一个过程，分享给大家希望对你能有所帮助。</p><span id="more"></span><h2 id="切换AppID国家"><a href="#切换AppID国家" class="headerlink" title="切换AppID国家"></a>切换AppID国家</h2><p>要想在 AppStore 中下载 TikTok，最重要的一步是切换你的AppID所在的国家，比如你选择 AppID的国家为美国后，你的手机就会连美国的AppStore，由于美国的AppStore没有禁用TikTok，所以此时你就可以将TikTok下载到你手上了。</p><p>网上有各种切换AppID国家的方法，我大体都试了，绝大部分都不好使。有的甚至说要你重新创建一个新帐号，其实这些方法都是错误的。</p><p>正确的方法是 <strong>不要在手机上进行AppID国家的切换，而应该在PC端的浏览器上打开appid.apple.com这个网址</strong>，之后用你当前手机上的Appid登录。</p><p>登录到你的AppID管理界面后，选择 <strong>“个人信息”</strong>，之后选择 <strong>国家和地区</strong>，在这里进行国家的切换即可。</p><p>还是以美国为例，当你将AppID切换到美国后，你可以将付款方式选为 <strong>None</strong>，再填入一个假的美国地址和手机号就好了。</p><p>此时，你在手机上选择 <strong>设置</strong> 中的第一项(AppID)，点进去后选择 <strong>媒体与购买项目</strong>，之后选择退出。接下来，你再走一次这个流程重新等了你的AppID</p><p>这样你就成功将AppID的国家更新成美国了。</p><h2 id="下载-TikTok-等软件"><a href="#下载-TikTok-等软件" class="headerlink" title="下载 TikTok 等软件"></a>下载 TikTok 等软件</h2><p>当将AppID的国家切换好后，现然你就可以下载 TikTok了。除了 TikTok，其它在国内下不了的软件你也可以下载了。</p><p>现在虽然 TikTok 已经可以成功安装到手机上了，但还注册不了用户，因为TikTok只允许非国内及香港的地区使用。</p><p>所以此时我们就要使用一些翻墙工具了。</p><h2 id="OpenXXX如何导入配置文件"><a href="#OpenXXX如何导入配置文件" class="headerlink" title="OpenXXX如何导入配置文件"></a>OpenXXX如何导入配置文件</h2><p>这里我顺便提一句，当我们使用OpenXXX时，会发现它需要先导入Profile文件，而在iPhone中又不能访问文件系统，这该如何是好呢？</p><p>有一个比较巧妙的办法，我们可以将profile文件以附件的形式发到网易邮箱中，再在iPhone上下载一个邮箱客户端，打开邮件时，就可以选择查看附件的应用程序了。</p><p>此时我们选择OpenXXX，这样就可以直接将这个profile文件加载到OpenXXX中，后面就可以愉快的玩耍了！</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总之，在国内想使用TikTok还是一件很麻烦的事儿，如果不是必须要使用该软件的话，建议还是别折腾了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TikTok是头条的产品，但该产品主要投放在欧美，在国内是不允许下载的。&lt;/p&gt;
&lt;p&gt;不过有很多同学也想在国内使用TikTok，有没有办法呢？&lt;/p&gt;
&lt;p&gt;我今天做了一个偿试还真行，下面是我整理的一个过程，分享给大家希望对你能有所帮助。&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂项" scheme="https://blog.avdancedu.com/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="海外软件安装" scheme="https://blog.avdancedu.com/tags/%E6%B5%B7%E5%A4%96%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>Vue经验点滴</title>
    <link href="https://blog.avdancedu.com/75e8ef30/"/>
    <id>https://blog.avdancedu.com/75e8ef30/</id>
    <published>2023-02-20T10:05:29.949Z</published>
    <updated>2023-02-22T04:57:36.419Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Vue开发项目的过程中遇到了很多问题，其中有一些是特别值得整理出来以备后用的。</p><p>所以我觉得值得记录下来的知识点都列在这篇文章中，希望对你也能有所帮助。</p><span id="more"></span><h2 id="如何在Vue中创建-Web-Worker线程"><a href="#如何在Vue中创建-Web-Worker线程" class="headerlink" title="如何在Vue中创建 Web Worker线程"></a>如何在Vue中创建 Web Worker线程</h2><p>在javascript中创建 Worker线程非常容易，你可以随便在网上找到一篇详解文章。</p><p>同样的方法在Vue中就不好用了。下面是在Vue中创建 Web Worker的正确做法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myworker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&#x27;./workers/worker&#x27;</span>, <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>), &#123;<span class="attr">type</span>: <span class="string">&#x27;module&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">myworker.<span class="property">onmessage</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码中有两上点需要注意：</p><ul><li>创建worker线程时，一定要用 <code>new URL(...)</code>指明woker.js文件的位置，否则无法成功创建woker线程。</li><li>onmessage 函数最好使用箭头函数，否则如果在其内部使用this指针时，该this指定指向的不是worker调用者的上下文。</li></ul><h2 id="如何在Vue中引入一个纯-javascript-库"><a href="#如何在Vue中引入一个纯-javascript-库" class="headerlink" title="如何在Vue中引入一个纯 javascript 库"></a>如何在Vue中引入一个纯 javascript 库</h2><p>在Vue中引入一个纯的javascript库需要执行以下几个步骤：</p><ul><li>将javascript库放到你的项目中的某个目录下。比如放在 src文件夹的util目录下。</li><li>在使用该javascript的Vue页面中引入该库<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> xxx <span class="keyword">from</span> <span class="string">&#x27;@/utils/xxx.js&#x27;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>其中 <code>@</code>代表 <code>src</code>目录。</li></ul><p>它是在<code>jsconfig.json</code>中配置的，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="string">&quot;paths&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;@/*&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;src/*&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外 import 引入的是一个对象还是一个方法也要注意。<br>如果写成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xxx <span class="keyword">from</span> ....</span><br></pre></td></tr></table></figure><p>表示 <strong>xxx</strong> 是一个对象，使用它里边的方法时，通常这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">xxx.<span class="title function_">someFunc</span>(...)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果只是想引入库中的某个方法，要写成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; xxx &#125; <span class="keyword">from</span> ...</span><br></pre></td></tr></table></figure><p>上面表示的是从某个库中引入一个对象的<strong>xxx</strong>方法，其中<code>&#123;&#125;</code>表示一个对象。</p><ul><li>当将javascript库引入到Vue之后，很有可能需要对该库做一些修改，比如在库中函数的前面加上<code>export</code>关键字，表示该函数可以被导出，供外面使用。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用Vue开发项目的过程中遇到了很多问题，其中有一些是特别值得整理出来以备后用的。&lt;/p&gt;
&lt;p&gt;所以我觉得值得记录下来的知识点都列在这篇文章中，希望对你也能有所帮助。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>WebRTC+科大讯飞+ChatGPT实现语音聊天机器人</title>
    <link href="https://blog.avdancedu.com/f407109e/"/>
    <id>https://blog.avdancedu.com/f407109e/</id>
    <published>2022-12-20T10:03:00.000Z</published>
    <updated>2023-02-20T10:13:01.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>这是一个很奇妙的小项目，做这个项目的初衷是想验证一下，是否可以将音视频技术与ChatGPT结合起来，做一个很酷炫的产品。</p><p>该项目可以作为音视频聊天机器人的基础，从而实现像类似<strong>智能客户</strong>、<strong>在线问答</strong> 之类的产品。你甚至可以把它当成一个<strong>在线助教</strong>，任何时间任何地址回答同学们的问题。</p><p>总之，这个小项目还是挺酷的。</p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><!--<img width="989" alt="voice_chat" data-src="https://user-images.githubusercontent.com/49577129/220062542-cbbb7daf-b8e1-41f1-8b1a-e800d986b1a2.png">--><iframe src="//player.bilibili.com/player.html?aid=779706209&bvid=BV1ty4y1Z7V1&cid=1015866081&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><span id="more"></span><!--视频地址如下：[【作品】WebRTC+ChatGPT实现语音聊天机器人](https://www.bilibili.com/video/BV1ty4y1Z7V1/?share_source=copy_web&vd_source=b393e4210396ee161923c1d02340e78d)--><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><h3 id="已有ChatGPT帐号"><a href="#已有ChatGPT帐号" class="headerlink" title="已有ChatGPT帐号"></a>已有ChatGPT帐号</h3><blockquote><p>注册ChatGPT的过程我就不讲了，一是要能上外网（香港不算），另一个就是要能接收短信。</p></blockquote><ul><li>当ChatGPT帐号注册好后,打开下面网址<a href="https://console.xfyun.cn/">https://platform.openai.com/</a></li><li>登录后，点击右上角<strong>Personal</strong></li><li>选择<strong>View API keys</strong></li><li>之后，点击下面的<strong>Create new secret key</strong>，创建一个新的Key。将新创建好的key保存下来。</li></ul><h3 id="已有科大讯飞帐号"><a href="#已有科大讯飞帐号" class="headerlink" title="已有科大讯飞帐号"></a>已有科大讯飞帐号</h3><ul><li>打开下面网址<a href="https://console.xfyun.cn/">https://console.xfyun.cn/</a>, 到科大讯飞注册一个账户</li><li>创建一个新的应用</li><li>之后，选择<strong>左侧</strong>-&gt;<strong>语音识别</strong>-&gt;<strong>实时语音转写</strong></li><li>购买服务后，可以看到<strong>服务接口认证信息</strong>里边包括了<strong>APPID</strong>和<strong>APIKey</strong></li></ul><p>通过上面的步骤先决条件就准备好了。接下来我们来看看如何配置这几个参数。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul><li>下载源码</li><li>打开src目录下的App.vue文件</li><li>将上面获取到的ChatGPT APIKey 和科大讯飞的 APPID、APIKey分别填入对应的变量中</li></ul><p>接下来安装启动Web服务。</p><h2 id="安装启动服务"><a href="#安装启动服务" class="headerlink" title="安装启动服务"></a>安装启动服务</h2><p><strong>特别注意：本项目只能在 本机使用 或部署在 有域名证书 的服务器上。</strong></p><p>本地安装运行步骤如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure><p>如果想部署到服务器上，可以先使用下面命令编译项目:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>之后再部署到服务器上即可。</p><p><strong>现在打开浏览器实验一下吧，祝好运！</strong></p><h2 id="参考项目"><a href="#参考项目" class="headerlink" title="参考项目"></a>参考项目</h2><ul><li><a href="https://github.com/bestony/ChatGPT-Feishu">飞书接入ChatGPT</a></li><li><a href="https://github.com/wangrongding/wechat-bot">微信接入ChatGPT</a>（小心微信被封)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;项目介绍&quot;&gt;&lt;a href=&quot;#项目介绍&quot; class=&quot;headerlink&quot; title=&quot;项目介绍&quot;&gt;&lt;/a&gt;项目介绍&lt;/h2&gt;&lt;p&gt;这是一个很奇妙的小项目，做这个项目的初衷是想验证一下，是否可以将音视频技术与ChatGPT结合起来，做一个很酷炫的产品。&lt;/p&gt;
&lt;p&gt;该项目可以作为音视频聊天机器人的基础，从而实现像类似&lt;strong&gt;智能客户&lt;/strong&gt;、&lt;strong&gt;在线问答&lt;/strong&gt; 之类的产品。你甚至可以把它当成一个&lt;strong&gt;在线助教&lt;/strong&gt;，任何时间任何地址回答同学们的问题。&lt;/p&gt;
&lt;p&gt;总之，这个小项目还是挺酷的。&lt;/p&gt;
&lt;h2 id=&quot;效果展示&quot;&gt;&lt;a href=&quot;#效果展示&quot; class=&quot;headerlink&quot; title=&quot;效果展示&quot;&gt;&lt;/a&gt;效果展示&lt;/h2&gt;&lt;!--&lt;img width=&quot;989&quot; alt=&quot;voice_chat&quot; data-src=&quot;https://user-images.githubusercontent.com/49577129/220062542-cbbb7daf-b8e1-41f1-8b1a-e800d986b1a2.png&quot;&gt;--&gt;
&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=779706209&amp;bvid=BV1ty4y1Z7V1&amp;cid=1015866081&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
      <category term="ChatGPT" scheme="https://blog.avdancedu.com/categories/WebRTC/ChatGPT/"/>
    
    
      <category term="janus" scheme="https://blog.avdancedu.com/tags/janus/"/>
    
  </entry>
  
  <entry>
    <title>如何使用VSCode调试Vue3+TypeScript+Vite应用</title>
    <link href="https://blog.avdancedu.com/1c60b49f/"/>
    <id>https://blog.avdancedu.com/1c60b49f/</id>
    <published>2022-12-09T13:48:00.000Z</published>
    <updated>2022-12-09T13:50:10.527Z</updated>
    
    <content type="html"><![CDATA[<p>目前 <strong>Vue3+TypeScript+Vite</strong> 这套组合已经成为了越来越流于的Web应用开发架构，我也要紧跟时代，把这块知识补一补。</p><p>我的学习习惯是在学习一门新知识之前，先将它的开发环境和调试环境搭建好，这样学习起来才能事半功倍，正所谓 <strong>“磨刀不误砍柴功”</strong> 嘛！</p><p>今天我就将 <strong>Vue3+TypeScript+Vite</strong> 这套组合的开发环境和调试环境的搭建过程记录以下，一方面是为自己作个学习记录，另一方面也可以帮助其它人少走些弯路，这种事情是我特别喜欢做的。</p><p>首先来看一下如何创建 <strong>Vue3+TypeScript+Vite</strong> 这套组合的开发环境。</p><span id="more"></span><h2 id="搭建-Vue3-TypeScript-Vite-开发环境"><a href="#搭建-Vue3-TypeScript-Vite-开发环境" class="headerlink" title="搭建 Vue3+TypeScript+Vite 开发环境"></a>搭建 <strong>Vue3+TypeScript+Vite</strong> 开发环境</h2><p>其实 <strong>Vue3+TypeScript+Vite</strong> 这套组合的开发环境特别好搭建，在<a href="https://cn.vuejs.org/guide/quick-start.html#creating-a-vue-application"> <strong>官方</strong> </a>的文档中就有说明，其过程如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">npm init vue@latest</span></span><br></pre></td></tr></table></figure><p>该命令会安装并执行 <strong>create-vue</strong>，它是Vue官方的项目脚手架，之后你会看到下面的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">✔ Project name: … &lt;your-project-name&gt;</span><br><span class="line">✔ Add TypeScript? … No / [Yes]</span><br><span class="line">✔ Add JSX Support? … [No] / Yes</span><br><span class="line">✔ Add Vue Router for Single Page Application development? … [No] / Yes</span><br><span class="line">✔ Add Pinia for state management? … [No] / Yes</span><br><span class="line">✔ Add Vitest for Unit testing? … [No] / Yes</span><br><span class="line">✔ Add Cypress for both Unit and End-to-End testing? … [No] / Yes</span><br><span class="line">✔ Add ESLint for code quality? … [No] / Yes</span><br><span class="line">✔ Add Prettier for code formatting? … [No] / Yes</span><br><span class="line"></span><br><span class="line">Scaffolding project in ./&lt;your-project-name&gt;...</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure><p>在上面的信息中，选择<code>[]</code>中的选项即可。再执行下面的命令就可以将依赖安装好，并启动开发服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">cd</span> &lt;your-project-name&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">npm install</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">npm run dev</span></span><br></pre></td></tr></table></figure><p>至此，<strong>Vue3+TypeScript+Vite</strong> 这套组合的开发环境就搭建好了。</p><h2 id="搭建-Vue3-TypeScript-Vite-调试环境"><a href="#搭建-Vue3-TypeScript-Vite-调试环境" class="headerlink" title="搭建 Vue3+TypeScript+Vite 调试环境"></a>搭建 <strong>Vue3+TypeScript+Vite</strong> 调试环境</h2><p><strong>Vue3+TypeScript+Vite</strong> 这套组合的调试环境也非常好搭建，首先将VSCode安装好，VSCode可以从这里<a href="https://code.visualstudio.com/Download">下载</a>。</p><p>之后进入到前面创建的项目中，执行下面命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入到之前创建的vue项目</span></span><br><span class="line">code .</span><br></pre></td></tr></table></figure><p>在保证 <strong>开发服务器已经启动</strong> 的情况下，点击:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VSCode-&gt; 左侧工具栏 -&gt; 调试与运行 -&gt; 创建launch.json</span><br></pre></td></tr></table></figure><p>将launch.json中的内容修改如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span><span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;confiugrations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;chrome&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Vue App&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://localhost:5173&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;webRoot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;worksapceFolder&#125;/dist&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>配置好VSCode后，我们就可以友好的调试咱们自己的程序了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前 &lt;strong&gt;Vue3+TypeScript+Vite&lt;/strong&gt; 这套组合已经成为了越来越流于的Web应用开发架构，我也要紧跟时代，把这块知识补一补。&lt;/p&gt;
&lt;p&gt;我的学习习惯是在学习一门新知识之前，先将它的开发环境和调试环境搭建好，这样学习起来才能事半功倍，正所谓 &lt;strong&gt;“磨刀不误砍柴功”&lt;/strong&gt; 嘛！&lt;/p&gt;
&lt;p&gt;今天我就将 &lt;strong&gt;Vue3+TypeScript+Vite&lt;/strong&gt; 这套组合的开发环境和调试环境的搭建过程记录以下，一方面是为自己作个学习记录，另一方面也可以帮助其它人少走些弯路，这种事情是我特别喜欢做的。&lt;/p&gt;
&lt;p&gt;首先来看一下如何创建 &lt;strong&gt;Vue3+TypeScript+Vite&lt;/strong&gt; 这套组合的开发环境。&lt;/p&gt;
    
    </summary>
    
    
      <category term="语言" scheme="https://blog.avdancedu.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="TypeScript" scheme="https://blog.avdancedu.com/tags/TypeScript/"/>
    
      <category term="Vue3" scheme="https://blog.avdancedu.com/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>Windows下编译FFmpeg5.0</title>
    <link href="https://blog.avdancedu.com/38b88453/"/>
    <id>https://blog.avdancedu.com/38b88453/</id>
    <published>2022-11-29T22:41:00.000Z</published>
    <updated>2023-03-01T05:25:00.527Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/windows_ffmpeg/FFmpeg_logo.jpeg"></p><p>在我的FFmpeg课程中，我总是推荐大家使用 <strong>Linux(Ubuntu)系统</strong> 或 <strong>Mac系统</strong> 来学习FFmpeg。其原因，是在Windows下编译FFmpeg太麻烦了，这大大增加了我们学习FFmpeg的成本。</p><span id="more"></span><p>不光如此，在Windows下编译FFmpeg所需要的依赖库也很麻烦，比如我们经常使用的fdk-aac、x264等在Windows下都要单独编译才可以使用。</p><p>不过，总还是有一些同学需要在Windows下使用FFmpeg，而FFmpeg官网上介绍的Windows下编译FFmpeg的<a href="https://visualstudio.microsoft.com/zh-hans/thank-you-downloading-visual-studio/?sku=Community&channel=Release&version=VS2022&source=VSLandingPage&cid=2030&passive=false">文章</a>实在是太老了，基本不可用。为了解决这部分同学的难题，这里我总结了一份Windows下编译和使用FFmpeg的方法，希望能帮助到大家！</p><h2 id="准备编译环境"><a href="#准备编译环境" class="headerlink" title="准备编译环境"></a>准备编译环境</h2><p>首先，我们要准备好编译环境，一台装有Windows10系统的电脑是必须的（没有比这再正确的废话了：））。</p><p>同时，要将Visual Studio安装好，比如 VS2019 社区版或 VS2022社区版（VS2019可以到<a href="https://visualstudio.microsoft.com/zh-hans/thank-you-downloading-visual-studio/?sku=Community&channel=Release&version=VS2022&source=VSLandingPage&cid=2030&passive=false">这里下载</a>，VS2022可以到<a href="https://visualstudio.microsoft.com/zh-hans/thank-you-downloading-visual-studio/?sku=Community&channel=Release&version=VS2022&source=VSLandingPage&cid=2030&passive=false">这里下载</a>）。这两个版本你用哪个都行，根据自己的需要选择吧。如果不是工作中必须要使用VS2019，那我建议你使用最新版的VS2022。</p><p>除了需要安装VS之外，还要安装<strong>MSYS2</strong>，这是一款Windows下模拟Linux的软件。FFmpeg的编译就是在该软件中进行的，而编译时使用的<strong>编译器</strong>(cl.exe)和<strong>链接器</strong>(link.exe)则是由Visual Studio提供的。MSYS2可以到<a href="https://github.com/msys2/msys2-installer/releases/download/2022-10-28/msys2-x86_64-20221028.exe">这里下载</a></p><p>需要注意的是，在下载MSYS2时可能需要有网络代理才行。考虑到有些同学没有网络代理软件，我将MSYS2的一个备份放到了百度盘上，你也可以到<a href="https://pan.baidu.com/s/1xOpcbJV1mKMCCaNgMBO90g?pwd=8888">这里下载</a>。不过当你去百度盘下载这个软件时，它的版本可能已经比较老了，建议有条件的同学还是到官网上下载。</p><blockquote><p>顺便说一下，对于刚学习Linux的同学来说，在Windows上装MSYS2学习Linux是个不错的选择，它比PowerShell要好用得多</p></blockquote><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>编译环境准备好之后，接下来我们需要下载一份最新的FFmpeg源码，你可以从<a href="https://ffmpeg.org/releases/ffmpeg-snapshot.tar.bz2">这里下载</a>，也可以使用Git下载。Git下载的方法如下：</p><ul><li>先将Git命令安装好</li><li>然后执行下面的命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /d</span><br><span class="line">git <span class="built_in">clone</span> https://git.ffmpeg.org/ffmpeg.git ffmpeg</span><br></pre></td></tr></table></figure>此时，代码就被下载到<code>D:</code>盘的ffmpeg目录下了</li></ul><h2 id="Windows下编译FFmpeg的方法"><a href="#Windows下编译FFmpeg的方法" class="headerlink" title="Windows下编译FFmpeg的方法"></a>Windows下编译FFmpeg的方法</h2><p>当 FFmpeg 源码准备就绪后，我们就可以编译FFmpeg了。</p><p>首先，进入MSYS2的安装目录，比如我这里将MSYS2安装到了<code>D:\MSYS64</code>目录下。在该目录下打开 <strong>msys2_shell.cmd</strong> 文件，将该文件第 <strong>17</strong> 行代码的注释打开，即去掉 <strong>rem</strong> 关键字，如下所示：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">setlocal</span> EnableDelayedExpansion</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> &quot;WD=<span class="variable">%__CD__%</span>&quot;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">NOT</span> <span class="keyword">EXIST</span> &quot;<span class="variable">%WD%</span>msys-<span class="number">2</span>.<span class="number">0</span>.dll&quot; <span class="built_in">set</span> &quot;WD=%~dp0usr\bin\&quot;</span><br><span class="line"><span class="built_in">set</span> &quot;LOGINSHELL=bash&quot;</span><br><span class="line"><span class="built_in">set</span> /a msys2_shiftCounter=<span class="number">0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rem To activate windows native symlinks uncomment next line</span></span><br><span class="line"><span class="comment">rem set MSYS=winsymlinks:nativestrict</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rem Set debugging program for errors</span></span><br><span class="line"><span class="comment">rem set MSYS=error_start:%WD%../../mingw64/bin/qtcreator.exe^|-debug^|^&lt;process-id^&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rem To export full current PATH from environment into MSYS2 use &#x27;-use-full-path&#x27; parameter</span></span><br><span class="line"><span class="comment">rem or uncomment next line</span></span><br><span class="line"><span class="built_in">set</span> MSYS2_PATH_TYPE=inherit</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>之所以要打开该注释，是为了让MSYS2可以继承Windows控制台的环境变量。</p><p>之后，通过面的方法找到<code>x64 Native Tools Command Prompt for VS 2019</code>命令窗口:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Windows开始菜单 -&gt; Visual Studio 2022 -&gt; x64 Native Tools Command Prompt <span class="keyword">for</span> VS 2019</span><br></pre></td></tr></table></figure><p>在该命令窗口中输入下面的命令启动 MSYS2 软件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入到MSYS2 目录下</span></span><br><span class="line"><span class="built_in">cd</span> D:\MSYS64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动MSYS2</span></span><br><span class="line">msys2_shell.cmd</span><br></pre></td></tr></table></figure><p>此时，会弹出MSYS2的命令窗口。接下来，在该窗口中输入下面命令，安装必要的编译工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S diffutils make pkg-config yasm</span><br></pre></td></tr></table></figure><p>其中 <strong>pacman</strong> 是MSYS2的 <strong>包安装工具</strong>；而 diffutils、make……都是编译FFmpeg时需要用的 <strong>编译工具</strong>。</p><p>当编译工具安装好后，曳光弹在MSYS2命令窗中执行下面命令，进入到FFmpeg源码目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /d/ffmpeg</span><br></pre></td></tr></table></figure><p>紧接着，运行 FFmpeg 源码目录中的 <code>configure</code> 脚本生成 <strong>Makefile</strong> 文件，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/ffmpeg--enable-gpl --enable-nonfree --enable-shared --disable-ffprobe --toolchain=msvc</span><br></pre></td></tr></table></figure><p>上述命令的含义是使用mscv作为FFmpeg的编译工具链；编译出的FFmpeg库被放到<code>/usr/local/ffmpeg</code> 目录下；编译的库是动态库，在Windows下就是 <strong>DLL</strong> 库；编译时不生成 <strong>ffprobe</strong> 程序。</p><p>上述脚本执行完成后，你可以在 FFmpeg 源码目录下发现多了一个 Makefile 文件。有了这个文件我们就可以编译FFmpeg了，编译命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j 4 &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>当执行完这条命令后，在 <code>/usr/local/ffmpeg/bin</code> 目录下就可以找到编译好的FFmpeg库和FFmpeg命令了。</p><p>需要注意的是，編译时有你有可能会遇到到如下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...... error C2065: “slib”: 未声明的标识符</span><br><span class="line">...... error C2296: “%”: 非法，左操作数包含“char [138]”类型</span><br></pre></td></tr></table></figure><p>该问题是因为在Windows下无法识别 <strong>CC_IDENT</strong> 导致的，只需将包括 <strong>CC_IDENT</strong>关键字的那行代码注释掉即可。</p><h2 id="在Windows上找到编译好的FFmpeg库"><a href="#在Windows上找到编译好的FFmpeg库" class="headerlink" title="在Windows上找到编译好的FFmpeg库"></a>在Windows上找到编译好的FFmpeg库</h2><p>上面我将编译好的FFmpeg库安装到了<code>/usr/local/ffmpeg</code>目录下，但在Windows下如何找到这个目录呢？</p><p>其实非常简单，你只需确定好MSYS2的根目录是哪儿就可以找到编译好的FFmpeg库了。以我的环境为例，我将MSYS2安装到了<code>D:\MSYS64</code>这个目录下，那么<code>D:\MSYS64</code>这个目录就是MSYS2的根目录。</p><p>因此，我编译好的FFmpeg库就存放在<code>D:\MSYS64\usr\local\ffmpeg</code>目录下。</p><h2 id="VS项目中引用FFmpeg库"><a href="#VS项目中引用FFmpeg库" class="headerlink" title="VS项目中引用FFmpeg库"></a>VS项目中引用FFmpeg库</h2><p>编译好FFmpeg库后，下面我们就可以在VS中引用它了。</p><p>首先你要创建一个新的VS项目，具体方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打开VS -&gt; 创建新项目 -&gt; 创建控制台项目 -&gt; 填写项目名 </span><br></pre></td></tr></table></figure><p>项目创建好后你会发现它里边只有一个<code>testffmpeg.cpp</code>文件，该文件特别简单，只有一个<code>main(...)</code>函数和一条<code>cout &lt;&lt; ...</code>语句。现在我们就可以在这个<code>main(...)</code>函数中调用<strong>FFmpeg API</strong> 了。</p><p>但在开始编码之前，我们需要将用到的FFmpeg库和头文件引入到VS工程中，这样后面VS才能正确的将程序编译出来。下面咱们来看看该如何在VS中引入FFmpeg库头文件、库文件：</p><ul><li><p>引入FFmpeg头文件</p><p>在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目右键 -&gt; 属性 -&gt; C/C++ -&gt; 常规 -&gt; 附加包含目录</span><br></pre></td></tr></table></figure><p>中添加FFmpeg头文件所在路径。</p></li><li><p>指定库文件位置</p><p>在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目右键 -&gt; 属性 -&gt; 链接器 -&gt; 常规 -&gt; 附加库目录</span><br></pre></td></tr></table></figure><p>中添加FFmpeg库所在路径。</p></li><li><p>指定使用哪个库<br>在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目右键 -&gt; 属性 -&gt; 链接器 -&gt; 输入 -&gt; 附加依赖项</span><br></pre></td></tr></table></figure><p>中指定你所用到的FFmpeg库，如avutil.lib</p></li></ul><p>当上面这此工作完成后，我们就可以在<code>main(...)</code>函数中调用FFmpeg API了，如调用FFmpeg库中的日志函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavtuil/log.h&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(...)</span></span><br><span class="line">&#123;</span><br><span class="line">    av_log_set_level(AV_LOG_DEBUG);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">&quot;Hello World!\n);</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>上述代码中，调用了FFmpeg中的两个API，分别是 <code>av_log_set_level(...)</code>以及<code>av_log(...)</code>，这两个函数都是FFmpeg avutil库中的API。所以在使用这两个API之前，我们要在main.c中需要通过<code>#include</code>关键字将 <strong>libavtuil&#x2F;log.h</strong> 这个头文件引入进来。</p><p>此外，由于FFmpeg是C语言库，而我们用VS创建的是C++工程，所以在引入头文件时需要加上<code>extern &quot;C&quot;</code>关键字，否则的话VS无法将其成功编译。</p><h2 id="运行编译好的程序"><a href="#运行编译好的程序" class="headerlink" title="运行编译好的程序"></a>运行编译好的程序</h2><p>上面当我们运行编译好的程序时你会发现，它弹出了报错窗口，显示 <strong>“无法找到xxx.dll库”</strong> 的出错信息，其原因是在运行时无法找到需要的动态库。</p><p>解决办法很简单，只需将我们之前编译好的FFmpeg库，即提示的无法找到的<code>.dll</code>库，拷贝到执行程序的同一目录下，这样执行程序就可以找到该库并正确执行了。</p><h2 id="编译FFmpeg依赖库"><a href="#编译FFmpeg依赖库" class="headerlink" title="编译FFmpeg依赖库"></a>编译FFmpeg依赖库</h2><p>很多时候我们在编译FFmpeg库时还要增加一些其它库，如SDL、x264等，如何能将这些库添加到FFmpeg中呢？</p><p>要想将这些库编译到FFmpeg中，首先我们要编译出Windows下可用的对应库，下面咱们就来看一下如何在Windows系统下将它们编译出来。</p><h3 id="编译SDL"><a href="#编译SDL" class="headerlink" title="编译SDL"></a>编译SDL</h3><p>首先从github上获取SDL源码，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/libsdl-org/SDL.git</span><br><span class="line">git checkout release-2.26.x</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，SDL现在已经发布了3.0版本，而ffmpeg目前只能用SDL2版本，所以在拉取代码后，需要切换到2.26这个版本</p></blockquote><p>下载好 SDL2 源码后，我们需要使用 <strong>CMake</strong> 为其生成VS工程，所以我们首先到这里<a href="https://github.com/Kitware/CMake/releases/download/v3.25.0/cmake-3.25.0-windows-x86_64.msi">下载CMake</a>，并将其安装到Windows系统上。</p><p>之后打开 CMake-GUI，在 CMake-GUI 中指定SDL2源码所在路径以及编译后的输出路径，随后执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Configure -&gt; Generate</span><br></pre></td></tr></table></figure><p>生成VS工程。有了VS工程，我们就可以通过VS2019或VS2022来编译SDL了。</p><p>需要指出的是，编译好的SDL会保存到指定输出目录的 <strong>Release</strong> 或 <strong>Debug</strong> 目录下（例如指定的输出目录为<code>/usr/local/sdl2</code>，则输出路径为<code>/usr/local/sdl2/Release</code>)，而我们希望输出的路径则是<code>/usr/local/sdl2/lib</code>。</p><p>为了满足要求，<strong>我们需要在指定输出目录下创建 <strong>lib</strong> 目录，并将SDL2.lib 和 SDL2.dll文件拷贝到 lib 目录下。同时在 lib 目录下创建 pkgconfig 目录，将sdl2.pc 文件拷贝到该目录中</strong>。</p><p>此外，我们还要修改 <strong>sdl2.pc</strong> 中的内容，将其中的库路径修改为指定的输出路径，最终完整的目录结构如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/sdl2</span><br><span class="line"> |------------ lib</span><br><span class="line"> |              |-- sdl2.lib</span><br><span class="line"> |              |-- sdl2.dll</span><br><span class="line"> |              |-- pkgconfig</span><br><span class="line"> |                     |----- sdl2.pc</span><br><span class="line"> |------------ include</span><br></pre></td></tr></table></figure><h3 id="编译x264"><a href="#编译x264" class="headerlink" title="编译x264"></a>编译x264</h3><p>x264库的编译还是比较简单的，与SDL一样我们也要先获取其源码，可以通过下面的命令获取x264源码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://code.videolan.org/videolan/x264.git</span><br></pre></td></tr></table></figure><p>源码获取到后，可以直接在MSYS2环境下编译出Windows下可用的动态库，具体步骤如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过VS X64 Native... 窗口打开MSYS2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /d/x264 <span class="comment"># 在MSYS2中进入x264源码目录</span></span><br><span class="line"></span><br><span class="line">pacman -S automake autoconf libtool <span class="comment"># 安装生成Makefile的工具</span></span><br><span class="line"></span><br><span class="line">CC=cl ./configure --prefix=/usr/local/x264 --enable-shared</span><br><span class="line"></span><br><span class="line">make -j 4 &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>通过上面的命令就可以将x264编译出来了。x264编译好后，其输出的目录结构与SDL2是一样的，在<code>/usr/local/x264</code>中包括了<code>include</code>、<code>lib</code>、<code>bin</code>等目录。</p><p>要特别强调的一点是，我们需要将<code>lib</code>目录下的<code>libx264.dll.lib</code>文件名修改为<code>libx264.lib</code>，否则ffmpeg编译时会报 <strong>“无法找到该库”</strong> 的错误。</p><h3 id="编译fdk-aac"><a href="#编译fdk-aac" class="headerlink" title="编译fdk-aac"></a>编译fdk-aac</h3><p>fdk-aac的编译与SDL类似，它同样要使用CMake生成VS工程文件，之后再通过VS编译该库。</p><p>首先，通下面的的命令获取fdk-aac源码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/mstorsjo/fdk-aac.git</span><br></pre></td></tr></table></figure><p>之后，通过CMake生成VS工程文件，具体执行步骤请参考 SDL 生成 VS 工程的步骤，这里就不再重复了。</p><p>接下来，使用VS2019或VS2022编译fdk-aac，编译好的库同要会被放到Release或Debug目录下，因此我们必须像处理SDL库一样，需要手工组织fdk-aac的输出目录树。</p><p>至此fdk-aac就算编译好了。</p><blockquote><p>在编译fdk-aac时有个特殊情况，就是使用CMake的方式无法产生include头文件（这也有可能是我哪块执行的不对）。为了解决这个问题，我又用 MSYS2+mingw 的方式重新编译了一遍fdk-aac，这种方式是可以生成 <strong>include</strong> 头文件的，然后将生成的头文件手动拷贝到了&#x2F;usr&#x2F;local&#x2F;fdk-aac目录下即可。</p></blockquote><h3 id="FFmpeg如何使用上述编译好的库呢？"><a href="#FFmpeg如何使用上述编译好的库呢？" class="headerlink" title="FFmpeg如何使用上述编译好的库呢？"></a>FFmpeg如何使用上述编译好的库呢？</h3><p>首先，我们要设置环境变量<code>PKG_CONFIG_PATH</code>，通过它告诉FFmpeg上述几个库从哪儿可以找到，具体的设置方法如下：</p><ul><li>在MSYS2窗口中打开<code>.bashrc</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman -S vim</span><br><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure></li><li>在<code>~/.bashrc</code>中设置环境变量<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PKG_CONFIG_PATH=/usr/local/sdl2/lib/pkgconfig:/usr/local/x264/lib/pkgconfig:/usr/local/fdk-aac/lib/pkgconfig:<span class="variable">$PKG_CONFIG_PATH</span></span><br><span class="line"></span><br><span class="line">:wq <span class="comment">#保存并退出vim</span></span><br></pre></td></tr></table></figure></li><li>让环境变是生效<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></li></ul><p>接下来，重新生成FFmpeg的Makefile文件，并重新编译，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/ffmpeg --<span class="built_in">arch</span>=x86_64 --enable-shared --disable-ffprobe --disable-doc --enable-libx264 --enable-gpl --enable-fdk-aac --enable-nonfree --toolchain=msvc</span><br><span class="line"></span><br><span class="line">make clean</span><br><span class="line"></span><br><span class="line">make -j 4 &amp;&amp; make install</span><br></pre></td></tr></table></figure><p><strong>最后，将sdl2的dll、x264的dll以及fdk-aac的dll拷贝到ffmpeg的bin目录下，这样就可以正确的执行 ffmpeg.exe 或 ffplay.exe 命令了</strong>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上面就是在Windows下编译和使用FFmpeg的方法。如果你在Linux或Mac下可以熟练的编译FFmpeg，你会发现，在Window下编译FFmpeg的步骤与在Linux和Mac下编译的步骤是一样的，关键点是在Windows下该如何搭建好编译环境。</p><p>此外需要强调的是，在Windows下编译FFmpeg时，由于它不能识别 <strong>CC_IDENT</strong> 关键字，所以编译时会报错，我们只需将使用该关键字的语句注释掉即可解决该问题。</p><p>另外，在程序中通过<code>#include</code>引用FFmpeg头文件时，一定要记得加 <code>extern &quot;C&quot;</code>关键字，告诉C++编译器，这个头文件是一个C类型的头文件，这样它才能正确编译。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ul><li><a href="https://github.com/ShiftMediaProject/FFmpeg">ShiftMediaProject</a>，有同学给我推荐了这个项目，我简单了解了一下，这个项目真不错，可以直接使用VS对FFmpeg进行调试，有兴趣的同学可以偿试一下。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/windows_ffmpeg/FFmpeg_logo.jpeg&quot;&gt;&lt;/p&gt;
&lt;p&gt;在我的FFmpeg课程中，我总是推荐大家使用 &lt;strong&gt;Linux(Ubuntu)系统&lt;/strong&gt; 或 &lt;strong&gt;Mac系统&lt;/strong&gt; 来学习FFmpeg。其原因，是在Windows下编译FFmpeg太麻烦了，这大大增加了我们学习FFmpeg的成本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FFmpeg" scheme="https://blog.avdancedu.com/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="https://blog.avdancedu.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>VS中引入并使用WebRTC库</title>
    <link href="https://blog.avdancedu.com/fcd68433/"/>
    <id>https://blog.avdancedu.com/fcd68433/</id>
    <published>2022-11-24T13:35:00.000Z</published>
    <updated>2022-12-07T06:08:07.550Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://avdancevod.oss-cn-beijing.aliyuncs.com/image/article/import_webrtc/webrtc_banner_2.jpeg" alt="banner"></p><p>前段时间经常有同学问我，如何在Windows下利用编译出的WebRTC库开发自己的应用程序，当时特别忙就让同学到网上找答案了，没想到过了几天同学们又来问，说网上找不到……</p><p>相对于移动端，在Windows下使用WebRTC库确实困难些。在移动端（iOS、Andorid），你可以直接从Google提供的Pod库中拉取编译好的WebRTC库，而在Windows端则需要我们自己编译WebRTC库，并导出WebRTC头文件。</p><p>这几天手头的工作终于忙的差不多了，今天就花点时间整理一下这方面的知识，给同学们搭个<strong>台阶</strong>，让同学们快尽入手WebRTC:)。</p><span id="more"></span><h2 id="安装开发环境"><a href="#安装开发环境" class="headerlink" title="安装开发环境"></a>安装开发环境</h2><p>在Windows下开发应用程序最常用的开发工具还是Visual Studio，你可以使用VS2019，也可以使用VS2022，目前我还是建议大家先用 VS2019，再等个半年、一年的换VS2022比较合适。VS2019的下载地址<a href="https://visualstudio.microsoft.com/zh-hans/thank-you-downloading-visual-studio/?sku=community&rel=16&utm_medium=microsoft&utm_campaign=download+from+relnotes&utm_content=vs2019ga+button">在这里</a>，将 VS Installer下载好后，在CMD窗口中执行下面的命令即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ PATH_TO_INSTALLER.EXE ^</span><br><span class="line">--add Microsoft.VisualStudio.Workload.NativeDesktop ^</span><br><span class="line">--add Microsoft.VisualStudio.Component.VC.ATLMFC ^</span><br><span class="line">--includeRecommended</span><br></pre></td></tr></table></figure><p>当然，正常情况下你在配置WebRTC编译环境时就应该已经将VS安装好了。</p><h2 id="编译WebRTC"><a href="#编译WebRTC" class="headerlink" title="编译WebRTC"></a>编译WebRTC</h2><p>开发环境安装好后，下面我们就该编译WebRTC源码了。WebRTC源码的下载与编译请看<a href="https://avdancedu.com/2bafd6cf/">这篇文章</a>。</p><p>需要注意的是，我们在新项目中引入的WebRTC库，不能直接用下面的命令进行编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gn gen out/Default</span><br><span class="line">ninja -C out/Default</span><br></pre></td></tr></table></figure><p>而必须明确指明编译出的WebRTC是<strong>Debug</strong>版本，还是<strong>Release</strong>版本；是<strong>x86</strong>版本还是<strong>x64</strong>版本……</p><p>因此，应该使用下面的命令编译WebRTC:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gn gen --target=x64 --ide=vs2019 --args=&quot;is_debug=true rtc_enable_protobuf=false is_clang=false target_cpu=\&quot;x64\&quot;  enable_iterator_debugging=true  use_custom_libcxx=false symbol_level=0 rtc_include_tests=false&quot; out/debug_x64</span><br><span class="line">ninja - C out/debug_x64</span><br></pre></td></tr></table></figure><p>上述 <strong>gn</strong> 中的几个参数含义如下：</p><ul><li>–target，顾名思义，生成x64版本的WebRTC库</li><li>–ide，生成VS工程文件</li><li>–args，编译时的一些配置参数<ul><li>is_debug，为true编译出Debug版本；为false编译出Release版本</li><li>rtc_enable_protobuf，是否使用protobuf，使用可将其设置为true</li><li>use_custom_libcxx，WebRTC默认使用的是libc++库，而我们在Windows上使用的是libstdc++库，所以需要将其设置为false</li><li>symbol_level，编译出的WebRTC库是否带符号表，这个数据量很大，会影响运行速度，所以一般设置为0，表示编译出的WebRTC不带符号表</li><li>rtc_include_tests，编译WebRTC时是否编译测试用例，如果为false则不编译，这样可以大大加快WebRTC的编译速度</li></ul></li></ul><p>执行上面的命令时，会花一些时间，因此我们需要让<strong>子弹飞一会儿</strong>……</p><h2 id="构建自己的应用程序"><a href="#构建自己的应用程序" class="headerlink" title="构建自己的应用程序"></a>构建自己的应用程序</h2><p>如果顺利的话，你现在应该已经将WebRTC库编译好了。接下来我们来创建自己的应用程序。</p><p>为了方便，你可以将WebRTC examples中的peerconnection_client代码拿出来构建一个新的工程，之后再将前面编译好的WebRTC库引入进来，<strong>如果它可以正常运行就达到了我们的目标</strong>。</p><p>为了达到这个目标，首先我们先使用VS创建一个空项目，步骤如下：</p><ul><li>第一步，打开Visual Studio，<strong>创建新项目</strong><br><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/vs1.png" alt="图1"></li><li>第二步，使用Windows桌面向导创建Windows空项目<br><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/vs2.png" alt="图2"></li><li>第三步，填写项目名称，并将项目与解决方案放在同一目录下<br><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/vs3.png" alt="图3"></li><li>第四步，选择应用程序类型为<strong>桌面应用程序</strong><br><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/vs4.png" alt="图4"></li><li>第五步，同时勾选<strong>空项目</strong><br><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/vs5.png" alt="图5"></li></ul><p>至此，我们就构建出了一个VS<strong>空项目</strong>，它里边没有任何文件，如下图所示：</p><p><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/vs6_new.png" alt="图6"></p><p>空项目创建好后，紧接着我们来移植peerconnection_client代码到新项目中，步骤如下：</p><ul><li><p>第一步，从WebRTC源码中拷贝peerconnection_client中的代码到新项目的目录中，在我这里是<br>将<code>C:\webrtc\webrtc-checkout\src\exmaples\peerconnection\client</code>目录中的代码拷贝到<code>C:\Users\lichao\sourceMyWebRTCDemo</code>目录下。如下图所示：</p><p><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/code1.png" alt="code1"></p><p><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/code2.png" alt="code2"></p></li><li><p>第二步，将新项目中的代码<strong>拖</strong>到VS项目中<br><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/code3_new.png" alt="code3"></p></li></ul><p>通过以上步骤我们就将peerconnection_client中的代码移植好了。接下来咱们来看<strong>重头戏</strong>，如何在项目中引入WebRTC库。</p><h2 id="引入WebRTC库"><a href="#引入WebRTC库" class="headerlink" title="引入WebRTC库"></a>引入WebRTC库</h2><p>通常我们引入一个外部库只需要两步，<strong>引入库文件和其头文件</strong>。不过，对于WebRTC，更准确的说对于peerconnection_client而言，它需要的不仅仅是WebRTC库，还需要将WebRTC依赖的第三方库加进来，这是大家觉得在Windows下使用WebRTC库比较麻烦的原因。</p><p>下面咱们就来看一下如何引入WebRTC库吧！</p><h3 id="添加依赖的头文件"><a href="#添加依赖的头文件" class="headerlink" title="添加依赖的头文件"></a>添加依赖的头文件</h3><p>我们若想将WebRTC头文件引入到项目中，可以通过下面两种方法引入：</p><ul><li><p>方法一，在VS中将WebRTC源码路径添加到<strong>附加包含目录</strong>中。比如我这里将WebRTC源码下载到了<code>C:\webrtc\webrtc-checkout\src</code>目录下，我只需将该路径添加到:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目 -&gt; 属性 -&gt; C/C++ -&gt; 常规 -&gt; 附加包含目录</span><br></pre></td></tr></table></figure><p>中即可，如下图所示：<br><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/setting1.png" alt="setting1"></p><p><strong>这种方法的好处是简单方便，坏处是不便于我们将库文件发布给别人使用。</strong></p></li><li><p>方法二，我们可以通过<a href="https://avdancevod.oss-cn-beijing.aliyuncs.com/image/article/import_webrtc/extrac_webrtc_headers.bat">这个脚本</a>将WebRTC中的头文件提取出来。之后与<strong>方法一</strong>一样，将头文件路径添加到<strong>附加包含目录</strong>中即可。</p><p>需要注意的是，这个脚本下载后，要将其放到WebRTC源码目录<strong>src</strong>的同级目录中，如下图所示：<br><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/script.png" alt="script1"></p><p>之后打开Windows控制台，并进入到<strong>src</strong>的同级目录中，在CMD窗口中执行<code>extract_webrtc_headers.bat</code>脚本，这样就可以将WebRTC头文件提取出来了，如下图所示：<br><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/script2.png" alt="script2"></p><p><strong>这种方法的优点是方便其他人使用，缺点是抽取头文件需要花一些时间。</strong></p></li></ul><p>除了添加上面的头文件路径外，我们还需要将下面几个路径添加到<strong>附加包含项目</strong>中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\webrtc\webrtc-checkout\src\third_party\jsoncpp\generated</span><br><span class="line">C:\webrtc\webrtc-checkout\src\third_party\jsoncpp\source\include</span><br><span class="line">C:\webrtc\webrtc-checkout\src\third_party\libyuv\include</span><br><span class="line">C:\webrtc\webrtc-checkout\src\third_party\abseil-cpp</span><br></pre></td></tr></table></figure><h3 id="添加依赖的库"><a href="#添加依赖的库" class="headerlink" title="添加依赖的库"></a>添加依赖的库</h3><p>头文件添加好后，接下来咱们来添加WebRTC库文件。WebRTC编译好后，你可以在WebRTC源码目录<strong>src</strong>的<strong>out&#x2F;debug_x64&#x2F;obj</strong>目录下找到<strong>WebRTC.lib</strong>文件，这就是编译好的WebRTC库。</p><p>我们将它添加到VS中的<strong>附加库目录</strong>中，具体操作如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">右键项目 -&gt; 属性 -&gt; 链接器 -&gt; 常规 -&gt; 附加库目录</span><br></pre></td></tr></table></figure><p>WebRTC库文件路径添加好后，如下图所示：<br><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/linker1.png" alt="linker1"></p><p>接着咱们添加具体的的依赖库，添加依赖库的位置在:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">右键项目 -&gt; 属性 -&gt; 链接器 -&gt; 输入 -&gt; 附加依赖项</span><br></pre></td></tr></table></figure><p>如下图所示：<br><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/linker2.png" alt="linker2"></p><p>具体都依赖哪些依赖项呢？这里我以 <strong>M93(4577)</strong> 为例，对于这个版本的peerconnection_client来说，它需要下面的依赖库：</p><ul><li><p>WebRTC相关的库包括：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">third_party/abseil-cpp/absl/flags/marshalling/marshalling.obj</span><br><span class="line">third_party/abseil-cpp/absl/flags/program_name/program_name.obj</span><br><span class="line">third_party/abseil-cpp/absl/flags/flag/flag.obj</span><br><span class="line">third_party/abseil-cpp/absl/flags/flag_internal/flag.obj</span><br><span class="line">third_party/abseil-cpp/absl/flags/commandlineflag/commandlineflag.obj</span><br><span class="line">third_party/abseil-cpp/absl/flags/commandlineflag_internal/commandlineflag.obj</span><br><span class="line">third_party/abseil-cpp/absl/flags/private_handle_accessor/private_handle_accessor.obj</span><br><span class="line">third_party/abseil-cpp/absl/flags/reflection/reflection.obj</span><br><span class="line">third_party/abseil-cpp/absl/flags/parse/parse.obj</span><br><span class="line">third_party/abseil-cpp/absl/flags/usage/usage.obj</span><br><span class="line">third_party/abseil-cpp/absl/flags/usage_internal/usage.obj</span><br><span class="line">third_party/abseil-cpp/absl/flags/config/usage_config.obj</span><br><span class="line">third_party/jsoncpp/jsoncpp/json_reader.obj</span><br><span class="line">third_party/jsoncpp/jsoncpp/json_value.obj</span><br><span class="line">third_party/jsoncpp/jsoncpp/json_writer.obj</span><br><span class="line">test/field_trial/field_trial.obj</span><br><span class="line">test/video_test_common/test_video_capturer.obj</span><br><span class="line">test/platform_video_capturer/vcm_capturer.obj</span><br><span class="line">rtc_base/rtc_json/json.obj</span><br></pre></td></tr></table></figure></li><li><p>系统相关的库包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">advapi32.lib</span><br><span class="line">comdlg32.lib</span><br><span class="line">dbghelp.lib</span><br><span class="line">dnsapi.lib</span><br><span class="line">gdi32.lib</span><br><span class="line">msimg32.lib</span><br><span class="line">odbc32.lib</span><br><span class="line">odbccp32.lib</span><br><span class="line">oleaut32.lib</span><br><span class="line">shell32.lib</span><br><span class="line">shlwapi.lib</span><br><span class="line">user32.lib</span><br><span class="line">usp10.lib</span><br><span class="line">uuid.lib</span><br><span class="line">version.lib</span><br><span class="line">wininet.lib</span><br><span class="line">winmm.lib</span><br><span class="line">winspool.lib</span><br><span class="line">ws2_32.lib</span><br><span class="line">delayimp.lib</span><br><span class="line">kernel32.lib</span><br><span class="line">ole32.lib</span><br><span class="line">crypt32.lib</span><br><span class="line">iphlpapi.lib</span><br><span class="line">secur32.lib</span><br><span class="line">dmoguids.lib</span><br><span class="line">wmcodecdspuuid.lib</span><br><span class="line">amstrmid.lib</span><br><span class="line">msdmo.lib</span><br><span class="line">strmiids.lib</span><br></pre></td></tr></table></figure></li></ul><h3 id="添加宏"><a href="#添加宏" class="headerlink" title="添加宏"></a>添加宏</h3><p>除了上面讲的需要引入头文件和WebRTC库之外，还需要添加下面这些宏。这些宏的具体含义我有不介绍了，有兴趣的同学可以自己在网上搜索一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">USE_AURA=<span class="number">1</span></span><br><span class="line">_HAS_NODISCARD</span><br><span class="line">_HAS_EXCEPTIONS=<span class="number">0</span></span><br><span class="line">__STD_C</span><br><span class="line">_CRT_RAND_S</span><br><span class="line">_CRT_SECURE_NO_DEPRECATE</span><br><span class="line">_SCL_SECURE_NO_DEPRECATE</span><br><span class="line">_ATL_NO_OPENGL</span><br><span class="line">_WINDOWS</span><br><span class="line">CERT_CHAIN_PARA_HAS_EXTRA_FIELDS</span><br><span class="line">PSAPI_VERSION=<span class="number">2</span></span><br><span class="line">WIN32</span><br><span class="line">_SECURE_ATL</span><br><span class="line">WINAPI_FAMILY=WINAPI_FAMILY_DESKTOP_APP</span><br><span class="line">WIN32_LEAN_AND_MEAN</span><br><span class="line">NOMINMAX</span><br><span class="line">_UNICODE</span><br><span class="line">UNICODE</span><br><span class="line">NTDDI_VERSION=NTDDI_WIN10_VB</span><br><span class="line">_WIN32_WINNT=<span class="number">0x0A00</span></span><br><span class="line">WINVER=<span class="number">0x0A00</span></span><br><span class="line">_DEBUG</span><br><span class="line">DYNAMIC_ANNOTATIONS_ENABLED=<span class="number">1</span></span><br><span class="line">WEBRTC_ENABLE_PROTOBUF=<span class="number">0</span></span><br><span class="line">WEBRTC_INCLUDE_INTERNAL_AUDIO_DEVICE</span><br><span class="line">RTC_ENABLE_VP9</span><br><span class="line">WEBRTC_HAVE_SCTP</span><br><span class="line">WEBRTC_ENABLE_AVX2</span><br><span class="line">RTC_ENABLE_WIN_WGC</span><br><span class="line">WEBRTC_NON_STATIC_TRACE_EVENT_HANDLERS=<span class="number">0</span></span><br><span class="line">WEBRTC_WIN</span><br><span class="line">ABSL_ALLOCATOR_NOTHROW=<span class="number">1</span></span><br><span class="line">_ENABLE_EXTENDED_ALIGNED_STORAGE</span><br><span class="line">ABSL_FLAGS_STRIP_NAMES=<span class="number">0</span></span><br><span class="line">HAVE_WEBRTC_VIDEO</span><br></pre></td></tr></table></figure><p>添加方法如下:</p><ul><li><p>首先在 VS 中执行下面的操作，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">右键项目 -&gt; 属性 -&gt; C/C++ -&gt; 预处理器</span><br></pre></td></tr></table></figure></li><li><p>之后将上面的宏添加到<strong>预处理器</strong>中即可。</p></li></ul><h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><p>到此为止，我们就将peerconnection_client的代码移植好了，直接点<img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/run.png">测试一下吧！</p><p>此时，编译器有可能报4996的错误，解决该问题办法很简单，只要在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">右键项目项 -&gt; 属性 -&gt; C/C++ -&gt; 高级 -&gt; 禁用特定警告</span><br></pre></td></tr></table></figure><p>中将 <strong>4996</strong> 添加进去即可。除此之外，还有可能遇到 <strong>&#x2F;MDd</strong> 错误，解决它可以通过在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">右键项目项 -&gt; 属性 -&gt; C/C++ -&gt; 代码生成 -&gt; 运行库</span><br></pre></td></tr></table></figure><p>中将 <strong>&#x2F;MDd</strong> 改为 <strong>&#x2F;MTd</strong> 即可。</p><p>如果一切顺利，peerconnection_client的连接窗口就展示在你面前了，如下图所示。<br><img data-src="https://cdn.avdancedu.com/image/article/import_webrtc/conn.png"></p><p>此时，你需要先将peerconnection_server程序运行起来，让它侦听 <strong>8888</strong> 端口；之后在peerconnection_client的连接界面中输入 <strong>127.0.0.1</strong>，点击<strong>连接</strong>，如果能进入列表界面就表明OK了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上面我详细的向你介绍了如何将WebRTC中的peerconnection_client代码移植出来，并重点向你讲解了如何在项目中引入WebRTC库。</p><p>其重点包括三步：一是添加WebRTC库头文件路径；二是添加WebRTC库路径，及其WebRTC库；三是添加一堆宏。只要将上面三个步骤操作好了，其它的一些问题在网上都能找到答案。</p><p>祝大家好运！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://avdancevod.oss-cn-beijing.aliyuncs.com/image/article/import_webrtc/webrtc_banner_2.jpeg&quot; alt=&quot;banner&quot;&gt;&lt;/p&gt;
&lt;p&gt;前段时间经常有同学问我，如何在Windows下利用编译出的WebRTC库开发自己的应用程序，当时特别忙就让同学到网上找答案了，没想到过了几天同学们又来问，说网上找不到……&lt;/p&gt;
&lt;p&gt;相对于移动端，在Windows下使用WebRTC库确实困难些。在移动端（iOS、Andorid），你可以直接从Google提供的Pod库中拉取编译好的WebRTC库，而在Windows端则需要我们自己编译WebRTC库，并导出WebRTC头文件。&lt;/p&gt;
&lt;p&gt;这几天手头的工作终于忙的差不多了，今天就花点时间整理一下这方面的知识，给同学们搭个&lt;strong&gt;台阶&lt;/strong&gt;，让同学们快尽入手WebRTC:)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/tags/WebRTC/"/>
    
      <category term="VS" scheme="https://blog.avdancedu.com/tags/VS/"/>
    
  </entry>
  
  <entry>
    <title>SDL事件处理</title>
    <link href="https://blog.avdancedu.com/a0ec02a7/"/>
    <id>https://blog.avdancedu.com/a0ec02a7/</id>
    <published>2022-11-19T06:52:00.000Z</published>
    <updated>2022-11-20T04:07:08.621Z</updated>
    
    <content type="html"><![CDATA[<p>前面我为大家介绍了 SDL 的三个主题：</p><ul><li><a href="http://www.avdancedu.com/56ef4bcb">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8">SDL基本图形绘制</a></li></ul><p>今天我为大家介绍一下SDL的事件处理。这里所指的事件处理就是我们通常所说的，键盘事件，鼠标事件，窗口事件等。</p><p>SDL对这些事件都做了封装，提供了统一的API，下面我们就来详细的看一下。</p><span id="more"></span><h2 id="SDL中的事件处理"><a href="#SDL中的事件处理" class="headerlink" title="SDL中的事件处理"></a>SDL中的事件处理</h2><p>要想了解 SDL 的事件处理，我们必须要知道的一个原理是，SDL将所有事件都存放在一个队列中。所有对事件的操作，其实就是对队列的操作。了解了这个原理后，我们再来说SDL提供的 API 就很容易理解了。</p><ul><li>SDL_PollEvent: 将队列头中的事件抛出来。</li><li>SDL_WaitEvent: 当队列中有事件时，抛出事件。否则处于阻塞状态，释放 CPU。</li><li>SDL_WaitEventTimeout: 与SDL_WaitEvent的区别时，当到达超时时间后，退出阻塞状态。</li><li>SDL_PeekEvent: 从队列中取出事件，但该事件不从队列中删除。</li><li>SDL_PushEvent: 向队列中插入事件。</li></ul><p>SDL只提供了这样几个简单的API，下面们来介绍几个常见的事件：</p><ul><li>SDL_WindowEvent : Window窗口相关的事件。</li><li>SDL_KeyboardEvent : 键盘相关的事件。</li><li>SDL_MouseMotionEvent : 鼠标移动相关的事件。</li><li>SDL_QuitEvent : 退出事件。</li><li>SDL_UserEvent : 用户自定义事件。</li></ul><p>关于事件更加详的信息可以到 <a href="https://wiki.libsdl.org/SDL_Event">SDL Wiki</a> 上进行查询。现在我们来看一个使用的例子吧。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>在我们之前文章的例子中，大家已经发现一个问题，那就是窗口只显示了 3 秒钟，之后就自动消失了。</p><p>有的同学可以会通过修改代码最后面的 SDL_Delay 函数，增加它的等待时间让窗口多活一段时间。</p><p>但这样的体验实在是太糟糕了。有没有一种好的办法可以解决这个问题呢？能不能窗口一直显示，直到检测到用户按了<code>ctrl+c</code> 或 使用鼠标点击关闭按钮后才关闭呢？</p><p>当然是可以的。我们只需要在之前的程序的末尾增加下面这段代码即可。它会一直检测用户是否按下了退出按钮。如果检测到了，则直接退出，否则保持显示状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">while(!quit)&#123;</span><br><span class="line">    SDL_Event event;</span><br><span class="line">    while(SDL_PollEvent(&amp;event))&#123;</span><br><span class="line">        switch(event.type)&#123;</span><br><span class="line">            case SDL_QUIT:</span><br><span class="line">               quit = 1;</span><br><span class="line">               break;</span><br><span class="line">            default:</span><br><span class="line">               SDL_Log(&quot;.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SDL-PollEvent-与-SDL-WaitEvent"><a href="#SDL-PollEvent-与-SDL-WaitEvent" class="headerlink" title="SDL_PollEvent 与 SDL_WaitEvent"></a>SDL_PollEvent 与 SDL_WaitEvent</h2><p>增加了上面的代码，我们的实验程序似乎也显的很正规了。但有一个问题不知你发现没有<br>?当我们打开任务管理器时，发现我们的程序居然占了 100% 的 CPU。My GOD!这个的结果是决对不能接受的。</p><p>是什么原因造成的呢？我们来仔细看一下我们增加的代码吧。它由两层 while 循环组成，最里面的while循环的意思是，当队列中一直能取出事件，那就让他一直做下去，直到事件队列为空。外面的while循环的意思是，当队列为空的时候，重新执行内部的while循环。</p><p>也就是说，这段代码一直在工作，从不休息。所以导致cpu占到了100%。即然找到了问题的原因，我们就好处理了，只要在外层循环的最后 delay一下，让CPU休息一下就好了。</p><p>当然，SDL还为我们提供了 SDL_WaitEvent方法，使用这个API,你的CPU就不会跑到 100%了，因为当它发现队列为空时，它会阻塞在那里，并将CPU释放掉。</p><p>即然有 SDL_WaitEvent了，为什么还要有SDL_PollEvent呢？这主要是由于使用的场景不同。对于游戏来说，它要求事件的实时处理； 而对于一些其它实时性不高的case来说，则可以使用 SDL_WaitEvent了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到此，本文的内容就介绍完了。在本文中主要介绍了SDL是如何处理事件的，SDL为我们提供了非常简单的API，这大大减少了我们的开发成本。</p><p>另外，我在文章的最后，介绍了SDL_PollEvent 与 SDL_WaitEvent两个 API的区别。这也是使用 SDL 事件处理中最容易引起困惑的地方。</p><p>希望本文能对您有所帮助，谢谢！</p><h2 id="推荐阅读："><a href="#推荐阅读：" class="headerlink" title="推荐阅读："></a>推荐阅读：</h2><ul><li><a href="http://www.avdancedu.com/56ef4bcb">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8">SDL基本图形绘制</a></li><li><a href="http://www.avdancedu.com/a0ec02a7">SDL事件处事</a></li><li><a href="http://www.avdancedu.com/67189745">彻底理解SDL纹理</a></li><li><a href="http://www.avdancedu.com/a6aca2fe">SDL孙悟空与多线程</a></li><li><a href="http://www.avdancedu.com/f94132a0">PCM音频播放器的实现</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面我为大家介绍了 SDL 的三个主题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/56ef4bcb&quot;&gt;SDL 入门&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/287ad9ab&quot;&gt;SDL窗口渲染&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/24ee78a8&quot;&gt;SDL基本图形绘制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今天我为大家介绍一下SDL的事件处理。这里所指的事件处理就是我们通常所说的，键盘事件，鼠标事件，窗口事件等。&lt;/p&gt;
&lt;p&gt;SDL对这些事件都做了封装，提供了统一的API，下面我们就来详细的看一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="视频渲染" scheme="https://blog.avdancedu.com/categories/%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93/"/>
    
    
      <category term="SDL" scheme="https://blog.avdancedu.com/tags/SDL/"/>
    
  </entry>
  
  <entry>
    <title>SDL入门</title>
    <link href="https://blog.avdancedu.com/56ef4bcb/"/>
    <id>https://blog.avdancedu.com/56ef4bcb/</id>
    <published>2022-11-19T06:52:00.000Z</published>
    <updated>2022-11-20T05:07:01.481Z</updated>
    
    <content type="html"><![CDATA[<p>推荐阅读：</p><ul><li><a href="http://www.avdancedu.com/56ef4bcb">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8">SDL基本图形绘制</a></li><li><a href="http://www.avdancedu.com/a0ec02a7">SDL事件处事</a></li><li><a href="http://www.avdancedu.com/67189745">彻底理解SDL纹理</a></li><li><a href="http://www.avdancedu.com/a6aca2fe">SDL孙悟空与多线程</a></li><li><a href="http://www.avdancedu.com/f94132a0">PCM音频播放器的实现</a></li></ul><p>SDL是 “Simple DirectMedia Layer”的缩写，它是一个开源的项目。其主要用于游戏开发中的多媒体处理，如视频渲染，音频播放，鼠标&#x2F;键盘控制等操作。</p><p>并且它是一个跨平台的多媒体库。也就是说它对外接供了一套统一的接口，但在内部，它会根据不同平台调用不同的底层 API库。如在 Linux 系统下，它会使用 opengl 做渲染，而在 Window 下它会调用 D3D API进行渲染。</p><p>我之所以要介绍它，主要是因为我要在开发的多媒体播放器中使用它。</p><span id="more"></span><h2 id="SDL的编译与安装"><a href="#SDL的编译与安装" class="headerlink" title="SDL的编译与安装"></a>SDL的编译与安装</h2><p>目前 SDL 分为 SDL1 和 SDL2 两个主要版本。这两上版本差异非常大，无法相兼容。不过SDL1已经基本过时，主流产品都在使用的 SDL2，所以我们这里也使用SDL2作为例子进行讲解。</p><ul><li><p><a href="https://www.libsdl.org/download-2.0.php">下载SDL源码</a>（<strong>可能需要翻墙才行</strong>）</p></li><li><p>编译与安装</p><ul><li><p>生成SDL的Makefile</p><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configure --prefix=/usr/local</span><br></pre></td></tr></table></figure></code></pre></li><li><p>编译并安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="使用-SDL2-的其本流程"><a href="#使用-SDL2-的其本流程" class="headerlink" title="使用 SDL2 的其本流程"></a>使用 SDL2 的其本流程</h2><p>当我们通过源码编译并安装好 SDL2后，在我们的程序中使用 SDL2 就非常简单了，只要按照下面的步骤就可以绘制出一个窗口来。</p><ul><li><p>添加SDL头文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;SDL.h&gt;</span><br></pre></td></tr></table></figure></li><li><p>初始化SDL</p></li><li><p>创建窗口</p></li><li><p>销毁窗口</p></li><li><p>退出SDL</p></li></ul><p>当然，上面的步骤只是一个最基本的使用 SDL 的步骤，如果想了解更多的 SDL 的内容，静请期待我后面的文章。</p><h2 id="API详细介绍"><a href="#API详细介绍" class="headerlink" title="API详细介绍"></a>API详细介绍</h2><p>下面我们详细介绍一下上面用到的几个SDL API。</p><ul><li><p>初始化 SDL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int SDL_Init(Uint32 flags)</span><br></pre></td></tr></table></figure><table><thead><tr><th>flags</th><th>说明</th></tr></thead><tbody><tr><td>SDL_INIT_TIMER</td><td>timer subsystem</td></tr><tr><td>SDL_INIT_AUDIO</td><td>audio subsystem</td></tr><tr><td>SDL_INIT_VIDEO</td><td>video subsystem; automatically initializes the events subsystem</td></tr><tr><td>SDL_INIT_EVENTS</td><td>events subsystem</td></tr><tr><td>SDL_INIT_EVERYTHING</td><td>all of the above subsystems</td></tr></tbody></table><p>返回值：0, 成功。非0, 失败。</p></li><li><p>退出 SDL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void SDL_Quit(void)</span><br></pre></td></tr></table></figure></li><li><p>打印日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void SDL_Log(const char* fmt, ...)</span><br></pre></td></tr></table></figure><p>它与 C 语言中的 printf 格式相同。</p></li><li><p>创建窗口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SDL_Window* SDL_CreateWindow(const char* title,</span><br><span class="line">                           int         x,</span><br><span class="line">                           int         y,</span><br><span class="line">                           int         w,</span><br><span class="line">                           int         h,</span><br><span class="line">                           Uint32      flags)</span><br></pre></td></tr></table></figure><ul><li><p>title：窗口标题</p></li><li><p>x,y,w,h：窗口坐标</p></li><li><p>flag</p><table><thead><tr><th>flags</th><th>说明</th></tr></thead><tbody><tr><td>SDL_WINDOW_FULLSCREEN</td><td>fullscreen window</td></tr><tr><td>SDL_WINDOW_FULLSCREEN_DESKTOP</td><td>fullscreen window at the current desktop resolution</td></tr><tr><td>SDL_WINDOW_OPENGL</td><td>window usable with OpenGL context</td></tr><tr><td>SDL_WINDOW_HIDDEN</td><td>window is not visible</td></tr><tr><td>SDL_WINDOW_BORDERLESS</td><td>no window decoration</td></tr><tr><td>SDL_WINDOW_RESIZABLE</td><td>window can be resized</td></tr><tr><td>SDL_WINDOW_MINIMIZED</td><td>window is minimized</td></tr><tr><td>SDL_WINDOW_MAXIMIZED</td><td>window is maximized</td></tr><tr><td>SDL_WINDOW_SHOWN</td><td>show window</td></tr></tbody></table></li></ul></li><li><p>销毁窗口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void SDL_DestroyWindow(SDL_Window* window)</span><br></pre></td></tr></table></figure></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>下面是一个完整的使用SDL创建窗口的例子，你可以在 linux&#x2F;mac环境下执行它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;SDL.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    int flag = 1;</span><br><span class="line"></span><br><span class="line">    SDL_Window *window;                    // Declare a pointer</span><br><span class="line"></span><br><span class="line">    SDL_Init(SDL_INIT_VIDEO);              // Initialize SDL2</span><br><span class="line"></span><br><span class="line">    // Create an application window with the following settings:</span><br><span class="line">    window = SDL_CreateWindow(</span><br><span class="line">        &quot;An SDL2 window&quot;,                  // window title</span><br><span class="line">        SDL_WINDOWPOS_UNDEFINED,           // initial x position</span><br><span class="line">        SDL_WINDOWPOS_UNDEFINED,           // initial y position</span><br><span class="line">        640,                               // width, in pixels</span><br><span class="line">        480,                               // height, in pixels</span><br><span class="line">        SDL_WINDOW_SHOWN | SDL_WINDOW_BORDERLESS// flags - see below</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // Check that the window was successfully created</span><br><span class="line">    if (window == NULL) &#123;</span><br><span class="line">        // In the case that the window could not be made...</span><br><span class="line">        printf(&quot;Could not create window: %s\n&quot;, SDL_GetError());</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The window is open: could enter program loop here (see SDL_PollEvent())</span><br><span class="line"></span><br><span class="line">    SDL_Delay(3000);  // Pause execution for 3000 milliseconds, for example</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    // Close and destroy the window</span><br><span class="line">    SDL_DestroyWindow(window);</span><br><span class="line"></span><br><span class="line">    // Clean up</span><br><span class="line">    SDL_Quit();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你可以使用下面的命令在linux&#x2F;mac上编译上面的程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc/clang -g -o sdl2_base 文件名.c `pkg-config --cflags --libs sdl2`</span><br></pre></td></tr></table></figure><p>编译出的程序名为 sdl2_base，执行下面的命令就可能看到运行的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sdl2_base</span><br></pre></td></tr></table></figure><p><strong>需要注意的是，虽然上面的程序可以正常编译执行，但你会发现该程序创建的窗口并不能显示出来。我会在第二篇文章中介绍如何让窗口正常的显示出来</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过本文的介绍大家是不是觉得使用 SDL 非常简单易用呢？当然也许有人不太喜欢 SDL，认为直接使用 opengl 更高效。</p><p>但你要知道，SDL不只是对图像渲染做了封装，它还对其它媒体API做了封装，如对音频处理的封装等。这些封装大大减少了我们的开发工作量。</p><p>从另一方面讲，SDL 是一款非常优秀有多媒体库，除了使用它，其实我们还可以通过对其源码的分析，从中学到很多使用底层API的技巧。尤其是想学习播放器开发的同学，更是应该学好 SDL，因为著名的 ffplay 就是用的 SDL 做视频和音频的最终渲染与播放的。</p><p>最后，希望本文能帮你进行到 SDL 的世界。</p><h2 id="推荐阅读："><a href="#推荐阅读：" class="headerlink" title="推荐阅读："></a>推荐阅读：</h2><ul><li><a href="http://www.avdancedu.com/56ef4bcb">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8">SDL基本图形绘制</a></li><li><a href="http://www.avdancedu.com/a0ec02a7">SDL事件处事</a></li><li><a href="http://www.avdancedu.com/67189745">彻底理解SDL纹理</a></li><li><a href="http://www.avdancedu.com/a6aca2fe">SDL孙悟空与多线程</a></li><li><a href="http://www.avdancedu.com/f94132a0">PCM音频播放器的实现</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/56ef4bcb&quot;&gt;SDL 入门&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/287ad9ab&quot;&gt;SDL窗口渲染&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/24ee78a8&quot;&gt;SDL基本图形绘制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/a0ec02a7&quot;&gt;SDL事件处事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/67189745&quot;&gt;彻底理解SDL纹理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/a6aca2fe&quot;&gt;SDL孙悟空与多线程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/f94132a0&quot;&gt;PCM音频播放器的实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SDL是 “Simple DirectMedia Layer”的缩写，它是一个开源的项目。其主要用于游戏开发中的多媒体处理，如视频渲染，音频播放，鼠标&amp;#x2F;键盘控制等操作。&lt;/p&gt;
&lt;p&gt;并且它是一个跨平台的多媒体库。也就是说它对外接供了一套统一的接口，但在内部，它会根据不同平台调用不同的底层 API库。如在 Linux 系统下，它会使用 opengl 做渲染，而在 Window 下它会调用 D3D API进行渲染。&lt;/p&gt;
&lt;p&gt;我之所以要介绍它，主要是因为我要在开发的多媒体播放器中使用它。&lt;/p&gt;
    
    </summary>
    
    
      <category term="视频渲染" scheme="https://blog.avdancedu.com/categories/%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93/"/>
    
    
      <category term="SDL" scheme="https://blog.avdancedu.com/tags/SDL/"/>
    
      <category term="视频渲染" scheme="https://blog.avdancedu.com/tags/%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
</feed>
