<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>音视跳动科技</title>
  
  <subtitle>传播最前沿的科技知识！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.avdancedu.com/"/>
  <updated>2021-08-20T11:21:52.620Z</updated>
  <id>https://blog.avdancedu.com/</id>
  
  <author>
    <name>音视跳动</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《WebRTC音视频实时互动技术--原理、实战与源码分析》勘误表</title>
    <link href="https://blog.avdancedu.com/f2403a12/"/>
    <id>https://blog.avdancedu.com/f2403a12/</id>
    <published>2021-08-20T11:21:52.620Z</published>
    <updated>2021-08-20T11:21:52.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="勘误一"><a href="#勘误一" class="headerlink" title="勘误一"></a>勘误一</h2><p>a. P3, 1.2节，第三段中的 AVI 应为 AV1.<br>b. P11,  2.1.3节，第一段中的 AVI 应为 AV1<br>c. P22，3.2.2 节，第三段中的所有 AVI 应为 AV1<br>d. P261， 13.5节，第二段中的 AVI 应为 AV1</p><h2 id="勘误二"><a href="#勘误二" class="headerlink" title="勘误二"></a>勘误二</h2><p>P15，第三段应为：</p><p>“从上面的描述中你可以看到，在 WebRTC 架构的四层中，最复杂、最核心的是第三层，即 引擎层，因此，这里我再对引擎层内部的关系做下简要介绍。引擎层包括三部分内容，分别是: 音频引擎、视频引擎以及网络传输。其中<strong>音频引擎</strong>和视频引擎是相对比较独立的。不过，它们 都需要与网络传输层(transport)打交道。也就是说，它们都需要将自己产生的数据通过网络 传输层发送出去;同时，也需要通过网络传输层接收其它端发过来的数据。此外，音频引擎与 视频引擎由于要进行音视频同步的原因，所以它们之间也存在着关联关系。”</p><h2 id="勘误三"><a href="#勘误三" class="headerlink" title="勘误三"></a>勘误三</h2><p>P43，第四段第一个单词<strong>groudId</strong>应为<strong>groupId</strong>。</p><h2 id="勘误四"><a href="#勘误四" class="headerlink" title="勘误四"></a>勘误四</h2><p>P98，表6.2各NAT之间可穿越表应为：<br><img data-src="https://cdn.avdancedu.com/image/article/webrtc_book_kw/NAT_table.png" alt=""></p><a id="more"></a><h2 id="勘误五"><a href="#勘误五" class="headerlink" title="勘误五"></a>勘误五</h2><p>P103，6.4.2小节倒数第二应为：<br><img data-src="https://cdn.avdancedu.com/image/article/webrtc_book_kw/turn_protocal.png" alt=""></p><p>“因为主机 A 拿到了主机 B 的 Relay 类型的 Candidate，即 RelayB，所以主机 A 可以直接将音视频数据发向 RelayB。TurnServer 从 RelayB 接收到数据后，会将数据 打包成 TURN 消息，经 3478 端口发往主机<strong>B</strong>。主机<strong>B</strong>收数据后，再利用 TurnClient 模块将数据从 TURN 消息中取出，交给其它模块做进一步处理; 同理，主机 B 与主机 A 的操作流程是一样的。TurnServer 从 RelayA 收到数据后，将其打包成 TURN 消息， 也要经过 3478 端口转发给主机<strong>A</strong>。”</p><h2 id="勘误六"><a href="#勘误六" class="headerlink" title="勘误六"></a>勘误六</h2><p>P114，第一段应为：</p><p>“程， 默认情况下 WebRTC 会将 VP8/H264 等编码器编码后的数据再交由 red 模块编码，生成带一些冗余信息的数据包，这样当传输中某个包丢了，就可以通过其他包将其恢复回来，而不用重传丢失的包。了解了上面这些内容后，第 <strong>16～18</strong> 行代码的含义应该就清楚了，即 PT 值为 124 表示需要使用 red 对之前编码好的数据再进行 red 处理，119 是 PT=124 重传数据 包的 PayloadType。如果用 Wireshark 等抓包工具抓取 WebRTC 媒体数据包时会发现它们都 是 red 包，而在 red 包里装的是 VP8/H264 编码的数据。”</p><h2 id="勘误七"><a href="#勘误七" class="headerlink" title="勘误七"></a>勘误七</h2><p>P124，代码行号69，内容应为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">69 使用Opus时，每个音频帧的最小间隔为10毫秒，使用带内FEC</span><br><span class="line">70 a&#x3D;fmtp:111 minptime&#x3D;10;useinbandfec&#x3D;1</span><br></pre></td></tr></table></figure><h2 id="勘误八"><a href="#勘误八" class="headerlink" title="勘误八"></a>勘误八</h2><p>P168，图9.10有误，正确的图如下所示：<br><img data-src="https://cdn.avdancedu.com/image/article/webrtc_book_kw/onebyeheader2.png" alt=""></p><h2 id="勘误九"><a href="#勘误九" class="headerlink" title="勘误九"></a>勘误九</h2><p>P175，10.1 节的第一段应为：</p><p>“在 WebRTC 中包含多种拥塞控制算法，有 GCC、BBR和 PCC。GCC 根据其实现又可细分为基于发送端的拥塞控制算法 Transport-CC4和基于<strong>接收端</strong>的拥塞控制算法 Goog-REMB。”</p><h2 id="勘误十"><a href="#勘误十" class="headerlink" title="勘误十"></a>勘误十</h2><p>P176，第一段中的<strong>QUICK</strong>应该为<strong>QUIC</strong>。此外，注脚中的<strong>QUICK</strong>，也应为<strong>QUIC</strong>。</p><h2 id="勘误十一"><a href="#勘误十一" class="headerlink" title="勘误十一"></a>勘误十一</h2><p>P183, 公式10.19 下面一段的第一句应为：</p><p>“在上述公式中，d(i) 表示当前包组到达时长与包组发送时长之差，<strong>参见公式10.4。</strong>正常情况下该值有正有负, ……”</p><h2 id="勘误十二"><a href="#勘误十二" class="headerlink" title="勘误十二"></a>勘误十二</h2><p>P271, 第一段应为：</p><p>“在上述代码中，如果对其再进行简化的话，可以发现 StartNextDecode() 方法中只调用了frame_buffer_对象的 NextFrame() 这个方法。由于该方法传入参数过于复杂，所以不太好理解，其实关键点是掌握其核心代码的第9～15行。”</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;勘误一&quot;&gt;&lt;a href=&quot;#勘误一&quot; class=&quot;headerlink&quot; title=&quot;勘误一&quot;&gt;&lt;/a&gt;勘误一&lt;/h2&gt;&lt;p&gt;a. P3, 1.2节，第三段中的 AVI 应为 AV1.&lt;br&gt;b. P11,  2.1.3节，第一段中的 AVI 应为 AV1&lt;br&gt;c. P22，3.2.2 节，第三段中的所有 AVI 应为 AV1&lt;br&gt;d. P261， 13.5节，第二段中的 AVI 应为 AV1&lt;/p&gt;
&lt;h2 id=&quot;勘误二&quot;&gt;&lt;a href=&quot;#勘误二&quot; class=&quot;headerlink&quot; title=&quot;勘误二&quot;&gt;&lt;/a&gt;勘误二&lt;/h2&gt;&lt;p&gt;P15，第三段应为：&lt;/p&gt;
&lt;p&gt;“从上面的描述中你可以看到，在 WebRTC 架构的四层中，最复杂、最核心的是第三层，即 引擎层，因此，这里我再对引擎层内部的关系做下简要介绍。引擎层包括三部分内容，分别是: 音频引擎、视频引擎以及网络传输。其中&lt;strong&gt;音频引擎&lt;/strong&gt;和视频引擎是相对比较独立的。不过，它们 都需要与网络传输层(transport)打交道。也就是说，它们都需要将自己产生的数据通过网络 传输层发送出去;同时，也需要通过网络传输层接收其它端发过来的数据。此外，音频引擎与 视频引擎由于要进行音视频同步的原因，所以它们之间也存在着关联关系。”&lt;/p&gt;
&lt;h2 id=&quot;勘误三&quot;&gt;&lt;a href=&quot;#勘误三&quot; class=&quot;headerlink&quot; title=&quot;勘误三&quot;&gt;&lt;/a&gt;勘误三&lt;/h2&gt;&lt;p&gt;P43，第四段第一个单词&lt;strong&gt;groudId&lt;/strong&gt;应为&lt;strong&gt;groupId&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;勘误四&quot;&gt;&lt;a href=&quot;#勘误四&quot; class=&quot;headerlink&quot; title=&quot;勘误四&quot;&gt;&lt;/a&gt;勘误四&lt;/h2&gt;&lt;p&gt;P98，表6.2各NAT之间可穿越表应为：&lt;br&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/webrtc_book_kw/NAT_table.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Windows下编译WebRTC</title>
    <link href="https://blog.avdancedu.com/2bafd6cf/"/>
    <id>https://blog.avdancedu.com/2bafd6cf/</id>
    <published>2021-08-16T03:13:22.767Z</published>
    <updated>2021-08-16T03:13:22.768Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/webrtc_build/webrtc%E6%9E%B6%E6%9E%84.png" alt=""></p><p>随着音视频技术的不断普及，Google推出的 WebRTC 越来越受到大家的喜欢。现在很多直播产品都是基于WebRTC 进行二次开发做出来的。</p><p>WebRTC是提供了一整套处理实时音视频的开源库。它包括了音视频处理（采集，编解码，前处理，后处理，渲染），数据传输（实时传输，流控）和业务逻辑控制。可以说 WebRTC 的出现大大减少了做音视频开发的难度，所以熟练掌握好这个库对于做音视频相关的同学就显的特别重要了。</p><p>要想掌握 WebRTC 要过的头一关就是如何编译它。WebRTC库非常庞大，光源码就有几个G，所以它对开发主机的性能，网络带宽的要求都非常高。另外，在Windows平台下，它对Windows的系统版本，Visual Studio 版本也都有明确的要求，所以只要其中某一项出问题了，都可能导致失败。这就是为什么很多人在编译WebRTC经常失败的原因。</p><p>下面我们言归正传，介绍一下在如何在 Windows下成功编译WebRTC.</p><a id="more"></a><blockquote><p>注意：本文所有的操作的前提条件是，你可以访问外网</p></blockquote><h2 id="主机及系统配置"><a href="#主机及系统配置" class="headerlink" title="主机及系统配置"></a>主机及系统配置</h2><p>第一、WebRTC要求是 64位机器 8G 内存，最好超过16G内存。</p><blockquote><p>我实际的配置是 64位机器，4G内存，4核CPU也是没问题的。</p></blockquote><p>第二、至少 100G 磁盘空间，NTFS格式。</p><blockquote><p>FAT32格式是不能工作的，因为WebRTC中有的文件大于 4G。</p></blockquote><p>第三、Visual Studio 2019社区版即可。</p><blockquote><p>VS 不需要是英文版本</p></blockquote><p>第四、操作系统需要 Win10 系统。</p><h2 id="安装虚拟机（可选）"><a href="#安装虚拟机（可选）" class="headerlink" title="安装虚拟机（可选）"></a>安装虚拟机（可选）</h2><p>由于环境的问题经常会导致编译失败，所以为了方便设置环境，我使用了VirtualBox虚拟机（该虚拟机是免费的）。相较于VMware它虽然性能稍差，但完全够我们编译开发WebRTC使用。所以我们也不必在虚拟机这个环节上纠结。</p><p>安装虚拟机需要注意以下几点：</p><ol><li>为了更好的利用硬件，需要确认你机子的BOIS中是否打开了虚拟化选项，这对虚拟机的性能会产生很大影响。</li><li>在虚拟机上安装完系统后，一定要安装虚拟的<a href="https://jingyan.baidu.com/article/6525d4b13b7d0fac7d2e94ef.html" target="_blank" rel="noopener">增强驱动</a>，这样虚拟机要才能全屏显示。不会的可去问度娘。</li></ol><h2 id="安装-Visual-Stuido-注意事项"><a href="#安装-Visual-Stuido-注意事项" class="headerlink" title="安装 Visual Stuido 注意事项"></a>安装 Visual Stuido 注意事项</h2><p>安装 Visual Studio 2019 ，可以使用免费的 Community Edition 版本。在安装 VS 时选择定制（Custom Install）安装，并选择下面的模块:</p><ul><li>在安装VS2019之前先将Windows 10 SDK 安装好，<a href="https://developer.microsoft.com/zh-cn/windows/downloads/windows-10-sdk/" target="_blank" rel="noopener">下载地址</a></li><li><a href="https://visualstudio.microsoft.com/zh-hans/free-developer-offers/" target="_blank" rel="noopener">VS2019的下载地址</a></li><li>安装Win 10 SDK 时，要选择 “Debugging Tools For Windows” 这项，以便在你的开发环境中安装调试工具 windbg 和 cdb，这些工具会在后面测试和调试时使用。</li><li>安装SDK和VS2019时，要将它们安装到C盘</li><li>当VS2109下载好后，在命令行中执行下面的命令来安装：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ PATH_TO_INSTALLER.EXE ^</span><br><span class="line">--add Microsoft.VisualStudio.Workload.NativeDesktop ^</span><br><span class="line">--add Microsoft.VisualStudio.Component.VC.ATLMFC ^</span><br><span class="line">--includeRecommended</span><br></pre></td></tr></table></figure><blockquote><p>注意，如果 Windows SDK 是通过 Visual Studio 安装的, 则 调试 Tools 需要按下面步骤安装: </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Control Panel → Programs → Programs and Features → Select the “Windows Software Development Kit” v14393 → Change → Change → Check “Debugging Tools For Windows” → Change.</span><br></pre></td></tr></table></figure><h2 id="安装-depot-tools"><a href="#安装-depot-tools" class="headerlink" title="安装 depot_tools"></a>安装 depot_tools</h2><p>depot_tools就是一堆下载代码，编译等相关的工具，Google统一打包在 <a href="https://storage.googleapis.com/chrome-infra/depot_tools.zip" target="_blank" rel="noopener">depot_tools</a>中，你需将它下载到本地。</p><p><strong>首先</strong>，将 depot_tools.zip 文件解压。</p><p><strong>其次</strong>，将 depot_tools 目录地址添加到你机器的 <strong>系统环境变量 PATH</strong>  里，而不是用户级的环境变量里。具体操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Control Panel → System and Security → System → Advanced system settings</span><br></pre></td></tr></table></figure><blockquote><p>注意，必须将它放在PATH环境变量的开头。</p></blockquote><p><strong>然后</strong>，用同样的方法将 <strong>DEPOT_TOOLS_WIN_TOOLCHAIN</strong> 设置到你的系统环境变量里，并设置它的值为 0 ，该变量会告诉 depot_tools 使用你本地安装的 Visual Studio 版本。</p><blockquote><p>默认，depot_tools 使用 Google 内部版本。</p></blockquote><p><strong>最后</strong>，打开 cmd.exe, 运行 gclient 命令(不用带作何参数)。第一次运行时，gclient 将安装 Windows 下需要的工具, 包括 msysgit 和 python。gclient 执行完后，在命令行提示符下输入 python 将会显示 python.bat ，这就说明 depot_tools 安装好了。</p><h2 id="获取-WebRTC-代码"><a href="#获取-WebRTC-代码" class="headerlink" title="获取 WebRTC 代码"></a>获取 WebRTC 代码</h2><p>执行下面的命令就可以获取 WebRTC 的代码了，也只有用这种方式，后面才能编译通过。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. mkdir webrtc-checkout</span><br><span class="line">2. cd webrtc-checkout</span><br><span class="line">3. fetch --nohooks webrtc</span><br><span class="line">4. gclient sync</span><br></pre></td></tr></table></figure><blockquote><p>注意，由于 WebRTC 的代码量非常大，所以我一般都是在晚上让他去下载，第二天就可以用了。</p></blockquote><h2 id="编译及生成工程文件"><a href="#编译及生成工程文件" class="headerlink" title="编译及生成工程文件"></a>编译及生成工程文件</h2><p>执行下面的命令就可以编译WebRTC了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd src</span><br><span class="line">$ gn gen out&#x2F;Default</span><br><span class="line">$ ninja -C out&#x2F;Default</span><br></pre></td></tr></table></figure><p>编译成功后，执行下面的命令生成VS工程文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gn gen --ide&#x3D;vs out\Default</span><br></pre></td></tr></table></figure><p>这时，我们就可以在 src\out\Default\ 目录下找到 all.sln 这个工程文件，到这里我们就大功告成了。</p><h2 id="切换Branch"><a href="#切换Branch" class="headerlink" title="切换Branch"></a>切换Branch</h2><p>有时候我们需要切到WebRTC的某个分支，可以按下面的步聚操作：</p><ul><li>查看WebRTC远端有哪些分支</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure><ul><li>切换到某个具体的分支</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b my_branch refs&#x2F;remotes&#x2F;branch-heads&#x2F;xxxx</span><br><span class="line">gclient sync</span><br></pre></td></tr></table></figure><h2 id="指定VS-版本"><a href="#指定VS-版本" class="headerlink" title="指定VS 版本"></a>指定VS 版本</h2><p>有时间我们需要使用VS的老版本编译旧的WebRTC源码，此时除了需要在Windows上安装老版本VS外，还需要设置如下环境变量，这样WebRTC才会使用老的VS版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set GYP_MSVS_VERSION &#x3D; 2019</span><br><span class="line">set GYP_MSVS_OVERRIDE_PATH &#x3D; C:\Program Files (x86)\Microsoft Visual Studio\2019\Community</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们上面详细介绍了编译WebRTC的步骤，由于WebRTC本身的原因，大家在操作时一定要仔细阅读每一步，否则都有可能导致编译失败。</p><p>谢谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/webrtc_build/webrtc%E6%9E%B6%E6%9E%84.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;随着音视频技术的不断普及，Google推出的 WebRTC 越来越受到大家的喜欢。现在很多直播产品都是基于WebRTC 进行二次开发做出来的。&lt;/p&gt;
&lt;p&gt;WebRTC是提供了一整套处理实时音视频的开源库。它包括了音视频处理（采集，编解码，前处理，后处理，渲染），数据传输（实时传输，流控）和业务逻辑控制。可以说 WebRTC 的出现大大减少了做音视频开发的难度，所以熟练掌握好这个库对于做音视频相关的同学就显的特别重要了。&lt;/p&gt;
&lt;p&gt;要想掌握 WebRTC 要过的头一关就是如何编译它。WebRTC库非常庞大，光源码就有几个G，所以它对开发主机的性能，网络带宽的要求都非常高。另外，在Windows平台下，它对Windows的系统版本，Visual Studio 版本也都有明确的要求，所以只要其中某一项出问题了，都可能导致失败。这就是为什么很多人在编译WebRTC经常失败的原因。&lt;/p&gt;
&lt;p&gt;下面我们言归正传，介绍一下在如何在 Windows下成功编译WebRTC.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>非常棒的GDB与LLDB命令对照表</title>
    <link href="https://blog.avdancedu.com/2ffb45c8/"/>
    <id>https://blog.avdancedu.com/2ffb45c8/</id>
    <published>2021-08-15T13:27:20.284Z</published>
    <updated>2021-08-15T13:27:20.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GDB与LLDB命令对照表"><a href="#GDB与LLDB命令对照表" class="headerlink" title="GDB与LLDB命令对照表"></a>GDB与LLDB命令对照表</h2><hr><p><a href="https://lldb.llvm.org/lldb-gdb.html" target="_blank" rel="noopener">GDB 与 LLDB 命令对照表1</a><br><a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-command-examples.html" target="_blank" rel="noopener">GDB 与 LLDB 命令对照表2</a></p><hr><a id="more"></a><h2 id="设置观察点"><a href="#设置观察点" class="headerlink" title="设置观察点"></a>设置观察点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wa s v 变量名</span><br><span class="line">或 watchpoint set variable 变量名</span><br></pre></td></tr></table></figure><ul><li>观察点必须是独立的原始变量，而不能是类变量或结构体变量。</li></ul><h2 id="目前-LLDB-无法打印宏信息"><a href="#目前-LLDB-无法打印宏信息" class="headerlink" title="目前 LLDB 无法打印宏信息"></a>目前 LLDB 无法打印宏信息</h2><h2 id="查看内存内容"><a href="#查看内存内容" class="headerlink" title="查看内存内容"></a>查看内存内容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x -s4 -fx -c4 0xbffff3c0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;GDB与LLDB命令对照表&quot;&gt;&lt;a href=&quot;#GDB与LLDB命令对照表&quot; class=&quot;headerlink&quot; title=&quot;GDB与LLDB命令对照表&quot;&gt;&lt;/a&gt;GDB与LLDB命令对照表&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;https://lldb.llvm.org/lldb-gdb.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GDB 与 LLDB 命令对照表1&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-command-examples.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GDB 与 LLDB 命令对照表2&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>WebRTC传输与服务质量</title>
    <link href="https://blog.avdancedu.com/2763ac60/"/>
    <id>https://blog.avdancedu.com/2763ac60/</id>
    <published>2021-08-12T18:08:41.733Z</published>
    <updated>2021-08-12T18:08:41.734Z</updated>
    
    <content type="html"><![CDATA[<p>作者 | 李超<br>整理 | LiveVideoStack</p><p>非常高兴和大家一同探讨WebRTC传输是如何保证音视频服务质量的。</p><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_1.webp" alt=""></p><p>本次分享我将从四个方面向大家介绍一下WebRTC传输是如何保证音视频服务质量的。第一，实时通信的目标。我们首先需要确定实时通信的目标，才能够知道要将实时通信做成怎样的系统、保证怎样的实时性；第二，WebRTC如何保障数据传输的实时性；第三，进行实时传输时，想要满足实时性，网络与服务质量之间可能存在的矛盾；最后，就是WebRTC如何解决网络与服务质量之间的矛盾。</p><a id="more"></a><h2 id="实时通信的目标"><a href="#实时通信的目标" class="headerlink" title="实时通信的目标"></a>实时通信的目标</h2><h3 id="实时通信的目标是什么？"><a href="#实时通信的目标是什么？" class="headerlink" title="实时通信的目标是什么？"></a>实时通信的目标是什么？</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_2.webp" alt=""></p><p>首先提出两个问题：第一，开会时你是喜欢在办公室里，还是更喜欢在线上开？第二，如果有一场演唱会，你愿意去现场呢？还是愿意在线上听？</p><h3 id="线上与现在不同的原因"><a href="#线上与现在不同的原因" class="headerlink" title="线上与现在不同的原因"></a>线上与现在不同的原因</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_3.webp" alt=""></p><p>相信大家更多都会选择线下，理由是线上线下感觉不一样。其不同点在于：首先是摄像头与人眼看到的效果不一样，例如摄像头采集的角度过小、无法拍到某些角度的画面；其次是采集设备的质量参差不齐，一场会议中大家所使用的设备有的高清、有的模糊；最后，也是最关键的一点就是现场的气氛无法被摄像头采集到，每个人都有自己的气场，当大家聚集在一起时，现场氛围感非常热烈，但隔着屏幕无法感受到。</p><h3 id="实时通信的目标-1"><a href="#实时通信的目标-1" class="headerlink" title="实时通信的目标"></a>实时通信的目标</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_4.webp" alt=""></p><p>根据以上几点，我们可以总结出实时通信最终的目标是：尽可能逼近或达到面对面交流的效果。从目前的情况来看，超越面对面交流的效果是几乎不可能的。</p><h2 id="几个重要指标"><a href="#几个重要指标" class="headerlink" title="几个重要指标"></a>几个重要指标</h2><h3 id="几个重要指标-1"><a href="#几个重要指标-1" class="headerlink" title="几个重要指标"></a>几个重要指标</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_6.webp" alt=""></p><p>那么如何才能达到面对面交流的效果呢，这里涉及到几个重要指标。</p><p>最为关键的是实时通信的延迟指标，只有将延迟指标搞清楚，才能知道做实时通信时，达到怎样的延迟才算符合要求的，即接近面对面交流的效果。然后是音视频服务质量指标，延迟指标达到后，再根据这项指标判断音视频服务质量的好坏。</p><h3 id="实时通信延时指标"><a href="#实时通信延时指标" class="headerlink" title="实时通信延时指标"></a>实时通信延时指标</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_7.webp" alt=""></p><p>下面具体看一下延迟指标的分级标准。通过图中表格可以看到，如果端到端延迟在200ms以内，说明整个通话是优质的，通话效果就像大家在同一个房间里聊天一样；300ms以内，大多数人很满意，400ms以内，有小部分人可以感觉到延迟，但互动基本不受影响；500ms以上时，延迟会明显影响互动，大部分人都不满意。</p><p>所以最关键的一级是500ms，只有延迟低于500ms，才可以说是合格的实时互动系统。</p><h3 id="音频服务质量指标"><a href="#音频服务质量指标" class="headerlink" title="音频服务质量指标"></a>音频服务质量指标</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_8.webp" alt=""></p><p>接下来是音频服务质量指标，它根据MOS值来打分。4.0-5.0为“优”，评值标准是听得非常清楚，延时小，交流顺畅；3.5-4.0为“良”，音质稍差，听得清，延时小，有点杂音；3.0-3.5为“中”，音质较可，能听清，有一定时延，可以交流；1.5-3.0为“差”，勉强能够听清，交流时需要重复多次才能够表述清楚；0-1.5为“劣”，完全听不清，延时大，交流不畅。</p><h3 id="视频服务质量指标"><a href="#视频服务质量指标" class="headerlink" title="视频服务质量指标"></a>视频服务质量指标</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_9.png" alt=""></p><p>视频服务质量的评价标准有几个，它们也都是通过MOS值打分来判断质量好坏的，图中参考是以码流大小为标准评估指标。以640*480为例，如果想达到MOS值为4.5的优质效果，可以看到产生的码流的大小大概在3Mbps左右。这样的码流对于实时传输来说太大了，如果是640*480的视频占用3Mbps的带宽，那是一件非常奢侈的事儿。一般情况下，我们会选择MOS值为3.5（绿色线）的码流，其码流范围在600kbps左右。</p><p>从以上可以看到，在保证传输的实时性时，由于带宽是一定的，可能会牺牲一定的服务质量。</p><h2 id="主要矛盾"><a href="#主要矛盾" class="headerlink" title="主要矛盾"></a>主要矛盾</h2><h3 id="实时通信与服务质量的矛盾"><a href="#实时通信与服务质量的矛盾" class="headerlink" title="实时通信与服务质量的矛盾"></a>实时通信与服务质量的矛盾</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_10.webp" alt=""></p><p>通过了解上述三个指标，我们可以得到实时通信与服务质量的主要矛盾。</p><p>第一，码流与带宽之间的矛盾。要想达到好的质量，码流一般会比较大（当然，不能超过最大码流)，而带宽是有限的，于是码流和带宽之间就会产生矛盾；第二，实时性和服务质量之间的矛盾。通常为了保证好的实时性我们会选择UDP，而UDP不保证网络传输的可靠性，丢包、乱序是经常发生的。一旦出现丢包、乱序，网络传输质量就无法得到保证，最终会影响到音视频的质量。</p><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_11.webp" alt=""></p><p>这里我们就可以总结出实时通信的主要矛盾，即：音视频的质量与带宽大小、实时性和网络质量之间存在矛盾，其它包括3A问题都属于次要矛盾。</p><h2 id="解决矛盾方法"><a href="#解决矛盾方法" class="headerlink" title="解决矛盾方法"></a>解决矛盾方法</h2><h3 id="解决矛盾的方法"><a href="#解决矛盾的方法" class="headerlink" title="解决矛盾的方法"></a>解决矛盾的方法</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_12.webp" alt=""></p><p>下面来看下解决矛盾的方法。对于WebRTC来说，主要从以下几个方面解决主要矛盾：如何保障数据传输的实时性、如何提高网络质量、如何更准确的评估带宽、如何平衡码流与带宽。</p><h2 id="保障数据的实时性"><a href="#保障数据的实时性" class="headerlink" title="保障数据的实时性"></a>保障数据的实时性</h2><p>对于WebRTC来说，为了保障数据的实时性，提供了两种方法：一种是传输路径的选择，它首先会选择最佳的传输路径，使得端到端传输时采取最好、最短的传输路径从而保障数据传输的实时性；另一种是传输协议的选择，可以选择TCP或者UDP。下面咱们先看一下WebRTC是如何选择最佳传输路径的。</p><h3 id="选择一条最好的路径"><a href="#选择一条最好的路径" class="headerlink" title="选择一条最好的路径"></a>选择一条最好的路径</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_13.png" alt=""></p><p>图为WebRTC路径选择的架构图。图中包括三个端，A端、B端和C端，其中A和B在同一个局域网内，对于WebRTC来说，如果发现同一局域网内的两端需要通信时，会选择局域网内直连，从而保障网络路径最短最优；如果是A和C通信，它们不在同一局域网内，那么WebRTC会选择P2P直连，做NAT穿越，如果穿越成功，便可进行直连，这样路径相对服务器中转来说也比较短。只有在P2P不成功时，才会选择服务端中转。从图中可以看到，当一端通过TURN服务器将数据传输给另一端时，其传输路径明显长于P2P直连，所以对于WebRTC来说，它一定会选择最短、最优的路径，从而保障端到端的实时传输。</p><h3 id="使用TCP还是UDP？"><a href="#使用TCP还是UDP？" class="headerlink" title="使用TCP还是UDP？"></a>使用TCP还是UDP？</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_14.webp" alt=""></p><p>接下来看一下WebRTC对TCP/UDP协议的选择。在网络比较优质时，TCP/UDP都可以用于实时传输，但大多数情况下，我们首选UDP（后面会介绍UDP的优势）；弱网环境下不能使用TCP；而在进行网络穿越时，使用TCP又有较大的好处，在企业内可以使用TCP访问外网的80端口进行穿透。</p><h3 id="为什么极端网络环境下不能用TCP？"><a href="#为什么极端网络环境下不能用TCP？" class="headerlink" title="为什么极端网络环境下不能用TCP？"></a>为什么极端网络环境下不能用TCP？</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_15.webp" alt=""></p><p>为什么在弱网环境下不能用TCP？这是由于TCP的机制所造成的。TCP的机制是发送、确认、丢包、重传。正常情况下，数据从一端传输到另一端是没有任何问题的，但当出现丢包时就会有较大的麻烦。</p><p>图中显示了多次丢包时的延迟情况：从客户端向服务端发送数据包，服务端需要返回ACK消息进行确认; 客户端收到确认消息后, 才能继续发送后面的数据（有滑窗时也是类似的）。每次客户端发完数据后，都会启动一个定时器，定时器的最短超时时间是200ms。如果因某种原因，在200毫秒客户端没有收到返回的ACK包，客户端会重发上一个包。由于TCP有退避机制，以防止频繁发送丢失包，因此会将重发包的超时时间延长到400ms。如果重发包依然没有收到确认消息，则下一次重发的超时时间会延长到800ms。我们可以看到，连续几次丢包后，就会产生非常大的延迟，这就是TCP在弱网环境下不能使用的根本原因。</p><h3 id="选择UDP带来的问题"><a href="#选择UDP带来的问题" class="headerlink" title="选择UDP带来的问题"></a>选择UDP带来的问题</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_17.webp" alt=""></p><p>由于TCP的机制问题，因此通常我们会选择UDP来保障音视频传输的实时性。UDP在实时性方面有优势，但缺点同样明显。由于UDP是不可靠传输，它只能尽力送达，所以出现丢包、乱序是常见的事儿，但对于网络质量来说，丢包是非常严重的事情，这就需要我们自己处理这个问题。下面咱们就来看看WebRTC是如何解决这个问题的吧！</p><h2 id="如何提高网络质量"><a href="#如何提高网络质量" class="headerlink" title="如何提高网络质量"></a>如何提高网络质量</h2><h3 id="网络质量包含哪些指标"><a href="#网络质量包含哪些指标" class="headerlink" title="网络质量包含哪些指标"></a>网络质量包含哪些指标</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_18.webp" alt=""></p><p>那么，WebRTC是如何处理UDP的网络质量的呢？</p><p>要想解决网络质量，首先要知道影响网络质量的几个因素：它包括了丢包率、延迟时间、抖动、乱序。如果网络丢包率低、延迟时间小、不抖动、不乱序，这就是非常优质的网络啦。但如果丢包率很高，那么网络质量一定会很差。</p><h3 id="造成丢包的原因"><a href="#造成丢包的原因" class="headerlink" title="造成丢包的原因"></a>造成丢包的原因</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_19.webp" alt=""></p><p>图中是网络基本的拓扑，造成丢包的原因有很多，如链路质量差，当手机与基站连接时，由于信号不好会造成丢包，这就属于链路差，这种情况在移动端是经常发生的；第二是带宽满，比如一台机子上行发送码率比较大，而下行接收链路比较小，这时在上游的路由器会把数据缓存起来慢慢发送，但缓存是有限制的，一旦缓存被塞满，后面就会造成大量丢包；第三是主动丢包，比如路由是跨运营商的，在不同运营商之间传输数据时，可能由于运营商未知的原因造成丢包；第四是光线被挖断等偶然原因造成丢包。</p><h3 id="减少丢包的方法"><a href="#减少丢包的方法" class="headerlink" title="减少丢包的方法"></a>减少丢包的方法</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_20.webp" alt=""></p><p>WebRTC主要通过两种方式解决丢包：NACK和FEC。</p><h3 id="NACK"><a href="#NACK" class="headerlink" title="NACK"></a>NACK</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_21.webp" alt=""></p><p>NACK的作用是丢包重传。从图中你可以看到，WebRTC的发送端不停地向接收端发送RTP包，接收端每隔一小段时间，就对这段时间内的丢包情况进行统计。如果发现丢包，它会给发送端回一个NACK消息，NACK消息中记录了这一段时间内哪些包丢失了。发送端收到NACK后，会在之前的发送历史记录中找到丢失的包并重新发送。</p><h3 id="NACK适合使用的场景"><a href="#NACK适合使用的场景" class="headerlink" title="NACK适合使用的场景"></a>NACK适合使用的场景</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_22.webp" alt=""></p><p>当然，通过NACK重传，会产生一定的延时，该延时包括：等待发送NACK的时间（10或20ms），NACK经过网络的时延以及RTP的网络时延和重传RTP包的网络时延，即1.5RTT+10或20ms。通过这个公式我们可以知道，如果RTT时延比较大，比如200ms，那么1.5RTT就是300ms。通过前面讲述的实时传输延时指标我们可以知道，端到端实时传输的时延需要控制在500ms之内，如果仅数据的网络传输就占了300ms，那数据再经过采集、编码、解码、渲染等流程，这些处理时间加在一起很有可能就超过500ms。</p><p>所以可以得出结论，丢包重传仅适用于网络传输时延比较小的情况，如果RTT比较大时，就不适合使用丢包重传来保障网络质量了。</p><h3 id="FEC"><a href="#FEC" class="headerlink" title="FEC"></a>FEC</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_23.webp" alt=""></p><p>FEC的作用是通过冗余数据解决丢包。实际上，它就是一个异或操作。如图所示，假设传输的数据是Data1和Data2，这两个数据如果在传输的过程中没有FEC进行保护，其中一个数据丢失了，那只能通过NACK重新找回。那么，能否在传输过程中加一些冗余数据，以保证接收时，当某一个数据丢失后，不经过重传就可以将丢失的包找回来呢？这就是FEC。</p><p>在图中我们可以看到，Data1和Data2同时发送到对端，在发送时对它们做一下异或操作，即Data1的最后一位0与Data2的最后一位0异或为0，Data1的倒数第二位1与 Data2的倒数第二位1异或为0，依次类推，最后就产生了冗余数据R，同时将三个包从一端传输到另一端。传输过程中，如果Data1丢失，通过Data2和冗余包R就可以将Data1找回来。找回包的算法也是异或操作，即在接收端将Data2的每一位与冗余包中的相同位进行异或操作就算出了Data1。这就保证了不用重新请求，就将丢失包找回的作用。</p><p>而且异或具有传递性，A、B、C三个包可以同时异或得到D，如果其中任意一个包丢失，可以通过D和其它包找回丢失的包。</p><h3 id="ULPFEC"><a href="#ULPFEC" class="headerlink" title="ULPFEC"></a>ULPFEC</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_24.webp" alt=""></p><p>对于WebRTC来说，它默认使用的是ULPFEC。其原理是，将要传输的数据包先进行分组，如将三个包分为一组，然后为这一组包产生一个冗余包，如果这一组中某个包丢失了，就可以通过冗余包和其它包的异或操作将其找回。从图中第一行可以看到1和2到了，3丢了，通过R1可以找回3，第三行同样可以找回9。其缺点是，如果连续的两个包都丢失了，这种算法就失效了，比如第二行4和5丢失后，通过6和R2无法找回它们。</p><h3 id="FlexFEC"><a href="#FlexFEC" class="headerlink" title="FlexFEC"></a>FlexFEC</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_25.webp" alt=""></p><p>于是就有了改进的FlexFEC，它做了双向冗余处理，不仅横向做了冗余，而且纵向也做了冗余。</p><p>此时，当4和5同时丢失时，通过1、7和C1可以找到4，2、8和C2可以找到5，这样就可以找回连续的两个丢包。当然它也有弊端，其弊端是无法处理批量的连续丢包，例如连续丢失了10个包，FlexFEC对这种情况也无能为力。</p><p>以上就是WebRTC对于丢包的解决方法，通过“NACK+FEC”防止丢包。</p><h3 id="如何解决抖动和乱序"><a href="#如何解决抖动和乱序" class="headerlink" title="如何解决抖动和乱序"></a>如何解决抖动和乱序</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_26.webp" alt=""></p><p>下面来说说抖动和乱序。抖动的意思是，一会儿来了很多包，一会儿又一个没有，包是一波一波的来，包到达的时间很不平均；而乱序指的是先发的包后到了，后发的包先到了。</p><p>WebRTC处理抖动和乱序使用的是JitterBuffer和NetEQ。JitterBuffer用于处理视频包，NetEQ用于处理音频包。它们的原理大致相同（NetEQ更为复杂一些），都是通过一个队列（缓存区）对接收到的数据做下缓冲，然后再从队列的另一端将数据包一个个均匀的取出， 这样取出的数据就是平滑的了。</p><p>对于乱序的处理也比较好解决，如图中所示，每个RTP包进来的时候有一个序号（Sequence Number），在数据进入队列时，它会根据序号插到对应的位置上，比如图中104、107包已经到达，并且在对应的位置上，而103、105和106没来，位置就空着，等它们来了再插入对应的位置，这样就可以防止乱序，所以通过JitterBuffer和NetEQ就可以同时解决乱序和抖动了。</p><p>总结一下，NACK和FEC解决丢包问题，NACK会增加时延，FEC会占用带宽。JitterBuffer解决视频的乱序与抖动，NetEQ解决音频的乱序与抖动。</p><h3 id="网络延时产生的原因"><a href="#网络延时产生的原因" class="headerlink" title="网络延时产生的原因"></a>网络延时产生的原因</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_27.webp" alt=""></p><p>说到延时，实际上就与带宽评估有密切的关系了。延时的产生有两个原因：第一是链路问题，正常的网络上，数据包的传输都是时快时慢的；第二是发生了网络拥塞，当发生拥塞后，数据包会进行缓冲，就会造成延时，而当缓冲溢出时，就出现了丢包。</p><p>所以对于延时来说，我们需要解决的是因拥塞而造成的延时，链路问题无法解决。下面咱们就来看看WebRTC是如何防止拥塞的。</p><h2 id="准确的带宽评估方法"><a href="#准确的带宽评估方法" class="headerlink" title="准确的带宽评估方法"></a>准确的带宽评估方法</h2><h3 id="如何解决抖动和乱序-1"><a href="#如何解决抖动和乱序-1" class="headerlink" title="如何解决抖动和乱序"></a>如何解决抖动和乱序</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_28.webp" alt=""></p><p>WebRTC防止拥塞的根基是有准确的带宽评估方法。它提供了两种带宽评估方法，一种是基于丢包的带宽评估，另一种是基于延时的带宽评估。而基于延时的评估方法又分为接收端（Goog-REMB）和发送端（Goog-TCC）的带宽评估方法，目前默认采用的是Goog-TCC方法，因为其相对来说更为精准。</p><h3 id="基于丢包的带宽评估"><a href="#基于丢包的带宽评估" class="headerlink" title="基于丢包的带宽评估"></a>基于丢包的带宽评估</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_29.webp" alt=""></p><p>基于丢包的带宽评估方法比较简单，根据丢包率进行计算。实际上，正常带宽也有一定的丢包，如果丢包率&lt;2%，属于网络质量不错的正常丢包，说明带宽还没有达到上限，应该增加评估的带宽值。举个例子，比如你家里的带宽是8M，WebRTC最开始是不知道你家里的真实带宽的，它必须一点点测量，所以一开始它先给你的带宽设置一个假设值，即500K，当发现丢包率很低时，它再增加带宽的评估值，如从500K升到1兆，如果丢包率还是很低，就会加到1.5兆、2兆……，带宽评估值增加的速度是每次增加8%；如果丢包率&gt;10%，说明发生拥塞了，此时应该立即降低带宽，公式如图（loss&gt;0.1时）所示。如果丢包率&lt;10%，说明现在的带宽评估的比较准确，此时应该保持这个带宽，不增加也不减少；</p><h3 id="基于延时的带宽评估"><a href="#基于延时的带宽评估" class="headerlink" title="基于延时的带宽评估"></a>基于延时的带宽评估</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_30.webp" alt=""></p><p>基于延时的带宽评估方法比基于丢包的评估更好一些，因为它可以提前预估是否发生了拥塞。基于丢包的评估丢包率一旦超过10%就说明可能已经发生拥塞了，而网络一旦拥塞，再想恢复回原来的状态，需要花费一段时间，而这段时间就会影响音视频的服务质量。</p><p>而基于延时的带宽评估就不会产生这种情况。它的基本原理是，如果接收到的数据包的网络传输时延在持续增长，就说明网络变差了，当达到一定程度时，就要将评估的带宽值降下来，以防止发生网络拥塞。它的计算公式是根据状态机来的（状态机比较复杂，我这里就不讲了），当状态非常好时，需要增加带宽，同丢包增加带宽一样，每次增加8%；如果延时一直累加，则需要降低带宽，带宽降为原来85%，其它情况就保持当前带宽，无增无减。</p><h2 id="媒体数据与带宽的平衡"><a href="#媒体数据与带宽的平衡" class="headerlink" title="媒体数据与带宽的平衡"></a>媒体数据与带宽的平衡</h2><h3 id="媒体数据与带宽的平衡-1"><a href="#媒体数据与带宽的平衡-1" class="headerlink" title="媒体数据与带宽的平衡"></a>媒体数据与带宽的平衡</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_31.webp" alt=""></p><p>当带宽评估准确之后再进行控制就非常容易了。接下来，我们看一下WebRTC如何平衡媒体数据与带宽。</p><p>带宽评估方法和网络质量的提升在前面我已经介绍了。在有限的带宽下，如何才能提供更好的音视频服务质量，是人们一直孜孜不倦追求的目标。因此在同等条件下，可以将数据压缩的更小，一直是解决服务质量的一种关键方法。目前最常用的视频编码器还是H.264，不过新的编码器已经有了很大突破VP9/H265、AV1/H266提供了更高的压缩率，这使得我们在网络条件有限的情况下，可以传输更多的数据从而保障更好的服务质量。</p><p>另一方面，在带宽相同且码流无法压缩的情况下，还可以采用动态码率。通常，在使用动态码率时，我们可以直接从产品上看出来，你会发现视频一会儿清晰，一会儿模糊。即在带宽小时，编码器压缩码流，此时视频变得模糊；带宽大时，编码器放大了码流，所以视频变得清晰。以上就是通过减少数据量的方法来保障实时通信质量的。</p><h3 id="Simulcast与SVC"><a href="#Simulcast与SVC" class="headerlink" title="Simulcast与SVC"></a>Simulcast与SVC</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_32.png" alt=""></p><p>除此之外，还可以通过Simulcast或SVC解决质量问题。Simulcast和SVC解决问题的思路是类似的，它们会在发送端增大码流的发送，将数据先传给服务端，然后由服务端根据接收端带宽的不同，选择合适的码流下发。对于网络较差的用户，传输清晰度低的码流，对于网络较好的用户，传输高清晰度的码流。所以这两种技术对于发送方的带宽和质量有非常高的要求。</p><p>SVC与Simulcast最大的区别：SVC上传的是一路码流，但这一路码流是由多层构成的。服务端会按照不同接收端的带宽大小，选择传输不同的层。如上图所示，手机端带宽小，就传输小的一层数据，PC端带宽大，就将所有层全部传输过去；而Simulcast上传的是多路流，一般分为小、中、大三路。对手机端传输小的一路，对PC端传输最大的一路。Simulcast的好处在于，每一路流都是独立的，所以可以对每一路流使用硬件编解码器，而 SVC的分层方式目前没有硬件支持，所以无法通过硬件加速。</p><h3 id="流控"><a href="#流控" class="headerlink" title="流控"></a>流控</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_33.png" alt=""></p><p>当带宽评估准确后，如果发送的的码流还是大于带宽大小，此时就需要通过流控来进行控制了。流控的作用是当输出码流大于带宽时，降低发送码率，以防止发生拥塞。当然它会导致时延的增加。实际上，对于流控来说，它需要控制两个点：第一个点是Pacer，降低发送码率。当然仅降低发送码率还不够，因为如果编码器仍然输出大量码流给Pacer，那么Pacer 的缓冲区迟早会被撑爆。所以在控制Pacer让它减少发送码率的同时，一定要降低音视频的编码器的输出码率，从而保持平衡，进而使数据平缓下行。</p><p>正如我前面所说的，流控虽然防止了网络拥塞的发生，但会增加一些延时，增加的延时最终会反应到实时通信的总指标里，总的延时必须控制在500ms以内。比如以前端到端时延是200ms，由于带宽不足，时延增加到300ms、400ms都是可以的，但一定不要超过500ms。</p><p>此外，对于编码器的输出码流来说，如果流控通过直接降低码流仍然不能与带宽适配时，还可以通过降低分辨率的方式来降低码流。总之，在带宽不足时，要想尽办法减少数据量。实在不行，也可以关掉视频只保留音频来保障网络的畅通。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_34.png" alt=""></p><p>总结一下，对于服务质量保障，首先提高网络质量，NACK和FEC解决丢包问题，JitterBuffer解决视频的乱序与抖动，NetEQ解决音频的乱序与抖动；带宽评估通过Goog-REMB和Goog-TCC，还有丢包的带宽评估；为了保障实时性，需要选择更优质的线路，比如客户端与服务端通信的时候选择更好的路线节点，保证云端网络带宽等等；从业务上，减少数据量可以用AV1、SVC、Simulcast、动态码率，减少业务；在防拥塞上，通过Pacer进行流控，只要能控制在500ms之内，适当增加时延也是可以接收的。</p><p>以上就是本次分享的全部内容，谢谢！</p><h2 id="Q-amp-A-部分"><a href="#Q-amp-A-部分" class="headerlink" title="Q&amp;A (部分)"></a>Q&amp;A (部分)</h2><p><strong>1. 路径的选择是WebRTC内部自动选择的吗？</strong></p><p>是自动选择的。WebRTC会自动判断通信的双方是否在同一个局域网内，如果是就直接在局域网内建立连接；如果不是，会通过STUN协议获取各自的外网地址，然后进行NAT穿越；如果还不成功的话，才会选择TURN服务进行数据中转。</p><p><strong>2. WebRTC网络传输质量衡量指标有什么？</strong><br>衡量任何一个实时传输系统时，首要看它的时延是否达到500ms以内。其实500ms对于实时通信而言，也是比较苛刻的标准了，因为网络的变化是非常大的， 所以要实现这个指标其实难度也是蛮大的。其次是丢包率，这是非常关键的指标，刚才说到2%的丢包率代表网络比较好；小于10%，对于WebRTC来说，代表目前的带宽是准确的；超过10%则代表发生了拥塞。有些厂商说它的产品可以抗xx%的丢包，这样的前提是不认为丢包是一个指标，但在真网络中，当路由的缓冲被撑爆后，必然会出现大量丢包，如果不把丢包当作指标的话，就缺少了一种判断网络拥塞发生的条件，这显然是不合理的。</p><p><strong>3. 视频JitterBuffer怎么具体控制平滑的？</strong><br>其实JitterBuffer平滑处理的难度并不像我们想像的那样复杂，之所以大家认为它复杂，可能是因为一些额外的因素，如还要处理音视频同步等问题。对于平滑处理，我们完全可以自己通过一个Buffer来实现。Buffer可以是动态大小或固定大小。为了简化，我们假设它是固定大小，比如定义一个可以存放 100 个元素的数组，在数组的一头每隔 10 毫秒取一个包，这就是一个最简单的平滑处理。当然更好的方式是可以根据网络的变化让这个平滑数组的大小也动态变化，这样就更高级一些。当然，如果Buffer是动态变化的，那在计算平滑数组的动态大小时，会稍难一些。</p><p><strong>4. WebRTC要和SIP客户端通讯有什么好的方案？</strong><br>一般与SIP通信最好借助流媒体服务器比如Janus，它既支持SIP协议也能支持WebRTC客户端。这样SIP终端就可以将数据传输流媒体服务器，然后再转发给WebRTC终端了，同理WebRTC终端也可以通过流媒体服务器与SIP终端通信了。</p><p><strong>5. FEC和NACK默认是不是都要开启？</strong><br>是的。对于WebRTC来说，FEC和NACK都是开启的，也可以控制它们的开关。</p><p><strong>6. 能说下为什么TCC比REMB准确吗？</strong><br>TCC和REMB主要有两个区别。第一是计算的端不同，REMB是在接收端计算的，接收端计算后再将结果返回给发送端进行控制，而在回传结果时，可能网络又发生了新的变化，这就造成了REMB的及时性不够；TCC是将所有数据都交给发送端做计算和控制，因此及时性和准确度会更高。第二是滤波器不同，REMB是卡尔曼滤波器（Kalman），TCC是最小二乘法滤波器（Trend line）。最小二乘法滤波器在网络延时评估这方面比卡尔曼滤波器效果更好一些。</p><p><strong>7. 在内网环境下p2p想让延时尽可能小，可以做哪些工作？实验室环境最小延时可以达到100ms以下吗？</strong><br>如果在同一个局域网内，实际只有几十毫秒的延迟。有同学可能会疑惑，有的产品在同一局域网内延迟非常小，为什么用WebRTC反而延迟增大了？这就是因为WebRTC为保障网络质量，在内部通过多种机制，各种缓冲，来做到的。所以它必然会产生一定的延迟，也就是拿延迟换质量。而在局域网内，网络基本没有延时，不丢包、不抖动、不乱序。这时什么策略都不采用，网络的传输才是最快的，因此在内网通信时，WebRTC的实时性一定不如什么策略都不加的产品好。</p><p><strong>8. ULPFEC和FLEXFEC区别是？</strong><br>ULPFEC只能进行单向冗余处理，而FLEXFEC可以进行双向冗余处理，即可以横向分组还可以纵向分组做冗余，所以它的抗丢包性要比ULPFEC好，同时占的带宽也比ULPFEC多。</p><p><strong>9. 可靠性这块，UDP上的WebRTC做ack是自己封装了seq吗？然后，一样需要ack重传的话，跟TCP SACK有什么区别呢？</strong><br>WebRTC使用的是RTP协议传输数据。RTP协议中有seq字段。此外，WebRTC用的NACK与TCP的ACK机制不同。TCP每一块数据都需要通过ACK进行确认，如果没收到ACK就重发，直到成功收到ACK或断连；而NACK允许丢包，当重传多次不行时，就不传了。且而即使重传了数据包，在接收端发现它已经过期时，也会将其丢掉。</p><p><strong>10. WebRTC后面会用QUIC协议吗？</strong><br>这个问题争论较大。WebRTC也在一直在尝试使用QUIC协议，从我的角度来看，QUIC协议最主要的是解决Http3，Http3解决的是TCP的问题，就要保证数据的可靠性，那么实时性就会受到影响，什么时候QUIC如果可以解决好实时性问题就可以用，反之则不能。</p><p>从我的角度看，一种协议最好只解决一件事儿，很难通过一套协议解决所有问题。</p><p><strong>阅读推荐</strong></p><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_35.webp" alt=""></p><p>《WebRTC音视频实时互动技术 — 原理、实战与源码分析》— 李超</p><p>书籍深入浅出的对WebRTC进行了系统讲解，既有原理，又有实战，从WebRTC是如何实现实时音视频通信的，到如何应用WebRTC库实现音视频通信，再到WebRTC源码的剖析，逐步展开讲解。此外，本书对WebRTC的传输系统进行了重点分析，相信读者通过本书可以一窥WebRTC传输的奥秘。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者 | 李超&lt;br&gt;整理 | LiveVideoStack&lt;/p&gt;
&lt;p&gt;非常高兴和大家一同探讨WebRTC传输是如何保证音视频服务质量的。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_1.webp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本次分享我将从四个方面向大家介绍一下WebRTC传输是如何保证音视频服务质量的。第一，实时通信的目标。我们首先需要确定实时通信的目标，才能够知道要将实时通信做成怎样的系统、保证怎样的实时性；第二，WebRTC如何保障数据传输的实时性；第三，进行实时传输时，想要满足实时性，网络与服务质量之间可能存在的矛盾；最后，就是WebRTC如何解决网络与服务质量之间的矛盾。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>OpenCV课程资料</title>
    <link href="https://blog.avdancedu.com/65de593f/"/>
    <id>https://blog.avdancedu.com/65de593f/</id>
    <published>2021-08-07T04:21:07.513Z</published>
    <updated>2021-08-07T04:21:07.513Z</updated>
    
    <content type="html"><![CDATA[<p>这里是我OpenCV课程的相关资料，后面还会不断补充…</p><a id="more"></a><h2 id="Windows下编译OpenCV"><a href="#Windows下编译OpenCV" class="headerlink" title="Windows下编译OpenCV"></a>Windows下编译OpenCV</h2><h3 id="下载必要的工具和库"><a href="#下载必要的工具和库" class="headerlink" title="下载必要的工具和库"></a>下载必要的工具和库</h3><ol><li>安装python3和numpy库，下载地址:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;3.9.2&#x2F;python-3.9.2-amd64.exe</span><br></pre></td></tr></table></figure></li><li>安装 VS, 社区版即可，下载地址:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;visualstudio.microsoft.com&#x2F;zh-hans&#x2F;downloads&#x2F;</span><br></pre></td></tr></table></figure></li><li>安装 cmake，下载地址: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Kitware&#x2F;CMake&#x2F;releases&#x2F;download&#x2F;v3.20.0-rc1&#x2F;cmake-3.20.0-rc1-windows-x86_64.msi</span><br></pre></td></tr></table></figure></li><li>下载IPPICV<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;opencv&#x2F;opencv_3rdparty.git</span><br></pre></td></tr></table></figure><h3 id="下载opencv源码，下载地址："><a href="#下载opencv源码，下载地址：" class="headerlink" title="下载opencv源码，下载地址："></a>下载opencv源码，下载地址：</h3></li></ol><ul><li>opencv源码地址: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;opencv&#x2F;opencv.git</span><br></pre></td></tr></table></figure></li><li>opencv-contrib源码地址git: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone https:&#x2F;&#x2F;github.com&#x2F;opencv&#x2F;opencv_contrib.git</span><br></pre></td></tr></table></figure></li></ul><h3 id="编译方法："><a href="#编译方法：" class="headerlink" title="编译方法："></a>编译方法：</h3><ul><li>在存放opencv源码目录中创建build目录</li><li>运行cmake</li><li>选择opencv源码目录</li><li>选择编译目录</li><li>选择CPU架构</li><li>增加opencv-contrib选项, OPENCV_EXTRA_MODULES_PATH=../opencv_contrib/modules</li><li>检查编译选项<ul><li>勾选 opencv_world</li></ul></li><li>生成编译脚本</li></ul><h3 id="打开opencv工程文件"><a href="#打开opencv工程文件" class="headerlink" title="打开opencv工程文件"></a>打开opencv工程文件</h3><ol><li>选择输出版本类型</li><li>进行编译</li></ol><h2 id="Ubuntu下编译OpenCV4"><a href="#Ubuntu下编译OpenCV4" class="headerlink" title="Ubuntu下编译OpenCV4"></a>Ubuntu下编译OpenCV4</h2><ul><li><p>安装开发工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install build-essential cmake unzip pkg-config</span><br></pre></td></tr></table></figure></li><li><p>安装image and video I/O libraries</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libjpeg-dev libpng-dev libtiff-dev</span><br><span class="line">$ sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev</span><br><span class="line">$ sudo apt-get install libxvidcore-dev libx264-dev</span><br></pre></td></tr></table></figure></li><li><p>安装GUI</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libgtk-3-dev</span><br></pre></td></tr></table></figure></li><li><p>安装数据优化包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libatlas-base-dev gfortran</span><br></pre></td></tr></table></figure></li><li><p>安装 Python 3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install python3-dev</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里是我OpenCV课程的相关资料，后面还会不断补充…&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>我的新书《WebRTC音视频实时互动技术--原理、实战与源码分析》终于出版了</title>
    <link href="https://blog.avdancedu.com/bc71cb9a/"/>
    <id>https://blog.avdancedu.com/bc71cb9a/</id>
    <published>2021-07-22T13:22:03.373Z</published>
    <updated>2021-07-22T13:22:03.374Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/webrtc_qos/webrtc_book.png" alt=""></p><p>近年来，在音视频领域WebRTC越来越受到大家的追棒，它就像音视频技术的一顶“王冠”，上面嵌了大大小小、各种各样的“宝石”，如回音消除、降噪、自动增益、NetEQ、网络拥塞控制……不胜枚举！几乎所有的实时直播客户端都或多或少的使用了WebRTC的代码或借鉴了WebRTC的思想。</p><a id="more"></a><h2 id="WebRTC服务质量"><a href="#WebRTC服务质量" class="headerlink" title="WebRTC服务质量"></a>WebRTC服务质量</h2><p>为什么WebRTC会受到如此追棒呢？我想，究其原因是它有非常好的服务质量（网络服务质量、音视频服务质量）。</p><p>在众多的服务质量中，网络服务质量是最为关键的。你可以想像一下，如果网络是“畅通无阻”的：有无限的带宽，不丢包、不延时，那一切都变得美好了。但现实中，不可能每个用户都有如此好的网络，更多的是网络不佳，带宽受限。而让那些网络不佳、带宽受限的用户也能享受较好的服务，则是WebRTC一直孜孜不倦追求的目标。</p><p>为了达到这个目标，WebRTC发明了一种网控拥塞控制算法，称为GCC。该算法最厉害的地方是可以根据网络的丢包情况和延时趋势准确的判断出用户带宽的大小，并根据带宽的大小来控制发包的速度，从而避免网络拥塞的发生。</p><p>这项技术是十分关键的。大多数情况下，用户的带宽是动态变化的，如果我们不能实时的、有效的判断出带宽的大小，那么很有可能会因为发送音视频码流过大，导致网络拥塞，最终引起网络瘫痪。举个典型的例子，像长城宽带这种共享网络，假如你购买的是 100M 带宽，但实际使用时，分到的带宽并不是 100M，它的波动是非常大的。在早上人少的时候，带宽可以接近 100M；但晚上人多时，可能还 2M都达不到。如果没有拥塞控制算法，不能动态的判断出带宽的大小，我们发送大码流的时候，后果就可想而知了。</p><p>当然，能够准确的评估出带宽，只是“万里长征”的第一步，后面还有很多事情要做呢，如：如何进行发送码流的控制？只控制发送速度就可以了吗？如果不对“源”（产生音频与视频数据的地方）进行控制，就会导致内存爆长，从而引起系统崩溃。</p><p>此外，传输的实时性也是非常关键的。此时又涉及到传输协议的选择了，我们在传输音视频数据时，是应该选择TCP还是UDP？在极端网络情况下为什么要选择UDP？这些都是值得深入探讨的问题。</p><p>当传输协议选好后，端与端之间连接通路的选择对传输的实时性也起着至关重要的作用。如果通信的双方在同一个局域网内，那么它们应该首先选择局域网这条通路，而不是将包发向外网绕一圈再回来；如果不在同一个局域网内，则应该优先选择P2P直连；只有在直连不通的情况下，才应该考虑通过中继服务器进行数据中转，从而达到数据实时传输的目的。</p><p>总之，为了达到更好的服务质量，WebRTC想到了各种办法，可以说无所不用其极。这里我对其方法做了一下总结，分成五大类，如下图所示：</p><p><img data-src="https://cdn.avdancedu.com/image/article/webrtc_qos/webrtc_qos.png" alt=""></p><h2 id="我的新书"><a href="#我的新书" class="headerlink" title="我的新书"></a>我的新书</h2><p>实际上，上面这些内容，都在我的书《WebRTC音视频实时互动技术–原理、实战与源码分析》中做了详细介绍。</p><p>本书不仅对WebRTC的网络传输做了细致、大量的分析，而且还向你详细介绍了如何通过WebRTC实现Web端与Android和iOS端的互联互通；并且还在本书的最后三章对WebRTC的源码进行了剖析，以使你不但可以知道如何使用WebRTC实现音视频通信，还能让你了解其中的原理，并知道WebRTC具体是如何做的。</p><p>总体来说，本书是一本WebRTC入门到进阶的书籍，尤其适合对于WebRTC有一定了解，想进阶的同学来说，非常适合学习本书的内容。以下是本书的目录:</p><p><img data-src="https://cdn.avdancedu.com/image/article/webrtc_qos/webrtc_dir1.png" alt=""><br><img data-src="https://cdn.avdancedu.com/image/article/webrtc_qos/webrtc_dir2.png" alt=""><br><img data-src="https://cdn.avdancedu.com/image/article/webrtc_qos/webrtc_dir3.png" alt=""><br><img data-src="https://cdn.avdancedu.com/image/article/webrtc_qos/webrtc_dir4.png" alt=""></p><h2 id="购买地址"><a href="#购买地址" class="headerlink" title="购买地址"></a>购买地址</h2><p><a href="https://item.jd.com/10033954503352.html" target="_blank" rel="noopener">机械工业出版社(华章)</a></p><h2 id="沟通群"><a href="#沟通群" class="headerlink" title="沟通群"></a>沟通群</h2><p>对于图中的任何疑问可以到微信群中提问。</p><p><img data-src="https://cdn.avdancedu.com/image/article/webrtc_qos/webrtc_group.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/webrtc_qos/webrtc_book.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;近年来，在音视频领域WebRTC越来越受到大家的追棒，它就像音视频技术的一顶“王冠”，上面嵌了大大小小、各种各样的“宝石”，如回音消除、降噪、自动增益、NetEQ、网络拥塞控制……不胜枚举！几乎所有的实时直播客户端都或多或少的使用了WebRTC的代码或借鉴了WebRTC的思想。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Go的性能竟如何优秀？Go、C和RUST性能对比</title>
    <link href="https://blog.avdancedu.com/1ed22639/"/>
    <id>https://blog.avdancedu.com/1ed22639/</id>
    <published>2021-07-22T12:47:16.905Z</published>
    <updated>2021-07-22T12:47:16.905Z</updated>
    
    <content type="html"><![CDATA[<p>最近几年Go、RUST等新语言不断推陈出新，令人目不暇接。据说Go与RUST开发出的程序性能非常高，但对于我这种C/C++老鸟来说，对此并不感冒，“再快还能比C快？”这句话一直萦绕在我的心头。</p><p>但出于好奇，每次听到有人说Go性能多好多好时，难免都会追问一句“有没有与C进行过对比测试？”，这句并不是想“兑”谁，而是想确认一下网上的传言是否为真。</p><p>不幸的是，每当我问这句话时，从来没有得到一个明确答复，也搞不清是他们得出的“Go性能好”是道听途说，还是自己真实的测试结果。</p><p>近来时间充裕，一时兴起，心想不如做个简单的Go、C/C++、RUST的性能对比测试吧，验证一下Go的性能到底如何。</p><a id="more"></a><h2 id="简单的测试用例"><a href="#简单的测试用例" class="headerlink" title="简单的测试用例"></a>简单的测试用例</h2><p>由于我一直专注在音视频实时通信领域，因此对网络传输的性能特别关心，所以这次测试只验证一下不同语言在传输UDP包时的性能。</p><p>为了减少其它因素的影响，测试条件限制如下：</p><ul><li>在同一台机子上进行不同语言性能的测试，防止因硬件的不同影响测试结果</li><li>服务端只接收不回复，防止服务器干扰测试结果</li><li>客户端只发送不接收，每次只发送<code>Hello</code>几个字符</li><li>客户端循环发送 1000 0000次，看它的总时长是多少</li></ul><p>下面是不同语言编写的测试程序。</p><h3 id="C客户端代码"><a href="#C客户端代码" class="headerlink" title="C客户端代码"></a>C客户端代码</h3><p>下面是使用<code>C</code>语言实现的客户端代码的主要逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    gettimeofday(&amp;tv0, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> lastime = tv0.tv_sec * <span class="number">1000000000</span> + tv0.tv_usec; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"total: %lu, sec:%lu, nao:%u\n"</span>, lastime, tv0.tv_sec, tv0.tv_usec);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//循环 1000 0000 次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>; a&lt; <span class="number">10000000</span>; a++)&#123;</span><br><span class="line">        n = sendto(sock, </span><br><span class="line">                        buff_send, </span><br><span class="line">                        <span class="built_in">strlen</span>(buff_send), </span><br><span class="line">                        <span class="number">0</span>, (struct sockaddr *) &amp;addr, </span><br><span class="line">                        <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;tv1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> curtime = tv1.tv_sec * <span class="number">1000000000</span> + tv1.tv_usec; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"total:%lu, sec:%lu, nao:%u\n"</span>, curtime, tv1.tv_sec, tv1.tv_usec);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>从上述代码中可以看到，在<code>for</code>循环执行了 1000 0000 次，每次都调用 <code>sendto</code> 发送UDP数据。</p><h3 id="Go客户端代码"><a href="#Go客户端代码" class="headerlink" title="Go客户端代码"></a>Go客户端代码</h3><p>Go语言实现的逻辑与C客户端逻辑是类似的，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">var</span> lastime <span class="keyword">int64</span> = time.Now().UnixNano()</span><br><span class="line">    fmt.Printf(<span class="string">"lastime: %d\n"</span>, lastime)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> a:=<span class="number">0</span>; a &lt; <span class="number">10000000</span>; a++ &#123;</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        _, err = conn.Write([]<span class="keyword">byte</span>(<span class="string">"Hello"</span>))    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> curtime <span class="keyword">int64</span> = time.Now().UnixNano()</span><br><span class="line">    fmt.Printf(<span class="string">"curtime: %d"</span>, curtime)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Go的代码非常简单，它与C的区别是其使用Write来发送数据。</p><h3 id="RUST客户端代码"><a href="#RUST客户端代码" class="headerlink" title="RUST客户端代码"></a>RUST客户端代码</h3><p>RUST语言实现的逻辑也是类似的，代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">let</span> start = Instant::now();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> n = start.elapsed().as_nanos();</span><br><span class="line">    std::<span class="built_in">println!</span>(<span class="string">" elapsed: &#123;&#125;"</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//loop &#123;</span></span><br><span class="line">    <span class="keyword">for</span> _i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">100001</span> &#123;</span><br><span class="line">        socket.send_to(data.as_bytes(), <span class="string">"127.0.0.1:9998"</span>)?;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = start.elapsed().as_nanos();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"elapsed : &#123;&#125;"</span>, n);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><table><thead><tr><th align="left">系统</th><th align="left">硬件</th><th align="left">C</th><th align="left">Go</th><th align="left">RUST</th></tr></thead><tbody><tr><td align="left">Mac</td><td align="left">2.7 GHz Intel Core i5<br>8 GB DDR3</td><td align="left">150秒</td><td align="left">85秒</td><td align="left">150 秒</td></tr><tr><td align="left">Linux</td><td align="left">2.7GHz Inter 8 Core i7 <br> 8G</td><td align="left">17-18秒</td><td align="left">21-22秒</td><td align="left">22 秒</td></tr></tbody></table><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>刚看到这个结果时，我真是难以至信，Go和RUST的性能竟然与C如此接近。</p><p>通过上面的测试我们可以得出以下结论：</p><ul><li>新语言 Go 与 RUST 在性能上确实不错，基本上与 C 是接近的，应用层到系统接口之间的层级比较薄</li><li>不同的操作系统表现不一样，但通常情况下Go都是在Linux系统下运行，所以应该以Linux系统的测试为准</li><li>Go、RUST相较C/C++而言，开发效率高很多，如果性能差不多的情况下，采用Go或RUST做服务器开发更有优势</li></ul><p><strong>但这次只是一个简单的测试，只能说在发送UDP时，Go、RUST与C性能差别不大，但并不代表在整体性能上Go和RUST已经赶上C/C++性能了。如果想更好的了解Go、RUST与C/C++的差异，应该做更详尽的测试验证。</strong></p><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>代码地址：<a href="https://github.com/andancedu/go_rust_c.git" target="_blank" rel="noopener">https://github.com/andancedu/go_rust_c.git</a></p><h2 id="我的课程"><a href="#我的课程" class="headerlink" title="我的课程"></a>我的课程</h2><p>-<a href="https://coding.imooc.com/class/415.html" target="_blank" rel="noopener">音视频系统入门</a></p><p>-<a href="https://coding.imooc.com/class/279.html" target="_blank" rel="noopener">ffmpeg精讲</a></p><p>-<a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">WebRTC入门与实战</a></p><p>-<a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">WebRTC高并发流媒体服务器</a></p><p>-<a href="https://time.geekbang.org/column/article/111337" target="_blank" rel="noopener">从0开始构造直播系统</a></p><p>-<a href="https://coding.imooc.com/class/496.html" target="_blank" rel="noopener">OpenCV入门与实战</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近几年Go、RUST等新语言不断推陈出新，令人目不暇接。据说Go与RUST开发出的程序性能非常高，但对于我这种C/C++老鸟来说，对此并不感冒，“再快还能比C快？”这句话一直萦绕在我的心头。&lt;/p&gt;
&lt;p&gt;但出于好奇，每次听到有人说Go性能多好多好时，难免都会追问一句“有没有与C进行过对比测试？”，这句并不是想“兑”谁，而是想确认一下网上的传言是否为真。&lt;/p&gt;
&lt;p&gt;不幸的是，每当我问这句话时，从来没有得到一个明确答复，也搞不清是他们得出的“Go性能好”是道听途说，还是自己真实的测试结果。&lt;/p&gt;
&lt;p&gt;近来时间充裕，一时兴起，心想不如做个简单的Go、C/C++、RUST的性能对比测试吧，验证一下Go的性能到底如何。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>音频3A问题经验分享</title>
    <link href="https://blog.avdancedu.com/5756c48d/"/>
    <id>https://blog.avdancedu.com/5756c48d/</id>
    <published>2021-06-23T01:56:01.186Z</published>
    <updated>2021-06-23T01:56:01.187Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来音频的3A（回音消除、降噪、自动增益）问题都是音视频实时通信中特别关键，也特别难以解决的问题。尤其是回音消除问题，更是难上加难，它就好比你向水中倒了一些墨汁，现在又想将它从水中提取出来一样困难。</p><p>对于做音视频 PaaS (提供API接口服务）的公司而言，只有将3A问题处理好，才能在音视频实时通信市场上占有一席之地，否则就没法与声网、腾讯等这些老牌或巨头公司进行竞争。正是由于3A 问题是做音视频公司必须要解决好的问题，所以它们对能够解决这类问题的人才都求贤若渴，对于想进入音视频行业的同学来说，如果你能具有3A问题的解决能力，那你一定会成为各音视频大厂挣抢的“香饽饽”。</p><p>为了让大家学到更多的干货，这次我特意邀请到拍乐云合伙人&amp;音频专家 Ark，请他为大家详细介绍在商业应用中都会遇到哪些3A问题，遇到这类问题时该如何解决，对于初入门的同学又该如何学习音频技术。相信通过这次分享，一定会让大家会收获满满。</p><p>感兴趣的小伙伴请加入讨论群, 分享时间为2021年6月30 19:45。</p><p><img data-src="https://cdn.avdancedu.com/image/article/3A/dakashuo.png" alt="音频3A经验分享群"></p><a id="more"></a><h2 id="本次分享的大体题纲如下："><a href="#本次分享的大体题纲如下：" class="headerlink" title="本次分享的大体题纲如下："></a>本次分享的大体题纲如下：</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul><li>音频的一些基本知识，音量（响度），分贝，频率、振幅与音量的关系，为什么音量是负值？</li><li>增益是指什么？它与音量大小的区别是什么？如何进行自动增益？<h3 id="降噪相关"><a href="#降噪相关" class="headerlink" title="降噪相关"></a>降噪相关</h3></li><li>什么是噪音，算法是如何判断出噪音的？</li><li>噪音是有颜色的，这是什么意思？</li><li>降噪的难点是什么？什么样的噪音不好降？</li><li>我们是否应该优先使用硬件降噪？移动端与PC端有什么区别吗？</li><li>什么是舒适噪音？为什么要增加舒适噪音？<h3 id="回音相关"><a href="#回音相关" class="headerlink" title="回音相关"></a>回音相关</h3></li><li>回音消除的难点是什么？</li><li>是否可以简要的介绍一下回音产生的一个大体原理？</li><li>机端的回音消除是否比PC端的回音更好消除一些？其中的原理是否可以比大家介绍一下？</li><li>WebRTC在回音消除方法做了哪些工作，最新的AEC3 与以前的回音消除算法有什么显著的差别？<h3 id="学习相关"><a href="#学习相关" class="headerlink" title="学习相关"></a>学习相关</h3></li><li>在解决实际3A问题时，一定要用到数学吗？</li><li>未来的技术方向</li><li>学习音频的基本路径是什么？</li><li>能否给推荐几本好书？</li></ul><h2 id="分享嘉宾"><a href="#分享嘉宾" class="headerlink" title="分享嘉宾"></a>分享嘉宾</h2><p>Ark，拍乐云合伙人&amp;音频专家。中科大硕士毕业，多年音频开发经验，5年WebEx音频专家工作经验，精通音频3A算法，深入理解实时通信音频框架，主导设计了多套音频处理框架，对于音频算法、移动端设备适配、大屏远场算法优化、智能手表音频优化等都非常了解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直以来音频的3A（回音消除、降噪、自动增益）问题都是音视频实时通信中特别关键，也特别难以解决的问题。尤其是回音消除问题，更是难上加难，它就好比你向水中倒了一些墨汁，现在又想将它从水中提取出来一样困难。&lt;/p&gt;
&lt;p&gt;对于做音视频 PaaS (提供API接口服务）的公司而言，只有将3A问题处理好，才能在音视频实时通信市场上占有一席之地，否则就没法与声网、腾讯等这些老牌或巨头公司进行竞争。正是由于3A 问题是做音视频公司必须要解决好的问题，所以它们对能够解决这类问题的人才都求贤若渴，对于想进入音视频行业的同学来说，如果你能具有3A问题的解决能力，那你一定会成为各音视频大厂挣抢的“香饽饽”。&lt;/p&gt;
&lt;p&gt;为了让大家学到更多的干货，这次我特意邀请到拍乐云合伙人&amp;amp;音频专家 Ark，请他为大家详细介绍在商业应用中都会遇到哪些3A问题，遇到这类问题时该如何解决，对于初入门的同学又该如何学习音频技术。相信通过这次分享，一定会让大家会收获满满。&lt;/p&gt;
&lt;p&gt;感兴趣的小伙伴请加入讨论群, 分享时间为2021年6月30 19:45。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/3A/dakashuo.png&quot; alt=&quot;音频3A经验分享群&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>在Windows下使用VS编译OpenCV库</title>
    <link href="https://blog.avdancedu.com/d6343897/"/>
    <id>https://blog.avdancedu.com/d6343897/</id>
    <published>2021-06-06T08:29:01.643Z</published>
    <updated>2021-06-06T08:29:01.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近发现有很多同学在学习OpenCV时，不知道该如何在Windows下编译OpenCV源码，这里我整理了一份Windows编译OpenCV的具体步聚，希望可以帮助到大家。</p><p>Windows下编译OpenCV分为四步，即：</p><ul><li>一、下载安装必要的工具</li><li>二、下载OpenCV源码</li><li>三、生成编译脚本</li><li>四、使用VS工程编译OpenCV</li></ul><a id="more"></a><h2 id="下载必要的工具"><a href="#下载必要的工具" class="headerlink" title="下载必要的工具"></a>下载必要的工具</h2><ol><li>安装python3和numpy库，<a href="https://www.python.org/ftp/python/3.9.2/python-3.9.2-amd64.exe" target="_blank" rel="noopener">下载地址：https://www.python.org/ftp/python/3.9.2/python-3.9.2-amd64.exe</a></li><li>安装 VS, 下载社区版即可，<a href="https://visualstudio.microsoft.com/zh-hans/downloads/" target="_blank" rel="noopener">下载地址： https://visualstudio.microsoft.com/zh-hans/downloads/</a></li><li>安装 cmake，<a href="https://github.com/Kitware/CMake/releases/download/v3.20.0-rc1/cmake-3.20.0-rc1-windows-x86_64.msi" target="_blank" rel="noopener">下载地址：https://github.com/Kitware/CMake/releases/download/v3.20.0-rc1/cmake-3.20.0-rc1-windows-x86_64.msi</a></li><li>下载IPPICV，<a href="https://github.com/opencv/opencv_3rdparty.git" target="_blank" rel="noopener">下载地址：https://github.com/opencv/opencv_3rdparty.git</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;opencv&#x2F;opencv_3rdparty.git</span><br></pre></td></tr></table></figure></li></ol><h2 id="下载opencv源码"><a href="#下载opencv源码" class="headerlink" title="下载opencv源码"></a>下载opencv源码</h2><ol><li><p>下载opencv源码, 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;opencv&#x2F;opencv.git</span><br></pre></td></tr></table></figure></li><li><p>下载opencv-contrib源码, 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;opencv&#x2F;opencv_contrib.git</span><br></pre></td></tr></table></figure></li></ol><h2 id="生成编译脚本"><a href="#生成编译脚本" class="headerlink" title="生成编译脚本"></a>生成编译脚本</h2><ol><li>在存放opencv源码目录中创建build目录</li><li>运行cmake</li><li>选择opencv源码目录</li><li>选择编译目录</li><li>选择CPU架构</li><li>增加opencv-contrib选项, OPENCV_EXTRA_MODULES_PATH=../opencv_contrib/modules</li><li>检查编译选项，并<ol><li>勾选 opencv_world</li><li>勾选 ffmpeg</li><li>勾选 IPPICV，这步容易出错，如果你访问不了外网的话一般会出错。可以偿试手工下载IPPICV，进行设置。</li></ol></li><li>生成编译脚本</li></ol><h2 id="使用VS编译OpenCV"><a href="#使用VS编译OpenCV" class="headerlink" title="使用VS编译OpenCV"></a>使用VS编译OpenCV</h2><ol><li>选择输出版本类型</li><li>进行编译</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在上述步骤中，第三步<strong>生成编译脚本</strong>是最容易出错的，其中第7步是导致出错的最大原因，所以在生成编译脚本时一定要仔细检查这几项是否都是OK的。</p><h2 id="我的课程"><a href="#我的课程" class="headerlink" title="我的课程"></a>我的课程</h2><p>-<a href="https://coding.imooc.com/class/496.html" target="_blank" rel="noopener">OpenCV入门与实战</a></p><p>-<a href="https://coding.imooc.com/class/415.html" target="_blank" rel="noopener">音视频系统入门</a></p><p>-<a href="https://coding.imooc.com/class/279.html" target="_blank" rel="noopener">ffmpeg精讲</a></p><p>-<a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">WebRTC入门与实战</a></p><p>-<a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">WebRTC高并发流媒体服务器</a></p><p>-<a href="https://time.geekbang.org/column/article/111337" target="_blank" rel="noopener">从0开始构造直播系统</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近发现有很多同学在学习OpenCV时，不知道该如何在Windows下编译OpenCV源码，这里我整理了一份Windows编译OpenCV的具体步聚，希望可以帮助到大家。&lt;/p&gt;
&lt;p&gt;Windows下编译OpenCV分为四步，即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一、下载安装必要的工具&lt;/li&gt;
&lt;li&gt;二、下载OpenCV源码&lt;/li&gt;
&lt;li&gt;三、生成编译脚本&lt;/li&gt;
&lt;li&gt;四、使用VS工程编译OpenCV&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>《WebRTC实时互动技术原理实战与源码分析》一书的源码</title>
    <link href="https://blog.avdancedu.com/a0a831a3/"/>
    <id>https://blog.avdancedu.com/a0a831a3/</id>
    <published>2021-03-16T13:36:40.000Z</published>
    <updated>2021-03-17T04:33:32.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="源码下截地址"><a href="#源码下截地址" class="headerlink" title="源码下截地址"></a>源码下截地址</h1><p><a href="https://avdancedu.com/download/client.tar.gz" target="_blank" rel="noopener">客户端源码下载</a><br><a href="https://avdancedu.com/download/server.tar.gz" target="_blank" rel="noopener">服务端源码下载</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;源码下截地址&quot;&gt;&lt;a href=&quot;#源码下截地址&quot; class=&quot;headerlink&quot; title=&quot;源码下截地址&quot;&gt;&lt;/a&gt;源码下截地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://avdancedu.com/download/client.tar.gz&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>深入浅出C++的function</title>
    <link href="https://blog.avdancedu.com/dabab813/"/>
    <id>https://blog.avdancedu.com/dabab813/</id>
    <published>2020-07-16T14:05:23.000Z</published>
    <updated>2020-07-17T12:02:36.411Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来聊聊C++的function。std::function是从C++11开始支持的特性，它起什么作用?又有什么好处呢？</p><a id="more"></a><h2 id="C语言中的函数指针"><a href="#C语言中的函数指针" class="headerlink" title="C语言中的函数指针"></a>C语言中的函数指针</h2><p>对C语言熟悉的同学应该都知道，C语言中有一种高级技巧叫作函数指针，我们可以让函数指针指向参数类型相同、返回值类型也相同的函数。通过函数指针我们也可以实现C++中的多态。我们来看个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*func)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, print1 \n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, print2 \n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    func fp = print1;</span><br><span class="line">    fp();</span><br><span class="line"></span><br><span class="line">    fp = print2;</span><br><span class="line">    fp();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中定义了一个函数指针<code>func</code>，它可以指向无输入参数，返回值为整型的函数。因此在main函数中，我们可以用fp(这是func类型的指针）分别指向print1和print2并调用它们。</p><p>其运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello, print1</span><br><span class="line">hello, print2</span><br></pre></td></tr></table></figure><h2 id="function的作用"><a href="#function的作用" class="headerlink" title="function的作用"></a>function的作用</h2><p>从上面的C代码中我们可以看到C函数指针的作用，那在C++中是否也类似这样的功能呢？没错function就是完成这个任务的。但std::function比C的函数指针功能更强大些或者说更适合C++中使用。</p><p>下面我们来看一下如何在C++中使用std::function实现指向不同的函数吧。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello, print1"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello, print2"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::function&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">func</span><span class="params">(&amp;print1)</span></span>;</span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    func = &amp;print2;</span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码与C函数指针一样定义了两个全局函数print1和print2。在main函数中又定义了std::function 对象 func，然后将print1和print2分别赋值给func，这样就可以达到与C语言中指针同样的功能了。</p><p>其运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello, print1</span><br><span class="line">hello, print2</span><br></pre></td></tr></table></figure><p>可以看到std::function的结果与上面C函数指针的结果是一致的，因此std::function就是C++中用来代替C函数指针的。但如果std::function只是实现上面的功能也没啥好奇怪的对吧？实际上std::function还有一个特别有意思的用法，你可以将一个重载了<strong>()</strong>操作符的对象赋值给它，这样就可以像调用函数一样使用该对象了。下面咱们就对上面的代码做下简单修改，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"This is A Object"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    A a;</span><br><span class="line">    func = a;</span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，使用<code>struct</code>定义了一个结构体，而在该结构体中重载了<strong>()</strong>操作符，因此只要你将A的类对象赋值给func，它就可以像函数一样使用了。其结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">This is A Object</span><br></pre></td></tr></table></figure><h2 id="function的实现原理"><a href="#function的实现原理" class="headerlink" title="function的实现原理"></a>function的实现原理</h2><p>是不是觉得function做的事儿还挺神奇的？它是如何实现的呢？下面我们就来扒一扒它是如何实现的。</p><p>从实现上来说，有两种办法可以实现std::function：一种是通过类的多态，即通过虚表来达到多态；另一种方法是通过C语言的函数指针来实现。今天我们只介绍通过类多态的方式来实现function，对于通过函数指针实现的方式你可以自己去研究一下。</p><p>现在我们由浅入深的来分解一下function。通过观察我们可以发现function是一个包装类，它可以接收普通函数、<strong>函数类对象</strong>(也就是实现了（）操作符的类对象）等。它是如何做到的呢？</p><p>最简单的方式就是通过类模板。我们都知道function的类模板参数是可变的，但我们为了简单，所以只实现有一个参数的function类模板。这也符合我们的目标，只是扒一下实现原理，并不是想自己去实现它。</p><p>OK，下面我们来看看该如何定义这个类模板吧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> Arg0&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span>&lt;R(Arg0)&gt; &#123;</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(Arg0 arg0)</span></span>&#123;</span><br><span class="line">           <span class="keyword">return</span> ...;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个最简单的，只有一个参数的类模板。它是 <strong>function&lt;int(int)&gt;</strong> 或 <strong>function&lt;String(int)&gt;</strong> 等格式的类模板。这样我们在外型上与标准库中的std::function类似了。</p><p>接下来我们需要思考一下，如何让我们自己实现的function可以调用不同的函数呢？从其行为上可以推理出其内部应该有一个指针，而且这个指针具有多态性。想想C++中的多态是如何实现的？通过继承和虚表对吧。所以在function内部应该有一个基类指针，所有传入到function中的函数、类函数对象等都应该是继承于该类的子类成员。除此之外，还要在<strong>()</strong>操作符前加<code>virtual</code>关键字，让它创建虚表。</p><p>了解了上面的原理后，下面我们就在自己的function中增加基类及其类的指针。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> Arg0&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span>&lt;R(Arg0)&gt; <span class="title">function</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="class"><span class="keyword">class</span> __<span class="title">callbase</span> &#123;</span></span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                <span class="function"><span class="keyword">virtual</span> R <span class="title">operator</span><span class="params">()</span><span class="params">(Arg0 arg0)</span> </span>= <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">virtual</span> ~__callbase() &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        __callbase *base_;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(Arg0 arg0)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (*__callbase)(arg0); <span class="comment">//这里调用基类对象的()操作符</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面我们就将多态中的基类实现好了，在上面的代码中最关键是的<code>operator()</code>中增加了<strong>virtual</strong>关键字，这样该函数就被放到了vtable中，后面就可以在子类中实现该方法了。下面我们来实现子类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span>&lt;R(Arg0)&gt; <span class="title">function</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> __<span class="title">callable</span>:</span> <span class="keyword">public</span> __callbase &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                callable(F functor)</span><br><span class="line">                    : functor(functor)&#123;&#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">virtual</span> R <span class="title">operator</span><span class="params">()</span><span class="params">(Arg0 arg0)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> functor(arg0);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span>:</span><br><span class="line">                F functor;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">        myfunction(F f): base_(<span class="keyword">new</span> __callable&lt;F&gt;(f))&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~myfunction()&#123;</span><br><span class="line">            <span class="keyword">if</span>(base_) &#123;</span><br><span class="line">                <span class="keyword">delete</span> base_;</span><br><span class="line">                base_ = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在子类的实现中，核心点是增加指向赋值给function类的函数指针或函数类对象，也就是上面<code>__callable</code>类中的<strong>F functor</strong> 成员。该成员的类型是通过模板<code>template&lt;typename F&gt;</code>推导出来的。如果我们在创建function时传入的是函数，那么functor就是一个函数指针，如果我们传入的是函数类对象，则functor就是类对象。</p><p>另外你可以发现，我分别在myfunction类的构造函数和<code>__callable</code>类前定义了模板<code>F</code>，这样当我们在main函数中创建myfunction对象时，通过类型推导就可以获到F的具体类型了。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">myfunction <span class="title">myfunc</span><span class="params">(<span class="built_in">print</span>)</span></span>; <span class="comment">//通过这句可以获得F类型为函数指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了functor成员后，还需要在构造<code>__callable</code>时给functor赋值，也就是让functor指向具体的函数或函数类对象。之后重载<strong>()</strong>操作符就可以直接调用具体的函数或函数类对象了。</p><p>通过以上讲解我想你应该已经知道标准库中的function实现的基本原理了。当然我们这里实现的比较简陋，真正的实现还要考虑很多性能的问题，所以实现的要比这个复杂得多。另外标准库中的实现是通过函数指针来实现的而非通过C++的多态。</p><p>不过我们今天实现的的myfunction虽然与标准库有很多不同，但原理都是类似的，对于我们理解function已经足够了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在本文中我首先向你介绍了std::function的作用以及如何使用它，之后又苞丁解牛的实现了一个最简陋的function，主要的目的是加深你对function的理解。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">C++高阶知识：深入分析移动构造函数及其原理</a><br><a href="https://avdancedu.com/360c1c76" target="_blank" rel="noopener">聊聊C++中的完美转发</a><br><a href="https://avdancedu.com/9683d88/" target="_blank" rel="noopener">细说智能指针</a><br><a href="https://avdancedu/670ef31f/" target="_blank" rel="noopener">聊聊C++中的类型转换</a><br><a href="https://avdancedu.com/5e7916e3/" target="_blank" rel="noopener">重学C/C++中的const</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们来聊聊C++的function。std::function是从C++11开始支持的特性，它起什么作用?又有什么好处呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://blog.avdancedu.com/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="https://blog.avdancedu.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>聊聊C++中的完美转发</title>
    <link href="https://blog.avdancedu.com/360c1c76/"/>
    <id>https://blog.avdancedu.com/360c1c76/</id>
    <published>2020-07-16T05:46:39.000Z</published>
    <updated>2020-07-16T10:47:13.621Z</updated>
    
    <content type="html"><![CDATA[<p>之前我已经向你介绍了<a href="http://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">C++中的std::move</a>，它的作用是无论你传给它的是左值还是右值，通过std::move之后都变成了右值。而今天我们要介绍的std::forward则与之不同，它的作用是什么呢？</p><a id="more"></a><h2 id="forward的作用"><a href="#forward的作用" class="headerlink" title="forward的作用"></a>forward的作用</h2><p>std::forward被称为<strong>完美转发</strong>，它的作用是保持原来的<code>值</code>属性不变。啥意思呢？通俗的讲就是，如果原来的值是左值，经std::forward处理后该值还是左值；如果原来的值是右值，经std::forward处理后它还是右值。</p><p>看看下面的例子，你应该就清楚上面这句话的含义了:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T &amp; t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lvalue"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T &amp;&amp; t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rvalue"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(v);</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">std</span>::forward&lt;T&gt;(v));</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">std</span>::<span class="built_in">move</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    testForward(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"======================"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    testFoward(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，定义了两个模板函数，一个接收左值，另一个接收右值。在<code>testForward</code>函数中向模板函数<code>print</code>传入不同的参数，这样我们就可以观察出forward与move的区别了。</p><p>上面代码执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lvalue</span><br><span class="line">rvalue</span><br><span class="line">rvalue</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">lvalue</span><br><span class="line">lvalue</span><br><span class="line">rvalue</span><br></pre></td></tr></table></figure><p>从上面第一组的结果我们可以看到，传入的1虽然是右值，但经过函数传参之后它变成了左值（在内存中分配了空间）；而第二行由于使用了std::forward函数，所以不会改变它的右值属性，因此会调用参数为右值引用的print模板函数；第三行，因为std::move会将传入的参数强制转成右值，所以结果一定是右值。</p><p>再来看看第二组结果。因为x变量是左值，所以第一行一定是左值；第二行使用forward处理，它依然会让其保持左值，所以第二也是左值；最后一行使用move函数，因此一定是右值。</p><p>通过上面的例子我想你应该已经清楚forward的作用是什么了吧？</p><h2 id="forward实现原理"><a href="#forward实现原理" class="headerlink" title="forward实现原理"></a>forward实现原理</h2><p>要分析forward实现原理，我们首先来看一下forward代码实现。由于我们之前已经有了<a href="http://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">分析std::move</a>的基础，所以再来看forward代码应该不会太困难。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>forward实现了两个模板函数，一个接收左值，另一个接收右值。在上面有代码中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type</span><br></pre></td></tr></table></figure><p>的含义我们在<a href="http://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">分析std::move</a>时已经向你做了说细的说明，其作用就是获得去掉引用后的参数类型。所以在上面的两上模板函数中，第一个是左值引用模板函数，第二个是右值引用模板函数。</p><p>紧接着forward模板函数对传入的参数进行强制转换，转换的目标类型符合引用折叠规则，因此左值参数最终转换后仍为左值，右值参数最终转成右值。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们首先通一个小例子向你介绍了std::forward的作用为“完美转发”，也就是不改变原值的属性。接着我带你分析了std::forward的原码实现，如果你看过我之前对std::move的分析文章，相信你在阅读std:forward的代码实现时不会遇到什么困难。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">C++高阶知识：深入分析移动构造函数及其原理</a><br><a href="https://avdancedu.com/9683d88/" target="_blank" rel="noopener">细说智能指针</a><br><a href="https://avdancedu/670ef31f/" target="_blank" rel="noopener">聊聊C++中的类型转换</a><br><a href="https://avdancedu.com/5e7916e3/" target="_blank" rel="noopener">重学C/C++中的const</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前我已经向你介绍了&lt;a href=&quot;http://avdancedu.com/a39d51f9/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;C++中的std::move&lt;/a&gt;，它的作用是无论你传给它的是左值还是右值，通过std::move之后都变成了右值。而今天我们要介绍的std::forward则与之不同，它的作用是什么呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://blog.avdancedu.com/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="https://blog.avdancedu.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>[转]Mac配置中文man手册</title>
    <link href="https://blog.avdancedu.com/a77533/"/>
    <id>https://blog.avdancedu.com/a77533/</id>
    <published>2020-07-11T16:29:40.000Z</published>
    <updated>2020-07-13T09:00:53.517Z</updated>
    
    <content type="html"><![CDATA[<p>转自： <a href="http://www.jackaiup.com/index/detail?id=10234" target="_blank" rel="noopener">http://www.jackaiup.com/index/detail?id=10234</a></p><p>man手册对于我们在Mac或Linux系统下开发起着至关重要的作用，今天我们就来看一下如何在Mac系统下安装Man手册。</p><a id="more"></a><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li>安装软件依赖</li><li>编译安装man手册</li><li>修改配置文件</li><li>解决乱码问题</li></ul><h2 id="软件依赖"><a href="#软件依赖" class="headerlink" title="软件依赖"></a>软件依赖</h2><ul><li>autotools (autoconf, automake)</li><li>python3</li><li>opencc 1.x</li></ul><p>可以通过homebrew自行安装:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew install autotools</span><br><span class="line">brew install python3</span><br><span class="line">brew install opencc</span><br></pre></td></tr></table></figure><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><blockquote><p>git clone  <a href="https://github.com/man-pages-zh/manpages-zh" target="_blank" rel="noopener">https://github.com/man-pages-zh/manpages-zh</a>    #下载文件<br>cd manpages-zh<br>autoreconf –install –force     #构建configure文件<br>./configure<br>make<br>make install                     #需要超级用户权限</p></blockquote><h2 id="添加手册路径"><a href="#添加手册路径" class="headerlink" title="添加手册路径"></a>添加手册路径</h2><p>打开 man 手册配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;man.conf</span><br></pre></td></tr></table></figure><p>修改配置文件，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line">MANPATH &#x2F;usr&#x2F;local&#x2F;share&#x2F;man              #line 44</span><br><span class="line">MANPATH &#x2F;usr&#x2F;local&#x2F;share&#x2F;man&#x2F;zh_CN        #添加中文手册路径</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">:wq</span><br></pre></td></tr></table></figure><p>可以通过下面的命令查看是否中文文档已经加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man -aw</span><br></pre></td></tr></table></figure><p>如果出现下面的信息表示已加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;share&#x2F;man:&#x2F;usr&#x2F;share&#x2F;man:&#x2F;usr&#x2F;local&#x2F;share&#x2F;man&#x2F;zh_CN         #已经加载</span><br></pre></td></tr></table></figure><h2 id="查看中文文档"><a href="#查看中文文档" class="headerlink" title="查看中文文档"></a>查看中文文档</h2><p>执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man -aw ls            &lt;&#x3D; 查看有几个中文文档</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;share&#x2F;man&#x2F;man1&#x2F;ls.1                 &lt;&#x3D; 默认文档</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;share&#x2F;man&#x2F;zh_CN&#x2F;man1&#x2F;ls.1     &lt;&#x3D; 中文文档</span><br></pre></td></tr></table></figure><p>查看文档内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man -a ls             &lt;&#x3D; 查看文档内容</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">LS(1)                     BSD General Commands Manual                    LS(1)</span><br><span class="line">NAME</span><br><span class="line">     ls — list directory contents</span><br><span class="line">SYNOPSIS</span><br><span class="line">     ls [-ABCFGHLOPRSTUW@abcdefghiklmnopqrstuwx1] [file ...]</span><br><span class="line">DESCRIPTION</span><br><span class="line">     For each operand that names a file of a type other than directory, ls displays its name as</span><br><span class="line">     well as any requested, associated information.  For each operand that names a file of type</span><br><span class="line">     directory, ls displays the names of files contained within that directory, as well as any</span><br><span class="line">     requested, associated information.</span><br><span class="line">     If no operands are given, the contents of the current directory are displayed.  If more than</span><br><span class="line">     one operand is given, non-directory operands are displayed first; directory and non-direc‐</span><br><span class="line">     tory operands are sorted separately and in lexicographical order.</span><br><span class="line">     The following options are available:</span><br><span class="line">     -@      Display extended attribute keys and sizes in long (-l) output.</span><br><span class="line">     -1      (The numeric digit “one”.)  Force output to be one entry per line.  This is the</span><br><span class="line">     ...</span><br><span class="line">    按【q】进入中文文档</span><br><span class="line"></span><br><span class="line">LS(1)                                General Commands Manual                                LS(1)</span><br><span class="line">NAME</span><br><span class="line">       ls, dir, vdir - 列目录内容</span><br><span class="line">提要</span><br><span class="line">       ls [选项] [文件名...]</span><br><span class="line">       POSIX 标准选项: [-CFRacdilqrtu1]</span><br><span class="line">GNU 选项 (短格式):</span><br><span class="line">       [-1abcdfgiklmnopqrstuxABCDFGLNQRSUX]  [-w  cols]  [-T  cols]  [-I  pattern]  [--full-time]</span><br><span class="line">       [--format&#x3D;&#123;long,verbose,commas,across,vertical,single-column&#125;]</span><br><span class="line">       [--sort&#x3D;&#123;none,time,size,extension&#125;]               [--time&#x3D;&#123;atime,access,use,ctime,status&#125;]</span><br><span class="line">       [--color[&#x3D;&#123;none,auto,always&#125;]] [--help] [--version] [--]</span><br><span class="line">描述（ DESCRIPTION ）</span><br><span class="line">       程序ls先列出非目录的文件项，然后是每一个目录中的“可显示”文件。如果</span><br><span class="line">       没有选项之外的参数【译注：即文件名部分为空】出现，缺省为   &quot;.&quot;   （当前目录）。  选项“  -d</span><br><span class="line">       ”使得目录与非目录项同样对待。除非“ -a ” 选项出现，文 件名以“.”开始的文件不属“可显示”文件。</span><br><span class="line">       以当前目录为准，每一组文件（包括非目录文件项，以及每一内含文件的目录）分</span><br><span class="line">       别按文件名比较顺序排序。如果“-l”选项存在，每组文件前显示一摘要行:</span><br><span class="line">       ...</span><br><span class="line">【注】默认进入英文文档，按【q】可进入中文文档，再次按【q】则退出文档</span><br></pre></td></tr></table></figure><h2 id="解决乱码"><a href="#解决乱码" class="headerlink" title="解决乱码"></a>解决乱码</h2><p>如果系统的groff版本太低，文档可能出现乱码，可以将groff更新到最新版本（1.22.3，可能的话请使用尚未发布的 1.22.4）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install groff</span><br></pre></td></tr></table></figure><p>安装完成后，配置man.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;man.conf</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">#修改NROFF配置如下（将UTF8编码的MAN页面通过转码而被groff识别）</span><br><span class="line">#line 95</span><br><span class="line"></span><br><span class="line">NROFF preconv -e utf8 | &#x2F;usr&#x2F;local&#x2F;bin&#x2F;groff -Wall -mtty-char -Tutf8 -mandoc -c</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">#修改PAGER配置如下（这样可以避免MAN手册页面中的ANSI Escape字符序列干扰（用于控制显示粗体等格式））</span><br><span class="line">#line 106</span><br><span class="line"></span><br><span class="line">PAGER &#x2F;usr&#x2F;bin&#x2F;less -isR</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">:wq</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自： &lt;a href=&quot;http://www.jackaiup.com/index/detail?id=10234&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.jackaiup.com/index/detail?id=10234&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;man手册对于我们在Mac或Linux系统下开发起着至关重要的作用，今天我们就来看一下如何在Mac系统下安装Man手册。&lt;/p&gt;
    
    </summary>
    
    
      <category term="man" scheme="https://blog.avdancedu.com/categories/man/"/>
    
    
      <category term="man" scheme="https://blog.avdancedu.com/tags/man/"/>
    
  </entry>
  
  <entry>
    <title>ffmpeg命令详解</title>
    <link href="https://blog.avdancedu.com/92d94a35/"/>
    <id>https://blog.avdancedu.com/92d94a35/</id>
    <published>2020-07-08T08:29:15.000Z</published>
    <updated>2020-07-08T08:51:37.235Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="http://upload-images.jianshu.io/upload_images/5956443-29b1eff4f8ce0e61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1600" alt="ffmpegX.png"></p><p>FFMPEG是特别强大的专门用于处理音视频的开源库。你既可以使用它的API对音视频进行处理，也可以使用它提供的工具，如 ffmpeg, ffplay, ffprobe，来编辑你的音视频文件。</p><p>本文将简要介绍一下 FFMPEG 库的基本目录结构及其功能，然后详细介绍一下我们在日常工作中，如何使用 ffmpeg 提供的工具来处理音视频文件。</p><a id="more"></a><h1 id="FFMPEG-目录及作用"><a href="#FFMPEG-目录及作用" class="headerlink" title="FFMPEG 目录及作用"></a>FFMPEG 目录及作用</h1><ul><li>libavcodec： 提供了一系列编码器的实现。</li><li>libavformat： 实现在流协议，容器格式及其本IO访问。</li><li>libavutil： 包括了hash器，解码器和各利工具函数。</li><li>libavfilter： 提供了各种音视频过滤器。</li><li>libavdevice： 提供了访问捕获设备和回放设备的接口。</li><li>libswresample： 实现了混音和重采样。</li><li>libswscale： 实现了色彩转换和缩放工能。</li></ul><h1 id="FFMPEG基本概念"><a href="#FFMPEG基本概念" class="headerlink" title="FFMPEG基本概念"></a>FFMPEG基本概念</h1><p>在讲解 FFMPEG 命令之前，我们先要介绍一些音视频格式的基要概念。</p><ul><li>音／视频流</li></ul><blockquote><p>在音视频领域，我们把一路音／视频称为一路<strong>流</strong>。如我们小时候经常使用VCD看港片，在里边可以选择粤语或国语声音，其实就是CD视频文件中存放了两路音频流，用户可以选择其中一路进行播放。</p></blockquote><ul><li>容器</li></ul><blockquote><p>我们一般把 MP4､ FLV、MOV等文件格式称之为<strong>容器</strong>。也就是在这些常用格式文件中，可以存放多路音视频文件。以 MP4 为例，就可以存放一路视频流，多路音频流，多路字幕流。</p></blockquote><ul><li>channel</li></ul><blockquote><p>channel是音频中的概念，称之为声道。在一路音频流中，可以有单声道，双声道或立体声。</p></blockquote><h1 id="FFMPEG-命令"><a href="#FFMPEG-命令" class="headerlink" title="FFMPEG 命令"></a>FFMPEG 命令</h1><p>我们按使用目的可以将 FFMPEG 命令分成以下几类：</p><ul><li>基本信息查询命令</li><li>录制</li><li>分解/复用</li><li>处理原始数据</li><li>滤镜</li><li>切割与合并</li><li>图／视互转</li><li>直播相关</li></ul><p>除了 FFMPEG 的基本信息查询命令外，其它命令都按下图所示的流程处理音视频。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> _______              ______________</span><br><span class="line">|       |            |              |</span><br><span class="line">| input |  demuxer   | encoded data |   decoder</span><br><span class="line">| file  | ---------&gt; | packets      | -----+</span><br><span class="line">|_______|            |______________|      |</span><br><span class="line">                                           v</span><br><span class="line">                                       _________</span><br><span class="line">                                      |         |</span><br><span class="line">                                      | decoded |</span><br><span class="line">                                      | frames  |</span><br><span class="line">                                      |_________|</span><br><span class="line"> ________             ______________       |</span><br><span class="line">|        |           |              |      |</span><br><span class="line">| output | &lt;-------- | encoded data | &lt;----+</span><br><span class="line">| file   |   muxer   | packets      |   encoder</span><br><span class="line">|________|           |______________|</span><br></pre></td></tr></table></figure><p>ffmpeg调用libavformat库（包含demuxers）来读取输入文件并获取包含编码数据的数据包。 当有多个输入文件时，ffmpeg会尝试通过跟踪任何活动输入流上的最低时间戳来使其保持同步。</p><p>然后将编码的数据包传送给解码器（除非为数据流选择了流拷贝，请参阅进一步描述）。 解码器产生未压缩的帧（原始视频/ PCM音频/ …），可以通过滤波进一步处理（见下一节）。 在过滤之后，帧被传递到编码器，编码器并输出编码的数据包。 最后，这些传递给复用器，将编码的数据包写入输出文件。</p><p>默认情况下，ffmpeg只包含输入文件中每种类型（视频，音频，字幕）的一个流，并将其添加到每个输出文件中。 它根据以下标准挑选每一个的“最佳”：对于视频，它是具有最高分辨率的流，对于音频，它是具有最多channel的流，对于字幕，是第一个字幕流。 在相同类型的几个流相等的情况下，选择具有最低索引的流。</p><p>您可以通过使用-vn / -an / -sn / -dn选项来禁用某些默认设置。 要进行全面的手动控制，请使用-map选项，该选项禁用刚描述的默认设置。</p><p>下面我们就来详细介绍一下这些命令。</p><h2 id="基本信息查询命令"><a href="#基本信息查询命令" class="headerlink" title="基本信息查询命令"></a>基本信息查询命令</h2><p>FFMPEG 可以使用下面的参数进行基本信息查询。例如，想查询一下现在使用的 FFMPEG 都支持哪些 filter，就可以用 <code>ffmpeg -filters</code> 来查询。详细参数说明如下：</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-version</td><td align="left">显示版本。</td></tr><tr><td align="left">-formats</td><td align="left">显示可用的格式（包括设备）。</td></tr><tr><td align="left">-demuxers</td><td align="left">显示可用的demuxers。</td></tr><tr><td align="left">-muxers</td><td align="left">显示可用的muxers。</td></tr><tr><td align="left">-devices</td><td align="left">显示可用的设备。</td></tr><tr><td align="left">-codecs</td><td align="left">显示libavcodec已知的所有编解码器。</td></tr><tr><td align="left">-decoders</td><td align="left">显示可用的解码器。</td></tr><tr><td align="left">-encoders</td><td align="left">显示所有可用的编码器。</td></tr><tr><td align="left">-bsfs</td><td align="left">显示可用的比特流filter。</td></tr><tr><td align="left">-protocols</td><td align="left">显示可用的协议。</td></tr><tr><td align="left">-filters</td><td align="left">显示可用的libavfilter过滤器。</td></tr><tr><td align="left">-pix_fmts</td><td align="left">显示可用的像素格式。</td></tr><tr><td align="left">-sample_fmts</td><td align="left">显示可用的采样格式。</td></tr><tr><td align="left">-layouts</td><td align="left">显示channel名称和标准channel布局。</td></tr><tr><td align="left">-colors</td><td align="left">显示识别的颜色名称。</td></tr></tbody></table><p>接下来介绍的是 FFMPEG 处理音视频时使用的命令格式与参数。</p><h2 id="命令基本格式及参数"><a href="#命令基本格式及参数" class="headerlink" title="命令基本格式及参数"></a>命令基本格式及参数</h2><p>下面是 FFMPEG 的基本命令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg [global_options] &#123;[input_file_options] -i input_url&#125; ...</span><br><span class="line"> &#123;[output_file_options] output_url&#125; ...</span><br></pre></td></tr></table></figure><p>ffmpeg 通过 -i 选项读取输任意数量的输入“文件”（可以是常规文件，管道，网络流，抓取设备等，并写入任意数量的输出“文件”。</p><p>原则上，每个输入/输出“文件”都可以包含任意数量的不同类型的视频流（视频/音频/字幕/附件/数据）。 流的数量和/或类型是由容器格式来限制。 选择从哪个输入进入到哪个输出将自动完成或使用 -map 选项。</p><p>要引用选项中的输入文件，您必须使用它们的索引（从0开始）。 例如。 第一个输入文件是0，第二个输入文件是1，等等。类似地，文件内的流被它们的索引引用。 例如。 2：3是指第三个输入文件中的第四个流。</p><p>上面就是 FFMPEG 处理音视频的常用命令，下面是一些常用参数：</p><h3 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h3><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-f fmt（输入/输出）</td><td align="left">强制输入或输出文件格式。 格式通常是自动检测输入文件，并从输出文件的文件扩展名中猜测出来，所以在大多数情况下这个选项是不需要的。</td></tr><tr><td align="left">-i url（输入）</td><td align="left">输入文件的网址</td></tr><tr><td align="left">-y（全局参数）</td><td align="left">覆盖输出文件而不询问。</td></tr><tr><td align="left">-n（全局参数）</td><td align="left">不要覆盖输出文件，如果指定的输出文件已经存在，请立即退出。</td></tr><tr><td align="left">-c [：stream_specifier] codec（输入/输出，每个流）</td><td align="left">选择一个编码器（当在输出文件之前使用）或解码器（当在输入文件之前使用时）用于一个或多个流。codec 是解码器/编码器的名称或 copy（仅输出）以指示该流不被重新编码。如：ffmpeg -i INPUT -map 0 -c:v libx264 -c:a copy OUTPUT</td></tr><tr><td align="left">-codec [：stream_specifier]编解码器（输入/输出，每个流）</td><td align="left">同 -c</td></tr><tr><td align="left">-t duration（输入/输出）</td><td align="left">当用作输入选项（在-i之前）时，限制从输入文件读取的数据的持续时间。当用作输出选项时（在输出url之前），在持续时间到达持续时间之后停止输出。</td></tr><tr><td align="left">-ss位置（输入/输出）</td><td align="left">当用作输入选项时（在-i之前），在这个输入文件中寻找位置。 请注意，在大多数格式中，不可能精确搜索，因此ffmpeg将在位置之前寻找最近的搜索点。 当转码和-accurate_seek被启用时（默认），搜索点和位置之间的这个额外的分段将被解码和丢弃。 当进行流式复制或使用-noaccurate_seek时，它将被保留。当用作输出选项（在输出url之前）时，解码但丢弃输入，直到时间戳到达位置。</td></tr><tr><td align="left">-frames [：stream_specifier] framecount（output，per-stream）</td><td align="left">停止在帧计数帧之后写入流。</td></tr><tr><td align="left">-filter [：stream_specifier] filtergraph（output，per-stream）</td><td align="left">创建由filtergraph指定的过滤器图，并使用它来过滤流。filtergraph是应用于流的filtergraph的描述，并且必须具有相同类型的流的单个输入和单个输出。在过滤器图形中，输入与标签中的标签相关联，标签中的输出与标签相关联。有关filtergraph语法的更多信息，请参阅ffmpeg-filters手册。</td></tr></tbody></table><h3 id="视频参数"><a href="#视频参数" class="headerlink" title="视频参数"></a>视频参数</h3><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-vframes num（输出）</td><td align="left">设置要输出的视频帧的数量。对于-frames：v，这是一个过时的别名，您应该使用它。</td></tr><tr><td align="left">-r [：stream_specifier] fps（输入/输出，每个流）</td><td align="left">设置帧率（Hz值，分数或缩写）。作为输入选项，忽略存储在文件中的任何时间戳，根据速率生成新的时间戳。这与用于-framerate选项不同（它在FFmpeg的旧版本中使用的是相同的）。如果有疑问，请使用-framerate而不是输入选项-r。作为输出选项，复制或丢弃输入帧以实现恒定输出帧频fps。</td></tr><tr><td align="left">-s [：stream_specifier]大小（输入/输出，每个流）</td><td align="left">设置窗口大小。作为输入选项，这是video_size专用选项的快捷方式，由某些分帧器识别，其帧尺寸未被存储在文件中。作为输出选项，这会将缩放视频过滤器插入到相应过滤器图形的末尾。请直接使用比例过滤器将其插入到开头或其他地方。格式是’wxh’（默认 - 与源相同）。</td></tr><tr><td align="left">-aspect [：stream_specifier] 宽高比（输出，每个流）</td><td align="left">设置方面指定的视频显示宽高比。aspect可以是浮点数字符串，也可以是num：den形式的字符串，其中num和den是宽高比的分子和分母。例如“4：3”，“16：9”，“1.3333”和“1.7777”是有效的参数值。如果与-vcodec副本一起使用，则会影响存储在容器级别的宽高比，但不会影响存储在编码帧中的宽高比（如果存在）。</td></tr><tr><td align="left">-vn（输出）</td><td align="left">禁用视频录制。</td></tr><tr><td align="left">-vcodec编解码器（输出）</td><td align="left">设置视频编解码器。这是-codec：v的别名。</td></tr><tr><td align="left">-vf filtergraph（输出）</td><td align="left">创建由filtergraph指定的过滤器图，并使用它来过滤流。</td></tr></tbody></table><h3 id="音频参数"><a href="#音频参数" class="headerlink" title="音频参数"></a>音频参数</h3><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-aframes（输出）</td><td align="left">设置要输出的音频帧的数量。这是-frames：a的一个过时的别名。</td></tr><tr><td align="left">-ar [：stream_specifier] freq（输入/输出，每个流）</td><td align="left">设置音频采样频率。对于输出流，它默认设置为相应输入流的频率。对于输入流，此选项仅适用于音频捕获设备和原始分路器，并映射到相应的分路器选件。</td></tr><tr><td align="left">-ac [：stream_specifier]通道（输入/输出，每个流）</td><td align="left">设置音频通道的数量。对于输出流，它默认设置为输入音频通道的数量。对于输入流，此选项仅适用于音频捕获设备和原始分路器，并映射到相应的分路器选件。</td></tr><tr><td align="left">-an（输出）</td><td align="left">禁用录音。</td></tr><tr><td align="left">-acodec编解码器（输入/输出）</td><td align="left">设置音频编解码器。这是-codec的别名：a。</td></tr><tr><td align="left">-sample_fmt [：stream_specifier] sample_fmt（输出，每个流）</td><td align="left">设置音频采样格式。使用-sample_fmts获取支持的样本格式列表。</td></tr><tr><td align="left">-af filtergraph（输出）</td><td align="left">创建由filtergraph指定的过滤器图，并使用它来过滤流。</td></tr></tbody></table><p>了解了这些基本信息后，接下来我们看看 FFMPEG 具体都能干些什么吧。</p><h2 id="录制"><a href="#录制" class="headerlink" title="录制"></a>录制</h2><p>首先通过下面的命令查看一下 mac 上都有哪些设备。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f avfoundation -list_devices true -i &quot;&quot;</span><br></pre></td></tr></table></figure><p><strong>录屏</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f avfoundation -i 1 -r 30 out.yuv</span><br></pre></td></tr></table></figure><ul><li>-f 指定使用 avfoundation 采集数据。</li><li>-i 指定从哪儿采集数据，它是一个文件索引号。在我的MAC上，1代表桌面（可以通过上面的命令查询设备索引号）。</li><li>-r 指定帧率。按ffmpeg官方文档说-r与-framerate作用相同，但实际测试时发现不同。-framerate 用于限制输入，而-r用于限制输出。</li></ul><blockquote><p>注意，桌面的输入对帧率没有要求，所以不用限制桌面的帧率。其实限制了也没用。</p></blockquote><p><strong>录屏+声音</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -f avfoundation -i 1:0  -r 29.97 -c:v libx264 -crf 0 -c:a libfdk_aac -profile:a aac_he_v2 -b:a 32k  out.flv</span><br></pre></td></tr></table></figure><ul><li>-i 1:0 冒号前面的 “1” 代表的屏幕索引号。冒号后面的”0”代表的声音索相号。</li><li>-c:v 与参数 -vcodec 一样，表示视频编码器。c 是 codec 的缩写，v 是video的缩写。</li><li>-crf 是 x264 的参数。 0 表式无损压缩。</li><li>-c:a 与参数 -acodec 一样，表示音频编码器。</li><li>-profile 是 fdk_aac 的参数。 aac_he_v2 表式使用 AAC_HE v2 压缩数据。</li><li>-b:a 指定音频码率。 b 是 bitrate的缩写, a是 audio的缩与。</li></ul><p><strong>Linux下录屏</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f x11grab -s 640*480 -r 20 -i :0.0 test.mp4</span><br></pre></td></tr></table></figure><p><strong>录视频</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -framerate 30 -f avfoundation -i 0 out.mp4</span><br></pre></td></tr></table></figure><ul><li>-framerate 限制视频的采集帧率。这个必须要根据提示要求进行设置，如果不设置就会报错。</li><li>-f 指定使用 avfoundation 采集数据。</li><li>-i 指定视频设备的索引号。</li></ul><p><strong>视频+音频</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -framerate 30 -f avfoundation -i 0:0 out.mp4</span><br></pre></td></tr></table></figure><p><strong>录音</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f avfoundation -i :0 out.wav</span><br></pre></td></tr></table></figure><p><strong>录制音频裸数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -f avfoundation -i :0 -ar 44100 -f s16le out.pcm</span><br></pre></td></tr></table></figure><p><strong>在Windows下录制播放的声音</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -f dshow -i audio&#x3D;&quot;立体声混音 (Realtek High Definition Audio)&quot; -ar 48000  -acodec aac -bsf:a aac_adtstoasc -f flv temp.flv</span><br></pre></td></tr></table></figure><h2 id="分解与复用"><a href="#分解与复用" class="headerlink" title="分解与复用"></a>分解与复用</h2><p>流拷贝是通过将 copy 参数提供给-codec选项来选择流的模式。它使得ffmpeg省略了指定流的解码和编码步骤，所以它只能进行多路分解和多路复用。 这对于更改容器格式或修改容器级元数据很有用。 在这种情况下，上图将简化为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> _______              ______________            ________</span><br><span class="line">|       |            |              |          |        |</span><br><span class="line">| input |  demuxer   | encoded data |  muxer   | output |</span><br><span class="line">| file  | ---------&gt; | packets      | -------&gt; | file   |</span><br><span class="line">|_______|            |______________|          |________|</span><br></pre></td></tr></table></figure><p>由于没有解码或编码，速度非常快，没有质量损失。 但是，由于许多因素，在某些情况下可能无法正常工作。 应用过滤器显然也是不可能的，因为过滤器处理未压缩的数据。</p><p><strong>抽取音频流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -acodec copy -vn out.aac</span><br></pre></td></tr></table></figure><ul><li>acodec: 指定音频编码器，copy 指明只拷贝，不做编解码。</li><li>vn: v 代表视频，n 代表 no 也就是无视频的意思。</li></ul><p><strong>抽取视频流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -vcodec copy -an out.h264</span><br></pre></td></tr></table></figure><ul><li>vcodec: 指定视频编码器，copy 指明只拷贝，不做编解码。</li><li>an: a 代表视频，n 代表 no 也就是无音频的意思。</li></ul><p><strong>转格式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -vcodec copy -acodec copy out.flv</span><br></pre></td></tr></table></figure><p>上面的命令表式的是音频、视频都直接 copy，只是将 mp4 的封装格式转成了flv。</p><p><strong>音视频合并</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.h264 -i out.aac -vcodec copy -acodec copy out.mp4</span><br></pre></td></tr></table></figure><h2 id="处理原始数据"><a href="#处理原始数据" class="headerlink" title="处理原始数据"></a>处理原始数据</h2><p><strong>提取YUV数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -an -c:v rawvideo -pix_fmt yuv420p out.yuv</span><br><span class="line">ffplay -s wxh out.yuv</span><br></pre></td></tr></table></figure><ul><li>-c:v rawvideo 指定将视频转成原始数据</li><li>-pix_fmt yuv420p 指定转换格式为yuv420p</li></ul><p><strong>YUV转H264</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f rawvideo -pix_fmt yuv420p -s 320x240 -r 30 -i out.yuv -c:v libx264 -f rawvideo out.h264</span><br></pre></td></tr></table></figure><p><strong>提取PCM数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -vn -ar 44100 -ac 2 -f s16le out.pcm</span><br><span class="line">ffplay -ar 44100 -ac 2 -f s16le -i out.pcm</span><br></pre></td></tr></table></figure><p><strong>PCM转WAV</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f s16be -ar 8000 -ac 2 -acodec pcm_s16be -i input.raw output.wav</span><br></pre></td></tr></table></figure><h2 id="滤镜"><a href="#滤镜" class="headerlink" title="滤镜"></a>滤镜</h2><p>在编码之前，ffmpeg可以使用libavfilter库中的过滤器处理原始音频和视频帧。 几个链式过滤器形成一个过滤器图形。 ffmpeg区分两种类型的过滤器图形：简单和复杂。</p><h3 id="简单滤镜"><a href="#简单滤镜" class="headerlink" title="简单滤镜"></a>简单滤镜</h3><p>简单的过滤器图是那些只有一个输入和输出，都是相同的类型。 在上面的图中，它们可以通过在解码和编码之间插入一个额外的步骤来表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> _________                        ______________</span><br><span class="line">|         |                      |              |</span><br><span class="line">| decoded |                      | encoded data |</span><br><span class="line">| frames  |\                   _ | packets      |</span><br><span class="line">|_________| \                  &#x2F;||______________|</span><br><span class="line">             \   __________   &#x2F;</span><br><span class="line">  simple     _\||          | &#x2F;  encoder</span><br><span class="line">  filtergraph   | filtered |&#x2F;</span><br><span class="line">                | frames   |</span><br><span class="line">                |__________|</span><br></pre></td></tr></table></figure><p>简单的filtergraphs配置了per-stream-filter选项（分别为视频和音频使用-vf和-af别名）。 一个简单的视频filtergraph可以看起来像这样的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> _______        _____________        _______        ________</span><br><span class="line">|       |      |             |      |       |      |        |</span><br><span class="line">| input | ---&gt; | deinterlace | ---&gt; | scale | ---&gt; | output |</span><br><span class="line">|_______|      |_____________|      |_______|      |________|</span><br></pre></td></tr></table></figure><p>请注意，某些滤镜会更改帧属性，但不会改变帧内容。 例如。 上例中的fps过滤器会改变帧数，但不会触及帧内容。 另一个例子是setpts过滤器，它只设置时间戳，否则不改变帧。</p><h3 id="复杂滤镜"><a href="#复杂滤镜" class="headerlink" title="复杂滤镜"></a>复杂滤镜</h3><p>复杂的过滤器图是那些不能简单描述为应用于一个流的线性处理链的过滤器图。 例如，当图形有多个输入和/或输出，或者当输出流类型与输入不同时，就是这种情况。 他们可以用下图来表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> _________</span><br><span class="line">|         |</span><br><span class="line">| input 0 |\                    __________</span><br><span class="line">|_________| \                  |          |</span><br><span class="line">             \   _________    &#x2F;| output 0 |</span><br><span class="line">              \ |         |  &#x2F; |__________|</span><br><span class="line"> _________     \| complex | &#x2F;</span><br><span class="line">|         |     |         |&#x2F;</span><br><span class="line">| input 1 |----&gt;| filter  |\</span><br><span class="line">|_________|     |         | \   __________</span><br><span class="line">               &#x2F;| graph   |  \ |          |</span><br><span class="line">              &#x2F; |         |   \| output 1 |</span><br><span class="line"> _________   &#x2F;  |_________|    |__________|</span><br><span class="line">|         | &#x2F;</span><br><span class="line">| input 2 |&#x2F;</span><br><span class="line">|_________|</span><br></pre></td></tr></table></figure><p>复杂的过滤器图使用-filter_complex选项进行配置。 请注意，此选项是全局性的，因为复杂的过滤器图形本质上不能与单个流或文件明确关联。</p><p>-lavfi选项等同于-filter_complex。</p><p>一个复杂的过滤器图的一个简单的例子是覆盖过滤器，它有两个视频输入和一个视频输出，包含一个视频叠加在另一个上面。 它的音频对应是amix滤波器。</p><p><strong>添加水印</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4  -vf &quot;movie&#x3D;logo.png,scale&#x3D;64:48[watermask];[in][watermask] overlay&#x3D;30:10 [out]&quot; water.mp4</span><br></pre></td></tr></table></figure><ul><li>-vf中的 movie 指定logo位置。scale 指定 logo 大小。overlay 指定 logo 摆放的位置。</li></ul><p><strong>删除水印</strong><br>先通过 ffplay 找到要删除 LOGO 的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffplay -i test.flv -vf delogo&#x3D;x&#x3D;806:y&#x3D;20:w&#x3D;70:h&#x3D;80:show&#x3D;1</span><br></pre></td></tr></table></figure><p>使用 delogo 滤镜删除 LOGO</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.flv -vf delogo&#x3D;x&#x3D;806:y&#x3D;20:w&#x3D;70:h&#x3D;80 output.flv</span><br></pre></td></tr></table></figure><p><strong>视频缩小一倍</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -vf scale&#x3D;iw&#x2F;2:-1 scale.mp4</span><br></pre></td></tr></table></figure><ul><li>-vf scale 指定使用简单过滤器 scale，iw/2:-1 中的 iw 指定按整型取视频的宽度。 -1 表示高度随宽度一起变化。</li></ul><p><strong>视频裁剪</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i VR.mov  -vf crop&#x3D;in_w-200:in_h-200 -c:v libx264 -c:a copy -video_size 1280x720 vr_new.mp4</span><br></pre></td></tr></table></figure><p>crop 格式：crop=out_w:out_h:x:y</p><ul><li>out_w: 输出的宽度。可以使用 in_w 表式输入视频的宽度。</li><li>out_h: 输出的高度。可以使用 in_h 表式输入视频的高度。</li><li>x : X坐标</li><li>y : Y坐标</li></ul><blockquote><p>如果 x和y 设置为 0,说明从左上角开始裁剪。如果不写是从中心点裁剪。</p></blockquote><p><strong>倍速播放</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -filter_complex &quot;[0:v]setpts&#x3D;0.5*PTS[v];[0:a]atempo&#x3D;2.0[a]&quot; -map &quot;[v]&quot; -map &quot;[a]&quot; speed2.0.mp4</span><br></pre></td></tr></table></figure><ul><li>-filter_complex 复杂滤镜，[0:v]表示第一个（文件索引号是0）文件的视频作为输入。setpts=0.5*PTS表示每帧视频的pts时间戳都乘0.5 ，也就是差少一半。[v]表示输出的别名。音频同理就不详述了。</li><li>map 可用于处理复杂输出，如可以将指定的多路流输出到一个输出文件，也可以指定输出到多个文件。”[v]” 复杂滤镜输出的别名作为输出文件的一路流。上面 map的用法是将复杂滤镜输出的视频和音频输出到指定文件中。</li></ul><p><strong>对称视频</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -i out.mp4 -filter_complex &quot;[0:v]pad&#x3D;w&#x3D;2*iw[a];[0:v]hflip[b];[a][b]overlay&#x3D;x&#x3D;w&quot; duicheng.mp4</span><br></pre></td></tr></table></figure><ul><li>hflip 水平翻转</li></ul><p>如果要修改为垂直翻转可以用vflip。</p><p><strong>画中画</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -i out1.mp4 -filter_complex &quot;[1:v]scale&#x3D;w&#x3D;176:h&#x3D;144:force_original_aspect_ratio&#x3D;decrease[ckout];[0:v][ckout]overlay&#x3D;x&#x3D;W-w-10:y&#x3D;0[out]&quot; -map &quot;[out]&quot; -movflags faststart new.mp4</span><br></pre></td></tr></table></figure><p><strong>录制画中画</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -f avfoundation -i &quot;1&quot; -framerate 30 -f avfoundation -i &quot;0:0&quot;</span><br><span class="line">-r 30 -c:v libx264 -preset ultrafast</span><br><span class="line">-c:a libfdk_aac -profile:a aac_he_v2 -ar 44100 -ac 2</span><br><span class="line">-filter_complex &quot;[1:v]scale&#x3D;w&#x3D;176:h&#x3D;144:force_original_aspect_ratio&#x3D;decrease[a];[0:v][a]overlay&#x3D;x&#x3D;W-w-10:y&#x3D;0[out]&quot;</span><br><span class="line">-map &quot;[out]&quot; -movflags faststart -map 1:a b.mp4</span><br></pre></td></tr></table></figure><p><strong>多路视频拼接</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -f avfoundation -i &quot;1&quot; -framerate 30 -f avfoundation   -i &quot;0:0&quot; -r 30 -c:v libx264 -preset ultrafast -c:a libfdk_aac -profile:a aac_he_v2 -ar 44100 -ac 2 -filter_complex &quot;[0:v]scale&#x3D;320:240[a];[a]pad&#x3D;640:240[b];[b][1:v]overlay&#x3D;320:0[out]&quot; -map &quot;[out]&quot; -movflags faststart  -map 1:a  c.mp4</span><br></pre></td></tr></table></figure><p><strong>滤镜加水印</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i killer.mp4 -filter_complex &quot;movie&#x3D;.&#x2F;logo&#x2F;daka.png,scale&#x3D;64:48[w];[0:v]curves&#x3D;vintage[o];[o][w]overlay&#x3D;30:10[out]&quot; -map &quot;[out]&quot; -map 0:a test1.mp4</span><br></pre></td></tr></table></figure><p><strong>多张图片合成一张</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i killer.mp4 -vf &quot;select&#x3D;not(mod(n\,250)),scale&#x3D;320:240,tile&#x3D;2x3&quot; -an  out%3d.png</span><br></pre></td></tr></table></figure><h2 id="一些比较有意思的滤镜"><a href="#一些比较有意思的滤镜" class="headerlink" title="一些比较有意思的滤镜"></a>一些比较有意思的滤镜</h2><ul><li><p>镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crop&#x3D;iw&#x2F;2:ih:0:0,split[left][tmp];[tmp]hflip[right];</span><br></pre></td></tr></table></figure></li><li><p>复古</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curves&#x3D;vintage;</span><br></pre></td></tr></table></figure></li><li><p>光晕</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vignette&#x3D;PI&#x2F;4</span><br></pre></td></tr></table></figure></li><li><p>变暗</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colorlevels&#x3D;rimin&#x3D;0.058:gimin&#x3D;0.058:bimin&#x3D;0.058</span><br></pre></td></tr></table></figure></li><li><p>增加对比度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fftfilt&#x3D;dc_Y&#x3D;0:weight_Y&#x3D;&#39;exp(-4 * ((Y+X)&#x2F;(W+H)))</span><br></pre></td></tr></table></figure></li><li><p>降噪</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hqdn3d&#x3D;luma_spatial&#x3D;15.0</span><br></pre></td></tr></table></figure></li><li><p>强对比度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curves&#x3D;strong_contrast</span><br></pre></td></tr></table></figure></li><li><p>变亮</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curves&#x3D;lighter</span><br></pre></td></tr></table></figure></li><li><p>锐化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fftfilt&#x3D;dc_Y&#x3D;0:weight_Y&#x3D;&#39;1+squish(1-(Y+X)&#x2F;100)&#39;</span><br></pre></td></tr></table></figure></li><li><p>低通滤波</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fftfilt&#x3D;dc_Y&#x3D;0:weight_Y&#x3D;&#39;squish((Y+X)&#x2F;100-1)&#39;</span><br></pre></td></tr></table></figure></li><li><p>高通滤波</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fftfilt&#x3D;dc_Y&#x3D;128:weight_Y&#x3D;&#39;squish(1-(Y+X)&#x2F;100)&#39;</span><br></pre></td></tr></table></figure></li><li><p>复古</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curves&#x3D;vintage</span><br></pre></td></tr></table></figure></li><li><p>边缘检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edgedetect</span><br></pre></td></tr></table></figure></li><li><p>底片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">negate</span><br></pre></td></tr></table></figure></li><li><p>彩色底片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curves &#x3D; ‘none’‘color_negative’</span><br></pre></td></tr></table></figure></li></ul><h2 id="音视频的拼接与裁剪"><a href="#音视频的拼接与裁剪" class="headerlink" title="音视频的拼接与裁剪"></a>音视频的拼接与裁剪</h2><p><strong>裁剪</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -ss 00:00:00 -t 10 out1.mp4</span><br></pre></td></tr></table></figure><ul><li>-ss 指定裁剪的开始时间，精确到秒</li><li>-t 被裁剪后的时长。</li></ul><p><strong>视频合并</strong></p><p>首先创建一个 inputs.txt 文件，文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file &#39;1.flv&#39;</span><br><span class="line">file &#39;2.flv&#39;</span><br><span class="line">file &#39;3.flv&#39;</span><br></pre></td></tr></table></figure><p>然后执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f concat -i inputs.txt -c copy output.flv</span><br></pre></td></tr></table></figure><p><strong>音频合并</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i text.mp3 -i silenceall.mp3 -filter_complex &#39;[0:0] [1:0] concat&#x3D;n&#x3D;2:v&#x3D;0:a&#x3D;1 [a]&#39; -map [a] test.mp3</span><br></pre></td></tr></table></figure><p><strong>音频混音</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.mp4 -i test.mp3 -filter_complex &quot;[0:a] [1:a]amerge&#x3D;inputs&#x3D;2[aout]&quot; -map &quot;[aout]&quot; -ac 2 mix_amerge.aac</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i INPUT1 -i INPUT2 -i INPUT3 -filter_complex &#39;amix&#x3D;inputs&#x3D;3:duration&#x3D;first:dropout_transition&#x3D;3&#39; OUTPUT</span><br></pre></td></tr></table></figure><ul><li>inputs: The number of inputs. If unspecified, it defaults to 2.//输入的数量，如果没有指明，默认为2.</li><li>duration: How to determine the end-of-stream.//决定了流的结束</li><li>longest: The duration of the longest input. (default)//最长输入的持续时间</li><li>shortest: The duration of the shortest input.//最短输入的持续时间</li><li>first: The duration of the first input.//第一个输入的持续时间</li><li>dropout_transition: The transition time, in seconds, for volume renormalization when an input stream ends. The default value is 2 seconds.//输入流结束时（音频）容量重整化的转换时间（以秒为单位）。 默认值为2秒。</li></ul><blockquote><p>注： amerge 与amix 的区别<br>amerge terminates with the shortest input (always) and amix terminates with the longest input, by default. So the former will always truncate when streams are of different length.</p></blockquote><p><strong>hls切片</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -c:v libx264 -c:a libfdk_aac -strict -2 -f hls  out.m3u8</span><br></pre></td></tr></table></figure><ul><li>-strict -2 指明音频使有AAC。</li><li>-f hls 转成 m3u8 格式。</li></ul><p><strong>将ts文件按时间切片</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -i somefile.ts  -f segment -segment_time 3  -c copy out%03d.ts</span><br></pre></td></tr></table></figure><h2 id="视频图片互转"><a href="#视频图片互转" class="headerlink" title="视频图片互转"></a>视频图片互转</h2><p><strong>视频转JPEG</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.flv -r 1 -f image2 image-%3d.jpeg</span><br></pre></td></tr></table></figure><p><strong>视频转gif</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -ss 00:00:00 -t 10 out.gif</span><br></pre></td></tr></table></figure><p><strong>图片转视频</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -f image2 -i image-%3d.jpeg images.mp4</span><br></pre></td></tr></table></figure><p><strong>一张图片转成5秒视频</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -loop 1 -i .&#x2F;xxx.jpeg -pix_fmt yuv420p -c:v libx264 -preset veryfast -r 25 -t 5 b.mp4</span><br></pre></td></tr></table></figure><h2 id="直播相关"><a href="#直播相关" class="headerlink" title="直播相关"></a>直播相关</h2><p><strong>推流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i out.mp4 -c copy -f flv rtmp:&#x2F;&#x2F;server&#x2F;live&#x2F;streamName</span><br></pre></td></tr></table></figure><ul><li>re的含义 ，Read input at native frame rate. Mainly used to simulate a grab device, or live input stream (e.g. when reading from a file). Should not be used with actual grab devices or live input streams (where it can cause packet loss). By default ffmpeg attempts to read the input(s) as fast as possible. This option will slow down the reading of the input(s) to the native frame rate of the input(s). It is useful for real-time output (e.g. live streaming).</li></ul><p><strong>推rtsp流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i input -f rtsp -muxdelay 0.1 rtsp:&#x2F;&#x2F;server&#x2F;live.sdp</span><br></pre></td></tr></table></figure><p><strong>循环推流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -stream_loop 1 -i out.mp4  -c copy -f flv rtmp:&#x2F;&#x2F;server&#x2F;live&#x2F;streamName</span><br></pre></td></tr></table></figure><p><strong>拉流保存</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i rtmp:&#x2F;&#x2F;server&#x2F;live&#x2F;streamName -c copy dump.flv</span><br></pre></td></tr></table></figure><p><strong>转流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i rtmp:&#x2F;&#x2F;server&#x2F;live&#x2F;originalStream -c:a copy -c:v copy -f flv rtmp:&#x2F;&#x2F;server&#x2F;live&#x2F;h264Stream</span><br></pre></td></tr></table></figure><p><strong>实时推流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -framerate 15 -f avfoundation -i &quot;1&quot; -s 1280x720 -c:v libx264  -f  flv rtmp:&#x2F;&#x2F;localhost:1935&#x2F;live&#x2F;room</span><br></pre></td></tr></table></figure><h2 id="ffplay"><a href="#ffplay" class="headerlink" title="ffplay"></a>ffplay</h2><p><strong>播放YUV 数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffplay -pix_fmt nv12 -s 192x144 1.yuv</span><br></pre></td></tr></table></figure><p><strong>播放YUV中的 Y平面</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffplay -pix_fmt nv21 -s 640x480 -vf extractplanes&#x3D;&#39;y&#39; 1.yuv</span><br></pre></td></tr></table></figure><h2 id="查看多媒体文件详细信息"><a href="#查看多媒体文件详细信息" class="headerlink" title="查看多媒体文件详细信息"></a>查看多媒体文件详细信息</h2><p><strong>输出每路流最详细的信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffprobe -print_format json -show_streams 多媒体文件</span><br></pre></td></tr></table></figure><p><strong>输出帧信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffprobe -show_frames  多媒体文件</span><br></pre></td></tr></table></figure><p><strong>输出包信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffprobe -show_packets 多媒体文件</span><br></pre></td></tr></table></figure><h2 id="我的ffmpeg视频课地址"><a href="#我的ffmpeg视频课地址" class="headerlink" title="我的ffmpeg视频课地址"></a>我的ffmpeg视频课地址</h2><p><a href="http://www.imooc.com/u/4873493/courses?sort=publish" target="_blank" rel="noopener">课程主页地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;http://upload-images.jianshu.io/upload_images/5956443-29b1eff4f8ce0e61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1600&quot; alt=&quot;ffmpegX.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;FFMPEG是特别强大的专门用于处理音视频的开源库。你既可以使用它的API对音视频进行处理，也可以使用它提供的工具，如 ffmpeg, ffplay, ffprobe，来编辑你的音视频文件。&lt;/p&gt;
&lt;p&gt;本文将简要介绍一下 FFMPEG 库的基本目录结构及其功能，然后详细介绍一下我们在日常工作中，如何使用 ffmpeg 提供的工具来处理音视频文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="音视频" scheme="https://blog.avdancedu.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="ffmpeg" scheme="https://blog.avdancedu.com/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>深入剖析WebRTC之事件机制Slot</title>
    <link href="https://blog.avdancedu.com/a35f406b/"/>
    <id>https://blog.avdancedu.com/a35f406b/</id>
    <published>2020-07-07T13:05:13.000Z</published>
    <updated>2020-07-07T13:09:13.053Z</updated>
    
    <content type="html"><![CDATA[<p>我最早了解到 sigslot 大概是在 2007年 左右，当时在QT中大量使用了 sigslot 的概念。 现在 WebRTC 中也大量使用了 sigslot 这种机制来处理底层的事件。它对我们阅读WebRTC代码至关重要。本篇文章就详细介绍一下 sigslot。</p><a id="more"></a><h2 id="Sigslot作用"><a href="#Sigslot作用" class="headerlink" title="Sigslot作用"></a>Sigslot作用</h2><p>Sigslot 的作用一句话表式就是为了<strong>解耦</strong>。例如，有两个类 A 和 B，如果 B 使用 A, 就必须在 B 类中写入与 A 类有关的代码。看下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B(A&amp; a)&#123;</span><br><span class="line">m_a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcB</span><span class="params">()</span></span>&#123;</span><br><span class="line">m_a.funcA(); <span class="comment">//这里调用了A类的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">A m_a; <span class="comment">//引用 A 类型成员变量。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">A a;</span><br><span class="line"><span class="function">B <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">b.funcB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<strong>弊端</strong>是 B 中必须要声名使用 A。如果我们的项目特别复杂，这样的使用方式在后期维护时很容易让我们掉入“陷阱”。有没有一种通用的办法可以做到在 B 中不用使用 A 也可以调用 A 中的方法呢？答案就是使用 <strong>sigslot</strong>。我们看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> sigslot::has_slot&lt;&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">funcA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    sigslot::signal0&lt;&gt; sender;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在运行时才将 a 和 b 绑定到一起</span></span><br><span class="line">b.sender.<span class="built_in">connect</span>(&amp;a, &amp;A::funcA);</span><br><span class="line">b.sender();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以看到 B 中没有一行与 A 相关的代码。只在 main 函数中（也就是在运行时）才知道 A 与 B 有关联关系。是不是觉得很神奇呢？下面我们就看一下它的实现原理。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>sigslot的原理其实非常简单，它就是一个变化的观察者模式。观察者模式如下所示：</p><p><img data-src="http://upload-images.jianshu.io/upload_images/5956443-cd6a57418c8ff9fc.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""></p><p>观察者模式，首先让 Observer(“观察者”)对象 注册到 Subject(“被观察者”) 对象中。当 Subject 状态发生变化时，遍历所有注册到自己的 Observer 对象，并调用它们的 notify方法。</p><p>sigslot与观察者模式类似，它使用signal(“信号”)和slot(“槽”)，区别在于 signal 主动连接自己感兴趣的类及其方法，将它们保存到自己的列表中。当发射信号时，它遍历所有的连接，调用 slot（“槽”） 方法。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>下面我们看一下 WebRTC 中是如何使用 sigslot 的。</p><ul><li>首先，定义 slot(“槽”)，也就是事件处理函数。在WebRTC中定义槽必须继承 has_slots&lt;&gt;。如下图所示：</li></ul><p><img data-src="http://upload-images.jianshu.io/upload_images/5956443-9db34af78eb1e4ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""></p><ul><li><p>其次，定义 signal (“信号”) ，也就是发送的信号。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sigslot::signal1&lt;AsyncSocket*,</span><br><span class="line">           sigslot::multi_threaded_local&gt; SignalWriteEvent;</span><br></pre></td></tr></table></figure></li><li><p>然后，将 signal 与 slot 连接到一起。在这里就是将 AsyncUDPSocket和 OnWriteEvent方法与signal绑定到一起。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">socket_-&gt;SignalWriteEvent.<span class="built_in">connect</span>(<span class="keyword">this</span>,</span><br><span class="line">&amp;AsyncUDPSocket::OnWriteEvent);</span><br></pre></td></tr></table></figure></li><li><p>最后，发送信号。在 WebRTC中根据参数的不同定义了许多 signal，如 signal1 说明带一个参数，signal2说明带两个参数。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SignalWriteEvent(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><p>下面是对 sigslog 的类关系图及关键代码与其详细注释。</p><p><img data-src="http://upload-images.jianshu.io/upload_images/5956443-e2f8002c19fa7338.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// On our copy of sigslot.h, we set single threading as default.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSLOT_DEFAULT_MT_POLICY single_threaded</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(SIGSLOT_PURE_ISO) ||                   \</span></span><br><span class="line">    (!defined(WEBRTC_WIN) &amp;&amp; !defined(__GNUG__) &amp;&amp; \</span><br><span class="line">     !defined(SIGSLOT_USE_POSIX_THREADS))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SIGSLOT_SINGLE_THREADED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(WEBRTC_WIN)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SIGSLOT_HAS_WIN32_THREADS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(WIN32_LEAN_AND_MEAN)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"webrtc/rtc_base/win32.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__GNUG__) || defined(SIGSLOT_USE_POSIX_THREADS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SIGSLOT_HAS_POSIX_THREADS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SIGSLOT_SINGLE_THREADED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SIGSLOT_DEFAULT_MT_POLICY</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SIGSLOT_SINGLE_THREADED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSLOT_DEFAULT_MT_POLICY single_threaded</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSLOT_DEFAULT_MT_POLICY multi_threaded_local</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> change this namespace to rtc?</span></span><br><span class="line"><span class="keyword">namespace</span> sigslot &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//这面这大段代码是为了实现智能锁使用的。</span></span><br><span class="line"><span class="comment">//它会根据不同的平台初始化不同的互斥量，并调用不同的锁函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是 Window 平台</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SIGSLOT_HAS_WIN32_THREADS</span></span><br><span class="line"><span class="comment">// The multi threading policies only get compiled in if they are enabled.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是全局线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">multi_threaded_global</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  multi_threaded_global() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> isinitialised = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isinitialised) &#123;</span><br><span class="line">      InitializeCriticalSection(get_critsec());</span><br><span class="line">      isinitialised = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; EnterCriticalSection(get_critsec()); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; LeaveCriticalSection(get_critsec()); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function">CRITICAL_SECTION* <span class="title">get_critsec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> CRITICAL_SECTION g_critsec;</span><br><span class="line">    <span class="keyword">return</span> &amp;g_critsec;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是本地线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">multi_threaded_local</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  multi_threaded_local() &#123; InitializeCriticalSection(&amp;m_critsec); &#125;</span><br><span class="line"></span><br><span class="line">  multi_threaded_local(<span class="keyword">const</span> multi_threaded_local&amp;) &#123;</span><br><span class="line">    InitializeCriticalSection(&amp;m_critsec);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~multi_threaded_local() &#123; DeleteCriticalSection(&amp;m_critsec); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; EnterCriticalSection(&amp;m_critsec); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; LeaveCriticalSection(&amp;m_critsec); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  CRITICAL_SECTION m_critsec;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// _SIGSLOT_HAS_WIN32_THREADS</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//非window平台</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SIGSLOT_HAS_POSIX_THREADS</span></span><br><span class="line"><span class="comment">// The multi threading policies only get compiled in if they are enabled.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是全局线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">multi_threaded_global</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; pthread_mutex_lock(get_mutex()); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; pthread_mutex_unlock(get_mutex()); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span>* <span class="title">get_mutex</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是本地线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">multi_threaded_local</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  multi_threaded_local() &#123; pthread_mutex_init(&amp;m_mutex, <span class="literal">nullptr</span>); &#125;</span><br><span class="line">  multi_threaded_local(<span class="keyword">const</span> multi_threaded_local&amp;) &#123;</span><br><span class="line">    pthread_mutex_init(&amp;m_mutex, <span class="literal">nullptr</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ~multi_threaded_local() &#123; pthread_mutex_destroy(&amp;m_mutex); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; pthread_mutex_lock(&amp;m_mutex); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; pthread_mutex_unlock(&amp;m_mutex); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">pthread_mutex_t</span> m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// _SIGSLOT_HAS_POSIX_THREADS</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据不同的策略调用不同的锁。</span></span><br><span class="line"><span class="comment">//这里的策略就是不同的平台</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">mt_policy</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">lock_block</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  mt_policy* m_mutex;</span><br><span class="line"></span><br><span class="line">  lock_block(mt_policy* mtx) : m_mutex(mtx) &#123; m_mutex-&gt;lock(); &#125;</span><br><span class="line"></span><br><span class="line">  ~lock_block() &#123; m_mutex-&gt;unlock(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">signal_base_interface</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">has_slots_interface</span> &#123;</span></span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">signal_connect</span><span class="params">(_signal_base_interface* sender)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">signal_disconnect</span><span class="params">(_signal_base_interface* sender)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">disconnect_all</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">signal_base_interface</span> &#123;</span></span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">slot_disconnect</span><span class="params">(has_slots_interface* pslot)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">slot_duplicate</span><span class="params">(<span class="keyword">const</span> has_slots_interface* poldslot,</span></span></span><br><span class="line"><span class="function"><span class="params">                      has_slots_interface* pnewslot)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该类是一个特别重要的类</span></span><br><span class="line"><span class="comment">// signal与slot绑定之前，必须先将槽对象与槽方法组成 connection</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">opaque_connection</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">emit_t</span>)</span><span class="params">(<span class="keyword">const</span> _opaque_connection*)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//联合结构体，用于函数转换</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> FromT, <span class="keyword">typename</span> ToT&gt;</span><br><span class="line">  <span class="keyword">union</span> union_caster &#123;</span><br><span class="line">    FromT from;</span><br><span class="line">    ToT to;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//信号发射函数指针</span></span><br><span class="line">  <span class="keyword">emit_t</span> pemit;</span><br><span class="line">  <span class="comment">//存放“槽”对象</span></span><br><span class="line">  has_slots_interface* pdest;</span><br><span class="line">  <span class="comment">// Pointers to member functions may be up to 16 bytes for virtual classes,</span></span><br><span class="line">  <span class="comment">// so make sure we have enough space to store it.</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> pmethod[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  <span class="comment">//在构造connect时，要传入槽对象和槽类方法指针</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> DestT, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  _opaque_connection(DestT* pd, <span class="keyword">void</span> (DestT::*pm)(Args...)) : pdest(pd) &#123;</span><br><span class="line">    <span class="comment">//定义成员函数指针，与C语言中的函数指针是类似的</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(DestT::*<span class="keyword">pm_t</span>)</span><span class="params">(Args...)</span></span>;</span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(<span class="keyword">pm_t</span>) &lt;= <span class="keyword">sizeof</span>(pmethod),</span><br><span class="line">                  <span class="string">"Size of slot function pointer too large."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">memcpy</span>(pmethod, &amp;pm, <span class="keyword">sizeof</span>(<span class="keyword">pm_t</span>));</span><br><span class="line"></span><br><span class="line"> <span class="comment">//定义了一个函数指针</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">em_t</span>)</span><span class="params">(<span class="keyword">const</span> _opaque_connection* self, Args...)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过下面的方法，将 pemit 函数变理指向了 emitter 函数。</span></span><br><span class="line">    union_caster&lt;<span class="keyword">em_t</span>, <span class="keyword">emit_t</span>&gt; caster2;</span><br><span class="line">    <span class="comment">//注意 emitter后面的是模版参数，不是函数参数，这里不要弄混了。</span></span><br><span class="line">    caster2.from = &amp;_opaque_connection::emitter&lt;DestT, Args...&gt;;</span><br><span class="line">    pemit = caster2.to;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回"槽"对象</span></span><br><span class="line">  <span class="function">has_slots_interface* <span class="title">getdest</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pdest; &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">//因为在构造函数里已经将 pemit 设置为 emitter 了，</span></span><br><span class="line">  <span class="comment">//所以下面的代码就是调用 emitter 函数。为里只不过做了一次函数指针类型转换。</span></span><br><span class="line">  <span class="comment">//也就是说调用 connect 的 emit 方法，实际调的是 emitter。</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">emit</span><span class="params">(Args... args)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">em_t</span>)</span><span class="params">(<span class="keyword">const</span> _opaque_connection*, Args...)</span></span>;</span><br><span class="line">    union_caster&lt;<span class="keyword">emit_t</span>, <span class="keyword">em_t</span>&gt; caster;</span><br><span class="line">    caster.from = pemit;</span><br><span class="line">    (caster.to)(<span class="keyword">this</span>, args...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> DestT, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">emitter</span><span class="params">(<span class="keyword">const</span> _opaque_connection* self, Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//pm_t是一个成员函数指针，它指向的是传进来的成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(DestT::*<span class="keyword">pm_t</span>)</span><span class="params">(Args...)</span></span>;</span><br><span class="line">    <span class="keyword">pm_t</span> pm;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">memcpy</span>(&amp;pm, self-&gt;pmethod, <span class="keyword">sizeof</span>(<span class="keyword">pm_t</span>));</span><br><span class="line">    <span class="comment">//调用成员方法</span></span><br><span class="line">    (<span class="keyword">static_cast</span>&lt;DestT*&gt;(self-&gt;pdest)-&gt;*(pm))(args...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//signal_with_thread_policy类的父类。</span></span><br><span class="line"><span class="comment">//该类最主要的作用是存有一个conn list。</span></span><br><span class="line"><span class="comment">//在 signal_with_thread_policy中的connect方法就是对该成员变量的操作。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">mt_policy</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> _<span class="title">signal_base</span> :</span> <span class="keyword">public</span> _signal_base_interface, <span class="keyword">public</span> mt_policy &#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;_opaque_connection&gt; connections_list;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">//在 _signal_base 中定义了一个connection list，用于绑定的 slots.</span></span><br><span class="line">  connections_list m_connected_slots;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该类是"槽"的实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">mt_policy</span> = <span class="title">SIGSLOT_DEFAULT_MT_POLICY</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">has_slots</span> :</span> <span class="keyword">public</span> has_slots_interface, <span class="keyword">public</span> mt_policy &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;_signal_base_interface*&gt; sender_set;</span><br><span class="line">  <span class="keyword">typedef</span> sender_set::const_iterator const_iterator;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  has_slots()</span><br><span class="line">      : has_slots_interface(&amp;has_slots::do_signal_connect,</span><br><span class="line">                            &amp;has_slots::do_signal_disconnect,</span><br><span class="line">                            &amp;has_slots::do_disconnect_all) &#123;&#125;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  has_slots&amp; <span class="keyword">operator</span>=(has_slots <span class="keyword">const</span>&amp;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//静态函数，用于与signal绑定，由父类调用</span></span><br><span class="line">  <span class="comment">//它是在构造函数时传给父类的</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_signal_connect</span><span class="params">(has_slots_interface* p,</span></span></span><br><span class="line"><span class="function"><span class="params">                                _signal_base_interface* sender)</span> </span>&#123;</span><br><span class="line">    has_slots* <span class="keyword">const</span> self = <span class="keyword">static_cast</span>&lt;has_slots*&gt;(p);</span><br><span class="line">    <span class="function">lock_block&lt;mt_policy&gt; <span class="title">lock</span><span class="params">(self)</span></span>;</span><br><span class="line">    self-&gt;m_senders.insert(sender);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//静态函数，用于解绑signal，由父类调用</span></span><br><span class="line">  <span class="comment">//它是在构造函数时传给父类的</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_signal_disconnect</span><span class="params">(has_slots_interface* p,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   _signal_base_interface* sender)</span> </span>&#123;</span><br><span class="line">    has_slots* <span class="keyword">const</span> self = <span class="keyword">static_cast</span>&lt;has_slots*&gt;(p);</span><br><span class="line">    <span class="function">lock_block&lt;mt_policy&gt; <span class="title">lock</span><span class="params">(self)</span></span>;</span><br><span class="line">    self-&gt;m_senders.erase(sender);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//该集合中存放的是与slog绑定的 signal</span></span><br><span class="line">  sender_set m_senders;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该类是信号的具体实现</span></span><br><span class="line"><span class="comment">//为了保证信号可以在不同的平台是线程安全的，所以这里使用了策略模式</span></span><br><span class="line"><span class="comment">//mt_policy参数表式的是，不同的平台使用不同的策略</span></span><br><span class="line"><span class="comment">//该类中有两个重要的函数，一个是connect用于与槽进行绑定；另一个是 emit用于发射信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">mt_policy</span>, <span class="title">typename</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">signal_with_thread_policy</span> :</span> <span class="keyword">public</span> _signal_base&lt;mt_policy&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">desttype</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">connect</span>(<span class="title">desttype</span>* <span class="title">pclass</span>, <span class="title">void</span> (<span class="title">desttype</span>:</span>:*pmemfun)(Args...)) &#123;</span><br><span class="line">    <span class="comment">//这是一个智能锁，当函数结束时，自动释放锁。</span></span><br><span class="line">    <span class="function">lock_block&lt;mt_policy&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="comment">//先将对象与"槽"组成一个conn,然后存放到 signal的 conn list里</span></span><br><span class="line">    <span class="comment">//当发射信号时，调用 conn list中的每个conn的 emit方法。</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_connected_slots.push_back(_opaque_connection(pclass, pmemfun));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在槽对象中也要保存 signal 对象。</span></span><br><span class="line">    pclass-&gt;signal_connect(<span class="keyword">static_cast</span>&lt;_signal_base_interface*&gt;(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//遍历所有的连接，并调用 conn 的emit方法。最终调用的是绑定"槽"的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">emit</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="function">lock_block&lt;mt_policy&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_current_iterator = <span class="keyword">this</span>-&gt;m_connected_slots.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;m_current_iterator != <span class="keyword">this</span>-&gt;m_connected_slots.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      _opaque_connection <span class="keyword">const</span>&amp; conn = *<span class="keyword">this</span>-&gt;m_current_iterator;</span><br><span class="line">      ++(<span class="keyword">this</span>-&gt;m_current_iterator);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//调 conn 的 emit 方法，最终会调用绑定的 "槽" 方法。</span></span><br><span class="line">      conn.emit&lt;Args...&gt;(args...);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//重载（）操作符，这样就从直接调用emit方法变成隐含调用emit方法。</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args... args)</span> </span>&#123; emit(args...); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的对不同参数信号的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">using</span> signal = signal_with_thread_policy&lt;SIGSLOT_DEFAULT_MT_POLICY, Args...&gt;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> mt_policy = SIGSLOT_DEFAULT_MT_POLICY&gt;</span><br><span class="line"><span class="keyword">using</span> signal0 = signal_with_thread_policy&lt;mt_policy&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A1, <span class="keyword">typename</span> mt_policy = SIGSLOT_DEFAULT_MT_POLICY&gt;</span><br><span class="line"><span class="keyword">using</span> signal1 = signal_with_thread_policy&lt;mt_policy, A1&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A1,</span><br><span class="line">          <span class="keyword">typename</span> A2,</span><br><span class="line">          <span class="keyword">typename</span> mt_policy = SIGSLOT_DEFAULT_MT_POLICY&gt;</span><br><span class="line"><span class="keyword">using</span> signal2 = signal_with_thread_policy&lt;mt_policy, A1, A2&gt;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace sigslot</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文通过 sigslot作用、实现原理、如何使用以及详细的代码注释四个部分剖析了 WebRTC 中的 sigslot。sigslot是 WebRTC中非常底性的基础代码，它对 WebRTC 事件机制起着关键性的作用。熟悉sigslot，对我们阅读 WebRTC 代码会有非常大的帮助。</p><p>希望本文能对你有所帮助。谢谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我最早了解到 sigslot 大概是在 2007年 左右，当时在QT中大量使用了 sigslot 的概念。 现在 WebRTC 中也大量使用了 sigslot 这种机制来处理底层的事件。它对我们阅读WebRTC代码至关重要。本篇文章就详细介绍一下 sigslot。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="slot" scheme="https://blog.avdancedu.com/tags/slot/"/>
    
  </entry>
  
  <entry>
    <title>聊聊C++中的类型转换</title>
    <link href="https://blog.avdancedu.com/670ef31f/"/>
    <id>https://blog.avdancedu.com/670ef31f/</id>
    <published>2020-07-07T01:33:24.000Z</published>
    <updated>2020-07-07T13:48:35.933Z</updated>
    
    <content type="html"><![CDATA[<p>在C语言中我们经常要做类型转换，例如malloc函数分配内存时需要从<code>void *</code>转换成你指定的类型指针。如下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* block = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure><p>上面的代码是将<code>void*</code>转换成<code>int*</code>，这种转换方式在C语言中称为<code>强制转换</code>。它的好处是简洁，灵活；缺点是需要人来决定转换后类型是否正确，因此对开发人员的要求是很高的。</p><a id="more"></a><h2 id="C-的四种类型转换"><a href="#C-的四种类型转换" class="headerlink" title="C++的四种类型转换"></a>C++的四种类型转换</h2><p>C++觉得C的强制转换方式不是很友好，尤其是没法通过编译器或运行时检测工具来提供帮助，光靠人的能力来判断是很不靠谱的事儿。</p><p>而且相对于C来说，分析C++程序的运行轨迹要比分析C复杂得多。因此C++提出了四种新的类型转换方法，这四种类型转换方法分别是：<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>以及<code>reinterpret_cast</code>。</p><p>下面我们就来对这四种类型转换方法做下详细讨论。</p><h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>static_cast主要用于不同类型变量之间的转换及左值转右值等。比如说double转int就需要用static_cast转换。我们来举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不同类型之间的转换</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">10.1</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">//左值转右值</span></span><br><span class="line"><span class="keyword">int</span> lv = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp; rv = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&amp;&amp;&gt;(lv);</span><br></pre></td></tr></table></figure><blockquote><p>这里需要注意的是：int 转 double是隐式转换，右值转左值也是隐性转换，所以对这两种情况是不需要用static_cast进行显示转换的。</p></blockquote><p>上面我们说的是普通类型的转换。而对于类对象来说，static_cast不能直接将一种类对象转成另一种类对象。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    b = <span class="keyword">static_cast</span>&lt;B&gt;(a); <span class="comment">//不允许static_cast将一个对象转成另一个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像上面这种用static_cast将A类型的对象转成B类型对象是不允许的。但你可以利用static_cast将基类指针/引用转成子类指针/引用。如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">A ca;</span><br><span class="line">B &amp; crb = <span class="keyword">static_cast</span>&lt;B&amp;&gt;(ca);</span><br><span class="line">...</span><br><span class="line">A * pa = <span class="keyword">new</span> A();</span><br><span class="line">B * cpb = <span class="keyword">static_cast</span>&lt;B*&gt;(pa);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但这里有个前提条件，即只有有父子关系的类之间才可以做如上转换，否则编译失败。还有，虽然以上两种使用static_cast的方式都可以编译通过，但用户自己要防止越界访问的问题。</p><p>static_cast除了上面讨论的几种情况外，还有一点需要牢记，即<strong>static_cast不允许不同类型之间指针/引用的转换(有父子关系的类对象除外)</strong>。看个具体的例子：：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">double</span> *pd  = <span class="keyword">new</span> <span class="keyword">double</span>();</span><br><span class="line"><span class="keyword">int</span> * pi = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(pd); <span class="comment">//报错</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面的代码在编译时会报错，因为它不允许不同类型之间的指针或引用转换。对于有父子关系的类对象之间之所以可以转换是因为static_cast把它们当做同一类型看待了。</p><p>所以总结来说，static_cast主要用于不同类型变量之间的转换，指针和引用的转换不能用static_cast，而应该用reinterpret_cast。</p><h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><p>reinterpret_cast类似于C语言中不同类型指针间的类型转换，最接近于C的强制转换。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">double</span> *pd  = <span class="keyword">new</span> <span class="keyword">double</span>();</span><br><span class="line"><span class="keyword">int</span> * pi = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(pd);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面的代码是将<code>double*</code> 转成 <code>int*</code>。如果你使用static_cast做这种转换转换是不允许的，但改用reinterpret_cast就一切正常。 当然，如果你用reinterpret_cast做static_cast善长的变量类型转换也会报错。从上面的描述我们应该知道reinterpret_cast与static_cast之间的区别了。</p><p>如果我们像下面这样用reinterpret_cast去做类型变量的转换，编译器会报错：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">10.1</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>&gt;(d);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这样的转换是绝对不允许的。</p><p>reinterpret_cast还有一个特点，它可以将指针转成长整型，也可以将长整型转成指针。如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> ll = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">long</span>&gt;(&amp;a);</span><br><span class="line"><span class="keyword">double</span> *dd = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">double</span>*&gt;(ll);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面是将一个<code>int*</code>转成long型，又将long型转成<code>double*</code>，这些都是reinterpret_cast善长做的转换。</p><p>reinterpret_cast对于对象指针/引用的转换与普通类型的指针/引用转换是一样的。因此不同类型的对象指针/引用可以随意转换，但转换后是否会引起问题它不关心，这要由开发人员自己保证。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A * pa = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">B b;</span><br><span class="line">B &amp; rb = B();</span><br><span class="line"></span><br><span class="line">C * cc = <span class="keyword">reinterpret_cast</span>&lt;C*&gt;(pa);</span><br><span class="line">C &amp; rcc = <span class="keyword">reinterpret_cast</span>&lt;C&amp;&gt;(rb);</span><br></pre></td></tr></table></figure><p>总结一下，reinterpret_cast是对指针/引用的转换，其中必须至少有一个是指针或引用，否则它会报错。</p><h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p>这个比较简单，它的作用是去掉<strong>指针/引用</strong>中的const限制。这里要注意的是被转换的一定是指针/引用的const，而常数的const是不能去掉的。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b  = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&gt;(a);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面的代码是想通过const_cast将常数的const去掉？这是决对不可以的！！！编译器一定会报错。</p><p>而如果是加了const的指针/引用就没问题了，我们再来一个列子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pca = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> * pa = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(pca);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>将一个const 指针转换成非const指针正是const_cast做的事儿。</p><p>我们再来想一种case，是否可以将一种类型的const指针转换成另一种类型的非const指针呢？如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pca = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">double</span> * pa = <span class="keyword">const_cast</span>&lt;<span class="keyword">double</span>*&gt;(pca);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这样也是不允许的。对于const_cast来说，它只能将同一类型的const 指针/引用 转成非const指针/引用。</p><p>所以我们这里总结一下，const_cast是一个专门去掉同一类型的const限制的类型转换方法。它不如static_cast和reinterpret_cast应用的广泛。</p><h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p>这个转换方法限制比较多，一、它只能处理类对象；二、它只能处理指针；三、它只能用于将子对象转换成父对象这样的操作。我们来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">A * a;</span><br><span class="line">B * b =<span class="keyword">new</span> B();</span><br><span class="line">a = <span class="keyword">dynamic_cast</span>&lt;A*&gt;(b);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>只有上面这一种情况可以编译成功，其它情况都会失败！</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>下面我们总结一下这四种类型转换方法。四种转换方法中，用的比较多的是static_cast和reinterpret_cast这两种转换方法。</p><p>static_cast主要用于普通类型变量的转换，如double到int的转换，或左值转右值。当然它也可以在父对象与子对象之间进行指针转换。</p><p>reinterpret_cast主要用于不同类型指针/引用间的转换。也可以将指针/引用转成长整型或将长整型转成指针类型。但不可以像static_cast一样在两个不同的类型变量间转换。也就是说reinterpret_cast在转换时必须有一个是指针/引用。</p><p>const_cast就比较简单了，它只能将同一类型的const指针转成同一类型的非const指针。</p><p>dynamic_cast只能用于有父子关系的类对象之间的转换，而且只能用于将子对象转换成父对象。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">C++高阶知识：深入分析移动构造函数及其原理</a><br><a href="https://avdancedu.com/9683d88/" target="_blank" rel="noopener">细说智能指针</a><br><a href="https://avdancedu.com/5e7916e3/" target="_blank" rel="noopener">重学C/C++中的const</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在C语言中我们经常要做类型转换，例如malloc函数分配内存时需要从&lt;code&gt;void *&lt;/code&gt;转换成你指定的类型指针。如下面这样：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;* block = (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;*)&lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的代码是将&lt;code&gt;void*&lt;/code&gt;转换成&lt;code&gt;int*&lt;/code&gt;，这种转换方式在C语言中称为&lt;code&gt;强制转换&lt;/code&gt;。它的好处是简洁，灵活；缺点是需要人来决定转换后类型是否正确，因此对开发人员的要求是很高的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://blog.avdancedu.com/categories/C-C/"/>
    
    
      <category term="类型转换" scheme="https://blog.avdancedu.com/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>C++高阶知识：深入分析移动构造函数及其原理</title>
    <link href="https://blog.avdancedu.com/a39d51f9/"/>
    <id>https://blog.avdancedu.com/a39d51f9/</id>
    <published>2020-07-04T04:48:44.000Z</published>
    <updated>2020-07-07T13:53:51.397Z</updated>
    
    <content type="html"><![CDATA[<p>移动构造函数是C++11中新增加的一种构造函数，其作用是提高程序性能。今天我们就细扒一下它的工作原理，看看它是怎么提高性能的。</p><a id="more"></a><h2 id="移动构造函数的由来"><a href="#移动构造函数的由来" class="headerlink" title="移动构造函数的由来"></a>移动构造函数的由来</h2><p>在讲解移动构造函数之间，我们先来了解一下在没有移动构造函数之前哪里有性能瓶颈吧。我们来举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        A()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A construct..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            ptr_ = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        A(<span class="keyword">const</span> A &amp; a)&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A copy construct ..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            ptr_ = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line">            <span class="built_in">memcpy</span>(ptr_, a.ptr_, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~A()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A deconstruct ..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(ptr_)&#123;</span><br><span class="line">                <span class="keyword">delete</span> ptr_;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A &amp; a) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" A operator= ...."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> * <span class="title">getVal</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ptr_;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> *ptr_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;A&gt; vec;</span><br><span class="line">    vec.push_back(A());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//clang++ -g -o testmove test_move.cpp</span></span><br></pre></td></tr></table></figure><p>上面这段代码很简单对吧，就是定义了一个普通的类A。在main函数中创建一个vector，然后用A类创建一个对象，并把它放入到vector中。这样的程序在C++中是很常见，但就是这样很常见的代码确有非常大的性能问题。为什么呢？因为在将A对象放入vector时，在vector内部又创建了一个A对象，并调用了其拷贝构造函数进行了深拷贝。</p><p>我们看一下上面代码运行的结果就一目了然了，其结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A construct...          &#x2F;&#x2F;main中创建的A对象</span><br><span class="line">A copy construct ...    &#x2F;&#x2F;vector内部创建的A对象</span><br><span class="line">A deconstruct ...       &#x2F;&#x2F;vector内部创建的A对象被析构</span><br><span class="line">A deconstruct ...       &#x2F;&#x2F;main中创建的A对象析构</span><br></pre></td></tr></table></figure><p>上面的运行结果印证了我们之前的讨论，在vector内部确实又创建了一个A对象。如果在A对象中分配的是一个比较大的空间，且vector中要存放大量的A对象时（如 100000个)，就会不断的做分配/释放堆空间的操作，这会造成多在的性能消耗呀！</p><p>有什么办法可以解决这个问题呢？这就要用到我们今天要讲的移动构造函数了。</p><h2 id="移动构造函数的使用"><a href="#移动构造函数的使用" class="headerlink" title="移动构造函数的使用"></a>移动构造函数的使用</h2><p>从C++11开始，类中不光可以有构造函数、拷贝构造函数，还增加了一种新的构造函数即移动构造函数。移动构造函数起什么作用呢？就像它的名子一样，它可以实现指针的移动，即可以将一个对象中的指针成员转移给另一个对象。指针成员转移后，原对象中的指针成员一般要被设置为NULL，防止其再被使用。</p><p>还是以我们上面的代码为例，如果我们有了移动构造函数，那么在将A对象push到vector时，vector内部虽然还是会再分A对象，但在进行数据的拷贝时就不是深拷贝了，而变成了浅拷贝，这样就大大提高了程序的执行效率。</p><p>如何为A增加移动构造函数呢？我们来看一下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        A(A &amp;&amp; a)&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A move construct ..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            ptr_ = a.ptr_;</span><br><span class="line">            a.ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 A 类中增加上面代码即可，上面的代码看起来与普通构造函数好像没什么两样，但你细心观察可以发现该构造函数的参数是 <code>A &amp;&amp; a</code>。咦！<code>&amp;&amp;</code>这在以前还真没见过对吧。它表示的是C++中的右值，也就是只有创建A对象时传入的是右值才会执行该构造函数。</p><p>对于右值后面我们还会做详细介绍，现在我们只要知道要想让这个函数起作用，就必须传给它一个右值就可以了。如么问题来了，我们这个例子中如何传递给它一个右值呢？这就要用到 std::move 函数了。</p><p>std::move可以将任何一值变成右值，所以我们不管3721，在创建A对象时直接调用std::move”造”个右值给它就好了。于是我们修改main代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;A&gt; vec;</span><br><span class="line">    vec.push_back(<span class="built_in">std</span>::<span class="built_in">move</span>(A()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经这样修后，我们运行一下程序看现在它的结果是什么样子吧。结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A construct...          &#x2F;&#x2F;main中创建A对象</span><br><span class="line">A move construct ...    &#x2F;&#x2F;vector内部通过移动构造函数创建A对象，减少了对堆空间的频繁操作</span><br><span class="line">A deconstruct ...       &#x2F;&#x2F;释放vector中的A对象</span><br><span class="line">A deconstruct ...       &#x2F;&#x2F;释放main中创建的A对象</span><br></pre></td></tr></table></figure><p>从上面的结果我们可以看出我们新增加的移动构造函数确实被调用了，这样就大大减了频繁对堆空间的分配/释放操作，从而提高了程序的执行效率。这里需要注意的是，在移动构造函数操作之后原A对象的指针地址已经指向NULL了，因此此时就不能再通过其访问之前的堆空间了。</p><h2 id="C-的左值与右值"><a href="#C-的左值与右值" class="headerlink" title="C++的左值与右值"></a>C++的左值与右值</h2><p>右值是C++从C继承来的概念，最初是指=号右边的值。但现在C++中的右值已经与它最初的概念完全不一样了。在C++中右值指的的临时值或常量，更准确的说法是保存在CPU寄存器中的值为右值，而保存在内存中的值为左值。</p><p>可能有很多同学对计算机系统的底层不太了解，我们这里做一个简单的介绍。计算机是由CPU、内存、主板、总线、各种硬件等组成的，这个大家应该都清楚。而CPU又是由逻辑处理器，算术单元、寄存器等组成的。我们的程序运行时并不是直接从内存中取令运行的，因为内存相对于CPU来说太慢了。一般情况下都是先将一部分指令读到CPU的指令寄存器，CPU再从指令寄存器中取指令然后一条一条的执行。对于数据也是一样，先将数据从内存中读到数据寄存器，然后CPU从数据寄存器读数据。以Intel的CPU为例，它就包括了 EAX、EBX、ECX、EDX…多个通用寄存器，这样就可以让CPU更高效的工作。</p><p>比如说一个常数5，我们在使用它时不会在内存中为其分配一个空间，而是直接把它放到寄存器中，所以它在C++中就是一个右值。再比如说我们定义了一个变量 a，它在内存中会分配空间，因此它在C++中就是左值。那么<code>a+5</code>是左值还是右值呢？当然是右值对吧，因为a+5的结果存放在寄存器中，它并没有在内存中分配新空间，所以它是右值。</p><p>通过上面的描述你就应该对 C++ 中的左值和右值比较清楚了。我们来看个例子吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> &amp;&amp; a = <span class="number">5</span>;  <span class="comment">// 正确，5会被直接存放在寄存器中，所以它是右值</span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;&amp; c = b;  <span class="comment">// 错误，b在内存中有空间，所以是右值；右值不能赋值给左值</span></span><br><span class="line">    <span class="keyword">int</span> &amp;&amp; d = b + <span class="number">5</span>; <span class="comment">// 正确，虽然 b 在内存中，但 b+5 的结果放在寄存器中，它没有在内存中分配空间，因此是右值 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C++中使用<code>&amp;&amp;</code>表示右值引用，在上面的例子中，我首先将常数5赋值给右值引用a，因为常数5是右值，所以这条语句可以编译成功；紧接着我定义了变量b，因为它是左值，所以当将b赋值给右直引用c时，编译器会报错；最后一行将<code>b+5</code>赋值给右值引用d，由于<code>b+5</code>不会在内存中占用空间所以这也是右值，因此最后一句编译也没有任何问题。</p><p>接下来我们看一个有意思的情况，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">int</span> &amp;&amp; e = a;</span><br><span class="line">..</span><br></pre></td></tr></table></figure><p>这种情况是否是合法的呢？实际上当你这么做的时候编译器会报错，因为a是左值而e必须接收右值。那有没有办法将一个左值转成右值呢？这个问题我们前面其实已经回答过了，通过std::move就可以解决这个问题。我们来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">int</span> &amp;&amp; e = <span class="built_in">std</span>::<span class="built_in">move</span>(a);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>之前我们直接将a赋值给e是肯定不行的，但上面的操作编译器就不会报错了，因为通过std::move可以将一个左值转成右值。但这里有一点需要特别注意：<strong>e虽然接收的必须是右值，但它本身是左值。换句话说e是一种特殊的变量，它是只能接收右值的变量。我们再从左值的本质来看，e也是占内存空间的，所以它肯定是左值。</strong></p><h2 id="std-move的实现"><a href="#std-move的实现" class="headerlink" title="std::move的实现"></a>std::move的实现</h2><p>上面我们已经看到了std::move的神奇之处，你可能很好奇std::move是如何做到的呢？实际上std::move就是一个类型转换器，将左值转换成右值而以。我们来看一下它的实现吧！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> static_case&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::move的实现还是挺简单的就这么几行代码，但要理解这几行代码可不容易。下面我们就来对它做下详细分析。</p><h3 id="通用引用"><a href="#通用引用" class="headerlink" title="通用引用"></a>通用引用</h3><p>首先我们来看一下move的输入参数，move的输入参数类型称为通用引用类型。什么是通用引用呢？就是它既可以接收左值也可以接收右值。我们来看一下例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"the value is "</span>&lt;&lt; param &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> &amp;&amp; b = <span class="number">5</span>;   <span class="comment">//通用引用，可以接收右值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> &amp;&amp; c = a;    <span class="comment">//错误，右值引用，不能接收左值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> &amp;&amp; d = a;   <span class="comment">//通用引用，可以接收左值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;&amp; e = a; <span class="comment">//错误，加了const就不再是通用引用了</span></span><br><span class="line"></span><br><span class="line">    func(a);         <span class="comment">//通用引用，可以接收左值</span></span><br><span class="line">    func(<span class="number">10</span>);        <span class="comment">//通用引用，可以接收右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中有两种类型的通用引用: 一种是auto，另一种是通过模板定义的T&amp;&amp;。实际上auto就是模板中的T，它们是等价的。下面我们就对这段代码做下详细解读。</p><p>代码中的 a 是个左值，因为它在内存中会分配空间，这应该没什么异义；b 是通过引用。为什么呢？因为通用引用有两个条件：一，必须是T&amp;&amp;的形式，由于auto等价于T，所以auto &amp;&amp; 符合这个要求；二，T类型要可以推导，也就是说它必须是个模板，而auto是模板的一种变型，因此b是通用引用。通用引用即可以接收左值，也可以接收右值，所以b=5是正确的；c不是通用引用，因为它不符合T&amp;&amp;的形式。所经第三行代码是错误的，右值引用只能接收右值；d是通用引用，所以给它赋值a是正确的；e不是通用引用，它多了一个const已不符合T&amp;&amp; 的形式，所以给它左值肯定会出错；最后两个函数调用的形参符合 T&amp;&amp;，又因是模板可以进行类型推导，所以是通用引用，因此给它传左值和右值它都能正确接收。</p><h3 id="模板的类型推导"><a href="#模板的类型推导" class="headerlink" title="模板的类型推导"></a>模板的类型推导</h3><p>通用引用好强大呀！它既可以接收左值又可以接收右值，它是如何做到的呢？这就要讲讲模板的类型推导了。</p><p>模板的类型推导规则还是蛮复杂的，这里我们只简要说明一下，有兴趣的同学可以查一下C++11的规范。我们还是举个具体的例子吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br><span class="line"></span><br><span class="line">f(expr);</span><br></pre></td></tr></table></figure><p>上面这个例子是函数模板的通用例子，其中T是根据f函数的参数推到出来的，而ParamType则是根据 T 推导出来的。T与ParamType有可能相等，也可能不等，因为ParamType是可以加修饰的。我们看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;         <span class="comment">// x是int</span></span><br><span class="line">    <span class="keyword">int</span> &amp; rr = x;       <span class="comment">// rr是 int &amp;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> cx = x;   <span class="comment">// cx是const int</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;  <span class="comment">// rx是const int &amp;</span></span><br><span class="line">    <span class="keyword">int</span> *pp = &amp;x;       <span class="comment">// pp是int *</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面是传值的模板，由于传入参数的值不影响原值，所以参数类型退化为原始类型</span></span><br><span class="line">    f(x);               <span class="comment">// T是int</span></span><br><span class="line">    f(cx);              <span class="comment">// T是int</span></span><br><span class="line">    f(rx);              <span class="comment">// T是int</span></span><br><span class="line">    f(rr);              <span class="comment">// T是int</span></span><br><span class="line">    f(pp);              <span class="comment">// T是int*，指针比较特殊，直接使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面是传引用模板, 如果输入参数类型有引用，则去掉引用;如果没有引用，则输入参数类型就是T的类型</span></span><br><span class="line">    func(x);            <span class="comment">// T为int</span></span><br><span class="line">    func(cx);           <span class="comment">// T为const int</span></span><br><span class="line">    func(rx);           <span class="comment">// T为const int</span></span><br><span class="line">    func(rr);           <span class="comment">// T为int</span></span><br><span class="line">    func(pp);           <span class="comment">// T是int*，指针比较特殊，直接使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面是通用引用模板，与引用模板规则一致</span></span><br><span class="line">    function(x);        <span class="comment">// T为int&amp;</span></span><br><span class="line">    function(<span class="number">5</span>);        <span class="comment">// T为int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中可以将类型推导分成两大类：其中类型不是引用也不是指针的模板为一类; 引用和指针模板为另一类。</p><p>对于第一类其推导时根据的原则是，函数参数传值不影响原值，所以无论你实际传入的参数是普通变量、常量还是引用，它最终都退化为不带任何修修饰的原始类型。如上面的例子中，<code>const int &amp;</code>类型传进去后，退化为int型了。</p><p>第二类为模板类型为引用（包括左值引用和右值引用）或指针模板。这一类在类型推导时根据的原则是去除对等数量的引用符号，其它关键字照般。还是我们上面的例子，<code>func(x)</code>中x的类型为 <code>int&amp;</code>，它与<code>T&amp;</code>放在一起可以知道T为int。另一个例子<code>function(x)</code>，其中x为<code>int&amp;</code>它与T&amp;&amp; 放在一起可知T为<code>int&amp;</code>。</p><p>根据推导原则，我们可以知道通用引用最终的结果是什么了，左值与通用引用放在一推导出来的T仍为左值，而右值与通用引用放在一起推导出来的T仍然为右值。</p><h3 id="move-的返回类型"><a href="#move-的返回类型" class="headerlink" title="move 的返回类型"></a>move 的返回类型</h3><p>实际上上面通过模板推导出的T与move的返回类型息息相关的，要讲明白这一点我们先要把move的返回类型弄明白。下面我们就来讨论一下move的返回类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;</span><br></pre></td></tr></table></figure><p>move的返回类型非常奇特，我们在开发时很少会这样写，它表示的是什么意思呢？</p><p>这就要提到C++的另外一个知识点，即类型成员。你应该知道C++的类成员有成员函数、成员变量、静态成员三种类型，但从C++11之后又增加了一种成员称为类型成员。类型成员与静态成员一样，它们都属于类而不属于对象，访问它时也与访问静态成员一样用<code>::</code>访问。</p><p>了解了这点，我们再看move的返类型是不是也不难理解了呢？它表达的意思是返回remove_reference类的type类型成员。而该类是一个模板类，所以在它前面要加typename关键字。</p><p>remove_reference看着很陌生，接下来我们再分析一下remove_reference类，看它又起什么作用吧。其实，通过它的名子你应该也能猜个大概了，就是通过模板去除引用。我们来看一下它的实现吧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;  <span class="comment">//定义T的类型别名为type</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&gt; //左值引用</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&amp;&gt; //右值引用</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是remove_reference类的代码，在C++中struct与class基本是相同的，不同点是class默认成员是private，而struct默认是public，所以使用struct代码会写的更简洁一些。</p><p>通过上面的代码我们可以知道，经过remove_reference处理后，T的引用被剔除了。假设前面我们通过move的类型自动推导得到T为int&amp;&amp;，那么再次经过模板推导remove_reference的type成员，这样就可以得出type的类型为int了。</p><p>remove_reference利用模板的自动推导获取到了实参去引用后的类型。现在我们再回过来看move函数的时候是不是就一目了解了呢？之前无法理解的5行代码现然变成了这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int &amp;&amp; move(int&amp;&amp; &amp;&amp; t)&#123;</span><br><span class="line">    return static_case&lt;int&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line">int &amp;&amp; move(int&amp; &amp;&amp; t)&#123;</span><br><span class="line">    return static_case&lt;int&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经上面转换后，我们看这个代码就清晰多了，从中我们可以看到move实际上就是做了一个类型的强制转换。如果你是左值引用就强制转换成右值引用。</p><h3 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h3><p>上面的代码我们看起来是简单了很多，但其参数<code>int&amp; &amp;&amp;</code>和<code>int &amp;&amp; &amp;&amp;</code>还是让人觉得很别扭。因为C++编译器根本就不支持这两种类型。咦！这是怎么回事儿呢？</p><p>到这里我们就要讲到最后一个知识点引用折叠了。在C++中根本就不存 <code>int&amp; &amp;&amp;</code>、<code>int &amp;&amp; &amp;&amp;</code>这样的语法，但在编译器内部是能将它们识别出来的。换句话说，编译器内部能识别这种格式，但它没有给我们提供相应的接口(语法）。</p><p>实际上，当编译器遇到这类形式的时候它会使用引用折叠技术，将它们变成我们熟悉的格式。其规则如下：</p><ul><li><code>int &amp; &amp;</code> 折叠为 <code>int&amp;</code></li><li><code>int &amp; &amp;&amp;</code> 折叠为 <code>int&amp;</code></li><li><code>int &amp;&amp; &amp;</code> 折叠为 <code>int&amp;</code></li><li><code>int &amp;&amp; &amp;&amp;</code> 折叠为 <code>int &amp;&amp;</code></li></ul><p>总结一句话就是左值引用总是折叠为左值引用，右值引用总是折叠为右值引用。</p><p>经过这一系列的操作之后，对于一个具体的参数类型<code>int &amp; a</code>，std::move就变成了下面的样子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> &amp;&amp; <span class="title">move</span><span class="params">(<span class="keyword">int</span>&amp; t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> static_case&lt;<span class="keyword">int</span>&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一下我们就清楚它在做什么事儿了哈！</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上就是C++高阶知识移动构造函数及其原理的分析。在本文中我首先向你介绍了拷贝构造函数在某些场景下会引起程序性能严重下降，然后讲解了如何使用移动构造函数和std::move函数改善性能。在文章的最后，我带你深入剖析了std::move是如何实现的，最终我们发现它原来就是实现了一个自适应类型的强制类型转换的功能。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/9683d88/" target="_blank" rel="noopener">细说智能指针</a><br><a href="https://avdancedu.com/5e7916e3/" target="_blank" rel="noopener">重学C/C++中的const</a><br><a href="https://avdancedu.com/670ef31f/" target="_blank" rel="noopener">聊聊C++中的类型转换</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;移动构造函数是C++11中新增加的一种构造函数，其作用是提高程序性能。今天我们就细扒一下它的工作原理，看看它是怎么提高性能的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://blog.avdancedu.com/categories/C-C/"/>
    
    
      <category term="移动构造函数" scheme="https://blog.avdancedu.com/tags/%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>细说智能指针</title>
    <link href="https://blog.avdancedu.com/9683d88/"/>
    <id>https://blog.avdancedu.com/9683d88/</id>
    <published>2020-07-01T03:49:25.000Z</published>
    <updated>2020-07-07T13:57:16.865Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来聊聊C++的智能指针。C++从1983年诞生到现在已经有30多年历史了，为什么到现在还能如此流行呢(排名第四，2020年6月<a href="https://hellogithub.com/report/tiobe/" target="_blank" rel="noopener">HelloGitHub榜单</a>)？因为它具有很多其它语言所不具备的优势，比如说执行速度快，控制力更强等。同样的，有更多的同学会选择用Java(排名第二)等语言，这是因为它相对C++来说，它更简单，易上手，不用担心内存泄漏！</p><p>确实，<strong>内存泄漏</strong>在很长的一段时间里是影响人们学习C++的一个最重要的原因。不过C++也在不断进步中，智能指针的出现就大大降低了内存泄漏发生的风险。</p><p>下面我们就来细聊一下C++智能指针的方方面面，通过本文让你真正掌握C++智能指针。</p><a id="more"></a><h2 id="内存泄漏的产生"><a href="#内存泄漏的产生" class="headerlink" title="内存泄漏的产生"></a>内存泄漏的产生</h2><p>在C++中内存的分配与释放都是手工操作的(分配内存用<code>new</code>，释放内存用<code>delete</code>)，这种方式本身就很容易产生内存泄漏。因为人们在开发过程中需要内存时很自然的就用new分配一块，但这块内存什么时候释放就说不好了，有可能用完马上就释放，也有可能要等待一个周期才能释放等等。而且随着时间的推移，代码越来越大，需要被释放的内存被遗忘的可能性也就更大。</p><p>我来看一下具体的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *pVal = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line">    *pVal = <span class="number">10</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(*pVal == <span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;      <span class="comment">//这里会产生内存泄漏</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">delete</span> pVal;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，使用new在堆空间分配了一个整型大小的空间，在函数结束时通过delete将分配的内存释放。但当<code>pVal==10</code>时，函数没有释放内存就直接退出了，此时就产生了内存泄漏。</p><p>有的同学可能会说，谁会写出这么蠢的代码呢？实际上这样的代码在C++项目中经常出现，很多老手有时都犯这样的错误。你之所以可以一眼就看出上面代码的问题，是因为我将代码简化了。在真实的场景中，由于代码量比较大，你就没那么容易一眼看出问题了。</p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>上面我们已经看到了，通过new/delete这种方式申请/释放内存存在着很大弊端，有没有什么方法可以在使用时申请内存，在不需要的时自动释放它呢？当然有，<strong>这就是智能指针</strong>。</p><p>下面我们来看看智能指针是怎么做到的吧。实际上，智能指针最朴素的想法是利用类的<code>析构函数</code>和<code>函数栈</code>的自动释放机制来自动管理指针，即用户只要按需分配堆空间，堆空间的释放由智能指针帮你完成。</p><p>在解释这个原理之前，我们先来补充两个基本知识，一是构造函数与析构函数；另一个是堆空间与栈空间。首先来看构造函数与析构函数。</p><h3 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3><p>类对象的构造与析构是C++最基本的概念了，当创建对象时其构造函数会被调用，销毁对象时其析构函数会被调用。我们来举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MyClass()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"construct func"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~MyClass()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"deconstruct func"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"create MyClass object ..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    MyClass *myclass = <span class="keyword">new</span> MyClass();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"release MyClass object ..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> myclass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译命令 clang++ -g -o myclass test_class.cpp</span></span><br></pre></td></tr></table></figure><p>我们将上面的代码编译执行后，会得到下面的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create MyClass object ...</span><br><span class="line">construct func</span><br><span class="line">release MyClass object ...</span><br><span class="line">deconstruct func</span><br></pre></td></tr></table></figure><p>通过其结果就可以证明我们上面的结论了，即<strong>创建对象时其构造函数会被调用；销毁对像时其析构函数会被调用</strong>。</p><p>下面我们再来看看堆空间与栈空间。</p><h3 id="堆空间与栈空间"><a href="#堆空间与栈空间" class="headerlink" title="堆空间与栈空间"></a>堆空间与栈空间</h3><p>我们以Linux为例，在Linux系统上每个进程都有自己的虚似地址空间，如果你的系统是32位的，那它可以访问的内存空间是：2^32，也就是4G大小。</p><p>在这么大的空间中，内存被分成了几块：内核块、代码块、BSS块、堆空间，栈空间等。</p><ul><li>内核块，由Linux内核使用，应用层不可以访问。</li><li>代码块，用户的二进制应用程序，只读。</li><li>BSS块，全局量，全局常量等。</li><li>堆空间，用new分配的动态空间，可以分配大块内存。</li><li>栈空间，用于函数调用，分配临时变量等。其空间大小有限，<strong>当函数执行完成后其内存会自动回收</strong>。</li></ul><p>其中栈空间有个特点，当函数执行完后，它所用到的栈空间会被自动释放，而这正是智能指针所需要的。当它与构造函数/析构函数结合到一起时就可以实现智能指针了。下面我们来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">AutoPtr</span><span class="params">(T *ptr = <span class="literal">nullptr</span>)</span></span>&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"set new object"</span> &lt;&lt; ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            _ptr = ptr;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~AutoPtr()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"delete object"</span> &lt;&lt; _ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(_ptr != nulptr)</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T * _ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MyClass()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"construct MyClass func"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~MyClass()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"deconstruct MyClass func"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">AutoPtr&lt;MyClass&gt; <span class="title">myclass</span><span class="params">(<span class="keyword">new</span> MyClass())</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译命令 clang++ -g -o autoptr test_autoptr.cpp</span></span><br></pre></td></tr></table></figure><p>上面例子执行的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">construct MyClass func</span><br><span class="line">set new object, 0x7f8e25c028c0</span><br><span class="line">delete object, 0x7f8e25c028c0</span><br><span class="line">deconstruct MyClass func</span><br></pre></td></tr></table></figure><p>在上面main函数中创建了一个智能指针<code>AutoPtr&lt;MyClass&gt; myclass</code>，其在堆空间分配了一个MyClass对象交由智能指针管理，即<code>myclass(new MyClass())</code>。当main函数结束时，它会调用智能指针的析构函数，析构函数中执行了<code>delete</code>操作，最终将之前new出来的myclass对象释放掉了。</p><p>通过这个例子我们可以知道，有了智能指针我们就不用再担心内存泄漏了。对于C++开发同学来说像不像中了大奖一样高兴？不过上面的AutoPtr还称不上真正的智能指针，因为它只实现了智能指针最基本的一部分功能，我们还需要对它不断完善才行。</p><h2 id="AutoPtr智能指针"><a href="#AutoPtr智能指针" class="headerlink" title="AutoPtr智能指针"></a>AutoPtr智能指针</h2><p>上面实现的智能指针有什么问题呢？最大的问题就是它不能像真正的指针一样操作，比如说不能执行<code>xxx-&gt;xxx()</code>、<code>*xxx</code>等操作。下面我们就为AutoPtr重载这两个操作符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改AutoPtr，增加 -&gt; 和 * 操作符</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    T* <span class="keyword">operator</span> -&gt; ()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    T&amp; <span class="keyword">operator</span> * ()&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;(<span class="keyword">this</span>-&gt;_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改MyClass类，增加print方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加测试例子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">AutoPtr&lt;MyClass&gt; <span class="title">myclass</span><span class="params">(<span class="keyword">new</span> MyClass())</span></span>;</span><br><span class="line">    myclass-&gt;<span class="built_in">print</span>();</span><br><span class="line">    (*myclass).<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该程序，我们可以得到下面的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">construct MyClass func</span><br><span class="line">set new object,0x7f94f44028c0</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line">delete object，0x7f94f44028c0</span><br><span class="line">deconstruct MyClass func</span><br></pre></td></tr></table></figure><p>通过上面的例子我们可以看到AutoPtr确实像一个真正的指针了，既可以通过<code>-&gt;</code>调用MyClass方法，又可以通过<code>*</code>调用MyClass方法。</p><h2 id="AutoPtr缺陷"><a href="#AutoPtr缺陷" class="headerlink" title="AutoPtr缺陷"></a>AutoPtr缺陷</h2><p>虽然上面的AutoPtr实现看着很不错，不过它有非常致命的问题。当两个AutoPtr指针指向同一块堆空间时，在释放资源时会引起crash。咱们看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加测试例子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">AutoPtr&lt;MyClass&gt; <span class="title">myclass</span><span class="params">(<span class="keyword">new</span> MyClass())</span></span>;</span><br><span class="line">    AutoPtr&lt;MyClass&gt; newPtr = myclass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你在main函数中让两个AutoPtr指向同一块堆空间时就会引起crash。之所以会出现这个问题，是因为堆空间被释放了两次。上面程序的执行结果就可以推出这个结论：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">construct MyClass func</span><br><span class="line">set new object,0x7fdecfc028c0</span><br><span class="line"></span><br><span class="line">delete object，0x7fdecfc028c0     &#x2F;&#x2F;释放第二个对象</span><br><span class="line">deconstruct MyClass func</span><br><span class="line"></span><br><span class="line">delete object，0x7fdecfc028c0     &#x2F;&#x2F;释放第一个对象</span><br><span class="line">deconstruct MyClass func</span><br><span class="line">malloc: *** error for object 0x7fdecfc028c0: pointer being freed was not allocated &#x2F;&#x2F;0x7fdecfc028c0这个空间已经被释放过一次了</span><br></pre></td></tr></table></figure><p>通过上面的运行结果我们可以知道，创建myclass智能指针时它指向了<code>new MyClass</code>所分配的空间。紧接着，程序使用默认<code>=</code>运算符将myclass中的全部内容赋值给newPtr。此时newPtr的<code>_ptr</code>成员会与myclass的<code>_ptr</code>成员指向同一块堆空间(由于使用了默认<code>=</code>运算符，所以过程没有显示出来)。</p><p>当main函数结束时，它会按次序依次调用newPtr的析构函数和myclass的析构函数，所以我们可以看到有两次”delete object，0x7fdecfc028c0”。在C++中，如果对同一地址释放多次就会引起crash，所以我们在显示结果的最后一行看到了”pointer being freed was not allocated” 这条信息表示的就是重复释放了。</p><p>因此我们必须对 AutoPtr 继续改进，防止出现重复释放的情况。如何才能防止重复释放呢？</p><h2 id="谁来独享所有权？"><a href="#谁来独享所有权？" class="headerlink" title="谁来独享所有权？"></a>谁来独享所有权？</h2><p>我们可以想到的最简单的办法是当有多个智能指针指向同一块堆空间时，只能有一个智能指针拥有所有权。什么意思呢？就是这块堆空间的释放只能由其中的一个来完成。</p><h3 id="允许共享，独占所有权"><a href="#允许共享，独占所有权" class="headerlink" title="允许共享，独占所有权"></a>允许共享，独占所有权</h3><p>怎么才能让众多智能指针中的一个拥有所有权呢？简单的办法是在AutoPtr上加个owner就好了。我们将上面的代码修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    explicit AutoPtr(T *ptr = nullptr):_ptr(ptr), _owner(true)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr(AutoPtr&lt;T&gt; &amp; autoptr):_ptr(autoptr._ptr), _owner(<span class="literal">false</span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~AutoPtr()&#123;</span><br><span class="line">        <span class="keyword">if</span>(_owner &amp;&amp; _ptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr&amp; <span class="keyword">operator</span>=(AutoPtr&lt;T&gt; &amp; autoptr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;autoptr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(_ptr)&#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_ptr = autoptr._ptr;</span><br><span class="line">            _owner = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _ptr;</span><br><span class="line">    <span class="keyword">bool</span> _owner;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>经上面修改后，<code>new MyClass</code>分配的空间就有了具体的owner，所以再执行之前的测试程序就不会crash了。结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">construct MyClass func</span><br><span class="line">set new object,0x7fb9acc028c0</span><br><span class="line">copy construct, 0x7fb9acc028c0</span><br><span class="line">delete object，0x7fb9acc028c0   &#x2F;&#x2F; 调用newPtr 析构</span><br><span class="line">delete object，0x7fb9acc028c0   &#x2F;&#x2F; 调用 myclass 析构</span><br><span class="line">deconstruct MyClass func        &#x2F;&#x2F; 由于myclass是owner，所以才会真正的释放堆空间</span><br></pre></td></tr></table></figure><p>通过上面的修改问题似乎已经得到了解决，但实际的情况是后创建的智能指针更应该是owner，所以我们再做下微调：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    explicit AutoPtr(T *ptr = nullptr):_ptr(ptr), _owner(true)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr(AutoPtr&lt;T&gt; &amp; autoptr):_ptr(autoptr._ptr), _owner(<span class="literal">true</span>)&#123;</span><br><span class="line">        autoptr._owner = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr&amp; <span class="keyword">operator</span>=(AutoPtr&lt;T&gt; &amp; autoptr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;autoptr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(_ptr)&#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_ptr = autoptr._ptr;</span><br><span class="line">            _owner = <span class="literal">true</span>;</span><br><span class="line">            autoptr._owner = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>经上面修改后，后创建的AutoPtr就取代之前的智能指针成为owner了。我们来看一下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">construct MyClass func</span><br><span class="line">set new object,0x7fe67b4028c0</span><br><span class="line">copy construct, 0x7fe67b4028c0</span><br><span class="line">delete object，0x7fe67b4028c0       &#x2F;&#x2F; 调用newPtr析构函数</span><br><span class="line">deconstruct MyClass func            &#x2F;&#x2F; 堆空间被释放掉了</span><br><span class="line">delete object，0x7fe67b4028c0       &#x2F;&#x2F; 调用myclass析构函数</span><br></pre></td></tr></table></figure><p>通过上面最后三行的输出结果我们可以看出，释放空间的顺序发生了变化，说明owner已经变为最近创建的智能指针newPtr了。</p><p>调整后的AutoPtr还有没有问题呢？当然还有，我们再来看一下例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">T* <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">AutoPtr&lt;<span class="keyword">int</span>&gt; <span class="title">oldPtr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">AutoPtr&lt;<span class="keyword">int</span>&gt; <span class="title">newPtr</span><span class="params">(oldPtr)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里出现了野指针</span></span><br><span class="line">        *(oldPtr.<span class="built_in">get</span>())= <span class="number">-100</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"the value is "</span> &lt;&lt; *(oldPtr.<span class="built_in">get</span>()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我在AutoPtr中增加了一个get方法以便获得智能指针所指的堆空间</p></blockquote><p>在上面的代码中，将newPtr放到一个花括号里，这样它就有了自己的栈空间。当跳出花括号后，newPtr就完成了它的使命，然后它会将持有的资源全部释放掉。由于newPtr从oldPtr获得了<code>new int(100)</code>这块堆空间的控制权，所以当newPtr生命周期结束后，堆空间也被回收了。</p><p>但在newPtr被释放掉之后，oldPtr却还能通过get方法访问原来的堆空间，它还能将<code>-100</code>写入了被释放的堆空间。<strong>这是非常可怕的事情，因为oldPtr通过get方法拿到的已经是野指针了。</strong></p><p>因此，多智能指针共享堆空间并用owner控制最终资源释放的方法并不是特别好的智能指针方案。</p><h3 id="不允许共享，独占所有权"><a href="#不允许共享，独占所有权" class="headerlink" title="不允许共享，独占所有权"></a>不允许共享，独占所有权</h3><p>既然多智能指针共享堆空间存在着这样或那样的问题，那干脆不让他们共享得了。比如下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">AutoPtr</span><span class="params">(T * ptr=<span class="literal">nullptr</span>)</span>: _<span class="title">ptr</span><span class="params">(ptr)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr(AutoPtr&lt;T&gt; &amp; autoptr): _ptr(autoptr._ptr)&#123;</span><br><span class="line">        autoptr._ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~AutoPtr()&#123;</span><br><span class="line">        <span class="keyword">if</span>(_ptr)&#123;</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr&lt;T&gt; &amp; <span class="keyword">operator</span>=(AutoPtr&lt;T&gt; &amp; autoptr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;autoptr) &#123;</span><br><span class="line">            <span class="keyword">if</span>(_ptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            _ptr = autoptr._ptr;</span><br><span class="line">            autoptr._ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">AutoPtr&lt;<span class="keyword">int</span>&gt; <span class="title">oldPtr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line">    AutoPtr&lt;<span class="keyword">int</span>&gt; newPtr = oldPtr; <span class="comment">//oldPtr已经不指向堆空间了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中我们不允许多个AutoPtr之间共享同一块堆空间，当将一个AutoPtr赋值给另一个AutoPtr时，让原来的AutoPtr指向空地址（nullptr)，新的AutoPtr指向堆空间。上面代码执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set new object,0x7fe905502760</span><br><span class="line">copy construct, 0x7fe905502760          &#x2F;&#x2F;newPtr 指向堆空间</span><br><span class="line">delete object，0x7fe905502760           &#x2F;&#x2F;newPtr 析构</span><br><span class="line">really,delete object，0x7fe90550276     &#x2F;&#x2F;newPtr 指向的堆空间被释放</span><br><span class="line">delete object，0x0                      &#x2F;&#x2F;oldPtr 析构，此时可以看到它指向的地址为nullptr</span><br></pre></td></tr></table></figure><p>通过结果可以证明我们上面修改的代码已经阻止了多个AutoPtr共享同一块堆空间的可能。</p><p>然而上面的实现打破了我们对传统指针的认知，这会给你带来很多麻烦。尤其是多人合作时，如果大家对AutoPtr没有一致的认识，特别容易出现问题。因为既然是指针，那它就应该允许多个指针指向同一块堆空间。因此，当不有了解AutoPtr的同学使用它时，很可能还会认为多个AutoPtr是指向同一块堆空间的，这样当他通过老的AutoPtr向堆空间写数据时就会产生crash。比如像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">*(oldptr.get()) &#x3D; 10;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set new object,0x7fd93bc028c0</span><br><span class="line">copy construct, 0x7fd93bc028c0</span><br><span class="line">[1]    39662 segmentation fault  .&#x2F;autoptr  &#x2F;&#x2F;这里crash了</span><br></pre></td></tr></table></figure><p>上面的AutoPtr就是C++98规范中的auto_ptr的实现，由于该实现总是存在这样或那样的问题，因此现在auto_ptr已经被废弃掉了。</p><h2 id="scoped-ptr"><a href="#scoped-ptr" class="headerlink" title="scoped_ptr"></a>scoped_ptr</h2><p>我们已经看到上面的AutoPtr有各种弊端，引起这些弊端的最主要的原因是AutoPtr具有控制权的传递性，也就是说它允许从一个AutoPtr赋值给另一个AutoPtr。</p><p>为了彻底解决AutoPtr上面所述的问题，就出现了scoped_ptr。scoped_ptr最早是在C++的boost库中出现的，其出现的原因是从C++98之后C++标准一直没有更新智能指针的规范。因此C++大牛们纷纷发布了自己私有标准，而scoped_ptr就是其中之一。</p><p>scoped_ptr的核心思想是什么呢？既然auto_ptr的所有问题都是因为传递性引起的，所以阻止其传递性就可以解决这个问题了。因此scoped_ptr的实现也特别简单，它将其拷贝构造函数及赋值操作符全部隐藏起来，这样就不会有auto_ptr的问题了。</p><p>下面我们来看一下它的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScopedPtr</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ScopedPtr(T * ptr = <span class="literal">nullptr</span>): _ptr(ptr)&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T* <span class="keyword">operator</span>-&gt;()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T&amp; <span class="keyword">operator</span>*()&#123;</span><br><span class="line">            <span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_ptr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">T* <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~ScopedPtr()&#123;</span><br><span class="line">            <span class="keyword">if</span>(_ptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        ScopedPtr(ScopedPtr&lt;T&gt; &amp; scopedptr)&#123;&#125;</span><br><span class="line">        ScopedPtr&lt;T&gt; &amp; <span class="keyword">operator</span>=(ScopedPtr&lt;T&gt; &amp; scopedptr)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T *_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">ScopedPtr&lt;<span class="keyword">int</span>&gt; <span class="title">myPtr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line">    ScopedPtr&lt;<span class="keyword">int</span>&gt; newPtr = myPtr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//clang++ -g -o scopedptr test_scopedptr.cpp</span></span><br></pre></td></tr></table></figure><p>当我们编译上面的代码时，会报下面的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test_scopedptr.cpp:32:29: error: calling a protected constructor of class &#39;ScopedPtr&lt;int&gt;&#39;</span><br><span class="line">    ScopedPtr&lt;int&gt; newPtr &#x3D; myPtr;</span><br><span class="line">                            ^</span><br><span class="line">test_scopedptr.cpp:23:9: note: declared protected here</span><br><span class="line">        ScopedPtr(ScopedPtr&lt;T&gt; &amp; scopedptr)&#123;&#125;</span><br><span class="line">        ^</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure><p>上面的错误正是我们想要的结果。只要你对ScopedPtr进行赋值，在编译时就不让其编译通过，这样就不会再产生AutoPtr的问题了。</p><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>我们上面所讲的scoped_ptr并非是官方的标准，它是C++大牛们自己实现的版本。到了C++11之后官方版本来了，其被命名为unique_ptr。实际上unique_ptr与scoped_ptr功能几乎是一模一样，不过它们之间也有一些细微差别。</p><p>差别是什么呢？就是unique_ptr可以对右值进行转移，<code>对右值转移</code>这是啥意思呢？说明白了就是提供了一种特殊方法可以将unique_ptr赋值给另一个unique_ptr，被转移后的unique_ptr也就不能再处理之前管理的指针了。</p><p>我们还是来看一个具体的例子你就清楚了，只要给我们之前的ScopedPtr加上一个移动构造函数和移动赋值运算符就实现unique_ptrr的转移功能了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class ScopedPtr&#123;</span><br><span class="line">    ...</span><br><span class="line">    ScopedPtr(ScopedPtr&lt;T&gt;&amp;&amp; scopedptr) noexcept : _ptr(scopedptr._ptr)&#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;move construct...&quot; &lt;&lt; std::endl;</span><br><span class="line">        scopedptr._ptr &#x3D;  nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ScopedPtr&amp; operator&#x3D;(ScopedPtr&lt;T&gt; &amp;&amp; scopedptr) noexcept &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;move assignment...&quot; &lt;&lt; std::endl;</span><br><span class="line">        if(this !&#x3D; &amp;scopedptr)&#123;</span><br><span class="line">            _ptr &#x3D; scopedptr._ptr;</span><br><span class="line">           scopedptr._ptr &#x3D; nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[])&#123;</span><br><span class="line">    ScopedPtr&lt;int&gt; myPtr(new int(100));</span><br><span class="line">    &#x2F;&#x2F;ScopedPtr&lt;int&gt; newPtr &#x3D; myPtr;            &#x2F;&#x2F;拷贝构造函数已经不能用了</span><br><span class="line">    ScopedPtr&lt;int&gt; newPtr &#x3D; std::move(myPtr);   &#x2F;&#x2F;可以使用移动拷贝构造函数进行转移</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;clang++ -std&#x3D;c++11 -g -o scopedptr test_scopedptr.cpp</span><br></pre></td></tr></table></figure><p>上面main函数中的第二行调用的是拷贝构造函数，由于该函数是不是public属性，所以调用该行时会失败。而第三行会调用移动构造函数，因为我们已经实现了移动构造函数，所以该行可以编译成功。在运行时，当myPtr移动给newPtr后，myPtr也就失去了对原指针的控制权，这在代码中也有体现就是将 scopedptr的<code>_ptr</code>域设置为nullptr了。</p><p>上面就是C++11标准中的unique_ptr的实现，这样一分析下来也是蛮简单的对吧。</p><p>另外，对于移动构造函数，std::move这些概念我在另一篇文章<a href="https://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">《C++高阶知识：深入分析移动构造函数及其原理》</a>中有详细的介绍，对这块知识不了解的同学可以去看一下。</p><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>虽然unique_ptr已经很好用了，但有时候我们还是需要多个智能指针管理同一块堆内存空间。之前在讲AutoPtr时我们已经介绍了多个智能指针管理同一块内存空间会引起很多问题，有没有更好的方式来解决这些问题呢？</p><p>其中引用计数法是个不错的解决方案，实现起来也比较简单。其基本原理是当有多个智能指针指对同一块堆空间进行管理时，每增加一个智能指针引用计数就增1，每减少一个智能指针引用计数就减少。当引用计数减为0时，就将管理的堆空间释放掉。</p><p>我们还是看一个具体例子吧，其实现是在unique_ptr的基础之上实现的，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScopedPtr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        ScopedPtr(T *ptr = <span class="literal">nullptr</span>): _ptr(ptr), _ref_count(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>))&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ScopedPtr(ScopedPtr&lt;T&gt; &amp; scopedptr): _ptr(scopedptr._ptr), _ref_count(scopedptr._ref_count)&#123;</span><br><span class="line">            ++（*_ref_count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ScopedPtr &amp; <span class="keyword">operator</span>=(ScopedPtr&lt;T&gt; &amp; scopedptr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;scopedptr)&#123;</span><br><span class="line">                _release();</span><br><span class="line">                _ptr(scopedptr._ptr);</span><br><span class="line">                _ref_conut(scopedptr._ptr);</span><br><span class="line">                ++(*_ref_count);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~ScopedPtr()&#123;</span><br><span class="line">            _release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span>* <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> *_ref_count; </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="keyword">void</span> _release() &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"deconstruct...: count="</span> &lt;&lt; ((*_ref_count) <span class="number">-1</span>)  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(--(*_ref_count) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">                <span class="keyword">delete</span> _ref_count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">int</span> *_ref_count;   <span class="comment">//引用计数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">ScopedPtr&lt;<span class="keyword">int</span>&gt; <span class="title">myPtr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line">    ScopedPtr&lt;<span class="keyword">int</span>&gt; pT2 = myPtr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//clang++ -std=c++11 -g -o sharedptr test_sharedptr.cpp</span></span><br></pre></td></tr></table></figure><p>通过上面的修改，我们就可以将unique_ptr修改成shared_ptr了，测试结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">default construct ...</span><br><span class="line">copy construct ...: count&#x3D;2</span><br><span class="line">deconstruct...: count&#x3D;1</span><br><span class="line">deconstruct...: count&#x3D;0</span><br></pre></td></tr></table></figure><p>从结果中我们可以看到创建myPtr时引用计数为 1，将myPtr赋值给pT2时引用计算为2。当main程序结束后首先释放pT2，其引用计数减1。再释放myPtr，引用计数减为0，当引用计数为0时，释放堆空间。</p><p>这样的智能指针还是非常棒的，我们再也不怕内存泄漏了！！！</p><p>等等，我们好像高兴的太早了，当出现循环指向时还是会出现内存泄漏。我们来看一下例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ScopeddPtr&lt;Node&gt; _prev;</span><br><span class="line">    ScopeddPtr&lt;Node&gt; _next;</span><br><span class="line"></span><br><span class="line">    ~Node()</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"delete :"</span> &lt;&lt;<span class="keyword">this</span>&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ScopedPtr&lt;Node&gt; <span class="title">cur</span><span class="params">(<span class="keyword">new</span>(Node))</span></span>;</span><br><span class="line"><span class="function">ScopedPtr&lt;Node&gt; <span class="title">next</span><span class="params">(<span class="keyword">new</span>(Node))</span></span>;</span><br><span class="line">cur-&gt;_next = next;</span><br><span class="line">next-&gt;_prev = cur;</span><br></pre></td></tr></table></figure><p>上面这段代码就会出现内存泄漏，我们来分析一下。</p><p>首先第一行会创建三个Node类型的智能指针，分别是 <code>cur-&gt;_prev</code>、<code>cur-&gt;_next</code> 、<code>cur</code> 此时它们各自的引用计数都是 1；第二行也会创建三个Nodet智能指针，分别是<code>next-&gt;_prev</code>、<code>next-&gt;_next</code>及<code>next</code>; 第三行完成之后，<code>cur-&gt;_next</code>和<code>next</code>的引用计数都为 2；第四行完成后，<code>next-&gt;_prev</code>和<code>cur</code>的引用计数也变成了2；</p><p>当main程序结束时，next和cur分别调用它们的析构函数，因此<code>next</code>和<code>cur-&gt;_next</code>的引用计数变为1，<code>cur</code>和<code>next_prev</code>的引用计数也变成了1，但由于没有减至0，所以资源永会不会被释放掉。这就是产生内存泄露的原因。</p><p>真是辛辛苦苦好几年，一下回到解放前。使用引用计数还是会产生内存泄漏，我们仿佛又回到了起点。</p><p>不过别着急，C++11又给我们提供了新的解决方案，如何解决这个问题呢？</p><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>weak_ptr就是专门为了解决这个问题而出现的。实际上weak_ptr不能单独称为一个智能指针，它必须与shared_ptr一起使用，起到辅助share_ptr的作用。我们来看看它是如何解决上述问题的吧。</p><p>首先引入weak_ptr后，weak_ptr也要有自己的引用计数，因此我们需要修改之前的ScopedPtr，将它的计数成员变成一个类型，包括它自己的计数和weak_ptr的计数，它看起来像下面的样子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Counter():s(<span class="number">0</span>),w(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> s; <span class="comment">//存放share_ptr引用计数</span></span><br><span class="line">        <span class="keyword">int</span> w; <span class="comment">//存放weak_ptr引用计数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来我们来修改一下ScopedPtr，由于这次修改比较大，所以我给它重新起一个名子，叫作SharedPtr吧，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">WeakPtr</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SharedPtr &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        SharedPtr(T * ptr = <span class="literal">nullptr</span>):_ptr(ptr)&#123;</span><br><span class="line">            _cnt = <span class="keyword">new</span> Counter();</span><br><span class="line">           <span class="keyword">if</span>(_ptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                 _cnt-&gt;s = <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~SharedPtr()&#123;</span><br><span class="line">            _release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SharedPtr(SharedPtr&lt;T&gt; &amp; sharedptr): _ptr(sharedptr._ptr), _cnt(sharedptr._cnt)&#123;</span><br><span class="line">            _cnt-&gt;s++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SharedPtr(WeakPtr&lt;T&gt; &amp; weakptr): _ptr(weakptr._ptr), _cnt(weakptr._cnt)&#123;</span><br><span class="line">            _cnt-&gt;s++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SharedPtr &amp; <span class="keyword">operator</span>=(SharedPtr&lt;T&gt; &amp; sharedptr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> != &amp; sharedptr)&#123;</span><br><span class="line">                _release();</span><br><span class="line">                _ptr = sharedptr._ptr;</span><br><span class="line">                _cnt = sharedptr._cnt;</span><br><span class="line">                _cnt-&gt;s++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T&amp; <span class="keyword">operator</span> *()&#123;</span><br><span class="line">            <span class="keyword">return</span> *_ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T* <span class="keyword">operator</span> -&gt;()&#123;</span><br><span class="line">            <span class="keyword">return</span> _ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//friend class WeakPtr&lt;T&gt;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">       <span class="keyword">void</span> _release()&#123;</span><br><span class="line">            _cnt-&gt;s--;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"release "</span>&lt;&lt;_cnt-&gt;s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(_cnt-&gt;s &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">                <span class="keyword">if</span>(_cnt-&gt;w &lt;<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">delete</span> _cnt;</span><br><span class="line">                    _cnt=<span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T * _ptr;</span><br><span class="line">        Counter * _cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakPtr</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        WeakPtr():_ptr(<span class="literal">nullptr</span>), _cnt(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        ~WeakPtr()&#123;</span><br><span class="line">            _release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WeakPtr(WeakPtr&lt;T&gt; &amp; weakptr):_ptr(weakptr._ptr), _cnt(weakptr._cnt)&#123;</span><br><span class="line">            _cnt-&gt;w++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WeakPtr(SharedPtr&lt;T&gt; &amp; sharedptr):_ptr(sharedptr._ptr), _cnt(sharedptr._cnt)&#123;</span><br><span class="line">            _cnt-&gt;w++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WeakPtr &amp; <span class="keyword">operator</span>=(WeakPtr&lt;T&gt; &amp; weakptr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;weakptr)&#123;</span><br><span class="line">                _release();</span><br><span class="line">                _ptr = weakptr._ptr;</span><br><span class="line">                _cnt = weakptr._cnt;</span><br><span class="line">                _cnt-&gt;w++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WeakPtr &amp; <span class="keyword">operator</span>=(SharedPtr&lt;T&gt; &amp; sharedptr)&#123;</span><br><span class="line">            _release();</span><br><span class="line">            _ptr = sharedptr._ptr;</span><br><span class="line">            _cnt = sharedptr._cnt;</span><br><span class="line">            _cnt-&gt;w++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">SharedPtr&lt;T&gt; <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> SharedPtr&lt;T&gt;(*<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">expired</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(_cnt &amp;&amp; _cnt-&gt;s &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"empty "</span>&lt;&lt;_cnt-&gt;s&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//friend class SharedPtr&lt;T&gt;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="keyword">void</span> _release()&#123;</span><br><span class="line">            <span class="keyword">if</span>(_cnt)&#123;</span><br><span class="line">                _cnt-&gt;w--;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"weakptr release"</span>&lt;&lt;_cnt-&gt;w&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">if</span>(_cnt-&gt;w &lt; <span class="number">1</span> &amp;&amp; _cnt-&gt;s &lt;<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">//delete cnt;</span></span><br><span class="line">                        _cnt=<span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T * _ptr;</span><br><span class="line">        Counter * _cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    WeakPtr&lt;Node&gt; _prev;</span><br><span class="line">    WeakPtr&lt;Node&gt; _next;</span><br><span class="line"></span><br><span class="line">    ~Node()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"delete :"</span> &lt;&lt;<span class="keyword">this</span>&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">SharedPtr&lt;Node&gt; <span class="title">cur</span><span class="params">(<span class="keyword">new</span>(Node))</span></span>;</span><br><span class="line">    <span class="function">SharedPtr&lt;Node&gt; <span class="title">next</span><span class="params">(<span class="keyword">new</span>(Node))</span></span>;</span><br><span class="line">    cur-&gt;_next = next;</span><br><span class="line">    next-&gt;_prev = cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//clang++ -std=c++11 -g -o weakptr test_weakptr.cpp</span></span><br></pre></td></tr></table></figure><p>以上就是WeakPtr的实现以及SharedPtr的改造，从中我们可以看到，SharedPtr与我们之前的ScopedPtr区别并不是很大，主要做了三点有修改：一、以前只有一个计数器，然在变成了两个，一个是SharedPtr本身的计数，另一个是WeakPtr的计数；二是增加了一个参数为WeakPtr引用的拷贝构造函数;三、<code>_ptr</code>和<code>_cnt</code>的释放都是在SharedPtr中完成的，WeakPtr不做具体的释放工作。</p><p>WeakPtr是新增加的弱指针，它是配合SharedPtr使用的，自己并不能单独使用。WeakPtr也包含<code>_ptr</code>和<code>_cnt</code>两个成员，但它更多是是引用，对它们没有创建和释放权。另外在WeakPtr中会对Counter对象的w字段操作，也就是说多个WeakPtr指向同一个堆空间时，它仅操作Counter中的w字段。</p><p>因此，对于我们之前的SharedPtr形成环后导致的内存泄漏可以通过WeakPtr对其进行改造，这样内存泄漏的问题就迎刃而解了。</p><p>上面修改后的代码我们再来分析一遍。首先第一行会创建两个WeakPtr指针 <code>cur-&gt;_prev</code>、<code>cur-&gt;_next</code> 和一个SharedPtr智能指针<code>cur</code>。此时它们各自的引用计数都是 1；第二行同样也会创建二个WeakPtr指针<code>next-&gt;_prev</code>、<code>next-&gt;_next</code>和一个SharedPtr智能指针<code>next</code>; 第三行完成之后，<code>cur-&gt;_next</code>的_cnt-&gt;w为1，<code>next</code>的_cnt-&gt;s为1；第四行完成后，<code>next-&gt;_prev</code>的_cnt-&gt;w为1，<code>cur</code>的_cnt-&gt;s引用计数也为1；</p><p>当main程序结束时，next和cur分别调用它们的析构函数，因此<code>next</code>引用计数为0，释入Node对象，在Node中又会释放_prev和_next。next释放完成后开始释放<code>cur</code>，同里cur所持有的资源也一并释放。因此就不会再有内存泄漏了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文的篇幅有点长，不过每一部分都是不可或缺的。在本文中向你详细讲解了 auto_ptr、scoped_ptr、unique_ptr、shared_ptr以及与之配套的 weak_ptr的衍化过程。通过这样一个过程让你知道了这几个智能指针的作用是什么，应该用在地方，以及该如何使用。</p><p>相信通过本文你会对C++中的智能指针有了深刻的理解。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">C++高阶知识：深入分析移动构造函数及其原理</a><br>[重学C/C++中的const][<a href="https://avdancedu.com/5e7916e3/]" target="_blank" rel="noopener">https://avdancedu.com/5e7916e3/]</a><br><a href="http://localhost:4000/670ef31f/" target="_blank" rel="noopener">聊聊C++中的类型转换</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们来聊聊C++的智能指针。C++从1983年诞生到现在已经有30多年历史了，为什么到现在还能如此流行呢(排名第四，2020年6月&lt;a href=&quot;https://hellogithub.com/report/tiobe/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HelloGitHub榜单&lt;/a&gt;)？因为它具有很多其它语言所不具备的优势，比如说执行速度快，控制力更强等。同样的，有更多的同学会选择用Java(排名第二)等语言，这是因为它相对C++来说，它更简单，易上手，不用担心内存泄漏！&lt;/p&gt;
&lt;p&gt;确实，&lt;strong&gt;内存泄漏&lt;/strong&gt;在很长的一段时间里是影响人们学习C++的一个最重要的原因。不过C++也在不断进步中，智能指针的出现就大大降低了内存泄漏发生的风险。&lt;/p&gt;
&lt;p&gt;下面我们就来细聊一下C++智能指针的方方面面，通过本文让你真正掌握C++智能指针。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://blog.avdancedu.com/categories/C-C/"/>
    
    
      <category term="智能指针" scheme="https://blog.avdancedu.com/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>重学C/C++中的const</title>
    <link href="https://blog.avdancedu.com/5e7916e3/"/>
    <id>https://blog.avdancedu.com/5e7916e3/</id>
    <published>2020-06-30T06:09:42.000Z</published>
    <updated>2020-07-07T13:50:26.952Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/const/const.jpg" alt=""></p><p>使用<code>C/C++</code>语言的同学应该对<code>const</code>都比较了解，但对于初学者来说，<code>const</code>确是一个难肯的骨头，理解起来困难重重。今天我就带你重新学习一下C/C++的中的<code>const</code>。</p><a id="more"></a><h2 id="const-与-define-的区别"><a href="#const-与-define-的区别" class="headerlink" title="const 与 #define 的区别"></a>const 与 #define 的区别</h2><p>在<code>C/C++</code>中定义常量通常使用<code>const</code>关键字，当然你也可以使有宏<code>#define</code>来定义。这两种方式定义常量如下所示：</p><ul><li>const 定义常量  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int PI &#x3D; 3.14;</span><br></pre></td></tr></table></figure></li><li>宏定义常量  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define PI &#x3D; 3.14</span><br></pre></td></tr></table></figure></li></ul><p>这两种定义常量的方式有什么区别呢？</p><p>要回答这个问题，我们需要了解一点编译原理的知识。编译器在编译我们写好C/C++程序时，其编译器过程为：<strong>预编译-&gt;编译-&gt;链接</strong>。<code>C/C++</code>中宏的替换就是在预编译阶段完成的，也就是说在预编译阶段将C/C++中的所有用到的宏都用宏定义中的值替换掉。</p><p>而<code>const</code> 定义的常量则与宏定义的常量不同，它是在编译阶段进行检测，而且还可以对其类型进行检测。因此我们可以总结出使用<code>const</code>定义的常量与宏定义的常量有如下区别:</p><ul><li>宏是在预编译时进行宏展开，而const是在编译时检测，所以两者操作的时期不同</li><li>由于宏在预编译时被操作，所以无法进行类型检测；而const则可以进行类型检测</li><li>因在编译阶段可以形成符号表，所以const定义的常量可以通过调试器进行调试；而宏在展开后就消失了，所以无法通过调试器进行调试</li></ul><p>以上就是<code>const</code>与<code>宏</code>的最主要的区别。所以一般情况下我们都建议使用const来定义常量。</p><h2 id="const常量与const常量指针"><a href="#const常量与const常量指针" class="headerlink" title="const常量与const常量指针"></a>const常量与const常量指针</h2><p>上面我们已经列举过const如何定义常量，这里就不再赘述了。现在咱们来看一下const常量指针，它该如何定义呢?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int * ptr; &#x2F;&#x2F;const常量指针</span><br></pre></td></tr></table></figure><p>上面就是const常量指针的定义，也挺好理解的对吧。我们将const常量和const常量指针放在一起看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int i;    &#x2F;&#x2F;const常量</span><br><span class="line">const int* ptr; &#x2F;&#x2F;const常量指针</span><br></pre></td></tr></table></figure><p>将他们放在一起比较着看，你就更容易理解const常量指针了，无非就是将const常量中的类型变成指针而已。</p><h2 id="const常量指针的作用"><a href="#const常量指针的作用" class="headerlink" title="const常量指针的作用"></a>const常量指针的作用</h2><p><strong>那么常量指针的作用是什么呢？</strong>，我们来看个例子你就清楚了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const int i &#x3D; 100;     &#x2F;&#x2F; 定义一个常量</span><br><span class="line">i &#x3D; 100;               &#x2F;&#x2F; 不允许修改常量</span><br><span class="line"></span><br><span class="line">int *p &#x3D; &amp;i;           &#x2F;&#x2F; 老的编译器是被允许的，这实际存在安全问题</span><br><span class="line">                       &#x2F;&#x2F; 为了解决这个问题，新的编译器报错，非常量指针不允许指向常量地址</span><br><span class="line"></span><br><span class="line">const int * ptr &#x3D; &amp;i;  &#x2F;&#x2F; 常量指针指向常量地址</span><br><span class="line">*ptr &#x3D; 100;            &#x2F;&#x2F; 不允许修改常量的内容</span><br></pre></td></tr></table></figure><p>按照常量的定义，常量定义好后其内容就不允许再修改了，因此对于上面代码中的前两行相信你不会有什么异义。</p><p>但在较老的编译器上，存在一个漏洞，它允许你用普通指针指向常量地址。这样你就可以通过该指针修改常量的内容了，这是非常大的安全漏洞。为了消除这个安全隐患，在新的编译器上已经不允许普通指针指向const常量了。</p><p>为什么在老编译器上指针可以指向常量地址并修改其内容呢？究其原因是因为const定义的常量实际是在内存的可读写空间，只是由于编译器限制你才不能修改它。而老的编译器却没有这方面的限制，所以才会出现通过普通指针修改常量的可能。</p><p>我们再来看代码的最后两行。使用const常量指针指向常量地址，此时你无论用新编译器还是老编译器，都无法通过该指针修改常量的内容。所以代码的最后一行当你修改常量内容时就会报错。</p><p>通过上面的讲解，你应该对常量指针的概念比较清楚了。常量指针不能修改常量内容，但能不能让常量指针指向另外一个常量的地址呢？比如下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const int i &#x3D; 100;</span><br><span class="line">const int n &#x3D; 1000;</span><br><span class="line"></span><br><span class="line">const int * ptr &#x3D; &amp;i;   &#x2F;&#x2F;常量指针先指向 i 常量的地址</span><br><span class="line">ptr &#x3D; &amp;n;               &#x2F;&#x2F;又修改为指向 n 常量的地址</span><br></pre></td></tr></table></figure><p>这样做当然是可以的，因为常量指针限制的是不能修改常量内容，但并没有限制它指向哪个常量。</p><h2 id="const变形"><a href="#const变形" class="headerlink" title="const变形"></a>const变形</h2><p>上面我们已经清楚了const常量指针是什么，它起了什么作用。但它还有一点你不知道，就是它会变型。我们来看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int * ptr;</span><br><span class="line">int const * ptr;</span><br></pre></td></tr></table></figure><p>上面这两行代码很像是不是？第二行代码将 const 放到了 int 类型之后，它表达的是什么意思呢？<strong>其实两行表示的是同一个意思，都是常量指针</strong>。只是有的人喜欢将const写在最前面，有的人喜欢将const 写在类型后面罢了。这里有一个记忆的小巧门，我们只要记住const是在 <code>*</code> 左边它就表示的是常量指针就OK了，</p><h2 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h2><p>上面的内容清楚之后，我们再来一个复杂的<strong>指针常量</strong>。看到这个词相信很多同学立马晕了，上面是常量指针，这又来个指针常量是这是说绕口令吗？先别急，我们先来看个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int * const ptr;</span><br></pre></td></tr></table></figure><p>上面这行代码是不是与前面的很相似？一模一样? 如果你这样认为说明你没有仔细观察。之前的常量指针const是在<code>*</code>号左边，这次的const跑到<code>*</code>号右边了。</p><p>它表示的是什么意思呢？</p><p>前面我已经说了，对于常量指针来说，你是不能修改它所指向的内容的，因为内容是常量，但它可以让它指向不同的常量地址。新需求来了，有没有可能让指针指向一个地址就不动了呢？或者换个思考的角度，既然const可以定义常量，能不能定义一个指针常量呢？<strong>这就是指针常量的由来</strong>。</p><p>C/C++编译器的作者考虑的一下这个需求，觉得这个需求是合理的，决定实现它。但怎么才能表示指针常量呢？于是就有了 <code>const int * const ptr</code> 这个写法，const 放在<code>*</code>后面表达对ptr的限制。</p><p>了解了指针变量的由来，下面我们来看一下它的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 100;</span><br><span class="line">int n &#x3D; 1000;</span><br><span class="line"></span><br><span class="line">int * const ptr &#x3D;  &amp;i; &#x2F;&#x2F; 正确，初始指向某个变量</span><br><span class="line">ptr &#x3D; &amp;n;              &#x2F;&#x2F; 错误，ptr是常量，不能再发生变化</span><br><span class="line"></span><br><span class="line">*ptr &#x3D; 20;             &#x2F;&#x2F; 正确，因为我们没有对指针指向的内容做限制</span><br></pre></td></tr></table></figure><p>上面代码中定义了两个变量 i 和 n，ptr是针指常量，因此它只能在初始化时指向某个变量的地址，之后它就不能更改变指向其它地址了，因为它是<strong>常量</strong>。<strong>但需要注意的是ptr指向的内容是可以被修改的</strong>。</p><h2 id="指向常量的指针常量"><a href="#指向常量的指针常量" class="headerlink" title="指向常量的指针常量"></a>指向常量的指针常量</h2><p>看这个标题就觉得好复杂啊！没错我们又要升级难度了。先看个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int * const ptr1;</span><br><span class="line">int const * const ptr2;</span><br></pre></td></tr></table></figure><p>天呐，一条语句中出列了两个const，如果我们没有基础的话，这两行代码简直无法理解。不过，有了上面的基础我们再来看这两句还是能猜出它要干什么的对吧？</p><p>这两条语句的含义是一样的，表示的是ptr1/ptr2指向的地址不能再改变，而且它指向的地址里的内容也不能再改变。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在本文中我向你详细介绍了C/C++中的<code>const</code>的含义和用法，总结一下包括以下几种：</p><ul><li>定义常量, 内容不能改变，<code>const int a;</code></li><li>定义常量指针，指向的内容不能改变，<code>const int * ptr;</code> 或 <code>int const * ptr;</code></li><li>定义指针常量，指针不能改变，但指向的内容可以改变。<code>int * const ptr</code></li><li>定义指向常量的针指常量，指针不能改变，内容也不能改变。<code>const int * const ptr</code> 或 <code>int const * const ptr</code></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">C++高阶知识：深入分析移动构造函数及其原理</a><br><a href="https://avdancedu.com/9683d88/" target="_blank" rel="noopener">细说智能指针</a><br><a href="https://avdancedu/670ef31f/" target="_blank" rel="noopener">聊聊C++中的类型转换</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/const/const.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;C/C++&lt;/code&gt;语言的同学应该对&lt;code&gt;const&lt;/code&gt;都比较了解，但对于初学者来说，&lt;code&gt;const&lt;/code&gt;确是一个难肯的骨头，理解起来困难重重。今天我就带你重新学习一下C/C++的中的&lt;code&gt;const&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://blog.avdancedu.com/categories/C-C/"/>
    
    
      <category term="const" scheme="https://blog.avdancedu.com/tags/const/"/>
    
  </entry>
  
  <entry>
    <title>分析WebRTC，重学Windows开发</title>
    <link href="https://blog.avdancedu.com/2fb1b8c6/"/>
    <id>https://blog.avdancedu.com/2fb1b8c6/</id>
    <published>2020-06-29T14:47:36.000Z</published>
    <updated>2020-06-29T15:39:27.749Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/windows/win95.jpg" alt=""></p><p>N多年没有写过 Window 程序了。为了研究 WebRTC 源码，这两天重新学习一下。还记得上大学的时候看过 《Windows95 程式设计》台湾版，对那本书印象极为深刻。一是当时国内确实没有一本写的那么深入的书籍，二是那本书翻译的特别好，让人一看就特别明白。10多年过多了，当时的情景还记忆犹新，也可见那本书写的有多好了。</p><a id="more"></a><p>Windows开发有很多知识点，窗口啊，句柄啊，消息啊，重绘啊，baba …..，但一个 Windows 程序的核心就是一个消息处理机制。</p><h2 id="Windows程序运行的基本原理"><a href="#Windows程序运行的基本原理" class="headerlink" title="Windows程序运行的基本原理"></a>Windows程序运行的基本原理</h2><p>Windows程序是消息为驱动的，所以它的核心就是消息的传递与处理。如鼠标消息、键盘消息，Timer消息，窗口的创建与消毁等等。那么，Windows程序是在哪儿处理消息呢？是否掌握了它，就控制了Windows程序的核心呢？答案是肯定的，它就是 WndProc 函数。所有的消息都要经过这个函数处理。</p><p>Windows 程序有两种消息，一种是队列消息，它通过 DispatchMessage 函数分发给 WndProc 函数，像鼠标消息、键盘消息，Timer消息都是这类消息。另一种是非队列消息，它是系统函数直接发送给 WndProc 函数的，像窗口的创建与消毁消息，WM_COMMON消息等等都是非队列消息。</p><h2 id="最简单的-Windows-程序"><a href="#最简单的-Windows-程序" class="headerlink" title="最简单的 Windows 程序"></a>最简单的 Windows 程序</h2><p>一个最简单的 Windows 程序都包括哪些内容呢？下面我们详细介绍一下：</p><h3 id="WinMain-函数"><a href="#WinMain-函数" class="headerlink" title="WinMain 函数"></a>WinMain 函数</h3><p>我们都知道无论是Windows程序，还是Linux程序，也无论是C/C++，还是 Java语言，它们都有一个 main 函数。更准确点说应该叫“程序入口点”。</p><p>我们写程序时，一般都以 main 开头，编译器在编译该程序时，会将 main 函数地址写入到可执行文件的文件头中，这就是“程序入口点”了。</p><p>在执行程序时，操作系统首先通过程序加载器将要运行的程序加载到内存中，然后重新计算符号地址表。一切准备就绪后，才跳到程序入口点，将一条条指令送入CPU流水线开始执行程序。这就是程序的运行的基本流程。</p><p>因此，我们可以知道每个程序都有一个入口点。但是否一定以 main 开头呢? 其实，只要编译器能识别出入口点就可以，不必非要以 main 为标志。对于 Windows 程序就是这样，它就不使用 main作为入口点，而是换成了 WinMain 作为程序入口点。格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int CALLBACK WinMain(</span><br><span class="line">   _In_  HINSTANCE hInstance,</span><br><span class="line">   _In_  HINSTANCE hPrevInstance,</span><br><span class="line">   _In_  LPSTR lpCmdLine,</span><br><span class="line">   _In_  int nCmdShow</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="实现消息中心函数-WndProc"><a href="#实现消息中心函数-WndProc" class="headerlink" title="实现消息中心函数 WndProc()"></a>实现消息中心函数 WndProc()</h3><p>前面我已经介绍了 WndProc 是 Windows 程序的消息中心，所有的消息都要在这个函数中处理。如 窗口创建时发送的 WM_CREATE 消息，如果我们不处理它，Windows 操作系统就不会显示创建的窗口。</p><p>但 Windows 中有那么多消息，我们每个都处理岂不是要累死人？所以 Windows 很贴心的提供了一个API，就是 DefWindowProc 函数。该函数对所有的 Windows 消息都做了默认处理，如果我们很懒的话，可以将所有消息都交由它就好了。</p><p>有没有坐过山车的感脚？开始觉得很苦闷，突然又拨云见日了。嘿嘿！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK WndProc(</span><br><span class="line">        _In_  HWND hwnd,</span><br><span class="line">        _In_  UINT uMsg,</span><br><span class="line">        _In_  WPARAM wParam,</span><br><span class="line">        _In_  LPARAM lParam</span><br><span class="line">) &#123;</span><br><span class="line">return DefWindowProc(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册窗口类"><a href="#注册窗口类" class="headerlink" title="注册窗口类"></a>注册窗口类</h3><p>我们在创建窗口之前要注册一个窗口类，它是干啥用的呢？就是告诉操作系统，我要创建个什么样子的窗口，是啥背景色，鼠标是啥样子的，程序叫啥名子等等。</p><p>有了这个窗口类，我们就可以创建不同样式的窗口了，这样是不是觉得很方便呢？当然，一般情况下我们都使用默认样式！</p><p>这个窗口类除了设置样式外，其实它<strong>更重要的作用</strong>是指定 WndProc 函数，也就是为 Window 程序指定 “消息处理中心”。消息中心是谁，完全是由 RegisterClass 说了算，它说消息处理中心是 WndProc 就是 WndProc，它说 ABC 那就是 ABC。</p><p>一般我们调用注册窗口的代码都长的像下面这样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 类名</span><br><span class="line">WCHAR* cls_Name &#x3D; L&quot;My Class&quot;;</span><br><span class="line">&#x2F;&#x2F; 设计窗口类</span><br><span class="line">WNDCLASS wc &#x3D; &#123; &#125;;</span><br><span class="line">wc.hbrBackground &#x3D; (HBRUSH)COLOR_WINDOW;</span><br><span class="line">wc.lpfnWndProc &#x3D; WndProc;</span><br><span class="line">wc.lpszClassName &#x3D; cls_Name;</span><br><span class="line">wc.hInstance &#x3D; hInstance;</span><br><span class="line">&#x2F;&#x2F; 注册窗口类</span><br><span class="line">RegisterClass(&amp;wc);</span><br></pre></td></tr></table></figure><h3 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h3><p>创建窗口就比较简单了，高多少，宽多少，透明的还是非透明的，可显示还是不可显示，标题栏上要写啥字等等，这些都是由<code>创建窗口</code>说了算。形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建窗口</span><br><span class="line">      HWND hwnd &#x3D; CreateWindow(</span><br><span class="line">      cls_Name,           &#x2F;&#x2F;类名，要和刚才注册的一致</span><br><span class="line">      L&quot;我的应用程序&quot;,  &#x2F;&#x2F;窗口标题文字</span><br><span class="line">      WS_OVERLAPPEDWINDOW, &#x2F;&#x2F;窗口外观样式</span><br><span class="line">      38,                 &#x2F;&#x2F;窗口相对于父级的X坐标</span><br><span class="line">      20,                 &#x2F;&#x2F;窗口相对于父级的Y坐标</span><br><span class="line">      480,                &#x2F;&#x2F;窗口的宽度</span><br><span class="line">      250,                &#x2F;&#x2F;窗口的高度</span><br><span class="line">      NULL,               &#x2F;&#x2F;没有父窗口，为NULL</span><br><span class="line">      NULL,               &#x2F;&#x2F;没有菜单，为NULL</span><br><span class="line">      hInstance,          &#x2F;&#x2F;当前应用程序的实例句柄</span><br><span class="line">      NULL);              &#x2F;&#x2F;没有附加数据，为NULL</span><br></pre></td></tr></table></figure><h3 id="显示窗口"><a href="#显示窗口" class="headerlink" title="显示窗口"></a>显示窗口</h3><p>窗口创建完了，还要主动调<code>ShowWindows</code>函数让窗口显示出来，否则它是不会出来干活的。形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 显示窗口</span><br><span class="line">ShowWindow(hwnd, SW_SHOW);</span><br></pre></td></tr></table></figure><h3 id="循环处理，检索与分发消息"><a href="#循环处理，检索与分发消息" class="headerlink" title="循环处理，检索与分发消息"></a>循环处理，检索与分发消息</h3><p>这部分工作是在 WinMain 函数中要做的事儿。在 WinMain 中写一个循环，不停的从系统消息队列中取消息。</p><p>如果此时没有消息，则该线被程阻塞，并将CPU资源释放；如果有消息，需要判断是不是退出消息？如果不是，使用 DispatchMessage 将该消息分配出去。如果是退出消息，则退出消息循环，程序结束。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void WinMan(...)&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 消息循环</span><br><span class="line">MSG msg;</span><br><span class="line">while(GetMessage(&amp;msg, NULL, 0, 0))</span><br><span class="line">&#123;</span><br><span class="line">    TranslateMessage(&amp;msg);</span><br><span class="line">    DispatchMessage(&amp;msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是一个最简单的窗口 Window 程序。了解了上面这些知识，大家是不是觉得即使不用 MFC 也可以写出一个很不错的 Windows 程序呢？</p><h2 id="重要函数详细介绍"><a href="#重要函数详细介绍" class="headerlink" title="重要函数详细介绍"></a>重要函数详细介绍</h2><h3 id="WinMain"><a href="#WinMain" class="headerlink" title="WinMain"></a>WinMain</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int CALLBACK WinMain(</span><br><span class="line">  _In_ HINSTANCE hInstance, &#x2F;&#x2F;句柄</span><br><span class="line">  _In_ HINSTANCE hPrevInstance, &#x2F;&#x2F;总是 NULL</span><br><span class="line">  _In_ LPSTR     lpCmdLine, &#x2F;&#x2F;在命令行启动程序时的命令</span><br><span class="line">  _In_ int       nCmdShow &#x2F;&#x2F;程序启动时的显示方式</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>hInstance：句柄，就是一个内存地址，在该地址上有该程序的基本信息。</li><li>hPrevInstance：总是NULL，没啥用。</li><li>lpCmdLine： 用命令行启动时的命令，有兴趣的可以自己打印出来。</li><li>nCmdShow：程序启动时的显示方式，是隐藏，还是显示，是最大化，还是最小化显示。</li></ul><h3 id="注册窗口"><a href="#注册窗口" class="headerlink" title="注册窗口"></a>注册窗口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagWNDCLASS &#123;</span><br><span class="line">  UINT      style;</span><br><span class="line">  WNDPROC   lpfnWndProc;</span><br><span class="line">  int       cbClsExtra;</span><br><span class="line">  int       cbWndExtra;</span><br><span class="line">  HINSTANCE hInstance;</span><br><span class="line">  HICON     hIcon;</span><br><span class="line">  HCURSOR   hCursor;</span><br><span class="line">  HBRUSH    hbrBackground;</span><br><span class="line">  LPCTSTR   lpszMenuName;</span><br><span class="line">  LPCTSTR   lpszClassName;</span><br><span class="line">&#125; WNDCLASS, *PWNDCLASS;</span><br><span class="line"></span><br><span class="line">ATOM WINAPI RegisterClass(</span><br><span class="line">  _In_ const WNDCLASS *lpWndClass</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>style ：设置窗口样式。可以不设置。</li><li>lpfnWndProc ：这个字段特别重要，设置消息处理函数，它是消息的中心。</li><li>cbClsExtra ：不用设置。</li><li>cbWndExtra ：不用设置。</li><li>hInstance ：窗口句柄，与WinMain中的一样。</li><li>hIcon ：窗口图标。如果是NULL，使用默认图标。</li><li>hCursor ：设置光标样式。可以不设置</li><li>hbrBackground ：设置窗口背景色。</li><li>lpszMenuName：菜单名。如果为NULL说明没有菜单。</li><li>lpszClassName：这个参数要提供，长度不超过 256。</li></ul><h3 id="创建窗口-1"><a href="#创建窗口-1" class="headerlink" title="创建窗口"></a>创建窗口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HWND WINAPI CreateWindow(</span><br><span class="line">  _In_opt_ LPCTSTR   lpClassName,</span><br><span class="line">  _In_opt_ LPCTSTR   lpWindowName,</span><br><span class="line">  _In_     DWORD     dwStyle,</span><br><span class="line">  _In_     int       x,</span><br><span class="line">  _In_     int       y,</span><br><span class="line">  _In_     int       nWidth,</span><br><span class="line">  _In_     int       nHeight,</span><br><span class="line">  _In_opt_ HWND      hWndParent,</span><br><span class="line">  _In_opt_ HMENU     hMenu,</span><br><span class="line">  _In_opt_ HINSTANCE hInstance,</span><br><span class="line">  _In_opt_ LPVOID    lpParam</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>lpClassName ： 与注册的类名子一致。</li><li>lpWindowName ：窗口标题栏名子。</li><li>dwStyle ：窗口外观样式。</li><li>x ：窗口起始位置 x。</li><li>y ：窗口起始位置 y。</li><li>nWidth ：窗口宽度。</li><li>nHeight ：窗口高度。</li><li>hWndParent ：父窗口，没有的话设置为NULL</li><li>hMenu ：窗口菜单，没有设置为NULL</li><li>hInstance ： 窗口句柄。</li><li>lpParam ：符加数据，没有设置为 NULL</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过上面的介绍，我想你首先知道了Windows程序是由消息驱动的，真正负责消息处理的函数是 WinProc，它是在调用 RegisterClass 时指定的。通过 RegisterClass 我们还可以给窗口指定样式，并最终由 CreateWindow 创建出来。同时我们还可以总结出，通过 6 大步既可以创建出一个最简单的 Windows程序，这6步分别是：</p><ul><li>设置入口点，WinMain。</li><li>创建 WinProc 函数。</li><li>注册窗口类。</li><li>创建窗口。</li><li>显示窗口。</li><li>循环处理，检索与分发消息</li></ul><p>至此，一个Windows程序窗口已经展现在你面前了。 希望本文能对你有所帮助!</p><p> 谢谢！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/garrylea/SimpleWindow" target="_blank" rel="noopener">github地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/windows/win95.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;N多年没有写过 Window 程序了。为了研究 WebRTC 源码，这两天重新学习一下。还记得上大学的时候看过 《Windows95 程式设计》台湾版，对那本书印象极为深刻。一是当时国内确实没有一本写的那么深入的书籍，二是那本书翻译的特别好，让人一看就特别明白。10多年过多了，当时的情景还记忆犹新，也可见那本书写的有多好了。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
