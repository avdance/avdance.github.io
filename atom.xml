<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>音视跳动科技</title>
  
  <subtitle>传播最前沿的科技知识！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.avdancedu.com/"/>
  <updated>2021-06-23T01:56:01.187Z</updated>
  <id>https://blog.avdancedu.com/</id>
  
  <author>
    <name>音视跳动</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>音频3A问题经验分享</title>
    <link href="https://blog.avdancedu.com/5756c48d/"/>
    <id>https://blog.avdancedu.com/5756c48d/</id>
    <published>2021-06-23T01:56:01.186Z</published>
    <updated>2021-06-23T01:56:01.187Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来音频的3A（回音消除、降噪、自动增益）问题都是音视频实时通信中特别关键，也特别难以解决的问题。尤其是回音消除问题，更是难上加难，它就好比你向水中倒了一些墨汁，现在又想将它从水中提取出来一样困难。</p><p>对于做音视频 PaaS (提供API接口服务）的公司而言，只有将3A问题处理好，才能在音视频实时通信市场上占有一席之地，否则就没法与声网、腾讯等这些老牌或巨头公司进行竞争。正是由于3A 问题是做音视频公司必须要解决好的问题，所以它们对能够解决这类问题的人才都求贤若渴，对于想进入音视频行业的同学来说，如果你能具有3A问题的解决能力，那你一定会成为各音视频大厂挣抢的“香饽饽”。</p><p>为了让大家学到更多的干货，这次我特意邀请到拍乐云合伙人&amp;音频专家 Ark，请他为大家详细介绍在商业应用中都会遇到哪些3A问题，遇到这类问题时该如何解决，对于初入门的同学又该如何学习音频技术。相信通过这次分享，一定会让大家会收获满满。</p><p>感兴趣的小伙伴请加入讨论群, 分享时间为2021年6月30 19:45。</p><p><img data-src="https://cdn.avdancedu.com/image/article/3A/dakashuo.png" alt="音频3A经验分享群"></p><a id="more"></a><h2 id="本次分享的大体题纲如下："><a href="#本次分享的大体题纲如下：" class="headerlink" title="本次分享的大体题纲如下："></a>本次分享的大体题纲如下：</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul><li>音频的一些基本知识，音量（响度），分贝，频率、振幅与音量的关系，为什么音量是负值？</li><li>增益是指什么？它与音量大小的区别是什么？如何进行自动增益？<h3 id="降噪相关"><a href="#降噪相关" class="headerlink" title="降噪相关"></a>降噪相关</h3></li><li>什么是噪音，算法是如何判断出噪音的？</li><li>噪音是有颜色的，这是什么意思？</li><li>降噪的难点是什么？什么样的噪音不好降？</li><li>我们是否应该优先使用硬件降噪？移动端与PC端有什么区别吗？</li><li>什么是舒适噪音？为什么要增加舒适噪音？<h3 id="回音相关"><a href="#回音相关" class="headerlink" title="回音相关"></a>回音相关</h3></li><li>回音消除的难点是什么？</li><li>是否可以简要的介绍一下回音产生的一个大体原理？</li><li>机端的回音消除是否比PC端的回音更好消除一些？其中的原理是否可以比大家介绍一下？</li><li>WebRTC在回音消除方法做了哪些工作，最新的AEC3 与以前的回音消除算法有什么显著的差别？<h3 id="学习相关"><a href="#学习相关" class="headerlink" title="学习相关"></a>学习相关</h3></li><li>在解决实际3A问题时，一定要用到数学吗？</li><li>未来的技术方向</li><li>学习音频的基本路径是什么？</li><li>能否给推荐几本好书？</li></ul><h2 id="分享嘉宾"><a href="#分享嘉宾" class="headerlink" title="分享嘉宾"></a>分享嘉宾</h2><p>Ark，拍乐云合伙人&amp;音频专家。中科大硕士毕业，多年音频开发经验，5年WebEx音频专家工作经验，精通音频3A算法，深入理解实时通信音频框架，主导设计了多套音频处理框架，对于音频算法、移动端设备适配、大屏远场算法优化、智能手表音频优化等都非常了解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直以来音频的3A（回音消除、降噪、自动增益）问题都是音视频实时通信中特别关键，也特别难以解决的问题。尤其是回音消除问题，更是难上加难，它就好比你向水中倒了一些墨汁，现在又想将它从水中提取出来一样困难。&lt;/p&gt;
&lt;p&gt;对于做音视频 PaaS (提供API接口服务）的公司而言，只有将3A问题处理好，才能在音视频实时通信市场上占有一席之地，否则就没法与声网、腾讯等这些老牌或巨头公司进行竞争。正是由于3A 问题是做音视频公司必须要解决好的问题，所以它们对能够解决这类问题的人才都求贤若渴，对于想进入音视频行业的同学来说，如果你能具有3A问题的解决能力，那你一定会成为各音视频大厂挣抢的“香饽饽”。&lt;/p&gt;
&lt;p&gt;为了让大家学到更多的干货，这次我特意邀请到拍乐云合伙人&amp;amp;音频专家 Ark，请他为大家详细介绍在商业应用中都会遇到哪些3A问题，遇到这类问题时该如何解决，对于初入门的同学又该如何学习音频技术。相信通过这次分享，一定会让大家会收获满满。&lt;/p&gt;
&lt;p&gt;感兴趣的小伙伴请加入讨论群, 分享时间为2021年6月30 19:45。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/3A/dakashuo.png&quot; alt=&quot;音频3A经验分享群&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>在Windows下使用VS编译OpenCV库</title>
    <link href="https://blog.avdancedu.com/d6343897/"/>
    <id>https://blog.avdancedu.com/d6343897/</id>
    <published>2021-06-06T08:29:01.643Z</published>
    <updated>2021-06-06T08:29:01.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近发现有很多同学在学习OpenCV时，不知道该如何在Windows下编译OpenCV源码，这里我整理了一份Windows编译OpenCV的具体步聚，希望可以帮助到大家。</p><p>Windows下编译OpenCV分为四步，即：</p><ul><li>一、下载安装必要的工具</li><li>二、下载OpenCV源码</li><li>三、生成编译脚本</li><li>四、使用VS工程编译OpenCV</li></ul><a id="more"></a><h2 id="下载必要的工具"><a href="#下载必要的工具" class="headerlink" title="下载必要的工具"></a>下载必要的工具</h2><ol><li>安装python3和numpy库，<a href="https://www.python.org/ftp/python/3.9.2/python-3.9.2-amd64.exe" target="_blank" rel="noopener">下载地址：https://www.python.org/ftp/python/3.9.2/python-3.9.2-amd64.exe</a></li><li>安装 VS, 下载社区版即可，<a href="https://visualstudio.microsoft.com/zh-hans/downloads/" target="_blank" rel="noopener">下载地址： https://visualstudio.microsoft.com/zh-hans/downloads/</a></li><li>安装 cmake，<a href="https://github.com/Kitware/CMake/releases/download/v3.20.0-rc1/cmake-3.20.0-rc1-windows-x86_64.msi" target="_blank" rel="noopener">下载地址：https://github.com/Kitware/CMake/releases/download/v3.20.0-rc1/cmake-3.20.0-rc1-windows-x86_64.msi</a></li><li>下载IPPICV，<a href="https://github.com/opencv/opencv_3rdparty.git" target="_blank" rel="noopener">下载地址：https://github.com/opencv/opencv_3rdparty.git</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;opencv&#x2F;opencv_3rdparty.git</span><br></pre></td></tr></table></figure></li></ol><h2 id="下载opencv源码"><a href="#下载opencv源码" class="headerlink" title="下载opencv源码"></a>下载opencv源码</h2><ol><li><p>下载opencv源码, 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;opencv&#x2F;opencv.git</span><br></pre></td></tr></table></figure></li><li><p>下载opencv-contrib源码, 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;opencv&#x2F;opencv_contrib.git</span><br></pre></td></tr></table></figure></li></ol><h2 id="生成编译脚本"><a href="#生成编译脚本" class="headerlink" title="生成编译脚本"></a>生成编译脚本</h2><ol><li>在存放opencv源码目录中创建build目录</li><li>运行cmake</li><li>选择opencv源码目录</li><li>选择编译目录</li><li>选择CPU架构</li><li>增加opencv-contrib选项, OPENCV_EXTRA_MODULES_PATH=../opencv_contrib/modules</li><li>检查编译选项，并<ol><li>勾选 opencv_world</li><li>勾选 ffmpeg</li><li>勾选 IPPICV，这步容易出错，如果你访问不了外网的话一般会出错。可以偿试手工下载IPPICV，进行设置。</li></ol></li><li>生成编译脚本</li></ol><h2 id="使用VS编译OpenCV"><a href="#使用VS编译OpenCV" class="headerlink" title="使用VS编译OpenCV"></a>使用VS编译OpenCV</h2><ol><li>选择输出版本类型</li><li>进行编译</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在上述步骤中，第三步<strong>生成编译脚本</strong>是最容易出错的，其中第7步是导致出错的最大原因，所以在生成编译脚本时一定要仔细检查这几项是否都是OK的。</p><h2 id="我的课程"><a href="#我的课程" class="headerlink" title="我的课程"></a>我的课程</h2><p>-<a href="https://coding.imooc.com/class/496.html" target="_blank" rel="noopener">OpenCV入门与实战</a></p><p>-<a href="https://coding.imooc.com/class/415.html" target="_blank" rel="noopener">音视频系统入门</a></p><p>-<a href="https://coding.imooc.com/class/279.html" target="_blank" rel="noopener">ffmpeg精讲</a></p><p>-<a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">WebRTC入门与实战</a></p><p>-<a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">WebRTC高并发流媒体服务器</a></p><p>-<a href="https://time.geekbang.org/column/article/111337" target="_blank" rel="noopener">从0开始构造直播系统</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近发现有很多同学在学习OpenCV时，不知道该如何在Windows下编译OpenCV源码，这里我整理了一份Windows编译OpenCV的具体步聚，希望可以帮助到大家。&lt;/p&gt;
&lt;p&gt;Windows下编译OpenCV分为四步，即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一、下载安装必要的工具&lt;/li&gt;
&lt;li&gt;二、下载OpenCV源码&lt;/li&gt;
&lt;li&gt;三、生成编译脚本&lt;/li&gt;
&lt;li&gt;四、使用VS工程编译OpenCV&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Go的性能竟如何优秀？Go、C和RUST性能对比</title>
    <link href="https://blog.avdancedu.com/1ed22639/"/>
    <id>https://blog.avdancedu.com/1ed22639/</id>
    <published>2021-05-26T02:26:39.682Z</published>
    <updated>2021-05-26T02:26:39.682Z</updated>
    
    <content type="html"><![CDATA[<p>最近几年Go、RUST等新语言不断推陈出新，令人目不暇接。据说Go与RUST开发出的程序性能非常高，但对于我这种C/C++老鸟来说，对此并不感冒，“再快还能比C快？”这句话一直萦绕在我的心头。</p><p>但出于好奇，每次听到有人说Go性能多好多好时，难免都会追问一句“有没有与C进行过对比测试？”，这句并不是想“兑”谁，而是想确认一下网上的传言是否为真。</p><p>不幸的是，每当我问这句话时，从来没有得到一个明确答复，也搞不清是他们得出的“Go性能好”是道听途说，还是自己真实的测试结果。</p><p>近来时间充裕，一时兴起，心想不如做个简单的Go、C/C++、RUST的性能对比测试吧，验证一下Go的性能到底如何。</p><a id="more"></a><h2 id="简单的测试用例"><a href="#简单的测试用例" class="headerlink" title="简单的测试用例"></a>简单的测试用例</h2><p>由于我一直专注在音视频实时通信领域，因此对网络传输的性能特别关心，所以这次测试只验证一下不同语言在传输UDP包时的性能。</p><p>为了减少其它因素的影响，测试条件限制如下：</p><ul><li>在同一台机子上进行不同语言性能的测试，防止因硬件的不同影响测试结果</li><li>服务端只接收不回复，防止服务器干扰测试结果</li><li>客户端只发送不接收，每次只发送<code>Hello</code>几个字符</li><li>客户端循环发送 1000 0000次，看它的总时长是多少</li></ul><p>下面是不同语言编写的测试程序。</p><h3 id="C客户端代码"><a href="#C客户端代码" class="headerlink" title="C客户端代码"></a>C客户端代码</h3><p>下面是使用<code>C</code>语言实现的客户端代码的主要逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    gettimeofday(&amp;tv0, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> lastime = tv0.tv_sec * <span class="number">1000000000</span> + tv0.tv_usec; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"total: %lu, sec:%lu, nao:%u\n"</span>, lastime, tv0.tv_sec, tv0.tv_usec);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//循环 1000 0000 次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>; a&lt; <span class="number">10000000</span>; a++)&#123;</span><br><span class="line">        n = sendto(sock, </span><br><span class="line">                        buff_send, </span><br><span class="line">                        <span class="built_in">strlen</span>(buff_send), </span><br><span class="line">                        <span class="number">0</span>, (struct sockaddr *) &amp;addr, </span><br><span class="line">                        <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;tv1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> curtime = tv1.tv_sec * <span class="number">1000000000</span> + tv1.tv_usec; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"total:%lu, sec:%lu, nao:%u\n"</span>, curtime, tv1.tv_sec, tv1.tv_usec);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>从上述代码中可以看到，在<code>for</code>循环执行了 1000 0000 次，每次都调用 <code>sendto</code> 发送UDP数据。</p><h3 id="Go客户端代码"><a href="#Go客户端代码" class="headerlink" title="Go客户端代码"></a>Go客户端代码</h3><p>Go语言实现的逻辑与C客户端逻辑是类似的，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">var</span> lastime <span class="keyword">int64</span> = time.Now().UnixNano()</span><br><span class="line">    fmt.Printf(<span class="string">"lastime: %d\n"</span>, lastime)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> a:=<span class="number">0</span>; a &lt; <span class="number">10000000</span>; a++ &#123;</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        _, err = conn.Write([]<span class="keyword">byte</span>(<span class="string">"Hello"</span>))    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> curtime <span class="keyword">int64</span> = time.Now().UnixNano()</span><br><span class="line">    fmt.Printf(<span class="string">"curtime: %d"</span>, curtime)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Go的代码非常简单，它与C的区别是其使用Write来发送数据。</p><h3 id="RUST客户端代码"><a href="#RUST客户端代码" class="headerlink" title="RUST客户端代码"></a>RUST客户端代码</h3><p>RUST语言实现的逻辑也是类似的，代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">let</span> start = Instant::now();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> n = start.elapsed().as_nanos();</span><br><span class="line">    std::<span class="built_in">println!</span>(<span class="string">" elapsed: &#123;&#125;"</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//loop &#123;</span></span><br><span class="line">    <span class="keyword">for</span> _i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">100001</span> &#123;</span><br><span class="line">        socket.send_to(data.as_bytes(), <span class="string">"127.0.0.1:9998"</span>)?;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = start.elapsed().as_nanos();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"elapsed : &#123;&#125;"</span>, n);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><table><thead><tr><th align="left">系统</th><th align="left">硬件</th><th align="left">C</th><th align="left">Go</th><th align="left">RUST</th></tr></thead><tbody><tr><td align="left">Mac</td><td align="left">2.7 GHz Intel Core i5<br>8 GB DDR3</td><td align="left">150秒</td><td align="left">85秒</td><td align="left">150 秒</td></tr><tr><td align="left">Linux</td><td align="left">2.7GHz Inter 8 Core i7 <br> 8G</td><td align="left">17-18秒</td><td align="left">21-22秒</td><td align="left">22 秒</td></tr></tbody></table><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>刚看到这个结果时，我真是难以至信，Go和RUST的性能竟然与C如此接近。</p><p>通过上面的测试我们可以得出以下结论：</p><ul><li>新语言 Go 与 RUST 在性能上确实不错，基本上与 C 是接近的，应用层到系统接口之间的层级比较薄</li><li>不同的操作系统表现不一样，但通常情况下Go都是在Linux系统下运行，所以应该以Linux系统的测试为准</li><li>Go、RUST相较C/C++而言，开发效率高很多，如果性能差不多的情况下，采用Go或RUST做服务器开发更有优势</li></ul><p><strong>但这次只是一个简单的测试，只能说在发送UDP时，Go、RUST与C性能差别不大，但并不代表在整体性能上Go和RUST已经赶上C/C++性能了。如果想更好的了解Go、RUST与C/C++的差异，应该做更详尽的测试验证。</strong></p><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>代码地址：<a href="https://github.com/andancedu/go_rust_c.git" target="_blank" rel="noopener">https://github.com/andancedu/go_rust_c.git</a></p><h2 id="我的课程"><a href="#我的课程" class="headerlink" title="我的课程"></a>我的课程</h2><p>-<a href="https://coding.imooc.com/class/415.html" target="_blank" rel="noopener">音视频系统入门</a></p><p>-<a href="https://coding.imooc.com/class/279.html" target="_blank" rel="noopener">ffmpeg精讲</a></p><p>-<a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">WebRTC入门与实战</a></p><p>-<a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">WebRTC高并发流媒体服务器</a></p><p>-<a href="https://time.geekbang.org/column/article/111337" target="_blank" rel="noopener">从0开始构造直播系统</a></p><p>-<a href="https://coding.imooc.com/class/496.html" target="_blank" rel="noopener">OpenCV入门与实战</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近几年Go、RUST等新语言不断推陈出新，令人目不暇接。据说Go与RUST开发出的程序性能非常高，但对于我这种C/C++老鸟来说，对此并不感冒，“再快还能比C快？”这句话一直萦绕在我的心头。&lt;/p&gt;
&lt;p&gt;但出于好奇，每次听到有人说Go性能多好多好时，难免都会追问一句“有没有与C进行过对比测试？”，这句并不是想“兑”谁，而是想确认一下网上的传言是否为真。&lt;/p&gt;
&lt;p&gt;不幸的是，每当我问这句话时，从来没有得到一个明确答复，也搞不清是他们得出的“Go性能好”是道听途说，还是自己真实的测试结果。&lt;/p&gt;
&lt;p&gt;近来时间充裕，一时兴起，心想不如做个简单的Go、C/C++、RUST的性能对比测试吧，验证一下Go的性能到底如何。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>《WebRTC实时互动技术原理实战与源码分析》一书的源码</title>
    <link href="https://blog.avdancedu.com/a0a831a3/"/>
    <id>https://blog.avdancedu.com/a0a831a3/</id>
    <published>2021-03-16T13:36:40.000Z</published>
    <updated>2021-03-17T04:33:32.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="源码下截地址"><a href="#源码下截地址" class="headerlink" title="源码下截地址"></a>源码下截地址</h1><p><a href="https://avdancedu.com/download/client.tar.gz" target="_blank" rel="noopener">客户端源码下载</a><br><a href="https://avdancedu.com/download/server.tar.gz" target="_blank" rel="noopener">服务端源码下载</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;源码下截地址&quot;&gt;&lt;a href=&quot;#源码下截地址&quot; class=&quot;headerlink&quot; title=&quot;源码下截地址&quot;&gt;&lt;/a&gt;源码下截地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://avdancedu.com/download/client.tar.gz&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>深入浅出C++的function</title>
    <link href="https://blog.avdancedu.com/dabab813/"/>
    <id>https://blog.avdancedu.com/dabab813/</id>
    <published>2020-07-16T14:05:23.000Z</published>
    <updated>2020-07-17T12:02:36.411Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来聊聊C++的function。std::function是从C++11开始支持的特性，它起什么作用?又有什么好处呢？</p><a id="more"></a><h2 id="C语言中的函数指针"><a href="#C语言中的函数指针" class="headerlink" title="C语言中的函数指针"></a>C语言中的函数指针</h2><p>对C语言熟悉的同学应该都知道，C语言中有一种高级技巧叫作函数指针，我们可以让函数指针指向参数类型相同、返回值类型也相同的函数。通过函数指针我们也可以实现C++中的多态。我们来看个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*func)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, print1 \n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, print2 \n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    func fp = print1;</span><br><span class="line">    fp();</span><br><span class="line"></span><br><span class="line">    fp = print2;</span><br><span class="line">    fp();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中定义了一个函数指针<code>func</code>，它可以指向无输入参数，返回值为整型的函数。因此在main函数中，我们可以用fp(这是func类型的指针）分别指向print1和print2并调用它们。</p><p>其运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello, print1</span><br><span class="line">hello, print2</span><br></pre></td></tr></table></figure><h2 id="function的作用"><a href="#function的作用" class="headerlink" title="function的作用"></a>function的作用</h2><p>从上面的C代码中我们可以看到C函数指针的作用，那在C++中是否也类似这样的功能呢？没错function就是完成这个任务的。但std::function比C的函数指针功能更强大些或者说更适合C++中使用。</p><p>下面我们来看一下如何在C++中使用std::function实现指向不同的函数吧。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello, print1"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello, print2"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::function&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">func</span><span class="params">(&amp;print1)</span></span>;</span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    func = &amp;print2;</span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码与C函数指针一样定义了两个全局函数print1和print2。在main函数中又定义了std::function 对象 func，然后将print1和print2分别赋值给func，这样就可以达到与C语言中指针同样的功能了。</p><p>其运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello, print1</span><br><span class="line">hello, print2</span><br></pre></td></tr></table></figure><p>可以看到std::function的结果与上面C函数指针的结果是一致的，因此std::function就是C++中用来代替C函数指针的。但如果std::function只是实现上面的功能也没啥好奇怪的对吧？实际上std::function还有一个特别有意思的用法，你可以将一个重载了<strong>()</strong>操作符的对象赋值给它，这样就可以像调用函数一样使用该对象了。下面咱们就对上面的代码做下简单修改，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"This is A Object"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    A a;</span><br><span class="line">    func = a;</span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，使用<code>struct</code>定义了一个结构体，而在该结构体中重载了<strong>()</strong>操作符，因此只要你将A的类对象赋值给func，它就可以像函数一样使用了。其结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">This is A Object</span><br></pre></td></tr></table></figure><h2 id="function的实现原理"><a href="#function的实现原理" class="headerlink" title="function的实现原理"></a>function的实现原理</h2><p>是不是觉得function做的事儿还挺神奇的？它是如何实现的呢？下面我们就来扒一扒它是如何实现的。</p><p>从实现上来说，有两种办法可以实现std::function：一种是通过类的多态，即通过虚表来达到多态；另一种方法是通过C语言的函数指针来实现。今天我们只介绍通过类多态的方式来实现function，对于通过函数指针实现的方式你可以自己去研究一下。</p><p>现在我们由浅入深的来分解一下function。通过观察我们可以发现function是一个包装类，它可以接收普通函数、<strong>函数类对象</strong>(也就是实现了（）操作符的类对象）等。它是如何做到的呢？</p><p>最简单的方式就是通过类模板。我们都知道function的类模板参数是可变的，但我们为了简单，所以只实现有一个参数的function类模板。这也符合我们的目标，只是扒一下实现原理，并不是想自己去实现它。</p><p>OK，下面我们来看看该如何定义这个类模板吧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> Arg0&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span>&lt;R(Arg0)&gt; &#123;</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(Arg0 arg0)</span></span>&#123;</span><br><span class="line">           <span class="keyword">return</span> ...;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个最简单的，只有一个参数的类模板。它是 <strong>function&lt;int(int)&gt;</strong> 或 <strong>function&lt;String(int)&gt;</strong> 等格式的类模板。这样我们在外型上与标准库中的std::function类似了。</p><p>接下来我们需要思考一下，如何让我们自己实现的function可以调用不同的函数呢？从其行为上可以推理出其内部应该有一个指针，而且这个指针具有多态性。想想C++中的多态是如何实现的？通过继承和虚表对吧。所以在function内部应该有一个基类指针，所有传入到function中的函数、类函数对象等都应该是继承于该类的子类成员。除此之外，还要在<strong>()</strong>操作符前加<code>virtual</code>关键字，让它创建虚表。</p><p>了解了上面的原理后，下面我们就在自己的function中增加基类及其类的指针。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> Arg0&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span>&lt;R(Arg0)&gt; <span class="title">function</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="class"><span class="keyword">class</span> __<span class="title">callbase</span> &#123;</span></span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                <span class="function"><span class="keyword">virtual</span> R <span class="title">operator</span><span class="params">()</span><span class="params">(Arg0 arg0)</span> </span>= <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">virtual</span> ~__callbase() &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        __callbase *base_;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(Arg0 arg0)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (*__callbase)(arg0); <span class="comment">//这里调用基类对象的()操作符</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面我们就将多态中的基类实现好了，在上面的代码中最关键是的<code>operator()</code>中增加了<strong>virtual</strong>关键字，这样该函数就被放到了vtable中，后面就可以在子类中实现该方法了。下面我们来实现子类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span>&lt;R(Arg0)&gt; <span class="title">function</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> __<span class="title">callable</span>:</span> <span class="keyword">public</span> __callbase &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                callable(F functor)</span><br><span class="line">                    : functor(functor)&#123;&#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">virtual</span> R <span class="title">operator</span><span class="params">()</span><span class="params">(Arg0 arg0)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> functor(arg0);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span>:</span><br><span class="line">                F functor;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">        myfunction(F f): base_(<span class="keyword">new</span> __callable&lt;F&gt;(f))&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~myfunction()&#123;</span><br><span class="line">            <span class="keyword">if</span>(base_) &#123;</span><br><span class="line">                <span class="keyword">delete</span> base_;</span><br><span class="line">                base_ = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在子类的实现中，核心点是增加指向赋值给function类的函数指针或函数类对象，也就是上面<code>__callable</code>类中的<strong>F functor</strong> 成员。该成员的类型是通过模板<code>template&lt;typename F&gt;</code>推导出来的。如果我们在创建function时传入的是函数，那么functor就是一个函数指针，如果我们传入的是函数类对象，则functor就是类对象。</p><p>另外你可以发现，我分别在myfunction类的构造函数和<code>__callable</code>类前定义了模板<code>F</code>，这样当我们在main函数中创建myfunction对象时，通过类型推导就可以获到F的具体类型了。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">myfunction <span class="title">myfunc</span><span class="params">(<span class="built_in">print</span>)</span></span>; <span class="comment">//通过这句可以获得F类型为函数指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了functor成员后，还需要在构造<code>__callable</code>时给functor赋值，也就是让functor指向具体的函数或函数类对象。之后重载<strong>()</strong>操作符就可以直接调用具体的函数或函数类对象了。</p><p>通过以上讲解我想你应该已经知道标准库中的function实现的基本原理了。当然我们这里实现的比较简陋，真正的实现还要考虑很多性能的问题，所以实现的要比这个复杂得多。另外标准库中的实现是通过函数指针来实现的而非通过C++的多态。</p><p>不过我们今天实现的的myfunction虽然与标准库有很多不同，但原理都是类似的，对于我们理解function已经足够了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在本文中我首先向你介绍了std::function的作用以及如何使用它，之后又苞丁解牛的实现了一个最简陋的function，主要的目的是加深你对function的理解。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">C++高阶知识：深入分析移动构造函数及其原理</a><br><a href="https://avdancedu.com/360c1c76" target="_blank" rel="noopener">聊聊C++中的完美转发</a><br><a href="https://avdancedu.com/9683d88/" target="_blank" rel="noopener">细说智能指针</a><br><a href="https://avdancedu/670ef31f/" target="_blank" rel="noopener">聊聊C++中的类型转换</a><br><a href="https://avdancedu.com/5e7916e3/" target="_blank" rel="noopener">重学C/C++中的const</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们来聊聊C++的function。std::function是从C++11开始支持的特性，它起什么作用?又有什么好处呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://blog.avdancedu.com/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="https://blog.avdancedu.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>聊聊C++中的完美转发</title>
    <link href="https://blog.avdancedu.com/360c1c76/"/>
    <id>https://blog.avdancedu.com/360c1c76/</id>
    <published>2020-07-16T05:46:39.000Z</published>
    <updated>2020-07-16T10:47:13.621Z</updated>
    
    <content type="html"><![CDATA[<p>之前我已经向你介绍了<a href="http://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">C++中的std::move</a>，它的作用是无论你传给它的是左值还是右值，通过std::move之后都变成了右值。而今天我们要介绍的std::forward则与之不同，它的作用是什么呢？</p><a id="more"></a><h2 id="forward的作用"><a href="#forward的作用" class="headerlink" title="forward的作用"></a>forward的作用</h2><p>std::forward被称为<strong>完美转发</strong>，它的作用是保持原来的<code>值</code>属性不变。啥意思呢？通俗的讲就是，如果原来的值是左值，经std::forward处理后该值还是左值；如果原来的值是右值，经std::forward处理后它还是右值。</p><p>看看下面的例子，你应该就清楚上面这句话的含义了:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T &amp; t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lvalue"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T &amp;&amp; t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rvalue"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(v);</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">std</span>::forward&lt;T&gt;(v));</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">std</span>::<span class="built_in">move</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    testForward(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"======================"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    testFoward(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，定义了两个模板函数，一个接收左值，另一个接收右值。在<code>testForward</code>函数中向模板函数<code>print</code>传入不同的参数，这样我们就可以观察出forward与move的区别了。</p><p>上面代码执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lvalue</span><br><span class="line">rvalue</span><br><span class="line">rvalue</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">lvalue</span><br><span class="line">lvalue</span><br><span class="line">rvalue</span><br></pre></td></tr></table></figure><p>从上面第一组的结果我们可以看到，传入的1虽然是右值，但经过函数传参之后它变成了左值（在内存中分配了空间）；而第二行由于使用了std::forward函数，所以不会改变它的右值属性，因此会调用参数为右值引用的print模板函数；第三行，因为std::move会将传入的参数强制转成右值，所以结果一定是右值。</p><p>再来看看第二组结果。因为x变量是左值，所以第一行一定是左值；第二行使用forward处理，它依然会让其保持左值，所以第二也是左值；最后一行使用move函数，因此一定是右值。</p><p>通过上面的例子我想你应该已经清楚forward的作用是什么了吧？</p><h2 id="forward实现原理"><a href="#forward实现原理" class="headerlink" title="forward实现原理"></a>forward实现原理</h2><p>要分析forward实现原理，我们首先来看一下forward代码实现。由于我们之前已经有了<a href="http://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">分析std::move</a>的基础，所以再来看forward代码应该不会太困难。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>forward实现了两个模板函数，一个接收左值，另一个接收右值。在上面有代码中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type</span><br></pre></td></tr></table></figure><p>的含义我们在<a href="http://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">分析std::move</a>时已经向你做了说细的说明，其作用就是获得去掉引用后的参数类型。所以在上面的两上模板函数中，第一个是左值引用模板函数，第二个是右值引用模板函数。</p><p>紧接着forward模板函数对传入的参数进行强制转换，转换的目标类型符合引用折叠规则，因此左值参数最终转换后仍为左值，右值参数最终转成右值。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们首先通一个小例子向你介绍了std::forward的作用为“完美转发”，也就是不改变原值的属性。接着我带你分析了std::forward的原码实现，如果你看过我之前对std::move的分析文章，相信你在阅读std:forward的代码实现时不会遇到什么困难。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">C++高阶知识：深入分析移动构造函数及其原理</a><br><a href="https://avdancedu.com/9683d88/" target="_blank" rel="noopener">细说智能指针</a><br><a href="https://avdancedu/670ef31f/" target="_blank" rel="noopener">聊聊C++中的类型转换</a><br><a href="https://avdancedu.com/5e7916e3/" target="_blank" rel="noopener">重学C/C++中的const</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前我已经向你介绍了&lt;a href=&quot;http://avdancedu.com/a39d51f9/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;C++中的std::move&lt;/a&gt;，它的作用是无论你传给它的是左值还是右值，通过std::move之后都变成了右值。而今天我们要介绍的std::forward则与之不同，它的作用是什么呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://blog.avdancedu.com/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="https://blog.avdancedu.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>[转]Mac配置中文man手册</title>
    <link href="https://blog.avdancedu.com/a77533/"/>
    <id>https://blog.avdancedu.com/a77533/</id>
    <published>2020-07-11T16:29:40.000Z</published>
    <updated>2020-07-13T09:00:53.517Z</updated>
    
    <content type="html"><![CDATA[<p>转自： <a href="http://www.jackaiup.com/index/detail?id=10234" target="_blank" rel="noopener">http://www.jackaiup.com/index/detail?id=10234</a></p><p>man手册对于我们在Mac或Linux系统下开发起着至关重要的作用，今天我们就来看一下如何在Mac系统下安装Man手册。</p><a id="more"></a><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li>安装软件依赖</li><li>编译安装man手册</li><li>修改配置文件</li><li>解决乱码问题</li></ul><h2 id="软件依赖"><a href="#软件依赖" class="headerlink" title="软件依赖"></a>软件依赖</h2><ul><li>autotools (autoconf, automake)</li><li>python3</li><li>opencc 1.x</li></ul><p>可以通过homebrew自行安装:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew install autotools</span><br><span class="line">brew install python3</span><br><span class="line">brew install opencc</span><br></pre></td></tr></table></figure><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><blockquote><p>git clone  <a href="https://github.com/man-pages-zh/manpages-zh" target="_blank" rel="noopener">https://github.com/man-pages-zh/manpages-zh</a>    #下载文件<br>cd manpages-zh<br>autoreconf –install –force     #构建configure文件<br>./configure<br>make<br>make install                     #需要超级用户权限</p></blockquote><h2 id="添加手册路径"><a href="#添加手册路径" class="headerlink" title="添加手册路径"></a>添加手册路径</h2><p>打开 man 手册配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;man.conf</span><br></pre></td></tr></table></figure><p>修改配置文件，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line">MANPATH &#x2F;usr&#x2F;local&#x2F;share&#x2F;man              #line 44</span><br><span class="line">MANPATH &#x2F;usr&#x2F;local&#x2F;share&#x2F;man&#x2F;zh_CN        #添加中文手册路径</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">:wq</span><br></pre></td></tr></table></figure><p>可以通过下面的命令查看是否中文文档已经加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man -aw</span><br></pre></td></tr></table></figure><p>如果出现下面的信息表示已加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;share&#x2F;man:&#x2F;usr&#x2F;share&#x2F;man:&#x2F;usr&#x2F;local&#x2F;share&#x2F;man&#x2F;zh_CN         #已经加载</span><br></pre></td></tr></table></figure><h2 id="查看中文文档"><a href="#查看中文文档" class="headerlink" title="查看中文文档"></a>查看中文文档</h2><p>执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man -aw ls            &lt;&#x3D; 查看有几个中文文档</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;share&#x2F;man&#x2F;man1&#x2F;ls.1                 &lt;&#x3D; 默认文档</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;share&#x2F;man&#x2F;zh_CN&#x2F;man1&#x2F;ls.1     &lt;&#x3D; 中文文档</span><br></pre></td></tr></table></figure><p>查看文档内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man -a ls             &lt;&#x3D; 查看文档内容</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">LS(1)                     BSD General Commands Manual                    LS(1)</span><br><span class="line">NAME</span><br><span class="line">     ls — list directory contents</span><br><span class="line">SYNOPSIS</span><br><span class="line">     ls [-ABCFGHLOPRSTUW@abcdefghiklmnopqrstuwx1] [file ...]</span><br><span class="line">DESCRIPTION</span><br><span class="line">     For each operand that names a file of a type other than directory, ls displays its name as</span><br><span class="line">     well as any requested, associated information.  For each operand that names a file of type</span><br><span class="line">     directory, ls displays the names of files contained within that directory, as well as any</span><br><span class="line">     requested, associated information.</span><br><span class="line">     If no operands are given, the contents of the current directory are displayed.  If more than</span><br><span class="line">     one operand is given, non-directory operands are displayed first; directory and non-direc‐</span><br><span class="line">     tory operands are sorted separately and in lexicographical order.</span><br><span class="line">     The following options are available:</span><br><span class="line">     -@      Display extended attribute keys and sizes in long (-l) output.</span><br><span class="line">     -1      (The numeric digit “one”.)  Force output to be one entry per line.  This is the</span><br><span class="line">     ...</span><br><span class="line">    按【q】进入中文文档</span><br><span class="line"></span><br><span class="line">LS(1)                                General Commands Manual                                LS(1)</span><br><span class="line">NAME</span><br><span class="line">       ls, dir, vdir - 列目录内容</span><br><span class="line">提要</span><br><span class="line">       ls [选项] [文件名...]</span><br><span class="line">       POSIX 标准选项: [-CFRacdilqrtu1]</span><br><span class="line">GNU 选项 (短格式):</span><br><span class="line">       [-1abcdfgiklmnopqrstuxABCDFGLNQRSUX]  [-w  cols]  [-T  cols]  [-I  pattern]  [--full-time]</span><br><span class="line">       [--format&#x3D;&#123;long,verbose,commas,across,vertical,single-column&#125;]</span><br><span class="line">       [--sort&#x3D;&#123;none,time,size,extension&#125;]               [--time&#x3D;&#123;atime,access,use,ctime,status&#125;]</span><br><span class="line">       [--color[&#x3D;&#123;none,auto,always&#125;]] [--help] [--version] [--]</span><br><span class="line">描述（ DESCRIPTION ）</span><br><span class="line">       程序ls先列出非目录的文件项，然后是每一个目录中的“可显示”文件。如果</span><br><span class="line">       没有选项之外的参数【译注：即文件名部分为空】出现，缺省为   &quot;.&quot;   （当前目录）。  选项“  -d</span><br><span class="line">       ”使得目录与非目录项同样对待。除非“ -a ” 选项出现，文 件名以“.”开始的文件不属“可显示”文件。</span><br><span class="line">       以当前目录为准，每一组文件（包括非目录文件项，以及每一内含文件的目录）分</span><br><span class="line">       别按文件名比较顺序排序。如果“-l”选项存在，每组文件前显示一摘要行:</span><br><span class="line">       ...</span><br><span class="line">【注】默认进入英文文档，按【q】可进入中文文档，再次按【q】则退出文档</span><br></pre></td></tr></table></figure><h2 id="解决乱码"><a href="#解决乱码" class="headerlink" title="解决乱码"></a>解决乱码</h2><p>如果系统的groff版本太低，文档可能出现乱码，可以将groff更新到最新版本（1.22.3，可能的话请使用尚未发布的 1.22.4）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install groff</span><br></pre></td></tr></table></figure><p>安装完成后，配置man.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;man.conf</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">#修改NROFF配置如下（将UTF8编码的MAN页面通过转码而被groff识别）</span><br><span class="line">#line 95</span><br><span class="line"></span><br><span class="line">NROFF preconv -e utf8 | &#x2F;usr&#x2F;local&#x2F;bin&#x2F;groff -Wall -mtty-char -Tutf8 -mandoc -c</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">#修改PAGER配置如下（这样可以避免MAN手册页面中的ANSI Escape字符序列干扰（用于控制显示粗体等格式））</span><br><span class="line">#line 106</span><br><span class="line"></span><br><span class="line">PAGER &#x2F;usr&#x2F;bin&#x2F;less -isR</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">:wq</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自： &lt;a href=&quot;http://www.jackaiup.com/index/detail?id=10234&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.jackaiup.com/index/detail?id=10234&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;man手册对于我们在Mac或Linux系统下开发起着至关重要的作用，今天我们就来看一下如何在Mac系统下安装Man手册。&lt;/p&gt;
    
    </summary>
    
    
      <category term="man" scheme="https://blog.avdancedu.com/categories/man/"/>
    
    
      <category term="man" scheme="https://blog.avdancedu.com/tags/man/"/>
    
  </entry>
  
  <entry>
    <title>ffmpeg命令详解</title>
    <link href="https://blog.avdancedu.com/92d94a35/"/>
    <id>https://blog.avdancedu.com/92d94a35/</id>
    <published>2020-07-08T08:29:15.000Z</published>
    <updated>2020-07-08T08:51:37.235Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="http://upload-images.jianshu.io/upload_images/5956443-29b1eff4f8ce0e61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1600" alt="ffmpegX.png"></p><p>FFMPEG是特别强大的专门用于处理音视频的开源库。你既可以使用它的API对音视频进行处理，也可以使用它提供的工具，如 ffmpeg, ffplay, ffprobe，来编辑你的音视频文件。</p><p>本文将简要介绍一下 FFMPEG 库的基本目录结构及其功能，然后详细介绍一下我们在日常工作中，如何使用 ffmpeg 提供的工具来处理音视频文件。</p><a id="more"></a><h1 id="FFMPEG-目录及作用"><a href="#FFMPEG-目录及作用" class="headerlink" title="FFMPEG 目录及作用"></a>FFMPEG 目录及作用</h1><ul><li>libavcodec： 提供了一系列编码器的实现。</li><li>libavformat： 实现在流协议，容器格式及其本IO访问。</li><li>libavutil： 包括了hash器，解码器和各利工具函数。</li><li>libavfilter： 提供了各种音视频过滤器。</li><li>libavdevice： 提供了访问捕获设备和回放设备的接口。</li><li>libswresample： 实现了混音和重采样。</li><li>libswscale： 实现了色彩转换和缩放工能。</li></ul><h1 id="FFMPEG基本概念"><a href="#FFMPEG基本概念" class="headerlink" title="FFMPEG基本概念"></a>FFMPEG基本概念</h1><p>在讲解 FFMPEG 命令之前，我们先要介绍一些音视频格式的基要概念。</p><ul><li>音／视频流</li></ul><blockquote><p>在音视频领域，我们把一路音／视频称为一路<strong>流</strong>。如我们小时候经常使用VCD看港片，在里边可以选择粤语或国语声音，其实就是CD视频文件中存放了两路音频流，用户可以选择其中一路进行播放。</p></blockquote><ul><li>容器</li></ul><blockquote><p>我们一般把 MP4､ FLV、MOV等文件格式称之为<strong>容器</strong>。也就是在这些常用格式文件中，可以存放多路音视频文件。以 MP4 为例，就可以存放一路视频流，多路音频流，多路字幕流。</p></blockquote><ul><li>channel</li></ul><blockquote><p>channel是音频中的概念，称之为声道。在一路音频流中，可以有单声道，双声道或立体声。</p></blockquote><h1 id="FFMPEG-命令"><a href="#FFMPEG-命令" class="headerlink" title="FFMPEG 命令"></a>FFMPEG 命令</h1><p>我们按使用目的可以将 FFMPEG 命令分成以下几类：</p><ul><li>基本信息查询命令</li><li>录制</li><li>分解/复用</li><li>处理原始数据</li><li>滤镜</li><li>切割与合并</li><li>图／视互转</li><li>直播相关</li></ul><p>除了 FFMPEG 的基本信息查询命令外，其它命令都按下图所示的流程处理音视频。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> _______              ______________</span><br><span class="line">|       |            |              |</span><br><span class="line">| input |  demuxer   | encoded data |   decoder</span><br><span class="line">| file  | ---------&gt; | packets      | -----+</span><br><span class="line">|_______|            |______________|      |</span><br><span class="line">                                           v</span><br><span class="line">                                       _________</span><br><span class="line">                                      |         |</span><br><span class="line">                                      | decoded |</span><br><span class="line">                                      | frames  |</span><br><span class="line">                                      |_________|</span><br><span class="line"> ________             ______________       |</span><br><span class="line">|        |           |              |      |</span><br><span class="line">| output | &lt;-------- | encoded data | &lt;----+</span><br><span class="line">| file   |   muxer   | packets      |   encoder</span><br><span class="line">|________|           |______________|</span><br></pre></td></tr></table></figure><p>ffmpeg调用libavformat库（包含demuxers）来读取输入文件并获取包含编码数据的数据包。 当有多个输入文件时，ffmpeg会尝试通过跟踪任何活动输入流上的最低时间戳来使其保持同步。</p><p>然后将编码的数据包传送给解码器（除非为数据流选择了流拷贝，请参阅进一步描述）。 解码器产生未压缩的帧（原始视频/ PCM音频/ …），可以通过滤波进一步处理（见下一节）。 在过滤之后，帧被传递到编码器，编码器并输出编码的数据包。 最后，这些传递给复用器，将编码的数据包写入输出文件。</p><p>默认情况下，ffmpeg只包含输入文件中每种类型（视频，音频，字幕）的一个流，并将其添加到每个输出文件中。 它根据以下标准挑选每一个的“最佳”：对于视频，它是具有最高分辨率的流，对于音频，它是具有最多channel的流，对于字幕，是第一个字幕流。 在相同类型的几个流相等的情况下，选择具有最低索引的流。</p><p>您可以通过使用-vn / -an / -sn / -dn选项来禁用某些默认设置。 要进行全面的手动控制，请使用-map选项，该选项禁用刚描述的默认设置。</p><p>下面我们就来详细介绍一下这些命令。</p><h2 id="基本信息查询命令"><a href="#基本信息查询命令" class="headerlink" title="基本信息查询命令"></a>基本信息查询命令</h2><p>FFMPEG 可以使用下面的参数进行基本信息查询。例如，想查询一下现在使用的 FFMPEG 都支持哪些 filter，就可以用 <code>ffmpeg -filters</code> 来查询。详细参数说明如下：</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-version</td><td align="left">显示版本。</td></tr><tr><td align="left">-formats</td><td align="left">显示可用的格式（包括设备）。</td></tr><tr><td align="left">-demuxers</td><td align="left">显示可用的demuxers。</td></tr><tr><td align="left">-muxers</td><td align="left">显示可用的muxers。</td></tr><tr><td align="left">-devices</td><td align="left">显示可用的设备。</td></tr><tr><td align="left">-codecs</td><td align="left">显示libavcodec已知的所有编解码器。</td></tr><tr><td align="left">-decoders</td><td align="left">显示可用的解码器。</td></tr><tr><td align="left">-encoders</td><td align="left">显示所有可用的编码器。</td></tr><tr><td align="left">-bsfs</td><td align="left">显示可用的比特流filter。</td></tr><tr><td align="left">-protocols</td><td align="left">显示可用的协议。</td></tr><tr><td align="left">-filters</td><td align="left">显示可用的libavfilter过滤器。</td></tr><tr><td align="left">-pix_fmts</td><td align="left">显示可用的像素格式。</td></tr><tr><td align="left">-sample_fmts</td><td align="left">显示可用的采样格式。</td></tr><tr><td align="left">-layouts</td><td align="left">显示channel名称和标准channel布局。</td></tr><tr><td align="left">-colors</td><td align="left">显示识别的颜色名称。</td></tr></tbody></table><p>接下来介绍的是 FFMPEG 处理音视频时使用的命令格式与参数。</p><h2 id="命令基本格式及参数"><a href="#命令基本格式及参数" class="headerlink" title="命令基本格式及参数"></a>命令基本格式及参数</h2><p>下面是 FFMPEG 的基本命令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg [global_options] &#123;[input_file_options] -i input_url&#125; ...</span><br><span class="line"> &#123;[output_file_options] output_url&#125; ...</span><br></pre></td></tr></table></figure><p>ffmpeg 通过 -i 选项读取输任意数量的输入“文件”（可以是常规文件，管道，网络流，抓取设备等，并写入任意数量的输出“文件”。</p><p>原则上，每个输入/输出“文件”都可以包含任意数量的不同类型的视频流（视频/音频/字幕/附件/数据）。 流的数量和/或类型是由容器格式来限制。 选择从哪个输入进入到哪个输出将自动完成或使用 -map 选项。</p><p>要引用选项中的输入文件，您必须使用它们的索引（从0开始）。 例如。 第一个输入文件是0，第二个输入文件是1，等等。类似地，文件内的流被它们的索引引用。 例如。 2：3是指第三个输入文件中的第四个流。</p><p>上面就是 FFMPEG 处理音视频的常用命令，下面是一些常用参数：</p><h3 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h3><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-f fmt（输入/输出）</td><td align="left">强制输入或输出文件格式。 格式通常是自动检测输入文件，并从输出文件的文件扩展名中猜测出来，所以在大多数情况下这个选项是不需要的。</td></tr><tr><td align="left">-i url（输入）</td><td align="left">输入文件的网址</td></tr><tr><td align="left">-y（全局参数）</td><td align="left">覆盖输出文件而不询问。</td></tr><tr><td align="left">-n（全局参数）</td><td align="left">不要覆盖输出文件，如果指定的输出文件已经存在，请立即退出。</td></tr><tr><td align="left">-c [：stream_specifier] codec（输入/输出，每个流）</td><td align="left">选择一个编码器（当在输出文件之前使用）或解码器（当在输入文件之前使用时）用于一个或多个流。codec 是解码器/编码器的名称或 copy（仅输出）以指示该流不被重新编码。如：ffmpeg -i INPUT -map 0 -c:v libx264 -c:a copy OUTPUT</td></tr><tr><td align="left">-codec [：stream_specifier]编解码器（输入/输出，每个流）</td><td align="left">同 -c</td></tr><tr><td align="left">-t duration（输入/输出）</td><td align="left">当用作输入选项（在-i之前）时，限制从输入文件读取的数据的持续时间。当用作输出选项时（在输出url之前），在持续时间到达持续时间之后停止输出。</td></tr><tr><td align="left">-ss位置（输入/输出）</td><td align="left">当用作输入选项时（在-i之前），在这个输入文件中寻找位置。 请注意，在大多数格式中，不可能精确搜索，因此ffmpeg将在位置之前寻找最近的搜索点。 当转码和-accurate_seek被启用时（默认），搜索点和位置之间的这个额外的分段将被解码和丢弃。 当进行流式复制或使用-noaccurate_seek时，它将被保留。当用作输出选项（在输出url之前）时，解码但丢弃输入，直到时间戳到达位置。</td></tr><tr><td align="left">-frames [：stream_specifier] framecount（output，per-stream）</td><td align="left">停止在帧计数帧之后写入流。</td></tr><tr><td align="left">-filter [：stream_specifier] filtergraph（output，per-stream）</td><td align="left">创建由filtergraph指定的过滤器图，并使用它来过滤流。filtergraph是应用于流的filtergraph的描述，并且必须具有相同类型的流的单个输入和单个输出。在过滤器图形中，输入与标签中的标签相关联，标签中的输出与标签相关联。有关filtergraph语法的更多信息，请参阅ffmpeg-filters手册。</td></tr></tbody></table><h3 id="视频参数"><a href="#视频参数" class="headerlink" title="视频参数"></a>视频参数</h3><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-vframes num（输出）</td><td align="left">设置要输出的视频帧的数量。对于-frames：v，这是一个过时的别名，您应该使用它。</td></tr><tr><td align="left">-r [：stream_specifier] fps（输入/输出，每个流）</td><td align="left">设置帧率（Hz值，分数或缩写）。作为输入选项，忽略存储在文件中的任何时间戳，根据速率生成新的时间戳。这与用于-framerate选项不同（它在FFmpeg的旧版本中使用的是相同的）。如果有疑问，请使用-framerate而不是输入选项-r。作为输出选项，复制或丢弃输入帧以实现恒定输出帧频fps。</td></tr><tr><td align="left">-s [：stream_specifier]大小（输入/输出，每个流）</td><td align="left">设置窗口大小。作为输入选项，这是video_size专用选项的快捷方式，由某些分帧器识别，其帧尺寸未被存储在文件中。作为输出选项，这会将缩放视频过滤器插入到相应过滤器图形的末尾。请直接使用比例过滤器将其插入到开头或其他地方。格式是’wxh’（默认 - 与源相同）。</td></tr><tr><td align="left">-aspect [：stream_specifier] 宽高比（输出，每个流）</td><td align="left">设置方面指定的视频显示宽高比。aspect可以是浮点数字符串，也可以是num：den形式的字符串，其中num和den是宽高比的分子和分母。例如“4：3”，“16：9”，“1.3333”和“1.7777”是有效的参数值。如果与-vcodec副本一起使用，则会影响存储在容器级别的宽高比，但不会影响存储在编码帧中的宽高比（如果存在）。</td></tr><tr><td align="left">-vn（输出）</td><td align="left">禁用视频录制。</td></tr><tr><td align="left">-vcodec编解码器（输出）</td><td align="left">设置视频编解码器。这是-codec：v的别名。</td></tr><tr><td align="left">-vf filtergraph（输出）</td><td align="left">创建由filtergraph指定的过滤器图，并使用它来过滤流。</td></tr></tbody></table><h3 id="音频参数"><a href="#音频参数" class="headerlink" title="音频参数"></a>音频参数</h3><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-aframes（输出）</td><td align="left">设置要输出的音频帧的数量。这是-frames：a的一个过时的别名。</td></tr><tr><td align="left">-ar [：stream_specifier] freq（输入/输出，每个流）</td><td align="left">设置音频采样频率。对于输出流，它默认设置为相应输入流的频率。对于输入流，此选项仅适用于音频捕获设备和原始分路器，并映射到相应的分路器选件。</td></tr><tr><td align="left">-ac [：stream_specifier]通道（输入/输出，每个流）</td><td align="left">设置音频通道的数量。对于输出流，它默认设置为输入音频通道的数量。对于输入流，此选项仅适用于音频捕获设备和原始分路器，并映射到相应的分路器选件。</td></tr><tr><td align="left">-an（输出）</td><td align="left">禁用录音。</td></tr><tr><td align="left">-acodec编解码器（输入/输出）</td><td align="left">设置音频编解码器。这是-codec的别名：a。</td></tr><tr><td align="left">-sample_fmt [：stream_specifier] sample_fmt（输出，每个流）</td><td align="left">设置音频采样格式。使用-sample_fmts获取支持的样本格式列表。</td></tr><tr><td align="left">-af filtergraph（输出）</td><td align="left">创建由filtergraph指定的过滤器图，并使用它来过滤流。</td></tr></tbody></table><p>了解了这些基本信息后，接下来我们看看 FFMPEG 具体都能干些什么吧。</p><h2 id="录制"><a href="#录制" class="headerlink" title="录制"></a>录制</h2><p>首先通过下面的命令查看一下 mac 上都有哪些设备。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f avfoundation -list_devices true -i &quot;&quot;</span><br></pre></td></tr></table></figure><p><strong>录屏</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f avfoundation -i 1 -r 30 out.yuv</span><br></pre></td></tr></table></figure><ul><li>-f 指定使用 avfoundation 采集数据。</li><li>-i 指定从哪儿采集数据，它是一个文件索引号。在我的MAC上，1代表桌面（可以通过上面的命令查询设备索引号）。</li><li>-r 指定帧率。按ffmpeg官方文档说-r与-framerate作用相同，但实际测试时发现不同。-framerate 用于限制输入，而-r用于限制输出。</li></ul><blockquote><p>注意，桌面的输入对帧率没有要求，所以不用限制桌面的帧率。其实限制了也没用。</p></blockquote><p><strong>录屏+声音</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -f avfoundation -i 1:0  -r 29.97 -c:v libx264 -crf 0 -c:a libfdk_aac -profile:a aac_he_v2 -b:a 32k  out.flv</span><br></pre></td></tr></table></figure><ul><li>-i 1:0 冒号前面的 “1” 代表的屏幕索引号。冒号后面的”0”代表的声音索相号。</li><li>-c:v 与参数 -vcodec 一样，表示视频编码器。c 是 codec 的缩写，v 是video的缩写。</li><li>-crf 是 x264 的参数。 0 表式无损压缩。</li><li>-c:a 与参数 -acodec 一样，表示音频编码器。</li><li>-profile 是 fdk_aac 的参数。 aac_he_v2 表式使用 AAC_HE v2 压缩数据。</li><li>-b:a 指定音频码率。 b 是 bitrate的缩写, a是 audio的缩与。</li></ul><p><strong>Linux下录屏</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f x11grab -s 640*480 -r 20 -i :0.0 test.mp4</span><br></pre></td></tr></table></figure><p><strong>录视频</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -framerate 30 -f avfoundation -i 0 out.mp4</span><br></pre></td></tr></table></figure><ul><li>-framerate 限制视频的采集帧率。这个必须要根据提示要求进行设置，如果不设置就会报错。</li><li>-f 指定使用 avfoundation 采集数据。</li><li>-i 指定视频设备的索引号。</li></ul><p><strong>视频+音频</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -framerate 30 -f avfoundation -i 0:0 out.mp4</span><br></pre></td></tr></table></figure><p><strong>录音</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f avfoundation -i :0 out.wav</span><br></pre></td></tr></table></figure><p><strong>录制音频裸数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -f avfoundation -i :0 -ar 44100 -f s16le out.pcm</span><br></pre></td></tr></table></figure><p><strong>在Windows下录制播放的声音</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -f dshow -i audio&#x3D;&quot;立体声混音 (Realtek High Definition Audio)&quot; -ar 48000  -acodec aac -bsf:a aac_adtstoasc -f flv temp.flv</span><br></pre></td></tr></table></figure><h2 id="分解与复用"><a href="#分解与复用" class="headerlink" title="分解与复用"></a>分解与复用</h2><p>流拷贝是通过将 copy 参数提供给-codec选项来选择流的模式。它使得ffmpeg省略了指定流的解码和编码步骤，所以它只能进行多路分解和多路复用。 这对于更改容器格式或修改容器级元数据很有用。 在这种情况下，上图将简化为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> _______              ______________            ________</span><br><span class="line">|       |            |              |          |        |</span><br><span class="line">| input |  demuxer   | encoded data |  muxer   | output |</span><br><span class="line">| file  | ---------&gt; | packets      | -------&gt; | file   |</span><br><span class="line">|_______|            |______________|          |________|</span><br></pre></td></tr></table></figure><p>由于没有解码或编码，速度非常快，没有质量损失。 但是，由于许多因素，在某些情况下可能无法正常工作。 应用过滤器显然也是不可能的，因为过滤器处理未压缩的数据。</p><p><strong>抽取音频流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -acodec copy -vn out.aac</span><br></pre></td></tr></table></figure><ul><li>acodec: 指定音频编码器，copy 指明只拷贝，不做编解码。</li><li>vn: v 代表视频，n 代表 no 也就是无视频的意思。</li></ul><p><strong>抽取视频流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -vcodec copy -an out.h264</span><br></pre></td></tr></table></figure><ul><li>vcodec: 指定视频编码器，copy 指明只拷贝，不做编解码。</li><li>an: a 代表视频，n 代表 no 也就是无音频的意思。</li></ul><p><strong>转格式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -vcodec copy -acodec copy out.flv</span><br></pre></td></tr></table></figure><p>上面的命令表式的是音频、视频都直接 copy，只是将 mp4 的封装格式转成了flv。</p><p><strong>音视频合并</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.h264 -i out.aac -vcodec copy -acodec copy out.mp4</span><br></pre></td></tr></table></figure><h2 id="处理原始数据"><a href="#处理原始数据" class="headerlink" title="处理原始数据"></a>处理原始数据</h2><p><strong>提取YUV数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -an -c:v rawvideo -pix_fmt yuv420p out.yuv</span><br><span class="line">ffplay -s wxh out.yuv</span><br></pre></td></tr></table></figure><ul><li>-c:v rawvideo 指定将视频转成原始数据</li><li>-pix_fmt yuv420p 指定转换格式为yuv420p</li></ul><p><strong>YUV转H264</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f rawvideo -pix_fmt yuv420p -s 320x240 -r 30 -i out.yuv -c:v libx264 -f rawvideo out.h264</span><br></pre></td></tr></table></figure><p><strong>提取PCM数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -vn -ar 44100 -ac 2 -f s16le out.pcm</span><br><span class="line">ffplay -ar 44100 -ac 2 -f s16le -i out.pcm</span><br></pre></td></tr></table></figure><p><strong>PCM转WAV</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f s16be -ar 8000 -ac 2 -acodec pcm_s16be -i input.raw output.wav</span><br></pre></td></tr></table></figure><h2 id="滤镜"><a href="#滤镜" class="headerlink" title="滤镜"></a>滤镜</h2><p>在编码之前，ffmpeg可以使用libavfilter库中的过滤器处理原始音频和视频帧。 几个链式过滤器形成一个过滤器图形。 ffmpeg区分两种类型的过滤器图形：简单和复杂。</p><h3 id="简单滤镜"><a href="#简单滤镜" class="headerlink" title="简单滤镜"></a>简单滤镜</h3><p>简单的过滤器图是那些只有一个输入和输出，都是相同的类型。 在上面的图中，它们可以通过在解码和编码之间插入一个额外的步骤来表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> _________                        ______________</span><br><span class="line">|         |                      |              |</span><br><span class="line">| decoded |                      | encoded data |</span><br><span class="line">| frames  |\                   _ | packets      |</span><br><span class="line">|_________| \                  &#x2F;||______________|</span><br><span class="line">             \   __________   &#x2F;</span><br><span class="line">  simple     _\||          | &#x2F;  encoder</span><br><span class="line">  filtergraph   | filtered |&#x2F;</span><br><span class="line">                | frames   |</span><br><span class="line">                |__________|</span><br></pre></td></tr></table></figure><p>简单的filtergraphs配置了per-stream-filter选项（分别为视频和音频使用-vf和-af别名）。 一个简单的视频filtergraph可以看起来像这样的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> _______        _____________        _______        ________</span><br><span class="line">|       |      |             |      |       |      |        |</span><br><span class="line">| input | ---&gt; | deinterlace | ---&gt; | scale | ---&gt; | output |</span><br><span class="line">|_______|      |_____________|      |_______|      |________|</span><br></pre></td></tr></table></figure><p>请注意，某些滤镜会更改帧属性，但不会改变帧内容。 例如。 上例中的fps过滤器会改变帧数，但不会触及帧内容。 另一个例子是setpts过滤器，它只设置时间戳，否则不改变帧。</p><h3 id="复杂滤镜"><a href="#复杂滤镜" class="headerlink" title="复杂滤镜"></a>复杂滤镜</h3><p>复杂的过滤器图是那些不能简单描述为应用于一个流的线性处理链的过滤器图。 例如，当图形有多个输入和/或输出，或者当输出流类型与输入不同时，就是这种情况。 他们可以用下图来表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> _________</span><br><span class="line">|         |</span><br><span class="line">| input 0 |\                    __________</span><br><span class="line">|_________| \                  |          |</span><br><span class="line">             \   _________    &#x2F;| output 0 |</span><br><span class="line">              \ |         |  &#x2F; |__________|</span><br><span class="line"> _________     \| complex | &#x2F;</span><br><span class="line">|         |     |         |&#x2F;</span><br><span class="line">| input 1 |----&gt;| filter  |\</span><br><span class="line">|_________|     |         | \   __________</span><br><span class="line">               &#x2F;| graph   |  \ |          |</span><br><span class="line">              &#x2F; |         |   \| output 1 |</span><br><span class="line"> _________   &#x2F;  |_________|    |__________|</span><br><span class="line">|         | &#x2F;</span><br><span class="line">| input 2 |&#x2F;</span><br><span class="line">|_________|</span><br></pre></td></tr></table></figure><p>复杂的过滤器图使用-filter_complex选项进行配置。 请注意，此选项是全局性的，因为复杂的过滤器图形本质上不能与单个流或文件明确关联。</p><p>-lavfi选项等同于-filter_complex。</p><p>一个复杂的过滤器图的一个简单的例子是覆盖过滤器，它有两个视频输入和一个视频输出，包含一个视频叠加在另一个上面。 它的音频对应是amix滤波器。</p><p><strong>添加水印</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4  -vf &quot;movie&#x3D;logo.png,scale&#x3D;64:48[watermask];[in][watermask] overlay&#x3D;30:10 [out]&quot; water.mp4</span><br></pre></td></tr></table></figure><ul><li>-vf中的 movie 指定logo位置。scale 指定 logo 大小。overlay 指定 logo 摆放的位置。</li></ul><p><strong>删除水印</strong><br>先通过 ffplay 找到要删除 LOGO 的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffplay -i test.flv -vf delogo&#x3D;x&#x3D;806:y&#x3D;20:w&#x3D;70:h&#x3D;80:show&#x3D;1</span><br></pre></td></tr></table></figure><p>使用 delogo 滤镜删除 LOGO</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.flv -vf delogo&#x3D;x&#x3D;806:y&#x3D;20:w&#x3D;70:h&#x3D;80 output.flv</span><br></pre></td></tr></table></figure><p><strong>视频缩小一倍</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -vf scale&#x3D;iw&#x2F;2:-1 scale.mp4</span><br></pre></td></tr></table></figure><ul><li>-vf scale 指定使用简单过滤器 scale，iw/2:-1 中的 iw 指定按整型取视频的宽度。 -1 表示高度随宽度一起变化。</li></ul><p><strong>视频裁剪</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i VR.mov  -vf crop&#x3D;in_w-200:in_h-200 -c:v libx264 -c:a copy -video_size 1280x720 vr_new.mp4</span><br></pre></td></tr></table></figure><p>crop 格式：crop=out_w:out_h:x:y</p><ul><li>out_w: 输出的宽度。可以使用 in_w 表式输入视频的宽度。</li><li>out_h: 输出的高度。可以使用 in_h 表式输入视频的高度。</li><li>x : X坐标</li><li>y : Y坐标</li></ul><blockquote><p>如果 x和y 设置为 0,说明从左上角开始裁剪。如果不写是从中心点裁剪。</p></blockquote><p><strong>倍速播放</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -filter_complex &quot;[0:v]setpts&#x3D;0.5*PTS[v];[0:a]atempo&#x3D;2.0[a]&quot; -map &quot;[v]&quot; -map &quot;[a]&quot; speed2.0.mp4</span><br></pre></td></tr></table></figure><ul><li>-filter_complex 复杂滤镜，[0:v]表示第一个（文件索引号是0）文件的视频作为输入。setpts=0.5*PTS表示每帧视频的pts时间戳都乘0.5 ，也就是差少一半。[v]表示输出的别名。音频同理就不详述了。</li><li>map 可用于处理复杂输出，如可以将指定的多路流输出到一个输出文件，也可以指定输出到多个文件。”[v]” 复杂滤镜输出的别名作为输出文件的一路流。上面 map的用法是将复杂滤镜输出的视频和音频输出到指定文件中。</li></ul><p><strong>对称视频</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -i out.mp4 -filter_complex &quot;[0:v]pad&#x3D;w&#x3D;2*iw[a];[0:v]hflip[b];[a][b]overlay&#x3D;x&#x3D;w&quot; duicheng.mp4</span><br></pre></td></tr></table></figure><ul><li>hflip 水平翻转</li></ul><p>如果要修改为垂直翻转可以用vflip。</p><p><strong>画中画</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -i out1.mp4 -filter_complex &quot;[1:v]scale&#x3D;w&#x3D;176:h&#x3D;144:force_original_aspect_ratio&#x3D;decrease[ckout];[0:v][ckout]overlay&#x3D;x&#x3D;W-w-10:y&#x3D;0[out]&quot; -map &quot;[out]&quot; -movflags faststart new.mp4</span><br></pre></td></tr></table></figure><p><strong>录制画中画</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -f avfoundation -i &quot;1&quot; -framerate 30 -f avfoundation -i &quot;0:0&quot;</span><br><span class="line">-r 30 -c:v libx264 -preset ultrafast</span><br><span class="line">-c:a libfdk_aac -profile:a aac_he_v2 -ar 44100 -ac 2</span><br><span class="line">-filter_complex &quot;[1:v]scale&#x3D;w&#x3D;176:h&#x3D;144:force_original_aspect_ratio&#x3D;decrease[a];[0:v][a]overlay&#x3D;x&#x3D;W-w-10:y&#x3D;0[out]&quot;</span><br><span class="line">-map &quot;[out]&quot; -movflags faststart -map 1:a b.mp4</span><br></pre></td></tr></table></figure><p><strong>多路视频拼接</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -f avfoundation -i &quot;1&quot; -framerate 30 -f avfoundation   -i &quot;0:0&quot; -r 30 -c:v libx264 -preset ultrafast -c:a libfdk_aac -profile:a aac_he_v2 -ar 44100 -ac 2 -filter_complex &quot;[0:v]scale&#x3D;320:240[a];[a]pad&#x3D;640:240[b];[b][1:v]overlay&#x3D;320:0[out]&quot; -map &quot;[out]&quot; -movflags faststart  -map 1:a  c.mp4</span><br></pre></td></tr></table></figure><p><strong>滤镜加水印</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i killer.mp4 -filter_complex &quot;movie&#x3D;.&#x2F;logo&#x2F;daka.png,scale&#x3D;64:48[w];[0:v]curves&#x3D;vintage[o];[o][w]overlay&#x3D;30:10[out]&quot; -map &quot;[out]&quot; -map 0:a test1.mp4</span><br></pre></td></tr></table></figure><p><strong>多张图片合成一张</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i killer.mp4 -vf &quot;select&#x3D;not(mod(n\,250)),scale&#x3D;320:240,tile&#x3D;2x3&quot; -an  out%3d.png</span><br></pre></td></tr></table></figure><h2 id="一些比较有意思的滤镜"><a href="#一些比较有意思的滤镜" class="headerlink" title="一些比较有意思的滤镜"></a>一些比较有意思的滤镜</h2><ul><li><p>镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crop&#x3D;iw&#x2F;2:ih:0:0,split[left][tmp];[tmp]hflip[right];</span><br></pre></td></tr></table></figure></li><li><p>复古</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curves&#x3D;vintage;</span><br></pre></td></tr></table></figure></li><li><p>光晕</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vignette&#x3D;PI&#x2F;4</span><br></pre></td></tr></table></figure></li><li><p>变暗</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colorlevels&#x3D;rimin&#x3D;0.058:gimin&#x3D;0.058:bimin&#x3D;0.058</span><br></pre></td></tr></table></figure></li><li><p>增加对比度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fftfilt&#x3D;dc_Y&#x3D;0:weight_Y&#x3D;&#39;exp(-4 * ((Y+X)&#x2F;(W+H)))</span><br></pre></td></tr></table></figure></li><li><p>降噪</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hqdn3d&#x3D;luma_spatial&#x3D;15.0</span><br></pre></td></tr></table></figure></li><li><p>强对比度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curves&#x3D;strong_contrast</span><br></pre></td></tr></table></figure></li><li><p>变亮</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curves&#x3D;lighter</span><br></pre></td></tr></table></figure></li><li><p>锐化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fftfilt&#x3D;dc_Y&#x3D;0:weight_Y&#x3D;&#39;1+squish(1-(Y+X)&#x2F;100)&#39;</span><br></pre></td></tr></table></figure></li><li><p>低通滤波</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fftfilt&#x3D;dc_Y&#x3D;0:weight_Y&#x3D;&#39;squish((Y+X)&#x2F;100-1)&#39;</span><br></pre></td></tr></table></figure></li><li><p>高通滤波</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fftfilt&#x3D;dc_Y&#x3D;128:weight_Y&#x3D;&#39;squish(1-(Y+X)&#x2F;100)&#39;</span><br></pre></td></tr></table></figure></li><li><p>复古</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curves&#x3D;vintage</span><br></pre></td></tr></table></figure></li><li><p>边缘检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edgedetect</span><br></pre></td></tr></table></figure></li><li><p>底片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">negate</span><br></pre></td></tr></table></figure></li><li><p>彩色底片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curves &#x3D; ‘none’‘color_negative’</span><br></pre></td></tr></table></figure></li></ul><h2 id="音视频的拼接与裁剪"><a href="#音视频的拼接与裁剪" class="headerlink" title="音视频的拼接与裁剪"></a>音视频的拼接与裁剪</h2><p><strong>裁剪</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -ss 00:00:00 -t 10 out1.mp4</span><br></pre></td></tr></table></figure><ul><li>-ss 指定裁剪的开始时间，精确到秒</li><li>-t 被裁剪后的时长。</li></ul><p><strong>视频合并</strong></p><p>首先创建一个 inputs.txt 文件，文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file &#39;1.flv&#39;</span><br><span class="line">file &#39;2.flv&#39;</span><br><span class="line">file &#39;3.flv&#39;</span><br></pre></td></tr></table></figure><p>然后执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f concat -i inputs.txt -c copy output.flv</span><br></pre></td></tr></table></figure><p><strong>音频合并</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i text.mp3 -i silenceall.mp3 -filter_complex &#39;[0:0] [1:0] concat&#x3D;n&#x3D;2:v&#x3D;0:a&#x3D;1 [a]&#39; -map [a] test.mp3</span><br></pre></td></tr></table></figure><p><strong>音频混音</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.mp4 -i test.mp3 -filter_complex &quot;[0:a] [1:a]amerge&#x3D;inputs&#x3D;2[aout]&quot; -map &quot;[aout]&quot; -ac 2 mix_amerge.aac</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i INPUT1 -i INPUT2 -i INPUT3 -filter_complex &#39;amix&#x3D;inputs&#x3D;3:duration&#x3D;first:dropout_transition&#x3D;3&#39; OUTPUT</span><br></pre></td></tr></table></figure><ul><li>inputs: The number of inputs. If unspecified, it defaults to 2.//输入的数量，如果没有指明，默认为2.</li><li>duration: How to determine the end-of-stream.//决定了流的结束</li><li>longest: The duration of the longest input. (default)//最长输入的持续时间</li><li>shortest: The duration of the shortest input.//最短输入的持续时间</li><li>first: The duration of the first input.//第一个输入的持续时间</li><li>dropout_transition: The transition time, in seconds, for volume renormalization when an input stream ends. The default value is 2 seconds.//输入流结束时（音频）容量重整化的转换时间（以秒为单位）。 默认值为2秒。</li></ul><blockquote><p>注： amerge 与amix 的区别<br>amerge terminates with the shortest input (always) and amix terminates with the longest input, by default. So the former will always truncate when streams are of different length.</p></blockquote><p><strong>hls切片</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -c:v libx264 -c:a libfdk_aac -strict -2 -f hls  out.m3u8</span><br></pre></td></tr></table></figure><ul><li>-strict -2 指明音频使有AAC。</li><li>-f hls 转成 m3u8 格式。</li></ul><p><strong>将ts文件按时间切片</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -i somefile.ts  -f segment -segment_time 3  -c copy out%03d.ts</span><br></pre></td></tr></table></figure><h2 id="视频图片互转"><a href="#视频图片互转" class="headerlink" title="视频图片互转"></a>视频图片互转</h2><p><strong>视频转JPEG</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.flv -r 1 -f image2 image-%3d.jpeg</span><br></pre></td></tr></table></figure><p><strong>视频转gif</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -ss 00:00:00 -t 10 out.gif</span><br></pre></td></tr></table></figure><p><strong>图片转视频</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -f image2 -i image-%3d.jpeg images.mp4</span><br></pre></td></tr></table></figure><p><strong>一张图片转成5秒视频</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -loop 1 -i .&#x2F;xxx.jpeg -pix_fmt yuv420p -c:v libx264 -preset veryfast -r 25 -t 5 b.mp4</span><br></pre></td></tr></table></figure><h2 id="直播相关"><a href="#直播相关" class="headerlink" title="直播相关"></a>直播相关</h2><p><strong>推流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i out.mp4 -c copy -f flv rtmp:&#x2F;&#x2F;server&#x2F;live&#x2F;streamName</span><br></pre></td></tr></table></figure><ul><li>re的含义 ，Read input at native frame rate. Mainly used to simulate a grab device, or live input stream (e.g. when reading from a file). Should not be used with actual grab devices or live input streams (where it can cause packet loss). By default ffmpeg attempts to read the input(s) as fast as possible. This option will slow down the reading of the input(s) to the native frame rate of the input(s). It is useful for real-time output (e.g. live streaming).</li></ul><p><strong>推rtsp流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i input -f rtsp -muxdelay 0.1 rtsp:&#x2F;&#x2F;server&#x2F;live.sdp</span><br></pre></td></tr></table></figure><p><strong>循环推流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -stream_loop 1 -i out.mp4  -c copy -f flv rtmp:&#x2F;&#x2F;server&#x2F;live&#x2F;streamName</span><br></pre></td></tr></table></figure><p><strong>拉流保存</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i rtmp:&#x2F;&#x2F;server&#x2F;live&#x2F;streamName -c copy dump.flv</span><br></pre></td></tr></table></figure><p><strong>转流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i rtmp:&#x2F;&#x2F;server&#x2F;live&#x2F;originalStream -c:a copy -c:v copy -f flv rtmp:&#x2F;&#x2F;server&#x2F;live&#x2F;h264Stream</span><br></pre></td></tr></table></figure><p><strong>实时推流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -framerate 15 -f avfoundation -i &quot;1&quot; -s 1280x720 -c:v libx264  -f  flv rtmp:&#x2F;&#x2F;localhost:1935&#x2F;live&#x2F;room</span><br></pre></td></tr></table></figure><h2 id="ffplay"><a href="#ffplay" class="headerlink" title="ffplay"></a>ffplay</h2><p><strong>播放YUV 数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffplay -pix_fmt nv12 -s 192x144 1.yuv</span><br></pre></td></tr></table></figure><p><strong>播放YUV中的 Y平面</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffplay -pix_fmt nv21 -s 640x480 -vf extractplanes&#x3D;&#39;y&#39; 1.yuv</span><br></pre></td></tr></table></figure><h2 id="查看多媒体文件详细信息"><a href="#查看多媒体文件详细信息" class="headerlink" title="查看多媒体文件详细信息"></a>查看多媒体文件详细信息</h2><p><strong>输出每路流最详细的信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffprobe -print_format json -show_streams 多媒体文件</span><br></pre></td></tr></table></figure><p><strong>输出帧信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffprobe -show_frames  多媒体文件</span><br></pre></td></tr></table></figure><p><strong>输出包信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffprobe -show_packets 多媒体文件</span><br></pre></td></tr></table></figure><h2 id="我的ffmpeg视频课地址"><a href="#我的ffmpeg视频课地址" class="headerlink" title="我的ffmpeg视频课地址"></a>我的ffmpeg视频课地址</h2><p><a href="http://www.imooc.com/u/4873493/courses?sort=publish" target="_blank" rel="noopener">课程主页地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;http://upload-images.jianshu.io/upload_images/5956443-29b1eff4f8ce0e61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1600&quot; alt=&quot;ffmpegX.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;FFMPEG是特别强大的专门用于处理音视频的开源库。你既可以使用它的API对音视频进行处理，也可以使用它提供的工具，如 ffmpeg, ffplay, ffprobe，来编辑你的音视频文件。&lt;/p&gt;
&lt;p&gt;本文将简要介绍一下 FFMPEG 库的基本目录结构及其功能，然后详细介绍一下我们在日常工作中，如何使用 ffmpeg 提供的工具来处理音视频文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="音视频" scheme="https://blog.avdancedu.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="ffmpeg" scheme="https://blog.avdancedu.com/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>深入剖析WebRTC之事件机制Slot</title>
    <link href="https://blog.avdancedu.com/a35f406b/"/>
    <id>https://blog.avdancedu.com/a35f406b/</id>
    <published>2020-07-07T13:05:13.000Z</published>
    <updated>2020-07-07T13:09:13.053Z</updated>
    
    <content type="html"><![CDATA[<p>我最早了解到 sigslot 大概是在 2007年 左右，当时在QT中大量使用了 sigslot 的概念。 现在 WebRTC 中也大量使用了 sigslot 这种机制来处理底层的事件。它对我们阅读WebRTC代码至关重要。本篇文章就详细介绍一下 sigslot。</p><a id="more"></a><h2 id="Sigslot作用"><a href="#Sigslot作用" class="headerlink" title="Sigslot作用"></a>Sigslot作用</h2><p>Sigslot 的作用一句话表式就是为了<strong>解耦</strong>。例如，有两个类 A 和 B，如果 B 使用 A, 就必须在 B 类中写入与 A 类有关的代码。看下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B(A&amp; a)&#123;</span><br><span class="line">m_a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcB</span><span class="params">()</span></span>&#123;</span><br><span class="line">m_a.funcA(); <span class="comment">//这里调用了A类的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">A m_a; <span class="comment">//引用 A 类型成员变量。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">A a;</span><br><span class="line"><span class="function">B <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">b.funcB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<strong>弊端</strong>是 B 中必须要声名使用 A。如果我们的项目特别复杂，这样的使用方式在后期维护时很容易让我们掉入“陷阱”。有没有一种通用的办法可以做到在 B 中不用使用 A 也可以调用 A 中的方法呢？答案就是使用 <strong>sigslot</strong>。我们看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> sigslot::has_slot&lt;&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">funcA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    sigslot::signal0&lt;&gt; sender;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在运行时才将 a 和 b 绑定到一起</span></span><br><span class="line">b.sender.<span class="built_in">connect</span>(&amp;a, &amp;A::funcA);</span><br><span class="line">b.sender();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以看到 B 中没有一行与 A 相关的代码。只在 main 函数中（也就是在运行时）才知道 A 与 B 有关联关系。是不是觉得很神奇呢？下面我们就看一下它的实现原理。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>sigslot的原理其实非常简单，它就是一个变化的观察者模式。观察者模式如下所示：</p><p><img data-src="http://upload-images.jianshu.io/upload_images/5956443-cd6a57418c8ff9fc.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""></p><p>观察者模式，首先让 Observer(“观察者”)对象 注册到 Subject(“被观察者”) 对象中。当 Subject 状态发生变化时，遍历所有注册到自己的 Observer 对象，并调用它们的 notify方法。</p><p>sigslot与观察者模式类似，它使用signal(“信号”)和slot(“槽”)，区别在于 signal 主动连接自己感兴趣的类及其方法，将它们保存到自己的列表中。当发射信号时，它遍历所有的连接，调用 slot（“槽”） 方法。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>下面我们看一下 WebRTC 中是如何使用 sigslot 的。</p><ul><li>首先，定义 slot(“槽”)，也就是事件处理函数。在WebRTC中定义槽必须继承 has_slots&lt;&gt;。如下图所示：</li></ul><p><img data-src="http://upload-images.jianshu.io/upload_images/5956443-9db34af78eb1e4ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""></p><ul><li><p>其次，定义 signal (“信号”) ，也就是发送的信号。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sigslot::signal1&lt;AsyncSocket*,</span><br><span class="line">           sigslot::multi_threaded_local&gt; SignalWriteEvent;</span><br></pre></td></tr></table></figure></li><li><p>然后，将 signal 与 slot 连接到一起。在这里就是将 AsyncUDPSocket和 OnWriteEvent方法与signal绑定到一起。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">socket_-&gt;SignalWriteEvent.<span class="built_in">connect</span>(<span class="keyword">this</span>,</span><br><span class="line">&amp;AsyncUDPSocket::OnWriteEvent);</span><br></pre></td></tr></table></figure></li><li><p>最后，发送信号。在 WebRTC中根据参数的不同定义了许多 signal，如 signal1 说明带一个参数，signal2说明带两个参数。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SignalWriteEvent(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><p>下面是对 sigslog 的类关系图及关键代码与其详细注释。</p><p><img data-src="http://upload-images.jianshu.io/upload_images/5956443-e2f8002c19fa7338.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// On our copy of sigslot.h, we set single threading as default.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSLOT_DEFAULT_MT_POLICY single_threaded</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(SIGSLOT_PURE_ISO) ||                   \</span></span><br><span class="line">    (!defined(WEBRTC_WIN) &amp;&amp; !defined(__GNUG__) &amp;&amp; \</span><br><span class="line">     !defined(SIGSLOT_USE_POSIX_THREADS))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SIGSLOT_SINGLE_THREADED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(WEBRTC_WIN)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SIGSLOT_HAS_WIN32_THREADS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(WIN32_LEAN_AND_MEAN)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"webrtc/rtc_base/win32.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__GNUG__) || defined(SIGSLOT_USE_POSIX_THREADS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SIGSLOT_HAS_POSIX_THREADS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SIGSLOT_SINGLE_THREADED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SIGSLOT_DEFAULT_MT_POLICY</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SIGSLOT_SINGLE_THREADED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSLOT_DEFAULT_MT_POLICY single_threaded</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSLOT_DEFAULT_MT_POLICY multi_threaded_local</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> change this namespace to rtc?</span></span><br><span class="line"><span class="keyword">namespace</span> sigslot &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//这面这大段代码是为了实现智能锁使用的。</span></span><br><span class="line"><span class="comment">//它会根据不同的平台初始化不同的互斥量，并调用不同的锁函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是 Window 平台</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SIGSLOT_HAS_WIN32_THREADS</span></span><br><span class="line"><span class="comment">// The multi threading policies only get compiled in if they are enabled.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是全局线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">multi_threaded_global</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  multi_threaded_global() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> isinitialised = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isinitialised) &#123;</span><br><span class="line">      InitializeCriticalSection(get_critsec());</span><br><span class="line">      isinitialised = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; EnterCriticalSection(get_critsec()); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; LeaveCriticalSection(get_critsec()); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function">CRITICAL_SECTION* <span class="title">get_critsec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> CRITICAL_SECTION g_critsec;</span><br><span class="line">    <span class="keyword">return</span> &amp;g_critsec;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是本地线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">multi_threaded_local</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  multi_threaded_local() &#123; InitializeCriticalSection(&amp;m_critsec); &#125;</span><br><span class="line"></span><br><span class="line">  multi_threaded_local(<span class="keyword">const</span> multi_threaded_local&amp;) &#123;</span><br><span class="line">    InitializeCriticalSection(&amp;m_critsec);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~multi_threaded_local() &#123; DeleteCriticalSection(&amp;m_critsec); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; EnterCriticalSection(&amp;m_critsec); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; LeaveCriticalSection(&amp;m_critsec); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  CRITICAL_SECTION m_critsec;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// _SIGSLOT_HAS_WIN32_THREADS</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//非window平台</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SIGSLOT_HAS_POSIX_THREADS</span></span><br><span class="line"><span class="comment">// The multi threading policies only get compiled in if they are enabled.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是全局线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">multi_threaded_global</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; pthread_mutex_lock(get_mutex()); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; pthread_mutex_unlock(get_mutex()); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span>* <span class="title">get_mutex</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是本地线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">multi_threaded_local</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  multi_threaded_local() &#123; pthread_mutex_init(&amp;m_mutex, <span class="literal">nullptr</span>); &#125;</span><br><span class="line">  multi_threaded_local(<span class="keyword">const</span> multi_threaded_local&amp;) &#123;</span><br><span class="line">    pthread_mutex_init(&amp;m_mutex, <span class="literal">nullptr</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ~multi_threaded_local() &#123; pthread_mutex_destroy(&amp;m_mutex); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; pthread_mutex_lock(&amp;m_mutex); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; pthread_mutex_unlock(&amp;m_mutex); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">pthread_mutex_t</span> m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// _SIGSLOT_HAS_POSIX_THREADS</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据不同的策略调用不同的锁。</span></span><br><span class="line"><span class="comment">//这里的策略就是不同的平台</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">mt_policy</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">lock_block</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  mt_policy* m_mutex;</span><br><span class="line"></span><br><span class="line">  lock_block(mt_policy* mtx) : m_mutex(mtx) &#123; m_mutex-&gt;lock(); &#125;</span><br><span class="line"></span><br><span class="line">  ~lock_block() &#123; m_mutex-&gt;unlock(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">signal_base_interface</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">has_slots_interface</span> &#123;</span></span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">signal_connect</span><span class="params">(_signal_base_interface* sender)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">signal_disconnect</span><span class="params">(_signal_base_interface* sender)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">disconnect_all</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">signal_base_interface</span> &#123;</span></span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">slot_disconnect</span><span class="params">(has_slots_interface* pslot)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">slot_duplicate</span><span class="params">(<span class="keyword">const</span> has_slots_interface* poldslot,</span></span></span><br><span class="line"><span class="function"><span class="params">                      has_slots_interface* pnewslot)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该类是一个特别重要的类</span></span><br><span class="line"><span class="comment">// signal与slot绑定之前，必须先将槽对象与槽方法组成 connection</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">opaque_connection</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">emit_t</span>)</span><span class="params">(<span class="keyword">const</span> _opaque_connection*)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//联合结构体，用于函数转换</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> FromT, <span class="keyword">typename</span> ToT&gt;</span><br><span class="line">  <span class="keyword">union</span> union_caster &#123;</span><br><span class="line">    FromT from;</span><br><span class="line">    ToT to;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//信号发射函数指针</span></span><br><span class="line">  <span class="keyword">emit_t</span> pemit;</span><br><span class="line">  <span class="comment">//存放“槽”对象</span></span><br><span class="line">  has_slots_interface* pdest;</span><br><span class="line">  <span class="comment">// Pointers to member functions may be up to 16 bytes for virtual classes,</span></span><br><span class="line">  <span class="comment">// so make sure we have enough space to store it.</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> pmethod[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  <span class="comment">//在构造connect时，要传入槽对象和槽类方法指针</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> DestT, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  _opaque_connection(DestT* pd, <span class="keyword">void</span> (DestT::*pm)(Args...)) : pdest(pd) &#123;</span><br><span class="line">    <span class="comment">//定义成员函数指针，与C语言中的函数指针是类似的</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(DestT::*<span class="keyword">pm_t</span>)</span><span class="params">(Args...)</span></span>;</span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(<span class="keyword">pm_t</span>) &lt;= <span class="keyword">sizeof</span>(pmethod),</span><br><span class="line">                  <span class="string">"Size of slot function pointer too large."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">memcpy</span>(pmethod, &amp;pm, <span class="keyword">sizeof</span>(<span class="keyword">pm_t</span>));</span><br><span class="line"></span><br><span class="line"> <span class="comment">//定义了一个函数指针</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">em_t</span>)</span><span class="params">(<span class="keyword">const</span> _opaque_connection* self, Args...)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过下面的方法，将 pemit 函数变理指向了 emitter 函数。</span></span><br><span class="line">    union_caster&lt;<span class="keyword">em_t</span>, <span class="keyword">emit_t</span>&gt; caster2;</span><br><span class="line">    <span class="comment">//注意 emitter后面的是模版参数，不是函数参数，这里不要弄混了。</span></span><br><span class="line">    caster2.from = &amp;_opaque_connection::emitter&lt;DestT, Args...&gt;;</span><br><span class="line">    pemit = caster2.to;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回"槽"对象</span></span><br><span class="line">  <span class="function">has_slots_interface* <span class="title">getdest</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pdest; &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">//因为在构造函数里已经将 pemit 设置为 emitter 了，</span></span><br><span class="line">  <span class="comment">//所以下面的代码就是调用 emitter 函数。为里只不过做了一次函数指针类型转换。</span></span><br><span class="line">  <span class="comment">//也就是说调用 connect 的 emit 方法，实际调的是 emitter。</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">emit</span><span class="params">(Args... args)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">em_t</span>)</span><span class="params">(<span class="keyword">const</span> _opaque_connection*, Args...)</span></span>;</span><br><span class="line">    union_caster&lt;<span class="keyword">emit_t</span>, <span class="keyword">em_t</span>&gt; caster;</span><br><span class="line">    caster.from = pemit;</span><br><span class="line">    (caster.to)(<span class="keyword">this</span>, args...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> DestT, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">emitter</span><span class="params">(<span class="keyword">const</span> _opaque_connection* self, Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//pm_t是一个成员函数指针，它指向的是传进来的成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(DestT::*<span class="keyword">pm_t</span>)</span><span class="params">(Args...)</span></span>;</span><br><span class="line">    <span class="keyword">pm_t</span> pm;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">memcpy</span>(&amp;pm, self-&gt;pmethod, <span class="keyword">sizeof</span>(<span class="keyword">pm_t</span>));</span><br><span class="line">    <span class="comment">//调用成员方法</span></span><br><span class="line">    (<span class="keyword">static_cast</span>&lt;DestT*&gt;(self-&gt;pdest)-&gt;*(pm))(args...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//signal_with_thread_policy类的父类。</span></span><br><span class="line"><span class="comment">//该类最主要的作用是存有一个conn list。</span></span><br><span class="line"><span class="comment">//在 signal_with_thread_policy中的connect方法就是对该成员变量的操作。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">mt_policy</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> _<span class="title">signal_base</span> :</span> <span class="keyword">public</span> _signal_base_interface, <span class="keyword">public</span> mt_policy &#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;_opaque_connection&gt; connections_list;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">//在 _signal_base 中定义了一个connection list，用于绑定的 slots.</span></span><br><span class="line">  connections_list m_connected_slots;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该类是"槽"的实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">mt_policy</span> = <span class="title">SIGSLOT_DEFAULT_MT_POLICY</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">has_slots</span> :</span> <span class="keyword">public</span> has_slots_interface, <span class="keyword">public</span> mt_policy &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;_signal_base_interface*&gt; sender_set;</span><br><span class="line">  <span class="keyword">typedef</span> sender_set::const_iterator const_iterator;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  has_slots()</span><br><span class="line">      : has_slots_interface(&amp;has_slots::do_signal_connect,</span><br><span class="line">                            &amp;has_slots::do_signal_disconnect,</span><br><span class="line">                            &amp;has_slots::do_disconnect_all) &#123;&#125;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  has_slots&amp; <span class="keyword">operator</span>=(has_slots <span class="keyword">const</span>&amp;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//静态函数，用于与signal绑定，由父类调用</span></span><br><span class="line">  <span class="comment">//它是在构造函数时传给父类的</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_signal_connect</span><span class="params">(has_slots_interface* p,</span></span></span><br><span class="line"><span class="function"><span class="params">                                _signal_base_interface* sender)</span> </span>&#123;</span><br><span class="line">    has_slots* <span class="keyword">const</span> self = <span class="keyword">static_cast</span>&lt;has_slots*&gt;(p);</span><br><span class="line">    <span class="function">lock_block&lt;mt_policy&gt; <span class="title">lock</span><span class="params">(self)</span></span>;</span><br><span class="line">    self-&gt;m_senders.insert(sender);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//静态函数，用于解绑signal，由父类调用</span></span><br><span class="line">  <span class="comment">//它是在构造函数时传给父类的</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_signal_disconnect</span><span class="params">(has_slots_interface* p,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   _signal_base_interface* sender)</span> </span>&#123;</span><br><span class="line">    has_slots* <span class="keyword">const</span> self = <span class="keyword">static_cast</span>&lt;has_slots*&gt;(p);</span><br><span class="line">    <span class="function">lock_block&lt;mt_policy&gt; <span class="title">lock</span><span class="params">(self)</span></span>;</span><br><span class="line">    self-&gt;m_senders.erase(sender);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//该集合中存放的是与slog绑定的 signal</span></span><br><span class="line">  sender_set m_senders;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该类是信号的具体实现</span></span><br><span class="line"><span class="comment">//为了保证信号可以在不同的平台是线程安全的，所以这里使用了策略模式</span></span><br><span class="line"><span class="comment">//mt_policy参数表式的是，不同的平台使用不同的策略</span></span><br><span class="line"><span class="comment">//该类中有两个重要的函数，一个是connect用于与槽进行绑定；另一个是 emit用于发射信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">mt_policy</span>, <span class="title">typename</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">signal_with_thread_policy</span> :</span> <span class="keyword">public</span> _signal_base&lt;mt_policy&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">desttype</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">connect</span>(<span class="title">desttype</span>* <span class="title">pclass</span>, <span class="title">void</span> (<span class="title">desttype</span>:</span>:*pmemfun)(Args...)) &#123;</span><br><span class="line">    <span class="comment">//这是一个智能锁，当函数结束时，自动释放锁。</span></span><br><span class="line">    <span class="function">lock_block&lt;mt_policy&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="comment">//先将对象与"槽"组成一个conn,然后存放到 signal的 conn list里</span></span><br><span class="line">    <span class="comment">//当发射信号时，调用 conn list中的每个conn的 emit方法。</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_connected_slots.push_back(_opaque_connection(pclass, pmemfun));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在槽对象中也要保存 signal 对象。</span></span><br><span class="line">    pclass-&gt;signal_connect(<span class="keyword">static_cast</span>&lt;_signal_base_interface*&gt;(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//遍历所有的连接，并调用 conn 的emit方法。最终调用的是绑定"槽"的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">emit</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="function">lock_block&lt;mt_policy&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_current_iterator = <span class="keyword">this</span>-&gt;m_connected_slots.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;m_current_iterator != <span class="keyword">this</span>-&gt;m_connected_slots.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      _opaque_connection <span class="keyword">const</span>&amp; conn = *<span class="keyword">this</span>-&gt;m_current_iterator;</span><br><span class="line">      ++(<span class="keyword">this</span>-&gt;m_current_iterator);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//调 conn 的 emit 方法，最终会调用绑定的 "槽" 方法。</span></span><br><span class="line">      conn.emit&lt;Args...&gt;(args...);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//重载（）操作符，这样就从直接调用emit方法变成隐含调用emit方法。</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args... args)</span> </span>&#123; emit(args...); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的对不同参数信号的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">using</span> signal = signal_with_thread_policy&lt;SIGSLOT_DEFAULT_MT_POLICY, Args...&gt;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> mt_policy = SIGSLOT_DEFAULT_MT_POLICY&gt;</span><br><span class="line"><span class="keyword">using</span> signal0 = signal_with_thread_policy&lt;mt_policy&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A1, <span class="keyword">typename</span> mt_policy = SIGSLOT_DEFAULT_MT_POLICY&gt;</span><br><span class="line"><span class="keyword">using</span> signal1 = signal_with_thread_policy&lt;mt_policy, A1&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A1,</span><br><span class="line">          <span class="keyword">typename</span> A2,</span><br><span class="line">          <span class="keyword">typename</span> mt_policy = SIGSLOT_DEFAULT_MT_POLICY&gt;</span><br><span class="line"><span class="keyword">using</span> signal2 = signal_with_thread_policy&lt;mt_policy, A1, A2&gt;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace sigslot</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文通过 sigslot作用、实现原理、如何使用以及详细的代码注释四个部分剖析了 WebRTC 中的 sigslot。sigslot是 WebRTC中非常底性的基础代码，它对 WebRTC 事件机制起着关键性的作用。熟悉sigslot，对我们阅读 WebRTC 代码会有非常大的帮助。</p><p>希望本文能对你有所帮助。谢谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我最早了解到 sigslot 大概是在 2007年 左右，当时在QT中大量使用了 sigslot 的概念。 现在 WebRTC 中也大量使用了 sigslot 这种机制来处理底层的事件。它对我们阅读WebRTC代码至关重要。本篇文章就详细介绍一下 sigslot。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="slot" scheme="https://blog.avdancedu.com/tags/slot/"/>
    
  </entry>
  
  <entry>
    <title>聊聊C++中的类型转换</title>
    <link href="https://blog.avdancedu.com/670ef31f/"/>
    <id>https://blog.avdancedu.com/670ef31f/</id>
    <published>2020-07-07T01:33:24.000Z</published>
    <updated>2020-07-07T13:48:35.933Z</updated>
    
    <content type="html"><![CDATA[<p>在C语言中我们经常要做类型转换，例如malloc函数分配内存时需要从<code>void *</code>转换成你指定的类型指针。如下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* block = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure><p>上面的代码是将<code>void*</code>转换成<code>int*</code>，这种转换方式在C语言中称为<code>强制转换</code>。它的好处是简洁，灵活；缺点是需要人来决定转换后类型是否正确，因此对开发人员的要求是很高的。</p><a id="more"></a><h2 id="C-的四种类型转换"><a href="#C-的四种类型转换" class="headerlink" title="C++的四种类型转换"></a>C++的四种类型转换</h2><p>C++觉得C的强制转换方式不是很友好，尤其是没法通过编译器或运行时检测工具来提供帮助，光靠人的能力来判断是很不靠谱的事儿。</p><p>而且相对于C来说，分析C++程序的运行轨迹要比分析C复杂得多。因此C++提出了四种新的类型转换方法，这四种类型转换方法分别是：<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>以及<code>reinterpret_cast</code>。</p><p>下面我们就来对这四种类型转换方法做下详细讨论。</p><h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>static_cast主要用于不同类型变量之间的转换及左值转右值等。比如说double转int就需要用static_cast转换。我们来举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不同类型之间的转换</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">10.1</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">//左值转右值</span></span><br><span class="line"><span class="keyword">int</span> lv = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp; rv = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&amp;&amp;&gt;(lv);</span><br></pre></td></tr></table></figure><blockquote><p>这里需要注意的是：int 转 double是隐式转换，右值转左值也是隐性转换，所以对这两种情况是不需要用static_cast进行显示转换的。</p></blockquote><p>上面我们说的是普通类型的转换。而对于类对象来说，static_cast不能直接将一种类对象转成另一种类对象。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    b = <span class="keyword">static_cast</span>&lt;B&gt;(a); <span class="comment">//不允许static_cast将一个对象转成另一个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像上面这种用static_cast将A类型的对象转成B类型对象是不允许的。但你可以利用static_cast将基类指针/引用转成子类指针/引用。如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">A ca;</span><br><span class="line">B &amp; crb = <span class="keyword">static_cast</span>&lt;B&amp;&gt;(ca);</span><br><span class="line">...</span><br><span class="line">A * pa = <span class="keyword">new</span> A();</span><br><span class="line">B * cpb = <span class="keyword">static_cast</span>&lt;B*&gt;(pa);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但这里有个前提条件，即只有有父子关系的类之间才可以做如上转换，否则编译失败。还有，虽然以上两种使用static_cast的方式都可以编译通过，但用户自己要防止越界访问的问题。</p><p>static_cast除了上面讨论的几种情况外，还有一点需要牢记，即<strong>static_cast不允许不同类型之间指针/引用的转换(有父子关系的类对象除外)</strong>。看个具体的例子：：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">double</span> *pd  = <span class="keyword">new</span> <span class="keyword">double</span>();</span><br><span class="line"><span class="keyword">int</span> * pi = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(pd); <span class="comment">//报错</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面的代码在编译时会报错，因为它不允许不同类型之间的指针或引用转换。对于有父子关系的类对象之间之所以可以转换是因为static_cast把它们当做同一类型看待了。</p><p>所以总结来说，static_cast主要用于不同类型变量之间的转换，指针和引用的转换不能用static_cast，而应该用reinterpret_cast。</p><h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><p>reinterpret_cast类似于C语言中不同类型指针间的类型转换，最接近于C的强制转换。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">double</span> *pd  = <span class="keyword">new</span> <span class="keyword">double</span>();</span><br><span class="line"><span class="keyword">int</span> * pi = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(pd);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面的代码是将<code>double*</code> 转成 <code>int*</code>。如果你使用static_cast做这种转换转换是不允许的，但改用reinterpret_cast就一切正常。 当然，如果你用reinterpret_cast做static_cast善长的变量类型转换也会报错。从上面的描述我们应该知道reinterpret_cast与static_cast之间的区别了。</p><p>如果我们像下面这样用reinterpret_cast去做类型变量的转换，编译器会报错：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">10.1</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>&gt;(d);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这样的转换是绝对不允许的。</p><p>reinterpret_cast还有一个特点，它可以将指针转成长整型，也可以将长整型转成指针。如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> ll = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">long</span>&gt;(&amp;a);</span><br><span class="line"><span class="keyword">double</span> *dd = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">double</span>*&gt;(ll);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面是将一个<code>int*</code>转成long型，又将long型转成<code>double*</code>，这些都是reinterpret_cast善长做的转换。</p><p>reinterpret_cast对于对象指针/引用的转换与普通类型的指针/引用转换是一样的。因此不同类型的对象指针/引用可以随意转换，但转换后是否会引起问题它不关心，这要由开发人员自己保证。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A * pa = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">B b;</span><br><span class="line">B &amp; rb = B();</span><br><span class="line"></span><br><span class="line">C * cc = <span class="keyword">reinterpret_cast</span>&lt;C*&gt;(pa);</span><br><span class="line">C &amp; rcc = <span class="keyword">reinterpret_cast</span>&lt;C&amp;&gt;(rb);</span><br></pre></td></tr></table></figure><p>总结一下，reinterpret_cast是对指针/引用的转换，其中必须至少有一个是指针或引用，否则它会报错。</p><h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p>这个比较简单，它的作用是去掉<strong>指针/引用</strong>中的const限制。这里要注意的是被转换的一定是指针/引用的const，而常数的const是不能去掉的。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b  = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&gt;(a);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面的代码是想通过const_cast将常数的const去掉？这是决对不可以的！！！编译器一定会报错。</p><p>而如果是加了const的指针/引用就没问题了，我们再来一个列子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pca = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> * pa = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(pca);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>将一个const 指针转换成非const指针正是const_cast做的事儿。</p><p>我们再来想一种case，是否可以将一种类型的const指针转换成另一种类型的非const指针呢？如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pca = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">double</span> * pa = <span class="keyword">const_cast</span>&lt;<span class="keyword">double</span>*&gt;(pca);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这样也是不允许的。对于const_cast来说，它只能将同一类型的const 指针/引用 转成非const指针/引用。</p><p>所以我们这里总结一下，const_cast是一个专门去掉同一类型的const限制的类型转换方法。它不如static_cast和reinterpret_cast应用的广泛。</p><h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p>这个转换方法限制比较多，一、它只能处理类对象；二、它只能处理指针；三、它只能用于将子对象转换成父对象这样的操作。我们来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">A * a;</span><br><span class="line">B * b =<span class="keyword">new</span> B();</span><br><span class="line">a = <span class="keyword">dynamic_cast</span>&lt;A*&gt;(b);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>只有上面这一种情况可以编译成功，其它情况都会失败！</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>下面我们总结一下这四种类型转换方法。四种转换方法中，用的比较多的是static_cast和reinterpret_cast这两种转换方法。</p><p>static_cast主要用于普通类型变量的转换，如double到int的转换，或左值转右值。当然它也可以在父对象与子对象之间进行指针转换。</p><p>reinterpret_cast主要用于不同类型指针/引用间的转换。也可以将指针/引用转成长整型或将长整型转成指针类型。但不可以像static_cast一样在两个不同的类型变量间转换。也就是说reinterpret_cast在转换时必须有一个是指针/引用。</p><p>const_cast就比较简单了，它只能将同一类型的const指针转成同一类型的非const指针。</p><p>dynamic_cast只能用于有父子关系的类对象之间的转换，而且只能用于将子对象转换成父对象。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">C++高阶知识：深入分析移动构造函数及其原理</a><br><a href="https://avdancedu.com/9683d88/" target="_blank" rel="noopener">细说智能指针</a><br><a href="https://avdancedu.com/5e7916e3/" target="_blank" rel="noopener">重学C/C++中的const</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在C语言中我们经常要做类型转换，例如malloc函数分配内存时需要从&lt;code&gt;void *&lt;/code&gt;转换成你指定的类型指针。如下面这样：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;* block = (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;*)&lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的代码是将&lt;code&gt;void*&lt;/code&gt;转换成&lt;code&gt;int*&lt;/code&gt;，这种转换方式在C语言中称为&lt;code&gt;强制转换&lt;/code&gt;。它的好处是简洁，灵活；缺点是需要人来决定转换后类型是否正确，因此对开发人员的要求是很高的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://blog.avdancedu.com/categories/C-C/"/>
    
    
      <category term="类型转换" scheme="https://blog.avdancedu.com/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>C++高阶知识：深入分析移动构造函数及其原理</title>
    <link href="https://blog.avdancedu.com/a39d51f9/"/>
    <id>https://blog.avdancedu.com/a39d51f9/</id>
    <published>2020-07-04T04:48:44.000Z</published>
    <updated>2020-07-07T13:53:51.397Z</updated>
    
    <content type="html"><![CDATA[<p>移动构造函数是C++11中新增加的一种构造函数，其作用是提高程序性能。今天我们就细扒一下它的工作原理，看看它是怎么提高性能的。</p><a id="more"></a><h2 id="移动构造函数的由来"><a href="#移动构造函数的由来" class="headerlink" title="移动构造函数的由来"></a>移动构造函数的由来</h2><p>在讲解移动构造函数之间，我们先来了解一下在没有移动构造函数之前哪里有性能瓶颈吧。我们来举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        A()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A construct..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            ptr_ = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        A(<span class="keyword">const</span> A &amp; a)&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A copy construct ..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            ptr_ = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line">            <span class="built_in">memcpy</span>(ptr_, a.ptr_, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~A()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A deconstruct ..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(ptr_)&#123;</span><br><span class="line">                <span class="keyword">delete</span> ptr_;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A &amp; a) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" A operator= ...."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> * <span class="title">getVal</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ptr_;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> *ptr_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;A&gt; vec;</span><br><span class="line">    vec.push_back(A());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//clang++ -g -o testmove test_move.cpp</span></span><br></pre></td></tr></table></figure><p>上面这段代码很简单对吧，就是定义了一个普通的类A。在main函数中创建一个vector，然后用A类创建一个对象，并把它放入到vector中。这样的程序在C++中是很常见，但就是这样很常见的代码确有非常大的性能问题。为什么呢？因为在将A对象放入vector时，在vector内部又创建了一个A对象，并调用了其拷贝构造函数进行了深拷贝。</p><p>我们看一下上面代码运行的结果就一目了然了，其结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A construct...          &#x2F;&#x2F;main中创建的A对象</span><br><span class="line">A copy construct ...    &#x2F;&#x2F;vector内部创建的A对象</span><br><span class="line">A deconstruct ...       &#x2F;&#x2F;vector内部创建的A对象被析构</span><br><span class="line">A deconstruct ...       &#x2F;&#x2F;main中创建的A对象析构</span><br></pre></td></tr></table></figure><p>上面的运行结果印证了我们之前的讨论，在vector内部确实又创建了一个A对象。如果在A对象中分配的是一个比较大的空间，且vector中要存放大量的A对象时（如 100000个)，就会不断的做分配/释放堆空间的操作，这会造成多在的性能消耗呀！</p><p>有什么办法可以解决这个问题呢？这就要用到我们今天要讲的移动构造函数了。</p><h2 id="移动构造函数的使用"><a href="#移动构造函数的使用" class="headerlink" title="移动构造函数的使用"></a>移动构造函数的使用</h2><p>从C++11开始，类中不光可以有构造函数、拷贝构造函数，还增加了一种新的构造函数即移动构造函数。移动构造函数起什么作用呢？就像它的名子一样，它可以实现指针的移动，即可以将一个对象中的指针成员转移给另一个对象。指针成员转移后，原对象中的指针成员一般要被设置为NULL，防止其再被使用。</p><p>还是以我们上面的代码为例，如果我们有了移动构造函数，那么在将A对象push到vector时，vector内部虽然还是会再分A对象，但在进行数据的拷贝时就不是深拷贝了，而变成了浅拷贝，这样就大大提高了程序的执行效率。</p><p>如何为A增加移动构造函数呢？我们来看一下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        A(A &amp;&amp; a)&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A move construct ..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            ptr_ = a.ptr_;</span><br><span class="line">            a.ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 A 类中增加上面代码即可，上面的代码看起来与普通构造函数好像没什么两样，但你细心观察可以发现该构造函数的参数是 <code>A &amp;&amp; a</code>。咦！<code>&amp;&amp;</code>这在以前还真没见过对吧。它表示的是C++中的右值，也就是只有创建A对象时传入的是右值才会执行该构造函数。</p><p>对于右值后面我们还会做详细介绍，现在我们只要知道要想让这个函数起作用，就必须传给它一个右值就可以了。如么问题来了，我们这个例子中如何传递给它一个右值呢？这就要用到 std::move 函数了。</p><p>std::move可以将任何一值变成右值，所以我们不管3721，在创建A对象时直接调用std::move”造”个右值给它就好了。于是我们修改main代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;A&gt; vec;</span><br><span class="line">    vec.push_back(<span class="built_in">std</span>::<span class="built_in">move</span>(A()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经这样修后，我们运行一下程序看现在它的结果是什么样子吧。结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A construct...          &#x2F;&#x2F;main中创建A对象</span><br><span class="line">A move construct ...    &#x2F;&#x2F;vector内部通过移动构造函数创建A对象，减少了对堆空间的频繁操作</span><br><span class="line">A deconstruct ...       &#x2F;&#x2F;释放vector中的A对象</span><br><span class="line">A deconstruct ...       &#x2F;&#x2F;释放main中创建的A对象</span><br></pre></td></tr></table></figure><p>从上面的结果我们可以看出我们新增加的移动构造函数确实被调用了，这样就大大减了频繁对堆空间的分配/释放操作，从而提高了程序的执行效率。这里需要注意的是，在移动构造函数操作之后原A对象的指针地址已经指向NULL了，因此此时就不能再通过其访问之前的堆空间了。</p><h2 id="C-的左值与右值"><a href="#C-的左值与右值" class="headerlink" title="C++的左值与右值"></a>C++的左值与右值</h2><p>右值是C++从C继承来的概念，最初是指=号右边的值。但现在C++中的右值已经与它最初的概念完全不一样了。在C++中右值指的的临时值或常量，更准确的说法是保存在CPU寄存器中的值为右值，而保存在内存中的值为左值。</p><p>可能有很多同学对计算机系统的底层不太了解，我们这里做一个简单的介绍。计算机是由CPU、内存、主板、总线、各种硬件等组成的，这个大家应该都清楚。而CPU又是由逻辑处理器，算术单元、寄存器等组成的。我们的程序运行时并不是直接从内存中取令运行的，因为内存相对于CPU来说太慢了。一般情况下都是先将一部分指令读到CPU的指令寄存器，CPU再从指令寄存器中取指令然后一条一条的执行。对于数据也是一样，先将数据从内存中读到数据寄存器，然后CPU从数据寄存器读数据。以Intel的CPU为例，它就包括了 EAX、EBX、ECX、EDX…多个通用寄存器，这样就可以让CPU更高效的工作。</p><p>比如说一个常数5，我们在使用它时不会在内存中为其分配一个空间，而是直接把它放到寄存器中，所以它在C++中就是一个右值。再比如说我们定义了一个变量 a，它在内存中会分配空间，因此它在C++中就是左值。那么<code>a+5</code>是左值还是右值呢？当然是右值对吧，因为a+5的结果存放在寄存器中，它并没有在内存中分配新空间，所以它是右值。</p><p>通过上面的描述你就应该对 C++ 中的左值和右值比较清楚了。我们来看个例子吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> &amp;&amp; a = <span class="number">5</span>;  <span class="comment">// 正确，5会被直接存放在寄存器中，所以它是右值</span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;&amp; c = b;  <span class="comment">// 错误，b在内存中有空间，所以是右值；右值不能赋值给左值</span></span><br><span class="line">    <span class="keyword">int</span> &amp;&amp; d = b + <span class="number">5</span>; <span class="comment">// 正确，虽然 b 在内存中，但 b+5 的结果放在寄存器中，它没有在内存中分配空间，因此是右值 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C++中使用<code>&amp;&amp;</code>表示右值引用，在上面的例子中，我首先将常数5赋值给右值引用a，因为常数5是右值，所以这条语句可以编译成功；紧接着我定义了变量b，因为它是左值，所以当将b赋值给右直引用c时，编译器会报错；最后一行将<code>b+5</code>赋值给右值引用d，由于<code>b+5</code>不会在内存中占用空间所以这也是右值，因此最后一句编译也没有任何问题。</p><p>接下来我们看一个有意思的情况，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">int</span> &amp;&amp; e = a;</span><br><span class="line">..</span><br></pre></td></tr></table></figure><p>这种情况是否是合法的呢？实际上当你这么做的时候编译器会报错，因为a是左值而e必须接收右值。那有没有办法将一个左值转成右值呢？这个问题我们前面其实已经回答过了，通过std::move就可以解决这个问题。我们来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">int</span> &amp;&amp; e = <span class="built_in">std</span>::<span class="built_in">move</span>(a);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>之前我们直接将a赋值给e是肯定不行的，但上面的操作编译器就不会报错了，因为通过std::move可以将一个左值转成右值。但这里有一点需要特别注意：<strong>e虽然接收的必须是右值，但它本身是左值。换句话说e是一种特殊的变量，它是只能接收右值的变量。我们再从左值的本质来看，e也是占内存空间的，所以它肯定是左值。</strong></p><h2 id="std-move的实现"><a href="#std-move的实现" class="headerlink" title="std::move的实现"></a>std::move的实现</h2><p>上面我们已经看到了std::move的神奇之处，你可能很好奇std::move是如何做到的呢？实际上std::move就是一个类型转换器，将左值转换成右值而以。我们来看一下它的实现吧！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> static_case&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::move的实现还是挺简单的就这么几行代码，但要理解这几行代码可不容易。下面我们就来对它做下详细分析。</p><h3 id="通用引用"><a href="#通用引用" class="headerlink" title="通用引用"></a>通用引用</h3><p>首先我们来看一下move的输入参数，move的输入参数类型称为通用引用类型。什么是通用引用呢？就是它既可以接收左值也可以接收右值。我们来看一下例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"the value is "</span>&lt;&lt; param &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> &amp;&amp; b = <span class="number">5</span>;   <span class="comment">//通用引用，可以接收右值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> &amp;&amp; c = a;    <span class="comment">//错误，右值引用，不能接收左值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> &amp;&amp; d = a;   <span class="comment">//通用引用，可以接收左值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;&amp; e = a; <span class="comment">//错误，加了const就不再是通用引用了</span></span><br><span class="line"></span><br><span class="line">    func(a);         <span class="comment">//通用引用，可以接收左值</span></span><br><span class="line">    func(<span class="number">10</span>);        <span class="comment">//通用引用，可以接收右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中有两种类型的通用引用: 一种是auto，另一种是通过模板定义的T&amp;&amp;。实际上auto就是模板中的T，它们是等价的。下面我们就对这段代码做下详细解读。</p><p>代码中的 a 是个左值，因为它在内存中会分配空间，这应该没什么异义；b 是通过引用。为什么呢？因为通用引用有两个条件：一，必须是T&amp;&amp;的形式，由于auto等价于T，所以auto &amp;&amp; 符合这个要求；二，T类型要可以推导，也就是说它必须是个模板，而auto是模板的一种变型，因此b是通用引用。通用引用即可以接收左值，也可以接收右值，所以b=5是正确的；c不是通用引用，因为它不符合T&amp;&amp;的形式。所经第三行代码是错误的，右值引用只能接收右值；d是通用引用，所以给它赋值a是正确的；e不是通用引用，它多了一个const已不符合T&amp;&amp; 的形式，所以给它左值肯定会出错；最后两个函数调用的形参符合 T&amp;&amp;，又因是模板可以进行类型推导，所以是通用引用，因此给它传左值和右值它都能正确接收。</p><h3 id="模板的类型推导"><a href="#模板的类型推导" class="headerlink" title="模板的类型推导"></a>模板的类型推导</h3><p>通用引用好强大呀！它既可以接收左值又可以接收右值，它是如何做到的呢？这就要讲讲模板的类型推导了。</p><p>模板的类型推导规则还是蛮复杂的，这里我们只简要说明一下，有兴趣的同学可以查一下C++11的规范。我们还是举个具体的例子吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br><span class="line"></span><br><span class="line">f(expr);</span><br></pre></td></tr></table></figure><p>上面这个例子是函数模板的通用例子，其中T是根据f函数的参数推到出来的，而ParamType则是根据 T 推导出来的。T与ParamType有可能相等，也可能不等，因为ParamType是可以加修饰的。我们看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;         <span class="comment">// x是int</span></span><br><span class="line">    <span class="keyword">int</span> &amp; rr = x;       <span class="comment">// rr是 int &amp;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> cx = x;   <span class="comment">// cx是const int</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;  <span class="comment">// rx是const int &amp;</span></span><br><span class="line">    <span class="keyword">int</span> *pp = &amp;x;       <span class="comment">// pp是int *</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面是传值的模板，由于传入参数的值不影响原值，所以参数类型退化为原始类型</span></span><br><span class="line">    f(x);               <span class="comment">// T是int</span></span><br><span class="line">    f(cx);              <span class="comment">// T是int</span></span><br><span class="line">    f(rx);              <span class="comment">// T是int</span></span><br><span class="line">    f(rr);              <span class="comment">// T是int</span></span><br><span class="line">    f(pp);              <span class="comment">// T是int*，指针比较特殊，直接使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面是传引用模板, 如果输入参数类型有引用，则去掉引用;如果没有引用，则输入参数类型就是T的类型</span></span><br><span class="line">    func(x);            <span class="comment">// T为int</span></span><br><span class="line">    func(cx);           <span class="comment">// T为const int</span></span><br><span class="line">    func(rx);           <span class="comment">// T为const int</span></span><br><span class="line">    func(rr);           <span class="comment">// T为int</span></span><br><span class="line">    func(pp);           <span class="comment">// T是int*，指针比较特殊，直接使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面是通用引用模板，与引用模板规则一致</span></span><br><span class="line">    function(x);        <span class="comment">// T为int&amp;</span></span><br><span class="line">    function(<span class="number">5</span>);        <span class="comment">// T为int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中可以将类型推导分成两大类：其中类型不是引用也不是指针的模板为一类; 引用和指针模板为另一类。</p><p>对于第一类其推导时根据的原则是，函数参数传值不影响原值，所以无论你实际传入的参数是普通变量、常量还是引用，它最终都退化为不带任何修修饰的原始类型。如上面的例子中，<code>const int &amp;</code>类型传进去后，退化为int型了。</p><p>第二类为模板类型为引用（包括左值引用和右值引用）或指针模板。这一类在类型推导时根据的原则是去除对等数量的引用符号，其它关键字照般。还是我们上面的例子，<code>func(x)</code>中x的类型为 <code>int&amp;</code>，它与<code>T&amp;</code>放在一起可以知道T为int。另一个例子<code>function(x)</code>，其中x为<code>int&amp;</code>它与T&amp;&amp; 放在一起可知T为<code>int&amp;</code>。</p><p>根据推导原则，我们可以知道通用引用最终的结果是什么了，左值与通用引用放在一推导出来的T仍为左值，而右值与通用引用放在一起推导出来的T仍然为右值。</p><h3 id="move-的返回类型"><a href="#move-的返回类型" class="headerlink" title="move 的返回类型"></a>move 的返回类型</h3><p>实际上上面通过模板推导出的T与move的返回类型息息相关的，要讲明白这一点我们先要把move的返回类型弄明白。下面我们就来讨论一下move的返回类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;</span><br></pre></td></tr></table></figure><p>move的返回类型非常奇特，我们在开发时很少会这样写，它表示的是什么意思呢？</p><p>这就要提到C++的另外一个知识点，即类型成员。你应该知道C++的类成员有成员函数、成员变量、静态成员三种类型，但从C++11之后又增加了一种成员称为类型成员。类型成员与静态成员一样，它们都属于类而不属于对象，访问它时也与访问静态成员一样用<code>::</code>访问。</p><p>了解了这点，我们再看move的返类型是不是也不难理解了呢？它表达的意思是返回remove_reference类的type类型成员。而该类是一个模板类，所以在它前面要加typename关键字。</p><p>remove_reference看着很陌生，接下来我们再分析一下remove_reference类，看它又起什么作用吧。其实，通过它的名子你应该也能猜个大概了，就是通过模板去除引用。我们来看一下它的实现吧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;  <span class="comment">//定义T的类型别名为type</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&gt; //左值引用</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&amp;&gt; //右值引用</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是remove_reference类的代码，在C++中struct与class基本是相同的，不同点是class默认成员是private，而struct默认是public，所以使用struct代码会写的更简洁一些。</p><p>通过上面的代码我们可以知道，经过remove_reference处理后，T的引用被剔除了。假设前面我们通过move的类型自动推导得到T为int&amp;&amp;，那么再次经过模板推导remove_reference的type成员，这样就可以得出type的类型为int了。</p><p>remove_reference利用模板的自动推导获取到了实参去引用后的类型。现在我们再回过来看move函数的时候是不是就一目了解了呢？之前无法理解的5行代码现然变成了这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int &amp;&amp; move(int&amp;&amp; &amp;&amp; t)&#123;</span><br><span class="line">    return static_case&lt;int&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line">int &amp;&amp; move(int&amp; &amp;&amp; t)&#123;</span><br><span class="line">    return static_case&lt;int&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经上面转换后，我们看这个代码就清晰多了，从中我们可以看到move实际上就是做了一个类型的强制转换。如果你是左值引用就强制转换成右值引用。</p><h3 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h3><p>上面的代码我们看起来是简单了很多，但其参数<code>int&amp; &amp;&amp;</code>和<code>int &amp;&amp; &amp;&amp;</code>还是让人觉得很别扭。因为C++编译器根本就不支持这两种类型。咦！这是怎么回事儿呢？</p><p>到这里我们就要讲到最后一个知识点引用折叠了。在C++中根本就不存 <code>int&amp; &amp;&amp;</code>、<code>int &amp;&amp; &amp;&amp;</code>这样的语法，但在编译器内部是能将它们识别出来的。换句话说，编译器内部能识别这种格式，但它没有给我们提供相应的接口(语法）。</p><p>实际上，当编译器遇到这类形式的时候它会使用引用折叠技术，将它们变成我们熟悉的格式。其规则如下：</p><ul><li><code>int &amp; &amp;</code> 折叠为 <code>int&amp;</code></li><li><code>int &amp; &amp;&amp;</code> 折叠为 <code>int&amp;</code></li><li><code>int &amp;&amp; &amp;</code> 折叠为 <code>int&amp;</code></li><li><code>int &amp;&amp; &amp;&amp;</code> 折叠为 <code>int &amp;&amp;</code></li></ul><p>总结一句话就是左值引用总是折叠为左值引用，右值引用总是折叠为右值引用。</p><p>经过这一系列的操作之后，对于一个具体的参数类型<code>int &amp; a</code>，std::move就变成了下面的样子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> &amp;&amp; <span class="title">move</span><span class="params">(<span class="keyword">int</span>&amp; t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> static_case&lt;<span class="keyword">int</span>&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一下我们就清楚它在做什么事儿了哈！</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上就是C++高阶知识移动构造函数及其原理的分析。在本文中我首先向你介绍了拷贝构造函数在某些场景下会引起程序性能严重下降，然后讲解了如何使用移动构造函数和std::move函数改善性能。在文章的最后，我带你深入剖析了std::move是如何实现的，最终我们发现它原来就是实现了一个自适应类型的强制类型转换的功能。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/9683d88/" target="_blank" rel="noopener">细说智能指针</a><br><a href="https://avdancedu.com/5e7916e3/" target="_blank" rel="noopener">重学C/C++中的const</a><br><a href="https://avdancedu.com/670ef31f/" target="_blank" rel="noopener">聊聊C++中的类型转换</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;移动构造函数是C++11中新增加的一种构造函数，其作用是提高程序性能。今天我们就细扒一下它的工作原理，看看它是怎么提高性能的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://blog.avdancedu.com/categories/C-C/"/>
    
    
      <category term="移动构造函数" scheme="https://blog.avdancedu.com/tags/%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>细说智能指针</title>
    <link href="https://blog.avdancedu.com/9683d88/"/>
    <id>https://blog.avdancedu.com/9683d88/</id>
    <published>2020-07-01T03:49:25.000Z</published>
    <updated>2020-07-07T13:57:16.865Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来聊聊C++的智能指针。C++从1983年诞生到现在已经有30多年历史了，为什么到现在还能如此流行呢(排名第四，2020年6月<a href="https://hellogithub.com/report/tiobe/" target="_blank" rel="noopener">HelloGitHub榜单</a>)？因为它具有很多其它语言所不具备的优势，比如说执行速度快，控制力更强等。同样的，有更多的同学会选择用Java(排名第二)等语言，这是因为它相对C++来说，它更简单，易上手，不用担心内存泄漏！</p><p>确实，<strong>内存泄漏</strong>在很长的一段时间里是影响人们学习C++的一个最重要的原因。不过C++也在不断进步中，智能指针的出现就大大降低了内存泄漏发生的风险。</p><p>下面我们就来细聊一下C++智能指针的方方面面，通过本文让你真正掌握C++智能指针。</p><a id="more"></a><h2 id="内存泄漏的产生"><a href="#内存泄漏的产生" class="headerlink" title="内存泄漏的产生"></a>内存泄漏的产生</h2><p>在C++中内存的分配与释放都是手工操作的(分配内存用<code>new</code>，释放内存用<code>delete</code>)，这种方式本身就很容易产生内存泄漏。因为人们在开发过程中需要内存时很自然的就用new分配一块，但这块内存什么时候释放就说不好了，有可能用完马上就释放，也有可能要等待一个周期才能释放等等。而且随着时间的推移，代码越来越大，需要被释放的内存被遗忘的可能性也就更大。</p><p>我来看一下具体的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *pVal = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line">    *pVal = <span class="number">10</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(*pVal == <span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;      <span class="comment">//这里会产生内存泄漏</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">delete</span> pVal;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，使用new在堆空间分配了一个整型大小的空间，在函数结束时通过delete将分配的内存释放。但当<code>pVal==10</code>时，函数没有释放内存就直接退出了，此时就产生了内存泄漏。</p><p>有的同学可能会说，谁会写出这么蠢的代码呢？实际上这样的代码在C++项目中经常出现，很多老手有时都犯这样的错误。你之所以可以一眼就看出上面代码的问题，是因为我将代码简化了。在真实的场景中，由于代码量比较大，你就没那么容易一眼看出问题了。</p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>上面我们已经看到了，通过new/delete这种方式申请/释放内存存在着很大弊端，有没有什么方法可以在使用时申请内存，在不需要的时自动释放它呢？当然有，<strong>这就是智能指针</strong>。</p><p>下面我们来看看智能指针是怎么做到的吧。实际上，智能指针最朴素的想法是利用类的<code>析构函数</code>和<code>函数栈</code>的自动释放机制来自动管理指针，即用户只要按需分配堆空间，堆空间的释放由智能指针帮你完成。</p><p>在解释这个原理之前，我们先来补充两个基本知识，一是构造函数与析构函数；另一个是堆空间与栈空间。首先来看构造函数与析构函数。</p><h3 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3><p>类对象的构造与析构是C++最基本的概念了，当创建对象时其构造函数会被调用，销毁对象时其析构函数会被调用。我们来举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MyClass()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"construct func"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~MyClass()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"deconstruct func"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"create MyClass object ..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    MyClass *myclass = <span class="keyword">new</span> MyClass();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"release MyClass object ..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> myclass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译命令 clang++ -g -o myclass test_class.cpp</span></span><br></pre></td></tr></table></figure><p>我们将上面的代码编译执行后，会得到下面的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create MyClass object ...</span><br><span class="line">construct func</span><br><span class="line">release MyClass object ...</span><br><span class="line">deconstruct func</span><br></pre></td></tr></table></figure><p>通过其结果就可以证明我们上面的结论了，即<strong>创建对象时其构造函数会被调用；销毁对像时其析构函数会被调用</strong>。</p><p>下面我们再来看看堆空间与栈空间。</p><h3 id="堆空间与栈空间"><a href="#堆空间与栈空间" class="headerlink" title="堆空间与栈空间"></a>堆空间与栈空间</h3><p>我们以Linux为例，在Linux系统上每个进程都有自己的虚似地址空间，如果你的系统是32位的，那它可以访问的内存空间是：2^32，也就是4G大小。</p><p>在这么大的空间中，内存被分成了几块：内核块、代码块、BSS块、堆空间，栈空间等。</p><ul><li>内核块，由Linux内核使用，应用层不可以访问。</li><li>代码块，用户的二进制应用程序，只读。</li><li>BSS块，全局量，全局常量等。</li><li>堆空间，用new分配的动态空间，可以分配大块内存。</li><li>栈空间，用于函数调用，分配临时变量等。其空间大小有限，<strong>当函数执行完成后其内存会自动回收</strong>。</li></ul><p>其中栈空间有个特点，当函数执行完后，它所用到的栈空间会被自动释放，而这正是智能指针所需要的。当它与构造函数/析构函数结合到一起时就可以实现智能指针了。下面我们来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">AutoPtr</span><span class="params">(T *ptr = <span class="literal">nullptr</span>)</span></span>&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"set new object"</span> &lt;&lt; ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            _ptr = ptr;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~AutoPtr()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"delete object"</span> &lt;&lt; _ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(_ptr != nulptr)</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T * _ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MyClass()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"construct MyClass func"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~MyClass()&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"deconstruct MyClass func"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">AutoPtr&lt;MyClass&gt; <span class="title">myclass</span><span class="params">(<span class="keyword">new</span> MyClass())</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译命令 clang++ -g -o autoptr test_autoptr.cpp</span></span><br></pre></td></tr></table></figure><p>上面例子执行的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">construct MyClass func</span><br><span class="line">set new object, 0x7f8e25c028c0</span><br><span class="line">delete object, 0x7f8e25c028c0</span><br><span class="line">deconstruct MyClass func</span><br></pre></td></tr></table></figure><p>在上面main函数中创建了一个智能指针<code>AutoPtr&lt;MyClass&gt; myclass</code>，其在堆空间分配了一个MyClass对象交由智能指针管理，即<code>myclass(new MyClass())</code>。当main函数结束时，它会调用智能指针的析构函数，析构函数中执行了<code>delete</code>操作，最终将之前new出来的myclass对象释放掉了。</p><p>通过这个例子我们可以知道，有了智能指针我们就不用再担心内存泄漏了。对于C++开发同学来说像不像中了大奖一样高兴？不过上面的AutoPtr还称不上真正的智能指针，因为它只实现了智能指针最基本的一部分功能，我们还需要对它不断完善才行。</p><h2 id="AutoPtr智能指针"><a href="#AutoPtr智能指针" class="headerlink" title="AutoPtr智能指针"></a>AutoPtr智能指针</h2><p>上面实现的智能指针有什么问题呢？最大的问题就是它不能像真正的指针一样操作，比如说不能执行<code>xxx-&gt;xxx()</code>、<code>*xxx</code>等操作。下面我们就为AutoPtr重载这两个操作符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改AutoPtr，增加 -&gt; 和 * 操作符</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    T* <span class="keyword">operator</span> -&gt; ()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    T&amp; <span class="keyword">operator</span> * ()&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;(<span class="keyword">this</span>-&gt;_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改MyClass类，增加print方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加测试例子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">AutoPtr&lt;MyClass&gt; <span class="title">myclass</span><span class="params">(<span class="keyword">new</span> MyClass())</span></span>;</span><br><span class="line">    myclass-&gt;<span class="built_in">print</span>();</span><br><span class="line">    (*myclass).<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该程序，我们可以得到下面的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">construct MyClass func</span><br><span class="line">set new object,0x7f94f44028c0</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line">delete object，0x7f94f44028c0</span><br><span class="line">deconstruct MyClass func</span><br></pre></td></tr></table></figure><p>通过上面的例子我们可以看到AutoPtr确实像一个真正的指针了，既可以通过<code>-&gt;</code>调用MyClass方法，又可以通过<code>*</code>调用MyClass方法。</p><h2 id="AutoPtr缺陷"><a href="#AutoPtr缺陷" class="headerlink" title="AutoPtr缺陷"></a>AutoPtr缺陷</h2><p>虽然上面的AutoPtr实现看着很不错，不过它有非常致命的问题。当两个AutoPtr指针指向同一块堆空间时，在释放资源时会引起crash。咱们看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加测试例子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">AutoPtr&lt;MyClass&gt; <span class="title">myclass</span><span class="params">(<span class="keyword">new</span> MyClass())</span></span>;</span><br><span class="line">    AutoPtr&lt;MyClass&gt; newPtr = myclass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你在main函数中让两个AutoPtr指向同一块堆空间时就会引起crash。之所以会出现这个问题，是因为堆空间被释放了两次。上面程序的执行结果就可以推出这个结论：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">construct MyClass func</span><br><span class="line">set new object,0x7fdecfc028c0</span><br><span class="line"></span><br><span class="line">delete object，0x7fdecfc028c0     &#x2F;&#x2F;释放第二个对象</span><br><span class="line">deconstruct MyClass func</span><br><span class="line"></span><br><span class="line">delete object，0x7fdecfc028c0     &#x2F;&#x2F;释放第一个对象</span><br><span class="line">deconstruct MyClass func</span><br><span class="line">malloc: *** error for object 0x7fdecfc028c0: pointer being freed was not allocated &#x2F;&#x2F;0x7fdecfc028c0这个空间已经被释放过一次了</span><br></pre></td></tr></table></figure><p>通过上面的运行结果我们可以知道，创建myclass智能指针时它指向了<code>new MyClass</code>所分配的空间。紧接着，程序使用默认<code>=</code>运算符将myclass中的全部内容赋值给newPtr。此时newPtr的<code>_ptr</code>成员会与myclass的<code>_ptr</code>成员指向同一块堆空间(由于使用了默认<code>=</code>运算符，所以过程没有显示出来)。</p><p>当main函数结束时，它会按次序依次调用newPtr的析构函数和myclass的析构函数，所以我们可以看到有两次”delete object，0x7fdecfc028c0”。在C++中，如果对同一地址释放多次就会引起crash，所以我们在显示结果的最后一行看到了”pointer being freed was not allocated” 这条信息表示的就是重复释放了。</p><p>因此我们必须对 AutoPtr 继续改进，防止出现重复释放的情况。如何才能防止重复释放呢？</p><h2 id="谁来独享所有权？"><a href="#谁来独享所有权？" class="headerlink" title="谁来独享所有权？"></a>谁来独享所有权？</h2><p>我们可以想到的最简单的办法是当有多个智能指针指向同一块堆空间时，只能有一个智能指针拥有所有权。什么意思呢？就是这块堆空间的释放只能由其中的一个来完成。</p><h3 id="允许共享，独占所有权"><a href="#允许共享，独占所有权" class="headerlink" title="允许共享，独占所有权"></a>允许共享，独占所有权</h3><p>怎么才能让众多智能指针中的一个拥有所有权呢？简单的办法是在AutoPtr上加个owner就好了。我们将上面的代码修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    explicit AutoPtr(T *ptr = nullptr):_ptr(ptr), _owner(true)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr(AutoPtr&lt;T&gt; &amp; autoptr):_ptr(autoptr._ptr), _owner(<span class="literal">false</span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~AutoPtr()&#123;</span><br><span class="line">        <span class="keyword">if</span>(_owner &amp;&amp; _ptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr&amp; <span class="keyword">operator</span>=(AutoPtr&lt;T&gt; &amp; autoptr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;autoptr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(_ptr)&#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_ptr = autoptr._ptr;</span><br><span class="line">            _owner = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _ptr;</span><br><span class="line">    <span class="keyword">bool</span> _owner;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>经上面修改后，<code>new MyClass</code>分配的空间就有了具体的owner，所以再执行之前的测试程序就不会crash了。结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">construct MyClass func</span><br><span class="line">set new object,0x7fb9acc028c0</span><br><span class="line">copy construct, 0x7fb9acc028c0</span><br><span class="line">delete object，0x7fb9acc028c0   &#x2F;&#x2F; 调用newPtr 析构</span><br><span class="line">delete object，0x7fb9acc028c0   &#x2F;&#x2F; 调用 myclass 析构</span><br><span class="line">deconstruct MyClass func        &#x2F;&#x2F; 由于myclass是owner，所以才会真正的释放堆空间</span><br></pre></td></tr></table></figure><p>通过上面的修改问题似乎已经得到了解决，但实际的情况是后创建的智能指针更应该是owner，所以我们再做下微调：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    explicit AutoPtr(T *ptr = nullptr):_ptr(ptr), _owner(true)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr(AutoPtr&lt;T&gt; &amp; autoptr):_ptr(autoptr._ptr), _owner(<span class="literal">true</span>)&#123;</span><br><span class="line">        autoptr._owner = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr&amp; <span class="keyword">operator</span>=(AutoPtr&lt;T&gt; &amp; autoptr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;autoptr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(_ptr)&#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_ptr = autoptr._ptr;</span><br><span class="line">            _owner = <span class="literal">true</span>;</span><br><span class="line">            autoptr._owner = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>经上面修改后，后创建的AutoPtr就取代之前的智能指针成为owner了。我们来看一下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">construct MyClass func</span><br><span class="line">set new object,0x7fe67b4028c0</span><br><span class="line">copy construct, 0x7fe67b4028c0</span><br><span class="line">delete object，0x7fe67b4028c0       &#x2F;&#x2F; 调用newPtr析构函数</span><br><span class="line">deconstruct MyClass func            &#x2F;&#x2F; 堆空间被释放掉了</span><br><span class="line">delete object，0x7fe67b4028c0       &#x2F;&#x2F; 调用myclass析构函数</span><br></pre></td></tr></table></figure><p>通过上面最后三行的输出结果我们可以看出，释放空间的顺序发生了变化，说明owner已经变为最近创建的智能指针newPtr了。</p><p>调整后的AutoPtr还有没有问题呢？当然还有，我们再来看一下例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">T* <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function">AutoPtr&lt;<span class="keyword">int</span>&gt; <span class="title">oldPtr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">AutoPtr&lt;<span class="keyword">int</span>&gt; <span class="title">newPtr</span><span class="params">(oldPtr)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里出现了野指针</span></span><br><span class="line">        *(oldPtr.<span class="built_in">get</span>())= <span class="number">-100</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"the value is "</span> &lt;&lt; *(oldPtr.<span class="built_in">get</span>()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我在AutoPtr中增加了一个get方法以便获得智能指针所指的堆空间</p></blockquote><p>在上面的代码中，将newPtr放到一个花括号里，这样它就有了自己的栈空间。当跳出花括号后，newPtr就完成了它的使命，然后它会将持有的资源全部释放掉。由于newPtr从oldPtr获得了<code>new int(100)</code>这块堆空间的控制权，所以当newPtr生命周期结束后，堆空间也被回收了。</p><p>但在newPtr被释放掉之后，oldPtr却还能通过get方法访问原来的堆空间，它还能将<code>-100</code>写入了被释放的堆空间。<strong>这是非常可怕的事情，因为oldPtr通过get方法拿到的已经是野指针了。</strong></p><p>因此，多智能指针共享堆空间并用owner控制最终资源释放的方法并不是特别好的智能指针方案。</p><h3 id="不允许共享，独占所有权"><a href="#不允许共享，独占所有权" class="headerlink" title="不允许共享，独占所有权"></a>不允许共享，独占所有权</h3><p>既然多智能指针共享堆空间存在着这样或那样的问题，那干脆不让他们共享得了。比如下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">AutoPtr</span><span class="params">(T * ptr=<span class="literal">nullptr</span>)</span>: _<span class="title">ptr</span><span class="params">(ptr)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr(AutoPtr&lt;T&gt; &amp; autoptr): _ptr(autoptr._ptr)&#123;</span><br><span class="line">        autoptr._ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~AutoPtr()&#123;</span><br><span class="line">        <span class="keyword">if</span>(_ptr)&#123;</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoPtr&lt;T&gt; &amp; <span class="keyword">operator</span>=(AutoPtr&lt;T&gt; &amp; autoptr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;autoptr) &#123;</span><br><span class="line">            <span class="keyword">if</span>(_ptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            _ptr = autoptr._ptr;</span><br><span class="line">            autoptr._ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">AutoPtr&lt;<span class="keyword">int</span>&gt; <span class="title">oldPtr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line">    AutoPtr&lt;<span class="keyword">int</span>&gt; newPtr = oldPtr; <span class="comment">//oldPtr已经不指向堆空间了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中我们不允许多个AutoPtr之间共享同一块堆空间，当将一个AutoPtr赋值给另一个AutoPtr时，让原来的AutoPtr指向空地址（nullptr)，新的AutoPtr指向堆空间。上面代码执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set new object,0x7fe905502760</span><br><span class="line">copy construct, 0x7fe905502760          &#x2F;&#x2F;newPtr 指向堆空间</span><br><span class="line">delete object，0x7fe905502760           &#x2F;&#x2F;newPtr 析构</span><br><span class="line">really,delete object，0x7fe90550276     &#x2F;&#x2F;newPtr 指向的堆空间被释放</span><br><span class="line">delete object，0x0                      &#x2F;&#x2F;oldPtr 析构，此时可以看到它指向的地址为nullptr</span><br></pre></td></tr></table></figure><p>通过结果可以证明我们上面修改的代码已经阻止了多个AutoPtr共享同一块堆空间的可能。</p><p>然而上面的实现打破了我们对传统指针的认知，这会给你带来很多麻烦。尤其是多人合作时，如果大家对AutoPtr没有一致的认识，特别容易出现问题。因为既然是指针，那它就应该允许多个指针指向同一块堆空间。因此，当不有了解AutoPtr的同学使用它时，很可能还会认为多个AutoPtr是指向同一块堆空间的，这样当他通过老的AutoPtr向堆空间写数据时就会产生crash。比如像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">*(oldptr.get()) &#x3D; 10;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set new object,0x7fd93bc028c0</span><br><span class="line">copy construct, 0x7fd93bc028c0</span><br><span class="line">[1]    39662 segmentation fault  .&#x2F;autoptr  &#x2F;&#x2F;这里crash了</span><br></pre></td></tr></table></figure><p>上面的AutoPtr就是C++98规范中的auto_ptr的实现，由于该实现总是存在这样或那样的问题，因此现在auto_ptr已经被废弃掉了。</p><h2 id="scoped-ptr"><a href="#scoped-ptr" class="headerlink" title="scoped_ptr"></a>scoped_ptr</h2><p>我们已经看到上面的AutoPtr有各种弊端，引起这些弊端的最主要的原因是AutoPtr具有控制权的传递性，也就是说它允许从一个AutoPtr赋值给另一个AutoPtr。</p><p>为了彻底解决AutoPtr上面所述的问题，就出现了scoped_ptr。scoped_ptr最早是在C++的boost库中出现的，其出现的原因是从C++98之后C++标准一直没有更新智能指针的规范。因此C++大牛们纷纷发布了自己私有标准，而scoped_ptr就是其中之一。</p><p>scoped_ptr的核心思想是什么呢？既然auto_ptr的所有问题都是因为传递性引起的，所以阻止其传递性就可以解决这个问题了。因此scoped_ptr的实现也特别简单，它将其拷贝构造函数及赋值操作符全部隐藏起来，这样就不会有auto_ptr的问题了。</p><p>下面我们来看一下它的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScopedPtr</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ScopedPtr(T * ptr = <span class="literal">nullptr</span>): _ptr(ptr)&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T* <span class="keyword">operator</span>-&gt;()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T&amp; <span class="keyword">operator</span>*()&#123;</span><br><span class="line">            <span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_ptr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">T* <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~ScopedPtr()&#123;</span><br><span class="line">            <span class="keyword">if</span>(_ptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        ScopedPtr(ScopedPtr&lt;T&gt; &amp; scopedptr)&#123;&#125;</span><br><span class="line">        ScopedPtr&lt;T&gt; &amp; <span class="keyword">operator</span>=(ScopedPtr&lt;T&gt; &amp; scopedptr)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T *_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">ScopedPtr&lt;<span class="keyword">int</span>&gt; <span class="title">myPtr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line">    ScopedPtr&lt;<span class="keyword">int</span>&gt; newPtr = myPtr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//clang++ -g -o scopedptr test_scopedptr.cpp</span></span><br></pre></td></tr></table></figure><p>当我们编译上面的代码时，会报下面的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test_scopedptr.cpp:32:29: error: calling a protected constructor of class &#39;ScopedPtr&lt;int&gt;&#39;</span><br><span class="line">    ScopedPtr&lt;int&gt; newPtr &#x3D; myPtr;</span><br><span class="line">                            ^</span><br><span class="line">test_scopedptr.cpp:23:9: note: declared protected here</span><br><span class="line">        ScopedPtr(ScopedPtr&lt;T&gt; &amp; scopedptr)&#123;&#125;</span><br><span class="line">        ^</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure><p>上面的错误正是我们想要的结果。只要你对ScopedPtr进行赋值，在编译时就不让其编译通过，这样就不会再产生AutoPtr的问题了。</p><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>我们上面所讲的scoped_ptr并非是官方的标准，它是C++大牛们自己实现的版本。到了C++11之后官方版本来了，其被命名为unique_ptr。实际上unique_ptr与scoped_ptr功能几乎是一模一样，不过它们之间也有一些细微差别。</p><p>差别是什么呢？就是unique_ptr可以对右值进行转移，<code>对右值转移</code>这是啥意思呢？说明白了就是提供了一种特殊方法可以将unique_ptr赋值给另一个unique_ptr，被转移后的unique_ptr也就不能再处理之前管理的指针了。</p><p>我们还是来看一个具体的例子你就清楚了，只要给我们之前的ScopedPtr加上一个移动构造函数和移动赋值运算符就实现unique_ptrr的转移功能了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class ScopedPtr&#123;</span><br><span class="line">    ...</span><br><span class="line">    ScopedPtr(ScopedPtr&lt;T&gt;&amp;&amp; scopedptr) noexcept : _ptr(scopedptr._ptr)&#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;move construct...&quot; &lt;&lt; std::endl;</span><br><span class="line">        scopedptr._ptr &#x3D;  nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ScopedPtr&amp; operator&#x3D;(ScopedPtr&lt;T&gt; &amp;&amp; scopedptr) noexcept &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;move assignment...&quot; &lt;&lt; std::endl;</span><br><span class="line">        if(this !&#x3D; &amp;scopedptr)&#123;</span><br><span class="line">            _ptr &#x3D; scopedptr._ptr;</span><br><span class="line">           scopedptr._ptr &#x3D; nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[])&#123;</span><br><span class="line">    ScopedPtr&lt;int&gt; myPtr(new int(100));</span><br><span class="line">    &#x2F;&#x2F;ScopedPtr&lt;int&gt; newPtr &#x3D; myPtr;            &#x2F;&#x2F;拷贝构造函数已经不能用了</span><br><span class="line">    ScopedPtr&lt;int&gt; newPtr &#x3D; std::move(myPtr);   &#x2F;&#x2F;可以使用移动拷贝构造函数进行转移</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;clang++ -std&#x3D;c++11 -g -o scopedptr test_scopedptr.cpp</span><br></pre></td></tr></table></figure><p>上面main函数中的第二行调用的是拷贝构造函数，由于该函数是不是public属性，所以调用该行时会失败。而第三行会调用移动构造函数，因为我们已经实现了移动构造函数，所以该行可以编译成功。在运行时，当myPtr移动给newPtr后，myPtr也就失去了对原指针的控制权，这在代码中也有体现就是将 scopedptr的<code>_ptr</code>域设置为nullptr了。</p><p>上面就是C++11标准中的unique_ptr的实现，这样一分析下来也是蛮简单的对吧。</p><p>另外，对于移动构造函数，std::move这些概念我在另一篇文章<a href="https://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">《C++高阶知识：深入分析移动构造函数及其原理》</a>中有详细的介绍，对这块知识不了解的同学可以去看一下。</p><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>虽然unique_ptr已经很好用了，但有时候我们还是需要多个智能指针管理同一块堆内存空间。之前在讲AutoPtr时我们已经介绍了多个智能指针管理同一块内存空间会引起很多问题，有没有更好的方式来解决这些问题呢？</p><p>其中引用计数法是个不错的解决方案，实现起来也比较简单。其基本原理是当有多个智能指针指对同一块堆空间进行管理时，每增加一个智能指针引用计数就增1，每减少一个智能指针引用计数就减少。当引用计数减为0时，就将管理的堆空间释放掉。</p><p>我们还是看一个具体例子吧，其实现是在unique_ptr的基础之上实现的，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScopedPtr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        ScopedPtr(T *ptr = <span class="literal">nullptr</span>): _ptr(ptr), _ref_count(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>))&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ScopedPtr(ScopedPtr&lt;T&gt; &amp; scopedptr): _ptr(scopedptr._ptr), _ref_count(scopedptr._ref_count)&#123;</span><br><span class="line">            ++（*_ref_count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ScopedPtr &amp; <span class="keyword">operator</span>=(ScopedPtr&lt;T&gt; &amp; scopedptr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;scopedptr)&#123;</span><br><span class="line">                _release();</span><br><span class="line">                _ptr(scopedptr._ptr);</span><br><span class="line">                _ref_conut(scopedptr._ptr);</span><br><span class="line">                ++(*_ref_count);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~ScopedPtr()&#123;</span><br><span class="line">            _release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span>* <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> *_ref_count; </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="keyword">void</span> _release() &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"deconstruct...: count="</span> &lt;&lt; ((*_ref_count) <span class="number">-1</span>)  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(--(*_ref_count) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">                <span class="keyword">delete</span> _ref_count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">int</span> *_ref_count;   <span class="comment">//引用计数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">ScopedPtr&lt;<span class="keyword">int</span>&gt; <span class="title">myPtr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line">    ScopedPtr&lt;<span class="keyword">int</span>&gt; pT2 = myPtr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//clang++ -std=c++11 -g -o sharedptr test_sharedptr.cpp</span></span><br></pre></td></tr></table></figure><p>通过上面的修改，我们就可以将unique_ptr修改成shared_ptr了，测试结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">default construct ...</span><br><span class="line">copy construct ...: count&#x3D;2</span><br><span class="line">deconstruct...: count&#x3D;1</span><br><span class="line">deconstruct...: count&#x3D;0</span><br></pre></td></tr></table></figure><p>从结果中我们可以看到创建myPtr时引用计数为 1，将myPtr赋值给pT2时引用计算为2。当main程序结束后首先释放pT2，其引用计数减1。再释放myPtr，引用计数减为0，当引用计数为0时，释放堆空间。</p><p>这样的智能指针还是非常棒的，我们再也不怕内存泄漏了！！！</p><p>等等，我们好像高兴的太早了，当出现循环指向时还是会出现内存泄漏。我们来看一下例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ScopeddPtr&lt;Node&gt; _prev;</span><br><span class="line">    ScopeddPtr&lt;Node&gt; _next;</span><br><span class="line"></span><br><span class="line">    ~Node()</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"delete :"</span> &lt;&lt;<span class="keyword">this</span>&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ScopedPtr&lt;Node&gt; <span class="title">cur</span><span class="params">(<span class="keyword">new</span>(Node))</span></span>;</span><br><span class="line"><span class="function">ScopedPtr&lt;Node&gt; <span class="title">next</span><span class="params">(<span class="keyword">new</span>(Node))</span></span>;</span><br><span class="line">cur-&gt;_next = next;</span><br><span class="line">next-&gt;_prev = cur;</span><br></pre></td></tr></table></figure><p>上面这段代码就会出现内存泄漏，我们来分析一下。</p><p>首先第一行会创建三个Node类型的智能指针，分别是 <code>cur-&gt;_prev</code>、<code>cur-&gt;_next</code> 、<code>cur</code> 此时它们各自的引用计数都是 1；第二行也会创建三个Nodet智能指针，分别是<code>next-&gt;_prev</code>、<code>next-&gt;_next</code>及<code>next</code>; 第三行完成之后，<code>cur-&gt;_next</code>和<code>next</code>的引用计数都为 2；第四行完成后，<code>next-&gt;_prev</code>和<code>cur</code>的引用计数也变成了2；</p><p>当main程序结束时，next和cur分别调用它们的析构函数，因此<code>next</code>和<code>cur-&gt;_next</code>的引用计数变为1，<code>cur</code>和<code>next_prev</code>的引用计数也变成了1，但由于没有减至0，所以资源永会不会被释放掉。这就是产生内存泄露的原因。</p><p>真是辛辛苦苦好几年，一下回到解放前。使用引用计数还是会产生内存泄漏，我们仿佛又回到了起点。</p><p>不过别着急，C++11又给我们提供了新的解决方案，如何解决这个问题呢？</p><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>weak_ptr就是专门为了解决这个问题而出现的。实际上weak_ptr不能单独称为一个智能指针，它必须与shared_ptr一起使用，起到辅助share_ptr的作用。我们来看看它是如何解决上述问题的吧。</p><p>首先引入weak_ptr后，weak_ptr也要有自己的引用计数，因此我们需要修改之前的ScopedPtr，将它的计数成员变成一个类型，包括它自己的计数和weak_ptr的计数，它看起来像下面的样子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Counter():s(<span class="number">0</span>),w(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> s; <span class="comment">//存放share_ptr引用计数</span></span><br><span class="line">        <span class="keyword">int</span> w; <span class="comment">//存放weak_ptr引用计数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来我们来修改一下ScopedPtr，由于这次修改比较大，所以我给它重新起一个名子，叫作SharedPtr吧，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">WeakPtr</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SharedPtr &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        SharedPtr(T * ptr = <span class="literal">nullptr</span>):_ptr(ptr)&#123;</span><br><span class="line">            _cnt = <span class="keyword">new</span> Counter();</span><br><span class="line">           <span class="keyword">if</span>(_ptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                 _cnt-&gt;s = <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~SharedPtr()&#123;</span><br><span class="line">            _release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SharedPtr(SharedPtr&lt;T&gt; &amp; sharedptr): _ptr(sharedptr._ptr), _cnt(sharedptr._cnt)&#123;</span><br><span class="line">            _cnt-&gt;s++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SharedPtr(WeakPtr&lt;T&gt; &amp; weakptr): _ptr(weakptr._ptr), _cnt(weakptr._cnt)&#123;</span><br><span class="line">            _cnt-&gt;s++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SharedPtr &amp; <span class="keyword">operator</span>=(SharedPtr&lt;T&gt; &amp; sharedptr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> != &amp; sharedptr)&#123;</span><br><span class="line">                _release();</span><br><span class="line">                _ptr = sharedptr._ptr;</span><br><span class="line">                _cnt = sharedptr._cnt;</span><br><span class="line">                _cnt-&gt;s++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T&amp; <span class="keyword">operator</span> *()&#123;</span><br><span class="line">            <span class="keyword">return</span> *_ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T* <span class="keyword">operator</span> -&gt;()&#123;</span><br><span class="line">            <span class="keyword">return</span> _ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//friend class WeakPtr&lt;T&gt;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">       <span class="keyword">void</span> _release()&#123;</span><br><span class="line">            _cnt-&gt;s--;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"release "</span>&lt;&lt;_cnt-&gt;s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(_cnt-&gt;s &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">                <span class="keyword">if</span>(_cnt-&gt;w &lt;<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">delete</span> _cnt;</span><br><span class="line">                    _cnt=<span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T * _ptr;</span><br><span class="line">        Counter * _cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakPtr</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        WeakPtr():_ptr(<span class="literal">nullptr</span>), _cnt(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        ~WeakPtr()&#123;</span><br><span class="line">            _release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WeakPtr(WeakPtr&lt;T&gt; &amp; weakptr):_ptr(weakptr._ptr), _cnt(weakptr._cnt)&#123;</span><br><span class="line">            _cnt-&gt;w++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WeakPtr(SharedPtr&lt;T&gt; &amp; sharedptr):_ptr(sharedptr._ptr), _cnt(sharedptr._cnt)&#123;</span><br><span class="line">            _cnt-&gt;w++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WeakPtr &amp; <span class="keyword">operator</span>=(WeakPtr&lt;T&gt; &amp; weakptr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;weakptr)&#123;</span><br><span class="line">                _release();</span><br><span class="line">                _ptr = weakptr._ptr;</span><br><span class="line">                _cnt = weakptr._cnt;</span><br><span class="line">                _cnt-&gt;w++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WeakPtr &amp; <span class="keyword">operator</span>=(SharedPtr&lt;T&gt; &amp; sharedptr)&#123;</span><br><span class="line">            _release();</span><br><span class="line">            _ptr = sharedptr._ptr;</span><br><span class="line">            _cnt = sharedptr._cnt;</span><br><span class="line">            _cnt-&gt;w++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">SharedPtr&lt;T&gt; <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> SharedPtr&lt;T&gt;(*<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">expired</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(_cnt &amp;&amp; _cnt-&gt;s &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"empty "</span>&lt;&lt;_cnt-&gt;s&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//friend class SharedPtr&lt;T&gt;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="keyword">void</span> _release()&#123;</span><br><span class="line">            <span class="keyword">if</span>(_cnt)&#123;</span><br><span class="line">                _cnt-&gt;w--;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"weakptr release"</span>&lt;&lt;_cnt-&gt;w&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">if</span>(_cnt-&gt;w &lt; <span class="number">1</span> &amp;&amp; _cnt-&gt;s &lt;<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">//delete cnt;</span></span><br><span class="line">                        _cnt=<span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T * _ptr;</span><br><span class="line">        Counter * _cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    WeakPtr&lt;Node&gt; _prev;</span><br><span class="line">    WeakPtr&lt;Node&gt; _next;</span><br><span class="line"></span><br><span class="line">    ~Node()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"delete :"</span> &lt;&lt;<span class="keyword">this</span>&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">SharedPtr&lt;Node&gt; <span class="title">cur</span><span class="params">(<span class="keyword">new</span>(Node))</span></span>;</span><br><span class="line">    <span class="function">SharedPtr&lt;Node&gt; <span class="title">next</span><span class="params">(<span class="keyword">new</span>(Node))</span></span>;</span><br><span class="line">    cur-&gt;_next = next;</span><br><span class="line">    next-&gt;_prev = cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//clang++ -std=c++11 -g -o weakptr test_weakptr.cpp</span></span><br></pre></td></tr></table></figure><p>以上就是WeakPtr的实现以及SharedPtr的改造，从中我们可以看到，SharedPtr与我们之前的ScopedPtr区别并不是很大，主要做了三点有修改：一、以前只有一个计数器，然在变成了两个，一个是SharedPtr本身的计数，另一个是WeakPtr的计数；二是增加了一个参数为WeakPtr引用的拷贝构造函数;三、<code>_ptr</code>和<code>_cnt</code>的释放都是在SharedPtr中完成的，WeakPtr不做具体的释放工作。</p><p>WeakPtr是新增加的弱指针，它是配合SharedPtr使用的，自己并不能单独使用。WeakPtr也包含<code>_ptr</code>和<code>_cnt</code>两个成员，但它更多是是引用，对它们没有创建和释放权。另外在WeakPtr中会对Counter对象的w字段操作，也就是说多个WeakPtr指向同一个堆空间时，它仅操作Counter中的w字段。</p><p>因此，对于我们之前的SharedPtr形成环后导致的内存泄漏可以通过WeakPtr对其进行改造，这样内存泄漏的问题就迎刃而解了。</p><p>上面修改后的代码我们再来分析一遍。首先第一行会创建两个WeakPtr指针 <code>cur-&gt;_prev</code>、<code>cur-&gt;_next</code> 和一个SharedPtr智能指针<code>cur</code>。此时它们各自的引用计数都是 1；第二行同样也会创建二个WeakPtr指针<code>next-&gt;_prev</code>、<code>next-&gt;_next</code>和一个SharedPtr智能指针<code>next</code>; 第三行完成之后，<code>cur-&gt;_next</code>的_cnt-&gt;w为1，<code>next</code>的_cnt-&gt;s为1；第四行完成后，<code>next-&gt;_prev</code>的_cnt-&gt;w为1，<code>cur</code>的_cnt-&gt;s引用计数也为1；</p><p>当main程序结束时，next和cur分别调用它们的析构函数，因此<code>next</code>引用计数为0，释入Node对象，在Node中又会释放_prev和_next。next释放完成后开始释放<code>cur</code>，同里cur所持有的资源也一并释放。因此就不会再有内存泄漏了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文的篇幅有点长，不过每一部分都是不可或缺的。在本文中向你详细讲解了 auto_ptr、scoped_ptr、unique_ptr、shared_ptr以及与之配套的 weak_ptr的衍化过程。通过这样一个过程让你知道了这几个智能指针的作用是什么，应该用在地方，以及该如何使用。</p><p>相信通过本文你会对C++中的智能指针有了深刻的理解。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">C++高阶知识：深入分析移动构造函数及其原理</a><br>[重学C/C++中的const][<a href="https://avdancedu.com/5e7916e3/]" target="_blank" rel="noopener">https://avdancedu.com/5e7916e3/]</a><br><a href="http://localhost:4000/670ef31f/" target="_blank" rel="noopener">聊聊C++中的类型转换</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们来聊聊C++的智能指针。C++从1983年诞生到现在已经有30多年历史了，为什么到现在还能如此流行呢(排名第四，2020年6月&lt;a href=&quot;https://hellogithub.com/report/tiobe/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HelloGitHub榜单&lt;/a&gt;)？因为它具有很多其它语言所不具备的优势，比如说执行速度快，控制力更强等。同样的，有更多的同学会选择用Java(排名第二)等语言，这是因为它相对C++来说，它更简单，易上手，不用担心内存泄漏！&lt;/p&gt;
&lt;p&gt;确实，&lt;strong&gt;内存泄漏&lt;/strong&gt;在很长的一段时间里是影响人们学习C++的一个最重要的原因。不过C++也在不断进步中，智能指针的出现就大大降低了内存泄漏发生的风险。&lt;/p&gt;
&lt;p&gt;下面我们就来细聊一下C++智能指针的方方面面，通过本文让你真正掌握C++智能指针。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://blog.avdancedu.com/categories/C-C/"/>
    
    
      <category term="智能指针" scheme="https://blog.avdancedu.com/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>重学C/C++中的const</title>
    <link href="https://blog.avdancedu.com/5e7916e3/"/>
    <id>https://blog.avdancedu.com/5e7916e3/</id>
    <published>2020-06-30T06:09:42.000Z</published>
    <updated>2020-07-07T13:50:26.952Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/const/const.jpg" alt=""></p><p>使用<code>C/C++</code>语言的同学应该对<code>const</code>都比较了解，但对于初学者来说，<code>const</code>确是一个难肯的骨头，理解起来困难重重。今天我就带你重新学习一下C/C++的中的<code>const</code>。</p><a id="more"></a><h2 id="const-与-define-的区别"><a href="#const-与-define-的区别" class="headerlink" title="const 与 #define 的区别"></a>const 与 #define 的区别</h2><p>在<code>C/C++</code>中定义常量通常使用<code>const</code>关键字，当然你也可以使有宏<code>#define</code>来定义。这两种方式定义常量如下所示：</p><ul><li>const 定义常量  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int PI &#x3D; 3.14;</span><br></pre></td></tr></table></figure></li><li>宏定义常量  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define PI &#x3D; 3.14</span><br></pre></td></tr></table></figure></li></ul><p>这两种定义常量的方式有什么区别呢？</p><p>要回答这个问题，我们需要了解一点编译原理的知识。编译器在编译我们写好C/C++程序时，其编译器过程为：<strong>预编译-&gt;编译-&gt;链接</strong>。<code>C/C++</code>中宏的替换就是在预编译阶段完成的，也就是说在预编译阶段将C/C++中的所有用到的宏都用宏定义中的值替换掉。</p><p>而<code>const</code> 定义的常量则与宏定义的常量不同，它是在编译阶段进行检测，而且还可以对其类型进行检测。因此我们可以总结出使用<code>const</code>定义的常量与宏定义的常量有如下区别:</p><ul><li>宏是在预编译时进行宏展开，而const是在编译时检测，所以两者操作的时期不同</li><li>由于宏在预编译时被操作，所以无法进行类型检测；而const则可以进行类型检测</li><li>因在编译阶段可以形成符号表，所以const定义的常量可以通过调试器进行调试；而宏在展开后就消失了，所以无法通过调试器进行调试</li></ul><p>以上就是<code>const</code>与<code>宏</code>的最主要的区别。所以一般情况下我们都建议使用const来定义常量。</p><h2 id="const常量与const常量指针"><a href="#const常量与const常量指针" class="headerlink" title="const常量与const常量指针"></a>const常量与const常量指针</h2><p>上面我们已经列举过const如何定义常量，这里就不再赘述了。现在咱们来看一下const常量指针，它该如何定义呢?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int * ptr; &#x2F;&#x2F;const常量指针</span><br></pre></td></tr></table></figure><p>上面就是const常量指针的定义，也挺好理解的对吧。我们将const常量和const常量指针放在一起看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int i;    &#x2F;&#x2F;const常量</span><br><span class="line">const int* ptr; &#x2F;&#x2F;const常量指针</span><br></pre></td></tr></table></figure><p>将他们放在一起比较着看，你就更容易理解const常量指针了，无非就是将const常量中的类型变成指针而已。</p><h2 id="const常量指针的作用"><a href="#const常量指针的作用" class="headerlink" title="const常量指针的作用"></a>const常量指针的作用</h2><p><strong>那么常量指针的作用是什么呢？</strong>，我们来看个例子你就清楚了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const int i &#x3D; 100;     &#x2F;&#x2F; 定义一个常量</span><br><span class="line">i &#x3D; 100;               &#x2F;&#x2F; 不允许修改常量</span><br><span class="line"></span><br><span class="line">int *p &#x3D; &amp;i;           &#x2F;&#x2F; 老的编译器是被允许的，这实际存在安全问题</span><br><span class="line">                       &#x2F;&#x2F; 为了解决这个问题，新的编译器报错，非常量指针不允许指向常量地址</span><br><span class="line"></span><br><span class="line">const int * ptr &#x3D; &amp;i;  &#x2F;&#x2F; 常量指针指向常量地址</span><br><span class="line">*ptr &#x3D; 100;            &#x2F;&#x2F; 不允许修改常量的内容</span><br></pre></td></tr></table></figure><p>按照常量的定义，常量定义好后其内容就不允许再修改了，因此对于上面代码中的前两行相信你不会有什么异义。</p><p>但在较老的编译器上，存在一个漏洞，它允许你用普通指针指向常量地址。这样你就可以通过该指针修改常量的内容了，这是非常大的安全漏洞。为了消除这个安全隐患，在新的编译器上已经不允许普通指针指向const常量了。</p><p>为什么在老编译器上指针可以指向常量地址并修改其内容呢？究其原因是因为const定义的常量实际是在内存的可读写空间，只是由于编译器限制你才不能修改它。而老的编译器却没有这方面的限制，所以才会出现通过普通指针修改常量的可能。</p><p>我们再来看代码的最后两行。使用const常量指针指向常量地址，此时你无论用新编译器还是老编译器，都无法通过该指针修改常量的内容。所以代码的最后一行当你修改常量内容时就会报错。</p><p>通过上面的讲解，你应该对常量指针的概念比较清楚了。常量指针不能修改常量内容，但能不能让常量指针指向另外一个常量的地址呢？比如下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const int i &#x3D; 100;</span><br><span class="line">const int n &#x3D; 1000;</span><br><span class="line"></span><br><span class="line">const int * ptr &#x3D; &amp;i;   &#x2F;&#x2F;常量指针先指向 i 常量的地址</span><br><span class="line">ptr &#x3D; &amp;n;               &#x2F;&#x2F;又修改为指向 n 常量的地址</span><br></pre></td></tr></table></figure><p>这样做当然是可以的，因为常量指针限制的是不能修改常量内容，但并没有限制它指向哪个常量。</p><h2 id="const变形"><a href="#const变形" class="headerlink" title="const变形"></a>const变形</h2><p>上面我们已经清楚了const常量指针是什么，它起了什么作用。但它还有一点你不知道，就是它会变型。我们来看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int * ptr;</span><br><span class="line">int const * ptr;</span><br></pre></td></tr></table></figure><p>上面这两行代码很像是不是？第二行代码将 const 放到了 int 类型之后，它表达的是什么意思呢？<strong>其实两行表示的是同一个意思，都是常量指针</strong>。只是有的人喜欢将const写在最前面，有的人喜欢将const 写在类型后面罢了。这里有一个记忆的小巧门，我们只要记住const是在 <code>*</code> 左边它就表示的是常量指针就OK了，</p><h2 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h2><p>上面的内容清楚之后，我们再来一个复杂的<strong>指针常量</strong>。看到这个词相信很多同学立马晕了，上面是常量指针，这又来个指针常量是这是说绕口令吗？先别急，我们先来看个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int * const ptr;</span><br></pre></td></tr></table></figure><p>上面这行代码是不是与前面的很相似？一模一样? 如果你这样认为说明你没有仔细观察。之前的常量指针const是在<code>*</code>号左边，这次的const跑到<code>*</code>号右边了。</p><p>它表示的是什么意思呢？</p><p>前面我已经说了，对于常量指针来说，你是不能修改它所指向的内容的，因为内容是常量，但它可以让它指向不同的常量地址。新需求来了，有没有可能让指针指向一个地址就不动了呢？或者换个思考的角度，既然const可以定义常量，能不能定义一个指针常量呢？<strong>这就是指针常量的由来</strong>。</p><p>C/C++编译器的作者考虑的一下这个需求，觉得这个需求是合理的，决定实现它。但怎么才能表示指针常量呢？于是就有了 <code>const int * const ptr</code> 这个写法，const 放在<code>*</code>后面表达对ptr的限制。</p><p>了解了指针变量的由来，下面我们来看一下它的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 100;</span><br><span class="line">int n &#x3D; 1000;</span><br><span class="line"></span><br><span class="line">int * const ptr &#x3D;  &amp;i; &#x2F;&#x2F; 正确，初始指向某个变量</span><br><span class="line">ptr &#x3D; &amp;n;              &#x2F;&#x2F; 错误，ptr是常量，不能再发生变化</span><br><span class="line"></span><br><span class="line">*ptr &#x3D; 20;             &#x2F;&#x2F; 正确，因为我们没有对指针指向的内容做限制</span><br></pre></td></tr></table></figure><p>上面代码中定义了两个变量 i 和 n，ptr是针指常量，因此它只能在初始化时指向某个变量的地址，之后它就不能更改变指向其它地址了，因为它是<strong>常量</strong>。<strong>但需要注意的是ptr指向的内容是可以被修改的</strong>。</p><h2 id="指向常量的指针常量"><a href="#指向常量的指针常量" class="headerlink" title="指向常量的指针常量"></a>指向常量的指针常量</h2><p>看这个标题就觉得好复杂啊！没错我们又要升级难度了。先看个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int * const ptr1;</span><br><span class="line">int const * const ptr2;</span><br></pre></td></tr></table></figure><p>天呐，一条语句中出列了两个const，如果我们没有基础的话，这两行代码简直无法理解。不过，有了上面的基础我们再来看这两句还是能猜出它要干什么的对吧？</p><p>这两条语句的含义是一样的，表示的是ptr1/ptr2指向的地址不能再改变，而且它指向的地址里的内容也不能再改变。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在本文中我向你详细介绍了C/C++中的<code>const</code>的含义和用法，总结一下包括以下几种：</p><ul><li>定义常量, 内容不能改变，<code>const int a;</code></li><li>定义常量指针，指向的内容不能改变，<code>const int * ptr;</code> 或 <code>int const * ptr;</code></li><li>定义指针常量，指针不能改变，但指向的内容可以改变。<code>int * const ptr</code></li><li>定义指向常量的针指常量，指针不能改变，内容也不能改变。<code>const int * const ptr</code> 或 <code>int const * const ptr</code></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">C++高阶知识：深入分析移动构造函数及其原理</a><br><a href="https://avdancedu.com/9683d88/" target="_blank" rel="noopener">细说智能指针</a><br><a href="https://avdancedu/670ef31f/" target="_blank" rel="noopener">聊聊C++中的类型转换</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/const/const.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;C/C++&lt;/code&gt;语言的同学应该对&lt;code&gt;const&lt;/code&gt;都比较了解，但对于初学者来说，&lt;code&gt;const&lt;/code&gt;确是一个难肯的骨头，理解起来困难重重。今天我就带你重新学习一下C/C++的中的&lt;code&gt;const&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://blog.avdancedu.com/categories/C-C/"/>
    
    
      <category term="const" scheme="https://blog.avdancedu.com/tags/const/"/>
    
  </entry>
  
  <entry>
    <title>分析WebRTC，重学Windows开发</title>
    <link href="https://blog.avdancedu.com/2fb1b8c6/"/>
    <id>https://blog.avdancedu.com/2fb1b8c6/</id>
    <published>2020-06-29T14:47:36.000Z</published>
    <updated>2020-06-29T15:39:27.749Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/windows/win95.jpg" alt=""></p><p>N多年没有写过 Window 程序了。为了研究 WebRTC 源码，这两天重新学习一下。还记得上大学的时候看过 《Windows95 程式设计》台湾版，对那本书印象极为深刻。一是当时国内确实没有一本写的那么深入的书籍，二是那本书翻译的特别好，让人一看就特别明白。10多年过多了，当时的情景还记忆犹新，也可见那本书写的有多好了。</p><a id="more"></a><p>Windows开发有很多知识点，窗口啊，句柄啊，消息啊，重绘啊，baba …..，但一个 Windows 程序的核心就是一个消息处理机制。</p><h2 id="Windows程序运行的基本原理"><a href="#Windows程序运行的基本原理" class="headerlink" title="Windows程序运行的基本原理"></a>Windows程序运行的基本原理</h2><p>Windows程序是消息为驱动的，所以它的核心就是消息的传递与处理。如鼠标消息、键盘消息，Timer消息，窗口的创建与消毁等等。那么，Windows程序是在哪儿处理消息呢？是否掌握了它，就控制了Windows程序的核心呢？答案是肯定的，它就是 WndProc 函数。所有的消息都要经过这个函数处理。</p><p>Windows 程序有两种消息，一种是队列消息，它通过 DispatchMessage 函数分发给 WndProc 函数，像鼠标消息、键盘消息，Timer消息都是这类消息。另一种是非队列消息，它是系统函数直接发送给 WndProc 函数的，像窗口的创建与消毁消息，WM_COMMON消息等等都是非队列消息。</p><h2 id="最简单的-Windows-程序"><a href="#最简单的-Windows-程序" class="headerlink" title="最简单的 Windows 程序"></a>最简单的 Windows 程序</h2><p>一个最简单的 Windows 程序都包括哪些内容呢？下面我们详细介绍一下：</p><h3 id="WinMain-函数"><a href="#WinMain-函数" class="headerlink" title="WinMain 函数"></a>WinMain 函数</h3><p>我们都知道无论是Windows程序，还是Linux程序，也无论是C/C++，还是 Java语言，它们都有一个 main 函数。更准确点说应该叫“程序入口点”。</p><p>我们写程序时，一般都以 main 开头，编译器在编译该程序时，会将 main 函数地址写入到可执行文件的文件头中，这就是“程序入口点”了。</p><p>在执行程序时，操作系统首先通过程序加载器将要运行的程序加载到内存中，然后重新计算符号地址表。一切准备就绪后，才跳到程序入口点，将一条条指令送入CPU流水线开始执行程序。这就是程序的运行的基本流程。</p><p>因此，我们可以知道每个程序都有一个入口点。但是否一定以 main 开头呢? 其实，只要编译器能识别出入口点就可以，不必非要以 main 为标志。对于 Windows 程序就是这样，它就不使用 main作为入口点，而是换成了 WinMain 作为程序入口点。格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int CALLBACK WinMain(</span><br><span class="line">   _In_  HINSTANCE hInstance,</span><br><span class="line">   _In_  HINSTANCE hPrevInstance,</span><br><span class="line">   _In_  LPSTR lpCmdLine,</span><br><span class="line">   _In_  int nCmdShow</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="实现消息中心函数-WndProc"><a href="#实现消息中心函数-WndProc" class="headerlink" title="实现消息中心函数 WndProc()"></a>实现消息中心函数 WndProc()</h3><p>前面我已经介绍了 WndProc 是 Windows 程序的消息中心，所有的消息都要在这个函数中处理。如 窗口创建时发送的 WM_CREATE 消息，如果我们不处理它，Windows 操作系统就不会显示创建的窗口。</p><p>但 Windows 中有那么多消息，我们每个都处理岂不是要累死人？所以 Windows 很贴心的提供了一个API，就是 DefWindowProc 函数。该函数对所有的 Windows 消息都做了默认处理，如果我们很懒的话，可以将所有消息都交由它就好了。</p><p>有没有坐过山车的感脚？开始觉得很苦闷，突然又拨云见日了。嘿嘿！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK WndProc(</span><br><span class="line">        _In_  HWND hwnd,</span><br><span class="line">        _In_  UINT uMsg,</span><br><span class="line">        _In_  WPARAM wParam,</span><br><span class="line">        _In_  LPARAM lParam</span><br><span class="line">) &#123;</span><br><span class="line">return DefWindowProc(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册窗口类"><a href="#注册窗口类" class="headerlink" title="注册窗口类"></a>注册窗口类</h3><p>我们在创建窗口之前要注册一个窗口类，它是干啥用的呢？就是告诉操作系统，我要创建个什么样子的窗口，是啥背景色，鼠标是啥样子的，程序叫啥名子等等。</p><p>有了这个窗口类，我们就可以创建不同样式的窗口了，这样是不是觉得很方便呢？当然，一般情况下我们都使用默认样式！</p><p>这个窗口类除了设置样式外，其实它<strong>更重要的作用</strong>是指定 WndProc 函数，也就是为 Window 程序指定 “消息处理中心”。消息中心是谁，完全是由 RegisterClass 说了算，它说消息处理中心是 WndProc 就是 WndProc，它说 ABC 那就是 ABC。</p><p>一般我们调用注册窗口的代码都长的像下面这样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 类名</span><br><span class="line">WCHAR* cls_Name &#x3D; L&quot;My Class&quot;;</span><br><span class="line">&#x2F;&#x2F; 设计窗口类</span><br><span class="line">WNDCLASS wc &#x3D; &#123; &#125;;</span><br><span class="line">wc.hbrBackground &#x3D; (HBRUSH)COLOR_WINDOW;</span><br><span class="line">wc.lpfnWndProc &#x3D; WndProc;</span><br><span class="line">wc.lpszClassName &#x3D; cls_Name;</span><br><span class="line">wc.hInstance &#x3D; hInstance;</span><br><span class="line">&#x2F;&#x2F; 注册窗口类</span><br><span class="line">RegisterClass(&amp;wc);</span><br></pre></td></tr></table></figure><h3 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h3><p>创建窗口就比较简单了，高多少，宽多少，透明的还是非透明的，可显示还是不可显示，标题栏上要写啥字等等，这些都是由<code>创建窗口</code>说了算。形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建窗口</span><br><span class="line">      HWND hwnd &#x3D; CreateWindow(</span><br><span class="line">      cls_Name,           &#x2F;&#x2F;类名，要和刚才注册的一致</span><br><span class="line">      L&quot;我的应用程序&quot;,  &#x2F;&#x2F;窗口标题文字</span><br><span class="line">      WS_OVERLAPPEDWINDOW, &#x2F;&#x2F;窗口外观样式</span><br><span class="line">      38,                 &#x2F;&#x2F;窗口相对于父级的X坐标</span><br><span class="line">      20,                 &#x2F;&#x2F;窗口相对于父级的Y坐标</span><br><span class="line">      480,                &#x2F;&#x2F;窗口的宽度</span><br><span class="line">      250,                &#x2F;&#x2F;窗口的高度</span><br><span class="line">      NULL,               &#x2F;&#x2F;没有父窗口，为NULL</span><br><span class="line">      NULL,               &#x2F;&#x2F;没有菜单，为NULL</span><br><span class="line">      hInstance,          &#x2F;&#x2F;当前应用程序的实例句柄</span><br><span class="line">      NULL);              &#x2F;&#x2F;没有附加数据，为NULL</span><br></pre></td></tr></table></figure><h3 id="显示窗口"><a href="#显示窗口" class="headerlink" title="显示窗口"></a>显示窗口</h3><p>窗口创建完了，还要主动调<code>ShowWindows</code>函数让窗口显示出来，否则它是不会出来干活的。形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 显示窗口</span><br><span class="line">ShowWindow(hwnd, SW_SHOW);</span><br></pre></td></tr></table></figure><h3 id="循环处理，检索与分发消息"><a href="#循环处理，检索与分发消息" class="headerlink" title="循环处理，检索与分发消息"></a>循环处理，检索与分发消息</h3><p>这部分工作是在 WinMain 函数中要做的事儿。在 WinMain 中写一个循环，不停的从系统消息队列中取消息。</p><p>如果此时没有消息，则该线被程阻塞，并将CPU资源释放；如果有消息，需要判断是不是退出消息？如果不是，使用 DispatchMessage 将该消息分配出去。如果是退出消息，则退出消息循环，程序结束。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void WinMan(...)&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 消息循环</span><br><span class="line">MSG msg;</span><br><span class="line">while(GetMessage(&amp;msg, NULL, 0, 0))</span><br><span class="line">&#123;</span><br><span class="line">    TranslateMessage(&amp;msg);</span><br><span class="line">    DispatchMessage(&amp;msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是一个最简单的窗口 Window 程序。了解了上面这些知识，大家是不是觉得即使不用 MFC 也可以写出一个很不错的 Windows 程序呢？</p><h2 id="重要函数详细介绍"><a href="#重要函数详细介绍" class="headerlink" title="重要函数详细介绍"></a>重要函数详细介绍</h2><h3 id="WinMain"><a href="#WinMain" class="headerlink" title="WinMain"></a>WinMain</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int CALLBACK WinMain(</span><br><span class="line">  _In_ HINSTANCE hInstance, &#x2F;&#x2F;句柄</span><br><span class="line">  _In_ HINSTANCE hPrevInstance, &#x2F;&#x2F;总是 NULL</span><br><span class="line">  _In_ LPSTR     lpCmdLine, &#x2F;&#x2F;在命令行启动程序时的命令</span><br><span class="line">  _In_ int       nCmdShow &#x2F;&#x2F;程序启动时的显示方式</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>hInstance：句柄，就是一个内存地址，在该地址上有该程序的基本信息。</li><li>hPrevInstance：总是NULL，没啥用。</li><li>lpCmdLine： 用命令行启动时的命令，有兴趣的可以自己打印出来。</li><li>nCmdShow：程序启动时的显示方式，是隐藏，还是显示，是最大化，还是最小化显示。</li></ul><h3 id="注册窗口"><a href="#注册窗口" class="headerlink" title="注册窗口"></a>注册窗口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tagWNDCLASS &#123;</span><br><span class="line">  UINT      style;</span><br><span class="line">  WNDPROC   lpfnWndProc;</span><br><span class="line">  int       cbClsExtra;</span><br><span class="line">  int       cbWndExtra;</span><br><span class="line">  HINSTANCE hInstance;</span><br><span class="line">  HICON     hIcon;</span><br><span class="line">  HCURSOR   hCursor;</span><br><span class="line">  HBRUSH    hbrBackground;</span><br><span class="line">  LPCTSTR   lpszMenuName;</span><br><span class="line">  LPCTSTR   lpszClassName;</span><br><span class="line">&#125; WNDCLASS, *PWNDCLASS;</span><br><span class="line"></span><br><span class="line">ATOM WINAPI RegisterClass(</span><br><span class="line">  _In_ const WNDCLASS *lpWndClass</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>style ：设置窗口样式。可以不设置。</li><li>lpfnWndProc ：这个字段特别重要，设置消息处理函数，它是消息的中心。</li><li>cbClsExtra ：不用设置。</li><li>cbWndExtra ：不用设置。</li><li>hInstance ：窗口句柄，与WinMain中的一样。</li><li>hIcon ：窗口图标。如果是NULL，使用默认图标。</li><li>hCursor ：设置光标样式。可以不设置</li><li>hbrBackground ：设置窗口背景色。</li><li>lpszMenuName：菜单名。如果为NULL说明没有菜单。</li><li>lpszClassName：这个参数要提供，长度不超过 256。</li></ul><h3 id="创建窗口-1"><a href="#创建窗口-1" class="headerlink" title="创建窗口"></a>创建窗口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HWND WINAPI CreateWindow(</span><br><span class="line">  _In_opt_ LPCTSTR   lpClassName,</span><br><span class="line">  _In_opt_ LPCTSTR   lpWindowName,</span><br><span class="line">  _In_     DWORD     dwStyle,</span><br><span class="line">  _In_     int       x,</span><br><span class="line">  _In_     int       y,</span><br><span class="line">  _In_     int       nWidth,</span><br><span class="line">  _In_     int       nHeight,</span><br><span class="line">  _In_opt_ HWND      hWndParent,</span><br><span class="line">  _In_opt_ HMENU     hMenu,</span><br><span class="line">  _In_opt_ HINSTANCE hInstance,</span><br><span class="line">  _In_opt_ LPVOID    lpParam</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>lpClassName ： 与注册的类名子一致。</li><li>lpWindowName ：窗口标题栏名子。</li><li>dwStyle ：窗口外观样式。</li><li>x ：窗口起始位置 x。</li><li>y ：窗口起始位置 y。</li><li>nWidth ：窗口宽度。</li><li>nHeight ：窗口高度。</li><li>hWndParent ：父窗口，没有的话设置为NULL</li><li>hMenu ：窗口菜单，没有设置为NULL</li><li>hInstance ： 窗口句柄。</li><li>lpParam ：符加数据，没有设置为 NULL</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过上面的介绍，我想你首先知道了Windows程序是由消息驱动的，真正负责消息处理的函数是 WinProc，它是在调用 RegisterClass 时指定的。通过 RegisterClass 我们还可以给窗口指定样式，并最终由 CreateWindow 创建出来。同时我们还可以总结出，通过 6 大步既可以创建出一个最简单的 Windows程序，这6步分别是：</p><ul><li>设置入口点，WinMain。</li><li>创建 WinProc 函数。</li><li>注册窗口类。</li><li>创建窗口。</li><li>显示窗口。</li><li>循环处理，检索与分发消息</li></ul><p>至此，一个Windows程序窗口已经展现在你面前了。 希望本文能对你有所帮助!</p><p> 谢谢！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/garrylea/SimpleWindow" target="_blank" rel="noopener">github地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/windows/win95.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;N多年没有写过 Window 程序了。为了研究 WebRTC 源码，这两天重新学习一下。还记得上大学的时候看过 《Windows95 程式设计》台湾版，对那本书印象极为深刻。一是当时国内确实没有一本写的那么深入的书籍，二是那本书翻译的特别好，让人一看就特别明白。10多年过多了，当时的情景还记忆犹新，也可见那本书写的有多好了。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>janus的线程模型</title>
    <link href="https://blog.avdancedu.com/8f43ddc9/"/>
    <id>https://blog.avdancedu.com/8f43ddc9/</id>
    <published>2020-06-29T05:33:58.000Z</published>
    <updated>2020-06-29T06:16:06.150Z</updated>
    
    <content type="html"><![CDATA[<p>我们要想把一个系统搞清楚，首先要把它的线程模型弄明白。比如它是单线程的还是多线程的？如果它是单线程的，那逻辑就比较简单了，像mediasoup就是单进程多实例的模型；如果是多线程的，那它的线程是如何分配的？每个线程的作用是什么？我们必须把这些都要弄清楚才行，否则我们就无法将这个系统彻底搞明白。</p><a id="more"></a><p>在分析 <code>janus</code> 的时候，我们也应尊循上面的原则。因此在分析<code>janus</code>之前，我们先来问几个问题，<code>janus</code>是多线程的模式吗？如果是多线程模式，那它一共有几个线程呢？ 这些线程又分别起什么作用？</p><p>如果我们将上面的问题回答好了，我想我们基本上就将<code>janus</code>的线程模型搞清楚了，搞清了它的线程模型也就撑握了<code>janus</code>的系统大体脉络。</p><h1 id="janus是多线程模式吗？"><a href="#janus是多线程模式吗？" class="headerlink" title="janus是多线程模式吗？"></a>janus是多线程模式吗？</h1><p>其实这个问题非常好回答，通过查看<code>janus</code>的主文件janus.c我们就能知道答案了。在janus.c中我们可以发现下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">GThread *watchdog &#x3D; g_thread_try_new(&quot;timeout watchdog&quot;, &amp;janus_sessions_watchdog, watchdog_loop, &amp;error);</span><br><span class="line">...</span><br><span class="line">GThread *requests_thread &#x3D; g_thread_try_new(&quot;sessions requests&quot;, &amp;janus_transport_requests, NULL, &amp;error);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>janus</code>是基于Linux 的GLIB库开发出来的，因此所有对系统的调用都是使用的GLIB库的API。而<code>g_thread_try_new</code>函数正中GLIB中用来创建线程的，在<code>g_thread_try_new</code>的底层真正调用的是<code>pthread</code>的相关API。</p><p><strong>通这上面的分析，我们可以知道janus是多线程的模式。</strong></p><h1 id="janus一共有几个线程？"><a href="#janus一共有几个线程？" class="headerlink" title="janus一共有几个线程？"></a>janus一共有几个线程？</h1><p>除了我们上面介绍的两个线程外，<code>janus</code>还使用了线程池的概念。在<code>janus</code>的初始化阶段就将线程池创建出来了。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">tasks &#x3D; g_thread_pool_new(janus_transport_task, NULL, -1, FALSE, &amp;error);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>查看<code>g_thread_pool_new</code>API的帮助文档，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GThreadPool *</span><br><span class="line">g_thread_pool_new (GFunc func,</span><br><span class="line">                   gpointer user_data,</span><br><span class="line">                   gint max_threads,</span><br><span class="line">                   gboolean exclusive,</span><br><span class="line">                   GError **error);</span><br></pre></td></tr></table></figure><p>通过这个定义我们可以知道<code>janus</code>创建的线程池时并没有对线程数进制控制。也就是说它可以开出系统可以支持的最大限度的线程个数。<strong>会在高并发时出现性能问题呢？这个还要等我们后面的深入分析才能清楚，目前来说这行代码还是有风险的。</strong></p><p>下面我们总结一下，通过对janus.c文件的分析，我们现在可以知道<code>janus</code>的线程模型是由两个专用线程<code>watchdog</code>、<code>request</code>和一个通用任务线程池构成的。如下图所示：</p><p><img data-src="https://cdn.avdancedu.com/image/article/janus_thread/janus_thread.jpg" alt="janus线程模型"></p><p>了解了<code>janus</code>的线程模型后，下面我们来看一下 <code>janus</code> 每个线程的作用吧。</p><h1 id="每个线程的作用"><a href="#每个线程的作用" class="headerlink" title="每个线程的作用"></a>每个线程的作用</h1><p>通过阅读代码，我们可以了解到这几个线程的主要作用是什么，下面我们来一一介绍一下。</p><p><strong>首先是主线程</strong>，这个线程的主要作用就是初始化的工作。主要包括以下几方面的工作：</p><ul><li>从配置文件中读配置信息，然后根据配置信息进行初始化工作</li><li>启动其它线程</li><li>动态加载plugin</li></ul><p><strong>WatchDog 线程</strong>，通过名子我们基本上就可以清楚它的作用了。它是监控线程，它每隔２秒做一次扫描，查看transport的session是否过期了。如果过期了，则给对应的transport发通知让transport结束处理。需要注意的是，这里的 trasnport代表的是不同协议的接入口，如RabbitMQ、MQTT、HTTP等。</p><p><strong>Request线程</strong>，用于处理接口请求。一般将接口请求分为两大类，文本类请求和命令类请求。如果是文本类请求的，则会启动新线程（从线程池中获取）进行处理；如果是命令的类的，则可以直接处理。当然对于命令类型的Request可能处理上会比较复杂，有可能会分成多个阶段处理，而在每个不同的阶段又会生成新的Request。</p><p><strong>最后一个就是线程池了</strong>，线程池的作用上面我已经介绍了，就是在处理Request时会从线程池中分配线程，然后执行Request任务，任务完成后再回收到线程池里。　</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过上面的描述我们可以看到<code>janus</code>的线程模型并不复杂，它启动了两个专门的线程，一个用于处理transport的session是否过期；另一个用于处理Request请求，当收到Request请求后，它又会把请求交给新的线程做延时处理。</p><p>以上我们就将 <code>janus</code> 的线程模型分析完了，读到这里我相信你已经对<code>janus</code>的线程模型有了一个大体的了解了。当然你仍然会很许多疑惑，这只能对照着<code>janus</code>的代码分析才能让你体会的更深刻！</p><p>谢谢！</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门》</a></li><li><a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级高并发WebRTC流媒体服务器设计与开发》</a></li><li><a href="https://time.geekbang.org/column/intro/207" target="_blank" rel="noopener">《从0打造音视频直播系统》</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们要想把一个系统搞清楚，首先要把它的线程模型弄明白。比如它是单线程的还是多线程的？如果它是单线程的，那逻辑就比较简单了，像mediasoup就是单进程多实例的模型；如果是多线程的，那它的线程是如何分配的？每个线程的作用是什么？我们必须把这些都要弄清楚才行，否则我们就无法将这个系统彻底搞明白。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="thread" scheme="https://blog.avdancedu.com/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>深入理解janus中的plugin管理</title>
    <link href="https://blog.avdancedu.com/26c3d930/"/>
    <id>https://blog.avdancedu.com/26c3d930/</id>
    <published>2020-06-29T05:05:29.000Z</published>
    <updated>2020-06-29T05:24:24.710Z</updated>
    
    <content type="html"><![CDATA[<p><code>janus</code>中的<code>plugin</code>是其非常重要的一部分内容，今天我们就来对这块内容做一下分析，看看<code>janus</code>是如何实现<code>plugin</code>的，以及它的工作原理是怎样的。</p><a id="more"></a><h2 id="janus的架构模型"><a href="#janus的架构模型" class="headerlink" title="janus的架构模型"></a>janus的架构模型</h2><p><code>janus</code>的最大特色就是可以以插件的方式对业务模块进行管理。比如当你想实现新业务时，按照<code>janus Plugin</code>的要求写一个<code>plugin</code>，然后将它放到指定目录下，这样<code>janus</code>在启动时就可以将它加载到内存中。</p><p>下面这张图是janus的整体架构图：</p><p><img data-src="https://cdn.avdancedu.com/image/article/janus_plugin/janus_plugin.png" alt="janus架构图"></p><p>从上面这张图我们可以看到，<code>janus</code>在设计时被分成了两层，即<code>核心层</code>和<code>插件层</code>。核心层主要用于资源的分配（如线程的启动与分配）、底层事件处理、各种WebRTC协议的实现及处理等；插件层用于业务处理，各种传输类型命令的处理等。</p><p>从中我们可以知道，这样的架构设计及管理方式特别适合变化比较快的业务模型。因为我们可以随时生成一个新的janus插件，并将它加载到内存中。</p><p>OK，了解了<code>janus</code>的架构，我们再来看看janus是如何实现插件管理的吧。</p><h2 id="Linux-系统下动态库的动态加载"><a href="#Linux-系统下动态库的动态加载" class="headerlink" title="Linux 系统下动态库的动态加载"></a>Linux 系统下动态库的动态加载</h2><p>要想真正理解janus的插件管理，我们首先要知道Linux系统是如何动态加载库的，这是我们理解 janus 插件管理的基础。</p><p>在Linux系统中，动态加载库其实很容易，只要用两个API 就可以了，即 <strong>dlopen</strong> 和 <strong>dlsym</strong> 。它们的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  path: 被加载到内存中的动态库路径</span><br><span class="line"> *  mode: RTLD_LAZY，用时加载；RTLD_NOW，立即加载；</span><br><span class="line"> *  return: handle，即被加载的动态库的内存地址</span><br><span class="line"> *&#x2F;</span><br><span class="line">void* dlopen(const char* path, int mode);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * handle: dlopen 的返回值</span><br><span class="line"> * symbol: 指向动态库中的符号，如函数，变量等</span><br><span class="line"> * return: 返回在内存中的符号地址</span><br><span class="line"> *&#x2F;</span><br><span class="line">void* dlsym(void* handle, const char* symbol);</span><br></pre></td></tr></table></figure><p>其中，<strong>dlopen</strong> 用于将动态库加载到内存中；<strong>dlsym</strong> 用于查找被加载到内存中的动态库的函数或变量的地址。</p><p>接下来我们就使用这两个API 来演示一下如何在 Linux 系统下动态加载库。</p><p>要想做这个演示，首先我们要写一个动态库。这个动态库特别简单，就一个函数 <strong>add()</strong> ， 用于加法运算。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;源码</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int add(int a, int b)&#123;</span><br><span class="line">  return a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;编译</span><br><span class="line">gcc -shared -o add.so add.c</span><br></pre></td></tr></table></figure><p>通过上面的操作我们就有了一个add.so的动态库。接下来我们再来看看如何使用 <strong>dlopen</strong> 及 <strong>dlsym</strong> 将上面生成的库动态库加载到内存中，并调用它的 <strong>add()</strong> 方法吧。具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line"></span><br><span class="line">typedef int(*FUNC)(int,int);</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])&#123;</span><br><span class="line">  void* handler &#x3D; dlopen(&quot;.&#x2F;add.so&quot;, RTLD_NOW);</span><br><span class="line">  if(!handler)&#123;</span><br><span class="line">    printf(&quot;Failed to load so!\n&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  FUNC func &#x3D; (FUNC)dlsym(handler, &quot;add&quot;);</span><br><span class="line">  int r &#x3D; func(10, 20);</span><br><span class="line">  printf(&quot;the result is : %d\n&quot;, r);</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;编译</span><br><span class="line">gcc -g -o loadso mytest.c</span><br></pre></td></tr></table></figure><p>上面的这段代码是不是很简单？短短的几行代码就向你展示了在 Linux/Mac 系统下动态加载并调用动态库中方法的具体步骤。有了上面的知识，我们再来看janus的实现就很容易理解它是如何做的了。</p><h2 id="janus-加载Plugin"><a href="#janus-加载Plugin" class="headerlink" title="janus 加载Plugin"></a>janus 加载Plugin</h2><p>janus实现加载插件的代码量很大，但核心代码就那么几行，只要我们将核心代码抽取出来，我们就会发现其实它与我们上面讲的代码几乎是一模一样的。下面我们来看看janus 是如何动态加载库的吧。</p><p>为了方便janus专门创建了一个目录用于存放插件。在janus启动时它会遍历该目录，并将目录中的插件一个个动态加载到内存中。经整理后的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((pluginent = readdir(dir))) &#123;</span><br><span class="line">  ......</span><br><span class="line">  g_snprintf(pluginpath, <span class="number">1024</span>, <span class="string">"%s/%s"</span>, path, pluginent-&gt;d_name);</span><br><span class="line">  <span class="keyword">void</span> *plugin = dlopen(pluginpath, RTLD_NOW |   RTLD_GLOBAL);</span><br><span class="line">  ......</span><br><span class="line">  create_p *create = (create_p*) dlsym(plugin, <span class="string">"create"</span>);</span><br><span class="line">  ......</span><br><span class="line">  janus_plugin *janus_plugin = create();</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这段核心代码是不是与我们上面 <strong>Linux 系统下动态库的动态加载</strong> 一节介绍的几乎是一样的？所以我们只要把基础知识撑握好了，再看一些复杂的实现时也就不会感觉很难了。</p><p>从上面的代码中我们还可以看到，janus 中的每个插件都实现了create 函数。该函数会返回一个包含多个函数的结构体。这些函数是我们实现janus插件必须要实现的，它们包括:</p><ul><li><code>init()</code>: 该函数是插件的初始化函数，像读取配置文件等操作都应该在这个函数中实现。</li><li><code>destroy()</code>: 插件被关闭的时候被调用</li><li><code>get_api_compatibility()</code>: 该方法只需要返回janus的API版本即可，用于控制不同janus版本是否兼容</li><li><code>get_version()</code>: 返回版本号(例如 3)</li><li><code>get_version_string()</code>: 返回字符串格式的版本号(例如, “v1.0.1”)</li><li><code>get_description()</code>: 返回插件的详细信息</li><li><code>get_name()</code>: 返回插件的短名子</li><li><code>get_package()</code>:返回插件的唯一包标识 (例如., “janus.plugin.myplugin”);</li><li><code>create_session()</code>: 在你和客户端之间创建一个session</li><li><code>handle_message()</code>: 处理对方发送给你的消息</li><li><code>handle_admin_message()</code>: 来自Admin API的消息</li><li><code>setup_media()</code>: 创建socket，建立与客户端<code>peerConnection</code>之间的连接</li><li><code>incoming_rtp()</code>: 接收客户端发过来的<code>rtp</code>包</li><li><code>incoming_rtcp()</code>: 接收客户端发过来的<code>rtcp</code>消息</li><li><code>incoming_data()</code>: 接收客户端通过<code>SCTP DataChannel</code>发过来的数据</li><li><code>data_ready()</code>: 检查数据是否可以通过<code>SCTP DataChannel</code>发送了</li><li><code>slow_link()</code>: 客户端发过来很多<code>NACK</code>，说是此时网络质量变差了</li><li><code>hangup_media()</code>: 客户端关闭了<code>PeerConnection</code></li><li><code>query_session()</code>: 查询在你与客户端之间的<code>session</code>信息</li><li><code>destroy_session()</code>: 销毁<code>session</code></li></ul><p>对于一个插件来讲，上面的方法中除了 <code>incoming_rtp</code> 、<code>incoming_rtcp</code>、<code>incoming_data</code> 可以不实现外，其它的方法都必须实现。只有这样当插件被<code>janus</code>核心层加载之后，才可以被顺利的调用。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我重点向你介绍了<code>janus</code>是如何使用和管理<code>plugin</code>的，同时向你简要的介绍了<code>janus</code>的架构模型以及要实现一个<code>janus</code>插件要实现哪些函数。</p><p>当然，我们这里只是对<code>plugin</code>做了一个大体的讲解，很多细节这里并没有讲到，我会在后面的文档中做更详细的介绍 。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门》</a></li><li><a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级高并发WebRTC流媒体服务器设计与开发》</a></li><li><a href="https://time.geekbang.org/column/intro/207" target="_blank" rel="noopener">《从0打造音视频直播系统》</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;janus&lt;/code&gt;中的&lt;code&gt;plugin&lt;/code&gt;是其非常重要的一部分内容，今天我们就来对这块内容做一下分析，看看&lt;code&gt;janus&lt;/code&gt;是如何实现&lt;code&gt;plugin&lt;/code&gt;的，以及它的工作原理是怎样的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="plugin" scheme="https://blog.avdancedu.com/tags/plugin/"/>
    
  </entry>
  
  <entry>
    <title>janus深入分析系列文章</title>
    <link href="https://blog.avdancedu.com/aafa6b93/"/>
    <id>https://blog.avdancedu.com/aafa6b93/</id>
    <published>2020-06-29T02:04:44.000Z</published>
    <updated>2020-06-29T06:26:50.507Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/janus_deep/janus_deep.jpg" alt=""></p><p>说到WebRTC流媒体服务器就不得不提<code>janus</code>，它是WebRTC众多流媒体服务器中的重要一员，其以优越的性能、丰富的功能、灵活的配置而著称。由于工作的原因，最近这段时间一直在分析<code>janus</code>，陆续整理出了我对janus的一些分析，希望这些文章对你了解<code>janus</code>能有所帮助。</p><a id="more"></a><h2 id="janus系列文章"><a href="#janus系列文章" class="headerlink" title="janus系列文章"></a>janus系列文章</h2><p>下面的这些文章是按照<strong>认知</strong>、<strong>使用</strong>、<strong>逐步深入</strong>的顺序做了编排，这种阅读顺序应该会使你更容易理解<code>janus</code>的整个运行机制。</p><ul><li><a href="http://avdancedu.com/947c722a/" target="_blank" rel="noopener">WebRTC流媒体服务器比较</a></li><li><a href="https://avdancedu.com/ed54b3d4/" target="_blank" rel="noopener">音视频会议系统-janus的编译与布署</a></li><li><a href="https://avdancedu.com/fdfe2594/" target="_blank" rel="noopener">janus各文件及目录的作用</a></li><li><a href="https://avdancedu.com/8f43ddc9/" target="_blank" rel="noopener">janus的线程模型</a></li><li><a href="https://avdancedu.com/26c3d930/" target="_blank" rel="noopener">深入理解janus的插件管理</a></li><li><a href="https://avdancedu.com/bb906872/" target="_blank" rel="noopener">janus的videoroom插件信令实现</a></li><li><a href="https://avdancedu.com/d7281c13/" target="_blank" rel="noopener">janus.js源码分析</a></li><li><a href="https://avdancedu.com/5ae5ee2f/" target="_blank" rel="noopener">janus.js的使用</a></li></ul><p>更深入的文章还在不断整理中，会陆续加到这个系列文章中来。如果你感兴趣也可以将你的分析心得放到这里，与大家一起分享。</p><p>另外，也欢迎大家一起讨论，文中有描述的不清楚的地方也希望大家指正批评！ </p><p>谢谢！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://coding.imooc.com/class/415.html" target="_blank" rel="noopener">音视频系统入门</a></li><li><a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">WebRTC入门与实战</a></li><li><a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">百万级WebRTC流媒体服务器设计与开发</a></li><li><a href="https://time.geekbang.org/column/article/132863" target="_blank" rel="noopener">从0开始打造音视频直播系统</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/janus_deep/janus_deep.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;说到WebRTC流媒体服务器就不得不提&lt;code&gt;janus&lt;/code&gt;，它是WebRTC众多流媒体服务器中的重要一员，其以优越的性能、丰富的功能、灵活的配置而著称。由于工作的原因，最近这段时间一直在分析&lt;code&gt;janus&lt;/code&gt;，陆续整理出了我对janus的一些分析，希望这些文章对你了解&lt;code&gt;janus&lt;/code&gt;能有所帮助。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="janus" scheme="https://blog.avdancedu.com/tags/janus/"/>
    
  </entry>
  
  <entry>
    <title>janus各文件及目录的作用</title>
    <link href="https://blog.avdancedu.com/fdfe2594/"/>
    <id>https://blog.avdancedu.com/fdfe2594/</id>
    <published>2020-06-28T11:57:29.000Z</published>
    <updated>2020-06-29T05:31:43.573Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/janus_file/janus_arch.jpg" alt="janus架构图"></p><p>在<a href="https://avdancedu.com/ed54b3d4/" target="_blank" rel="noopener">《音视频会议系统-janus的安装与布署》</a>一文中我已经向你介绍了如何布署<code>janus</code>，今天我们再来了解一下<code>janus</code>的源码，看看<code>janus</code>包括哪些文件以及它们所起的作用是什么。</p><a id="more"></a><h2 id="下载-janus-源码"><a href="#下载-janus-源码" class="headerlink" title="下载 janus 源码"></a>下载 janus 源码</h2><p><code>janus</code>源码可以在<a href="https://github.com/meetecho/janus-gateway" target="_blank" rel="noopener">这里</a>找到，执行下面命令就可将其下载下来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;meetecho&#x2F;janus-gateway.git</span><br><span class="line">cd janus-gateway</span><br></pre></td></tr></table></figure><h2 id="janus各源码文件的作用"><a href="#janus各源码文件的作用" class="headerlink" title="janus各源码文件的作用"></a>janus各源码文件的作用</h2><p>下载好<code>janus</code>源码后，你可以看到<code>janus</code>目录下有很多文件，这里我列出了比较重要的几个文件，下面来说明一下它们起所的作用是什么。目录列表如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">events           # 主要用于各种事件消息的分析</span><br><span class="line">plugins          # 各种业务插件，所有的业务应用都在这里实现</span><br><span class="line">transports       # 用于处理各种网络信令，HTTP、WebSocket、MQTT等</span><br><span class="line">docs             <span class="meta"># janus的文档，它是通过 Doxygen 生成的，janus的文档还是很全面的</span></span><br><span class="line">html             # Web端的Demo都放在这里</span><br><span class="line">rtcp.h           # RTCP 是RTP的控制协议</span><br><span class="line">rtcp.c           # RTCP 协议的具体实现</span><br><span class="line">rtp.c            # RTP协议的实现，它用于传输音视频数据</span><br><span class="line">rtp.h            # RTP 协议的头文件</span><br><span class="line">rtpsrtp.h        # SRTP 协议</span><br><span class="line">sctp.c           # SCTP 协议的实现</span><br><span class="line">sctp.h           # SCTP 协议的头文件</span><br><span class="line">sdp.c            # SDP 协议的实现</span><br><span class="line">sdp.h            # SDP 协议的头文件</span><br><span class="line">sdp-utils.c      # 处理 SDP 的常用工具</span><br><span class="line">sdp-utils.h</span><br><span class="line">test             # 测试文件所在目录</span><br><span class="line">record.c         <span class="meta"># janus的录制功能在该文件中实现</span></span><br><span class="line">record.h</span><br><span class="line">ice.c            <span class="meta"># janus 使用 libnice 实现 ICE 功能，该文件是对libnice库的封装</span></span><br><span class="line">ice.h</span><br><span class="line">janus.c          # 该文件是janus的主框架程序，里边做了很多事儿</span><br><span class="line">janus.h</span><br><span class="line"><span class="built_in">log</span>.c            # 日志</span><br><span class="line"><span class="built_in">log</span>.h</span><br><span class="line">dtls-bio.c       # DTLS 中 BIO 的实现</span><br><span class="line">dtls-bio.h</span><br><span class="line">dtls.c           # DTLS 协议实现</span><br><span class="line">dtls.h</span><br><span class="line">events.c         # 配合events插件与janus core连接用的</span><br><span class="line">events.h</span><br></pre></td></tr></table></figure><p>对于上面的文件我们可能将它们分成几大类：</p><ul><li>业务插件，<code>plugins</code>目录下的所有文件都属于该类，其主要作用是实现不同的业务逻辑的服务端，如<code>echotest</code>、<code>videoroom</code>、<code>videocall</code>等。</li><li>事件分析，<code>events</code>目录下的所有文件以及<code>events.c|h</code>，其作用是收集事件消息，做分析使用。这个功能只能高级用户才会用，对于一般用户来说可以不关注它。</li><li>协议，包括 <code>rtp.c|h</code>、<code>rtcp.c|h</code>、<code>rtpsrtp.h</code>、<code>stcp.c|h</code>、<code>sdp.c|h</code>、<code>dtls.c|h</code>、<code>dtls-bio.c|h</code>，这些都是用于处理不同协议的，每个文件都比较独利。</li><li>日志，包括 <code>log.c|h</code>，这个应该一眼就可以看出来。</li><li>浏览器Demo，<code>html</code>目录中的所有文件，主要包括一些demo程序，如videoroom、echotest等。</li><li>信令传输，<code>transports</code>目录下的文件属于该类，作用是接收不同传输协议发送过来的消息，并使用同样的协议将响应消息返回。</li><li>数据传输，<code>ice.c|h</code>，它是对<code>libnice</code>库的封装，用于媒体数据的传输。</li><li>janus核心，<code>janus.c|h</code>，这是<code>janus</code>中最核心的文件，程序的启动，插件的加载，数据的流转都是通过它来实现的。</li></ul><p>在上面几个类别中， <strong>janus核心</strong>、<strong>数据传输</strong>、<strong>信令传输</strong>、<strong>业务插件</strong>、<strong>浏览器Demo</strong> 中的代码是比较重要的，所以是你在阅读代码时需要重点看的内容。由于<strong>信令传输</strong>、<strong>业务插件</strong>、<strong>浏览器Demo</strong>都是目录，里边还包括了很多文件，所以下面我们再来看看这三个目录中都包括了那些文件。</p><h3 id="信令传输"><a href="#信令传输" class="headerlink" title="信令传输"></a>信令传输</h3><p>进入到 <code>transports</code> 目录，你会它有以下几个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">transport.h             # 定义了&#96;信令传输&#96;插件的接口</span><br><span class="line">transport.c             # 定义了几个通用的释放资源的函数</span><br><span class="line">janus_http.c            # HTTP 接口，默认使用的接口</span><br><span class="line">janus_mqtt.c            # MQTT 接口，编译时需要明确指定才会编入janus</span><br><span class="line">janus_pfunix.c          # UNIX 接口</span><br><span class="line">janus_nanomsg.c         # NanoMSG 接口</span><br><span class="line">janus_rabbitmq.c        # RabbitMQ 接口</span><br><span class="line">janus_websockets.c      # Websocket 接口</span><br></pre></td></tr></table></figure><p><code>janus</code>支持的信令接口方式还是蛮全的，这是它的一大优势。用户可以选择自己喜欢的接入方式进行接入。通过上面的描述你应该很容易判断出每个文件的作用，你对那个感兴趣就可以专门看那个文件。默认情况下<code>janus</code>使用的是HTTP接口，因此该接口也是最成熟的。</p><h3 id="业务插件"><a href="#业务插件" class="headerlink" title="业务插件"></a>业务插件</h3><p><code>janus</code>支持很多业务插件，这对于很多用户来说也是一个非常棒的特点，我们来看一下它都支持那些插件吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">plugin.h                # 定义了业务插件的接口</span><br><span class="line">plugin.c                # 实现了一些公用的释放资源的函数</span><br><span class="line">janus_echotest.c        # 回显业务插件</span><br><span class="line">janus_videocall.c       # 1:1视频通讯业务插件</span><br><span class="line">janus_videoroom.c       # 会议业务插件</span><br><span class="line">janus_textroom.c        # 文本聊天室插件</span><br><span class="line">janus_streaming.c       # 传输直接流插件，可以播放视频文件，或其它的RTP数据流</span><br><span class="line">streams</span><br><span class="line">janus_recordplay.c      # 录制回放业务插件</span><br><span class="line">recordings</span><br><span class="line">janus_sip.c             # sip 业务插件，主要用于与电话业务的互通</span><br><span class="line">janus_nosip.c           # 包含sip信令业务插件，用它可以中转RTP数据</span><br><span class="line">janus_audiobridge.c     # 音频会议插件</span><br><span class="line">janus_voicemail.c       # 语言信箱业务插件</span><br><span class="line">janus_lua.c             # lua 语言开发插件</span><br><span class="line">janus_lua_extra.h</span><br><span class="line">janus_lua_extra.c</span><br><span class="line">janus_lua_data.h</span><br><span class="line">lua</span><br><span class="line">janus_duktape.c         # duktape语言插件</span><br><span class="line">janus_duktape_extra.h</span><br><span class="line">janus_duktape_extra.c</span><br><span class="line">janus_duktape_data.h</span><br><span class="line">duktape</span><br><span class="line">duktape-deps</span><br></pre></td></tr></table></figure><p>通过上面的文件列表，我们看到<code>janus</code>支持的插件可真不少，有会议视会议的、1：1通话的、SIP、RTP、流…等等。这些插件几乎含盖的所有的业务场景。对于用户来话，要以根据自己的需求选择上面的业务插件进行修改即可完成自己的业务了。</p><p>最后我们再来看看客户端 Demo。</p><h3 id="HTML-Demo"><a href="#HTML-Demo" class="headerlink" title="HTML Demo"></a>HTML Demo</h3><p>在<code>janus</code>的html目录中有很多文件，其中大部分文件是与上面<code>业务插件</code>中的内容是对应的。也就是说一个业务插件对应一个HTML Demo。所以这块的内容大家自己看一下就可以了。我就不在这里一一列出来了。</p><p>通过上面的描述，我们大体上可以知道<code>janus</code>的实现并不是特别复杂。它实现了RTP/RTCP、SRTP、SCTP、DTLS/DTLS-BIO、SDP 等 WebRTC 必要的协议，而对于数据的传输则是使用<code>libnice</code> 库，并通过<code>ice.c|h</code>对libnice 做了一层封装。</p><p>除此之外，它所有的业务层都是以<code>plugin</code>的方式实现的，这对于后面的业务拓展有很大的优势。当我们要实现一个新业务时，只要按照 plugin 的规则进行开发就好了，非常简单。</p><p>另外，janus是用纯C实现的，并且使用了Linux社区丰常优秀的库<code>glib</code>(注意不是glibc)，这个库的性能非常好，对于在Linux 下开发的同学来说对它应该十分熟悉。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过本文，你应该对<code>janus</code>的源码有了一个大体功能的了解。由于<code>WebRTC</code>使用了很多的协议（如 RTP/RTCP、DTLS、SDP等），因此作为服务端的<code>janus</code>也必须实现这些协议，这样才能与<code>WebRTC</code>进行通信。</p><p>对于<code>janus</code>使用的这些协议可能很多同学会觉得一脸懵B，不知道其中的原理和作用，如果你对这块感兴趣的话，可以去看我的网课<a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门》</a>，在课程里我对这些协议都做了详细介绍。</p><p>如果你有一定基础的话，现在应该知道<code>janus</code>的实现并不是特别复杂，但它的架构设计还是很值得借鉴的，尤其是<code>plugin</code>的设计方案。</p><p>今天我只是对<code>janus</code>做个初步分析，后面会对它的一些性能做下详细分析，静请期待！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">《WebRTC入门》</a></li><li><a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级高并发WebRTC流媒体服务器设计与开发》</a></li><li><a href="https://time.geekbang.org/column/intro/207" target="_blank" rel="noopener">《从0打造音视频直播系统》</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/janus_file/janus_arch.jpg&quot; alt=&quot;janus架构图&quot;&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://avdancedu.com/ed54b3d4/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《音视频会议系统-janus的安装与布署》&lt;/a&gt;一文中我已经向你介绍了如何布署&lt;code&gt;janus&lt;/code&gt;，今天我们再来了解一下&lt;code&gt;janus&lt;/code&gt;的源码，看看&lt;code&gt;janus&lt;/code&gt;包括哪些文件以及它们所起的作用是什么。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="janus" scheme="https://blog.avdancedu.com/tags/janus/"/>
    
  </entry>
  
  <entry>
    <title>音视频会议系统-janus的编译与布署</title>
    <link href="https://blog.avdancedu.com/ed54b3d4/"/>
    <id>https://blog.avdancedu.com/ed54b3d4/</id>
    <published>2020-06-28T11:13:12.000Z</published>
    <updated>2020-06-29T04:13:49.754Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/janus_deploy/janus.jpg" alt=""></p><p>说到WebRTC流媒体服务器就不得不提janus。说实话我以前对这款流媒体服务器并没有进行特别深入的研究，不过2019年10月我有幸作为声网RTC大会 Workshop 分会场的主讲嘉宾及串场人与janus的创始人<strong>Lorenzo Miniero</strong>有了一次深入交流，从中了解到janus的强大，因此决定有时间一定要对janus做下深入分析。</p><a id="more"></a><p><img data-src="https://cdn.avdancedu.com/image/article/janus_deploy/agora.jpg" alt="声网RTC大会"></p><p>正好前段时间忙完了手头的一些工作，终于可以有时间来对janus做详细研究了，而本篇则是对janus分析的第一篇文章。</p><p>下面我们就来看一下如何在一台 Ubuntu 系统下安装布署 janus。</p><h1 id="janus的布署方法"><a href="#janus的布署方法" class="headerlink" title="janus的布署方法"></a>janus的布署方法</h1><p>不得不说janus提供的文档还是非常全面的，如果你英文比较好的话，完全可以按它的文档进行操作。但对于一些新手来说，通过阅读本文可以让你快速的在本机搭建出janus Demo，所以本文对你仍然是非常有意义的。</p><h2 id="布署环境"><a href="#布署环境" class="headerlink" title="布署环境"></a>布署环境</h2><p>janus的官方文档建议你把它安装在Linux系统上，可以是 Ubuntu、CentOS等。当然你也可以在MacOS上安装它，而文档中明确说明它不支持Ｗindows系统，因此千万不要再在Windows上浪费时间了。</p><p>对于我来说，我一直比较倾向于使用Ubuntu系统，最主要的原因是安装依赖包比较方便。如果你是Linux新手，我更是强烈推建你使用Ubuntu，这样可以让你更快速入门Linux。而CentOS安装依赖包则会麻烦得多，虽然它也提供yum（类似Ubuntu中的apt）工具，但有很多库都必须通过源码编译的方式安装，这样很繁琐。</p><p>今天我们就使用<strong>Ubuntu系统</strong>作为janus的布署环境，而且这个环境是一台<strong>本地主机</strong>，而不是云主机，这样可以大大减少很多不必要的麻烦。</p><h2 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h2><p>在我们正式布署janus之前，需要先在Ubuntu系统上安装上必要的依赖包。在Ubuntu上安装依赖包非常方便，只要执行下面的命令就好了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libmicrohttpd-dev libjansson-dev \</span><br><span class="line">       libssl-dev libsofia-sip-ua-dev libglib2.0-dev libopus-dev \</span><br><span class="line">       libogg-dev libcurl4-openssl-dev liblua5.3-ev libconfig-dev\</span><br><span class="line">       pkg-config gengetopt libtool automake libscrtp-dev \</span><br><span class="line">               libwebsockets-dev  librabbitmq-dev libnanomsg-dev libnice-dev \</span><br><span class="line">               gtk-doc-tools doxygen graphviz</span><br></pre></td></tr></table></figure><p>除了以上这些可以通过 apt工具安装的依赖包外，还有一个依赖库是必须通过源码安装的，它就是libsrtp库。</p><p>libsrtp库的主要作用是对数据进行加密。之所以要通过源码安装，是因为在apt源上的libsrtp库没有将ssl库编译上，而janus又需要使ssl库对数据做最终的加密，所以我们只能使用源码的方式安装了。具体操作步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;cisco&#x2F;libsrtp&#x2F;archive&#x2F;v2.2.0.tar.gz</span><br><span class="line">tar xfv v2.2.0.tar.gz</span><br><span class="line">cd libsrtp-2.2.0</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr --enable-openssl</span><br><span class="line">make shared_library &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><h2 id="编译安装janus"><a href="#编译安装janus" class="headerlink" title="编译安装janus"></a>编译安装janus</h2><p>布署环境搭建好之后，编译安装janus还是非常简单的，就按下面的三步执行就好了：</p><ul><li>下载 janus 源码</li><li>执行 ./configure 生成 Makefile 文件</li><li>执行 make -j 4 &amp; sudo make install</li></ul><p>首先我们来看看如何下载janus的源码，操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;meetecho&#x2F;janus-gateway.git</span><br><span class="line">cd janus-gateway</span><br></pre></td></tr></table></figure><p>源码下载好后，执行./configure就可以生成Makefile文件了。但需要注意的是，在执行./configure之前，先要执行autogen.sh脚本，这样才能生成./configure文件。具体操作步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;autogen.sh</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;janus</span><br></pre></td></tr></table></figure><p>当./configure执行完成后，Makefile文件就生成了，紧接着我们要开始编译安装 janus 了。按下面的执行步骤操作就好了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j 4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>通过上面的步骤，我们就将janus编译好并成功安装了。</p><h1 id="启动janus"><a href="#启动janus" class="headerlink" title="启动janus"></a>启动janus</h1><p>安装好janus 后，启动它非常容易，但在启动之前，我们还要为它准备好配置文件。</p><p>janus在启动时会分析配置文件，然后按照配置文件中的信息启动加载对应的模块。该如何构建配置文件呢？对于初学janus的新手来说，看到janus有一堆的参数，在构造配置文件时可能就有点懵了。</p><p>不过janus已经为我们想好了解决方案，就是从它的配置文件模板中拷贝一份作为janus的配置文件。其中最简单的就是将 janus.jcfg.sample作为配置文件即可。具体操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;installdir&gt;&#x2F;etc&#x2F;janus&#x2F;</span><br><span class="line">cp janus.jcfg.sample janus.jcfg</span><br></pre></td></tr></table></figure><p>有了janus配置文件之后，我们就可以直接启动janus了，执行如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;janus</span><br></pre></td></tr></table></figure><p>OK，到目前为止，我们就已经将janus启动好了。此时，如果有用户连接janus的话，你就可以从终端上看到对应的连接信息。</p><p>上面的启动方式非常适合于我们观察和调试janus，但如果你想让它像服务器一样一直运行，则需要让janus到Linux系统的后台运行。这该如何实现呢？其实操作也很简单，只要执行下面的命令就好了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;janus &amp;</span><br></pre></td></tr></table></figure><h1 id="janus-Demo的布署"><a href="#janus-Demo的布署" class="headerlink" title="janus Demo的布署"></a>janus Demo的布署</h1><p>通过上面的步骤我们已经将janus网关布署好了，但此时janus Demo还无法使用，我们还必须搭建一台WebServer，将janus Demo 客户端发布出来才行。</p><p>关于WebServer的搭建方法我这里就不做详细介绍了，大家应该在网上都可以找到方法，比如使用 nginx、nodejs、Apache、Tomcat等都是可以的。</p><p>当WebServer搭建好后，将/usr/local/janus/share/janus/demo目录中的内容全部拷贝到WebServer的发布目录下即可，这样我们就大功告成了！</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过上面的描述，我们就将如何搭建janus Demo的步骤向你做了详细的介绍，让你知道了如何在Ubuntu下搭建janus服务，又该如何将janus Demo布署好。总结起来就是以下三步：</p><ul><li>安装依赖包</li><li>编译安装janus</li><li>布署WebServer，并将 janus Demo 代码放到 WebServer发布目录下</li></ul><p>需要注意的是，我这里提供的方法只适用于本机，如果你想在云服务器上布署 janus的话，还有其它一些工作要做。对于这一点，我在这里就不做详细论述了，有兴趣的同学可以去参考我在慕课网的课程。</p><p>谢谢！</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">《百万级高并发WebRTC流媒体服务器设计与开发》</a></li><li><a href="https://time.geekbang.org/column/intro/207" target="_blank" rel="noopener">《从0打造音视频直播系统》</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/janus_deploy/janus.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;说到WebRTC流媒体服务器就不得不提janus。说实话我以前对这款流媒体服务器并没有进行特别深入的研究，不过2019年10月我有幸作为声网RTC大会 Workshop 分会场的主讲嘉宾及串场人与janus的创始人&lt;strong&gt;Lorenzo Miniero&lt;/strong&gt;有了一次深入交流，从中了解到janus的强大，因此决定有时间一定要对janus做下深入分析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="janus" scheme="https://blog.avdancedu.com/tags/janus/"/>
    
  </entry>
  
  <entry>
    <title>janus.js的使用</title>
    <link href="https://blog.avdancedu.com/5ae5ee2f/"/>
    <id>https://blog.avdancedu.com/5ae5ee2f/</id>
    <published>2020-06-24T12:48:27.000Z</published>
    <updated>2020-06-29T05:30:35.457Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/janus_jscall/jscall.jpg" alt=""></p><p>之前我在<a href="https://avdancedu.com/d7281c13/" target="_blank" rel="noopener">《janus前端核心库源码分析》</a>一文中已经向你详细分析了<code>janus.js</code>文件的实现，但对于大多同学来说，知道如何使用它才是最重要的。那具体我们该如何使用它呢？janus中的<code>videoroomtest.js</code>是一个不错的例子，今天就来分析一下<code>videoroomtest.js</code>，看看它是是如何使用<code>janus.js</code>的。</p><a id="more"></a><p>通过分析<code>videoroomtest.js</code>文件，你会发现使用<code>janus.js</code>的步骤很简单，只要下面三步即可：</p><ul><li>初始化<code>janus.js</code></li><li>创建<code>Janus</code>对象</li><li>attach 音视频流</li></ul><p>下面我就按上面的顺序向你逐一介绍<code>videoroomtest.js</code>是如何使用<code>janus.js</code>的。</p><h2 id="janus的初始化"><a href="#janus的初始化" class="headerlink" title="janus的初始化"></a>janus的初始化</h2><p>我们使用<code>janus.js</code>之前，第一步就是调用<code>Janus</code>的<code>类</code>方法<code>init</code>来初始化<code>janus.js</code>。方法的原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Janus.init &#x3D; function(options)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>init</code>方法需要一个<code>JSON</code>格式的输入参数，它包括两个<code>域</code>: <code>debug</code>和一个回调函数<code>callback</code>。这样当<code>init</code>执行完成后，就可以通过<code>callback</code>将结果返回到应用层了。<code>videoroomtest.js</code>调用<code>Janus.init</code>的代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Janus.init(</span><br><span class="line">            &#123;</span><br><span class="line">                debug: &quot;all&quot;,</span><br><span class="line">                callback: function()&#123;...&#125;</span><br><span class="line">            &#125;</span><br><span class="line">          );</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面的代码非常简单，关键的一点是我们要知道传入的参数是<code>JSON</code> 格式的，它有两个域<code>debug</code>和<code>callback</code>即可。知道如何调用了，接下来我们再来看看<code>init</code>函数的实现。</p><p><code>janus.js</code>的<code>init</code>方法实现了什么功能呢？我们把<code>Janus.init</code>方法中的主干逻辑抽取出来，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Janus.init &#x3D; function(options) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if(Janus.initDone) &#123;</span><br><span class="line">        options.callback();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ...</span><br><span class="line">        Janus.initDone &#x3D; true;</span><br><span class="line">        options.callback();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中的<code>initDone</code>表示的是之前是否初始化过<code>janus.js</code>？而<code>options</code>是<code>init</code>方法的输入参数，通过它可以回调应用层。通过上面的代码我们可以知道<code>init</code>方法的功能其实蛮简单的，就是将<code>initDone</code>置位，并回调应用层。</p><p>接下来我们看一下<code>init</code>回调应用层后，在应用层又做了什么事儿。 输入参数<code>options</code>的<code>callback</code>方法在<code>videoroomtest.js</code>中是一个<code>匿名函数</code>，其主干逻辑代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">callback: function() &#123;</span><br><span class="line">    $(&#39;#start&#39;).one(&#39;click&#39;, function() &#123; ... &#125; )</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>正如你上面看到的，<code>callback</code>函数只有一行关键代码，即给<code>start</code> 键钮绑定了一个<code>click</code>方法。当用户点击<code>start</code>时执行该方法。那么应用层在<code>start</code>方法中又做了哪些事儿呢？</p><h2 id="创建Janus对象"><a href="#创建Janus对象" class="headerlink" title="创建Janus对象"></a>创建Janus对象</h2><p>下面的代码就是<code>start</code>方法的主逻辑，从中我们可以知道<code>start</code>方法中完成了使用<code>janus.js</code>的第二个关键步骤，即创建<code>Janus</code>对象。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if(!Janus.isWebrtcSupported()) &#123;</span><br><span class="line">    ...</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">janus &#x3D; new Janus(</span><br><span class="line">                    &#123;</span><br><span class="line">                        server: server,</span><br><span class="line">                        success: function() &#123; ... &#125;,</span><br><span class="line">                        error: function(error) &#123; ... &#125;,</span><br><span class="line">                        destroyed: function() &#123; ... &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                 );</span><br></pre></td></tr></table></figure><p>在该方法中首先判断<code>浏览器</code>是否支持<code>WebRTC</code>，如果不支持则直接退出，否则创建<code>Janus</code>对象。在创建<code>Janus</code>对象时，需要给它传入了一个<code>JSON</code>格式的参数，该<code>JSON</code>对象包括以下几个<code>域</code>：</p><ul><li>server，Janus服务器地址</li><li>success，连接成功后执行的回调函数</li><li>error，连接失败后执行的回调函数</li><li>destroyed，连接销毁时的回调函数</li></ul><p>在上述几个<code>域</code>中，最关键的是<code>success</code>回调函数。它的含义是当Janus对象创建成功后，回调该函数到应用层。但对于这个回调函的详细介绍我们先<code>暂时</code>放一放，现在我们先来看看创建<code>Janus</code>对象时都做了哪些事儿，然后再来分析<code>success</code>回调函数。</p><p>Janus类的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function Janus(gatewayCallbacks) &#123;</span><br><span class="line">    ...</span><br><span class="line">    createSession(gatewayCallbacks);</span><br><span class="line">    ...</span><br><span class="line">    this.attach &#x3D; function(callbacks) &#123; createHandle(callbacks); &#125;;</span><br><span class="line">    function handleEvent(json, skipTimeout) &#123; ... &#125;;</span><br><span class="line">    function keepAlive() &#123;&#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建Session</span><br><span class="line">    function createSession(callbacks) &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F;与服务器相连</span><br><span class="line">        Janus.httpAPICall(server,</span><br><span class="line">                          &#123;</span><br><span class="line">                            ...</span><br><span class="line">                            &#x2F;&#x2F;处理服务器发过来的消息</span><br><span class="line">                            success: handleEvent(...)&#123; ... &#125;;</span><br><span class="line">                            ...</span><br><span class="line">                          &#125;);</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;绑定媒体流</span><br><span class="line">    function createHandle(callbacks) &#123;...&#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以知道，在创建<code>Janus</code>对象时它会调用<code>createSession</code>函数。而在<code>createSession</code>函数内部会通过<code>Janus</code>的<code>类</code>方法<code>httpAPICall</code>与服务端建立<code>HTTP</code>连接。连接建立成功后，会回调<code>success</code>函数，也就是类中的<code>handleEvent</code>方法。</p><p><code>handleEvent</code>的功能我在<a href="https://avdancedu.com/d7281c13/" target="_blank" rel="noopener">《janus前端核心库源码分析》</a>一文中已经介绍过，它用于处理服务端发来的消息，并根据不同的消息类型做不同的逻辑处理。</p><p>现在我们可以总结一下创建<code>Janus</code>对象所做的事儿啦，其实就两件事儿：一与<code>janus</code>服务器建立连接(HTTP/WebSocket/…)；二处理<code>janus</code>服务器发来的各种消息。</p><p>接下来我们再来讨论一下<code>Janus</code>对象创建成功后，回调<code>success</code>干了些什么吧！</p><h2 id="attach-绑定媒体流"><a href="#attach-绑定媒体流" class="headerlink" title="attach 绑定媒体流"></a>attach 绑定媒体流</h2><p>正如上面所说，<code>Janus</code>创建成功后会回调输入参数中的<code>success</code>函数。这个函数<code>特别重要</code>，下面我们来看看在该函数中实现了什么逻辑吧。</p><p>实际上，<code>success</code> 回调函数做的事儿也很简单，只是调用了 <code>janus.attach</code> 方法，<strong>而attach正是我们使用janus.js的第三步</strong>。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">success: function() &#123;</span><br><span class="line">    janus.attach(</span><br><span class="line">                    &#123;</span><br><span class="line">                        plugin: &quot;janus.plugin.videoroom&quot;,</span><br><span class="line">                        opaqueId: opaqueId,</span><br><span class="line">                        success: function(pluginHandle) &#123; ... &#125;,</span><br><span class="line">                        error: function(error) &#123; ... &#125;,</span><br><span class="line">                        consentDialog: function(on) &#123; ... &#125;,</span><br><span class="line">                        iceState: function(state) &#123; ... &#125;,</span><br><span class="line">                        mediaState: function(medium, on) &#123; ... &#125;,</span><br><span class="line">                        webrtcState: function(on) &#123; ... &#125;,</span><br><span class="line">                        onmessage: function(msg, jsep) &#123; ... &#125;,</span><br><span class="line">                        onlocalstream: function(stream) &#123; ... &#125;,</span><br><span class="line">                        onremotestream: function(stream) &#123; ... &#125;,</span><br><span class="line">                        oncleanup: function() &#123; ... &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，该方法的作用在<a href="https://avdancedu.com/d7281c13/" target="_blank" rel="noopener">《janus前端核心库源码分析》</a>一文中也已经做过介绍，该方法可以让浏览器与服务端的<code>videoroom插件</code>绑定，以便获取媒体流。</p><blockquote><p>这里<code>绑定</code>的真实含义是建立WEBRTC连接。</p></blockquote><p>在调用<code>attach</code>方法时，也要传一个<code>JSON</code>格式的对象。在该对像包含了很多属性，这些属性的含义如下：</p><ul><li>plugin，要绑定的<code>janus</code>插件，这里要绑定插件为<code>janus.plugin.videoroom</code>。</li><li>opaqueId，一个随机值，插件的唯一ID。</li><li>success，<code>attach</code>方法执行成功后的回调函数。</li><li>error，<code>attach</code>方法执行失败后的回调函数。</li><li>consentDialog,</li><li>iceState，可以通过该函数更新ICE状态。在<code>videoroomtest.js</code>中没有做任何处理。</li><li>mediaState，可以通过该函数更新媒体状态。该方法也没有做任你可事儿。</li><li>webrtcState，更改WebRTC状态的回调函数。</li><li>onmessage，收到事件消自己的回调函数。</li><li>onlocalstream，收到本地流时的回调函数。</li><li>onremotestream，收到远端流时的回调函数。</li><li>oncleanup，销毁时的回调函数。</li></ul><p>在上面属性中，比较关键的是<code>success</code>、<code>webrtceState</code>、<code>onmessage</code>、<code>onlocalstream</code>和<code>onremotestream</code> 。这几个属性都是回调函数，在不同的情况下<code>janus.js</code>会调不同的回调函数。下面我们就对这几个回调函数做一下详细分析。</p><h3 id="success回调函数"><a href="#success回调函数" class="headerlink" title="success回调函数"></a>success回调函数</h3><p>当调用<code>attach</code>方法成功与<code>janus</code>服务器<code>插件</code>绑定之后，<code>janus.js</code>会回调<code>success</code>函数。代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">this.attach &#x3D; function(callbacks) &#123; createHandle(callbacks); &#125;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">function createHandle(callbacks) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Janus.httpAPICall( server + &quot;&#x2F;&quot; + sessionId,</span><br><span class="line">                       &#123;</span><br><span class="line">                            verb: &#39;POST&#39;,</span><br><span class="line">                            withCredentials: withCredentials,</span><br><span class="line">                            body: request,</span><br><span class="line">                            success: function() &#123;</span><br><span class="line">                                var pluginHandle &#x3D; &#123; ... &#125;;</span><br><span class="line">                                callbacks.success(pluginHandle);</span><br><span class="line">                            &#125;,</span><br><span class="line">                            error: function() &#123; ... &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                     );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面代码的执行过程如下，<code>janus.js</code>向<code>janus</code>服务器发送<code>attach</code>请求，服务器收到<code>attach</code>请求后进行处理，然后根据处理结果返回<code>success</code>或<code>error</code>。如果浏览器收到的是服务器返回的<code>success</code>响应，那么就会回调<code>success</code>函数。</p><p>接下来我们看一下<code>success</code>回调到应用层<code>videoroomtest.js</code>后做了哪些事儿吧! 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">janus.attach(</span><br><span class="line">                &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    success: function(pluginHandle) &#123;</span><br><span class="line">                                ...</span><br><span class="line">                                sfutest &#x3D; pluginHandle;</span><br><span class="line">                                ...</span><br><span class="line">                             &#125;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>从上面的代码中我们可以看到，应用层<code>success</code>的逻辑非常简单，只是将<code>janus.js</code>层创建的<code>pluginHanle</code>保存起来以备后用，剩下的其它的一些代码是与界面相关的，我们这里就不介绍了。</p><h3 id="onmessage"><a href="#onmessage" class="headerlink" title="onmessage"></a>onmessage</h3><p><code>onmessagee</code>实现的是对<code>janus</code>服务端返回事件的处理逻辑。我们依然还是先看看在<code>janus.js</code>中是如何调用该函数的。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function handleEvent(json, skipTimeout) &#123;</span><br><span class="line">    ...</span><br><span class="line">    else if(json[&quot;janus&quot;] &#x3D;&#x3D;&#x3D; &quot;event&quot;) &#123;</span><br><span class="line">        ...</span><br><span class="line">        var sender &#x3D; json[&quot;sender&quot;];</span><br><span class="line">        var pluginHandle &#x3D; pluginHandles[sender];</span><br><span class="line">        ...</span><br><span class="line">        var plugindata &#x3D; json[&quot;plugindata&quot;];</span><br><span class="line">        ...</span><br><span class="line">        var jsep &#x3D; json[&quot;jsep&quot;];</span><br><span class="line">        var callback &#x3D; pluginHandle.onmessage;</span><br><span class="line">        if(callback) &#123;</span><br><span class="line">            callback(data, jsep);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是<code>janus.js</code>中的<code>handleEvent</code>函数的主逻辑，当<code>janus.js</code>收到janus服务端发来的<code>event</code>事件后，从中取出必要的信息，然后调用<code>pluginHandle.onmessage</code>方法回调应用层。</p><p>应用层的<code>onmessage</code>函数<code>非常重要</code>，可以说它是应用层最<code>核心的代码</code>。它根据从janus服务端收到的不同消息类型做不同的逻辑处理，其主逻辑框架如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">onmessage: function(msg, jsep) &#123;</span><br><span class="line">            var event &#x3D; msg[&quot;videoroom&quot;];</span><br><span class="line">            if(event) &#123;</span><br><span class="line">                if(event &#x3D;&#x3D;&#x3D; &quot;joined&quot;) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    publishOwnFeed(true);</span><br><span class="line">                    ...</span><br><span class="line">                &#125; else if(event &#x3D;&#x3D;&#x3D; &quot;destroyed&quot;) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125; else if(event &#x3D;&#x3D;&#x3D; &quot;event&quot;) &#123;</span><br><span class="line">                    if(msg[&quot;publishers&quot;]) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125; else if(msg[&quot;leaving&quot;]) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125; else if(msg[&quot;unpublished&quot;]) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;else if(msg[&quot;error&quot;]) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(jsep) &#123;</span><br><span class="line">                ...</span><br><span class="line">                sfutest.handleRemoteJsep(&#123; jsep: jsep &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以看到，消息包括以下3种：</p><ul><li>joined，表示作为<code>发布者</code>加入成功</li><li>destroyed, 表示用户成功<code>销毁</code>房间</li><li>event，子事件，<code>event</code>又有四个子事件：<ul><li>publishers，发布者列表</li><li>leaving，有用户离开了</li><li>unpublished，用户取消发布流</li><li>error，出错</li></ul></li></ul><p>在<code>onmessage</code>函数中会对3种事件消息做处理，下面我们分别对这几个事件消息做一下分析。</p><h4 id="joined-事件"><a href="#joined-事件" class="headerlink" title="joined 事件"></a>joined 事件</h4><p><code>joined</code>消息的含义我在<a href="https://avdancedu.com/bb906872/" target="_blank" rel="noopener">《janus的videoroom插件》</a>一文中已经向你做过介绍了，即当你作为<code>发布者</code>加入到房间里时，如果成功则会收到<code>joined</code>事件消息。</p><p>此时你可以从该消息中取出<code>publishers</code>列表，该列表中的每一个<code>publisher</code>都是会中的一个<code>发布者</code>(或称为一路流）。由于<code>发布者</code>也是房间的<code>订阅者</code>，所以你应该订阅每个<code>发布者</code>的媒体流，因此你要与列表中的每个<code>publisher</code>进行一次<code>媒体协商</code>，并进行<code>attach</code>。这样就可以接收<code>发布者</code>的媒体流啦。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if(event &#x3D;&#x3D;&#x3D; &quot;joined&quot;) &#123;</span><br><span class="line">    ...</span><br><span class="line">    publishOwnFeed(true); &#x2F;&#x2F;创建 Offer</span><br><span class="line">    if(msg[&quot;publishers&quot;]) &#123;</span><br><span class="line">        var list &#x3D; msg[&quot;publishers&quot;];</span><br><span class="line">        for(var f in list) &#123;</span><br><span class="line">            var id &#x3D; list[f][&quot;id&quot;];</span><br><span class="line">            var display &#x3D; list[f][&quot;display&quot;];</span><br><span class="line">            var audio &#x3D; list[f][&quot;audio_codec&quot;];</span><br><span class="line">            var video &#x3D; list[f][&quot;video_codec&quot;];</span><br><span class="line">            newRemoteFeed(id, display, audio, video); &#x2F;&#x2F;attach插件，并向插件发送 join 消息</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>从代码中我们可以看到，因为它是一个<code>发布者</code>所以它首先执行<code>publishOwnFeed(true)</code>创建<code>Offer</code>与janus服务端作媒体协商。之后遍历<code>publishers</code>列表，取出每个<code>publisher</code>执行<code>newRemoteFeed</code>方法，在该方法中又会调用<code>attach</code>方法获取其它<code>发布者</code>的媒体流。</p><h4 id="publishers-事件"><a href="#publishers-事件" class="headerlink" title="publishers 事件"></a>publishers 事件</h4><p>当有<code>发布者</code>加入到房间后，房间内的所有<code>订阅者</code>都会收到<code>publishers</code>事件消息。浏览器收到该消息后，应该对消息中的每个未绑定的<code>publisher</code>都进行<code>attach</code>操作，这样就可以接收<code>发布者</code>的媒体流了。 其主逻辑代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if(msg[&quot;publishers&quot;]) &#123;</span><br><span class="line">    var list &#x3D; msg[&quot;publishers&quot;];</span><br><span class="line">    for(var f in list) &#123;</span><br><span class="line">        var id &#x3D; list[f][&quot;id&quot;];</span><br><span class="line">        var display &#x3D; list[f][&quot;display&quot;];</span><br><span class="line">        var audio &#x3D; list[f][&quot;audio_codec&quot;];</span><br><span class="line">        var video &#x3D; list[f][&quot;video_codec&quot;];</span><br><span class="line">        newRemoteFeed(id, display, audio, video);&#x2F;&#x2F;attach插件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这段代码与<code>joined</code>消息的处理逻辑几乎是一样的，只不过<code>订阅者</code>此时不需要与janus服务器进行媒体协商，所以它没有调用<code>publishOwnFeed</code>方法，其它的逻辑都是一样的了。</p><h4 id="leaving-unpublished-事件"><a href="#leaving-unpublished-事件" class="headerlink" title="leaving/unpublished 事件"></a>leaving/unpublished 事件</h4><p>当一个<code>发布者</code>取消发布时，janus会向房间内的其它用户发送<code>unpublished</code>消息。另外，当有用户离开房间时，janus会给房间内的其它人发送<code>leaving</code>消息。另外，如果离开的用户是一个<code>发布者</code>的话，它同时也会发<code>unpublished</code>消息，所以这里我们将两个消息放在一起讨论。</p><p>这两个消息处理的核心逻辑如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">var remoteFeed &#x3D; null;</span><br><span class="line">for(var i&#x3D;1; i&lt;6; i++) &#123;</span><br><span class="line">    if(feeds[i] &amp;&amp; feeds[i].rfid &#x3D;&#x3D; unpublished) &#123;</span><br><span class="line">        remoteFeed &#x3D; feeds[i];</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(remoteFeed !&#x3D; null) &#123;</span><br><span class="line">    ...</span><br><span class="line">    feeds[remoteFeed.rfindex] &#x3D; null;</span><br><span class="line">    remoteFeed.detach();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面这段代码有点不太好理解，我这里解释一下你就清楚了。首先我们来看看循环中的固定数字<code>6</code>，表示什么含义呢？实际上我在<a href="https://avdancedu.com/bb906872/" target="_blank" rel="noopener">《janus的videoroom插件》</a>一文中有解释过，在janus中一个房间内最多可以支持<code>6</code>路流，这个<code>6</code>表过的正是这个意思。所以当收到<code>leaving</code>和<code>unpublished</code>消息时，客户端会遍历全局变量<code>feeds</code>(保存所有订阅的流），如果在<code>feeds</code>中找到了该流，则需要与该流进行<code>detach</code>操作。</p><p>现在我们再读这段代码时是不是就理解它要表达的意思了呢？</p><h3 id="onlocalstream-消息"><a href="#onlocalstream-消息" class="headerlink" title="onlocalstream 消息"></a>onlocalstream 消息</h3><p>当收到<code>onlocalstream</code>消息时，说明本地流已经准备就绪了，此时我们需要让本地流的视频在浏览器里显示出来。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">onlocalstream: function(stream) &#123;</span><br><span class="line">    mystream &#x3D; stream;</span><br><span class="line">    ...</span><br><span class="line">    Janus.attachMediaStream($(&#39;#myvideo&#39;).get(0), stream);</span><br><span class="line">    $(&quot;#myvideo&quot;).get(0).muted &#x3D; &quot;muted&quot;;</span><br><span class="line">    ...</span><br><span class="line">    var videoTracks &#x3D; stream.getVideoTracks();&#125;</span><br><span class="line">    &#x2F;&#x2F;显示video标签</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这段代码的含议非常简单了，就是获取本地址，然后从<code>HTML</code>中拿到一个<code>video</code>标签，最后将<code>video</code>与本地流绑定到一起，这样就可以看到捕获的本地视频了。</p><h3 id="onremotestream-消息"><a href="#onremotestream-消息" class="headerlink" title="onremotestream 消息"></a>onremotestream 消息</h3><p><code>onremotestream</code>消息与<code>onlocalstream</code>是类似的，只不过它表示的是远端的视频流。当收到远端的视频流时，我们也同样在本地创建一个<code>video</code>，然后将远端视频流与<code>video</code>绑定即可。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我向你详细介绍了janus中的<code>videoroom</code>是如何使用<code>janus.js</code>文件的，其总的步骤是先调用<code>Janus.init</code>方法进行初始化；然后创建<code>Janus</code>对象，即与janus服务器建立连接，并接收来自服务器端的消息; 最后调用<code>attach</code>与业务服务器绑定，再根据消息进行推流或拉流。</p><p>总的来看，使用<code>janus.js</code>库大大减轻了我们开发<code>webrtc</code>应用程序的工作量，提高了工作效率。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/bb906872/" target="_blank" rel="noopener">《janus的videoroom插件》</a><br><a href="https://avdancedu.com/d7281c13/" target="_blank" rel="noopener">《janus前端核心库源码分析》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/janus_jscall/jscall.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;之前我在&lt;a href=&quot;https://avdancedu.com/d7281c13/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《janus前端核心库源码分析》&lt;/a&gt;一文中已经向你详细分析了&lt;code&gt;janus.js&lt;/code&gt;文件的实现，但对于大多同学来说，知道如何使用它才是最重要的。那具体我们该如何使用它呢？janus中的&lt;code&gt;videoroomtest.js&lt;/code&gt;是一个不错的例子，今天就来分析一下&lt;code&gt;videoroomtest.js&lt;/code&gt;，看看它是是如何使用&lt;code&gt;janus.js&lt;/code&gt;的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebRTC" scheme="https://blog.avdancedu.com/categories/WebRTC/"/>
    
    
      <category term="janus" scheme="https://blog.avdancedu.com/tags/janus/"/>
    
  </entry>
  
</feed>
