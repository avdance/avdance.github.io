<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>音视跳动科技</title>
  
  <subtitle>传播最前沿的科技知识！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.avdancedu.com/"/>
  <updated>2021-09-04T09:08:33.605Z</updated>
  <id>https://blog.avdancedu.com/</id>
  
  <author>
    <name>音视跳动</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SDL第七篇-PCM音频播放器的实现</title>
    <link href="https://blog.avdancedu.com/f94132a0/"/>
    <id>https://blog.avdancedu.com/f94132a0/</id>
    <published>2021-09-04T09:08:33.605Z</published>
    <updated>2021-09-04T09:08:33.605Z</updated>
    
    <content type="html"><![CDATA[<p>今天向大家介绍一下如何通过 SDL 实现一个PCM音频播放器。这是一个最简单的播放器，它不涉及到音频的解复用，解码等工作。我们只需要将音频原始数据喂给 SDL 音频接口就可以听到悦耳的声音了。在下面的列子中我将向你演示，使用 SDL 做这样一个播放器是何等的简单。</p><p>当然这个看似简单的播放器其实是由许多的理论基础在底层支持着的。如果在这方面没有什么基础的同学可以通过下面的链接去自行学习。</p><ul><li><a href="http://www.avdanchedu.com/56ef4bcb" target="_blank" rel="noopener">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab" target="_blank" rel="noopener">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8" target="_blank" rel="noopener">SDL基本图形绘制</a></li><li><a href="http://www.avdancedu.com/a0ec02a7" target="_blank" rel="noopener">SDL事件处事</a></li><li><a href="http://www.avdancedu.com/67189745" target="_blank" rel="noopener">彻底理解SDL纹理</a></li><li><a href="http://www.avdancedu.com/a6aca2fe" target="_blank" rel="noopener">SDL孙悟空与多线程</a></li><li><a href="http://www.avdancedu.com/f94132a0" target="_blank" rel="noopener">PCM音频播放器的实现</a></li></ul><a id="more"></a><h2 id="播放音频的基本原则"><a href="#播放音频的基本原则" class="headerlink" title="播放音频的基本原则"></a>播放音频的基本原则</h2><p>如果我们要播放一段声音，想当然的认为直接将播放的声音发送给声卡，这样扬声器就会将声音播放出来。只要我们不断的送数据，声音就会不停的输出。</p><p>事实上真的是这样吗？<strong>当 然 不 是!!!</strong></p><p>实际上，所有的音频播放都遵守着一个原则，就是当声卡将要播放的声音输出到扬声器时，它首先会通过回调函数，向你要它一部分声频数据，然后拿着这部分音频数据去播放。等播放完了，它会再向你要下一部分。</p><p>至于要的数据的多少，什么时候向你要，这些都是由声卡决定的。对于我们上层应用来说，这些都是由底层 API 决定的。</p><p>为什么会出现这种情况呢？为什么播放音频与我们一般的逻辑相反呢？这是因为声卡会严格按照音频的播放时间进行播放，不会多一秒，也不会少一秒。正因为它能准确的计算出时间来，而应用层是不知道这个时间的，所以我们必须按照声卡的要求给它喂数据，而不能依据自己的性子来。</p><p>那么有人会问，为什么声卡可以精准的计算出播放时间来呢？这是因为在播放之前我们给它设置了采样率、通道数、采样大小等参数，通过这些参数它就可以计算出时间来。</p><p>我们来做个计算，假设采样率是 48000, 双通道，采样大小是 16bit，那么一秒种的数据是多少呢？ 48000*2*16=1536000. 反过来，如果我们有一段 8M 的数据，那么声卡就知道它能播放 5秒多的声音。</p><p>上面的一大段文字描述，实际上只是想说明一个道理，就是要播放的声音数据，是声卡主动要的，不能由上层直接设置。这是通过回调函数来实现的。后面会有具体的例子。</p><h2 id="SDL如何处理音频"><a href="#SDL如何处理音频" class="headerlink" title="SDL如何处理音频"></a>SDL如何处理音频</h2><p>SDL是一个处理多媒体的开源库，我们来看看它是如何播放音频的，具体的操作步骤是啥？</p><ul><li>打开音频设备</li><li>设置音频参数</li><li>播放音频</li><li>向声卡喂数据</li><li>关闭音频设置</li></ul><h2 id="详细API介绍"><a href="#详细API介绍" class="headerlink" title="详细API介绍"></a>详细API介绍</h2><ul><li><p>打开音频设备</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int SDL_OpenAudio(SDL_AudioSpec* desired,</span><br><span class="line">                SDL_AudioSpec* obtained)</span><br></pre></td></tr></table></figure><ul><li><p>desired: 设置音频参数。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>freq</td><td>每秒采频率</td></tr><tr><td>SDL_AudioFormat</td><td>音频数据存储格式</td></tr><tr><td>channels</td><td>通道数</td></tr><tr><td>silence</td><td>静音值</td></tr><tr><td>samples</td><td>采样个数</td></tr><tr><td>size</td><td>音频缓冲区大小</td></tr><tr><td>SDL_AudioCallback</td><td>回调函数</td></tr><tr><td>userdata</td><td>回调函数参数指针</td></tr></tbody></table></li><li><p>obtained: 返回参数。</p></li></ul></li></ul><ul><li><p>关闭音频设备</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void SDL_CloseAudio(void)</span><br></pre></td></tr></table></figure></li><li><p>播放与暂停</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void SDL_PauseAudio(int pause_on)</span><br></pre></td></tr></table></figure><p>pause_on: 0, 暂停播放；1, 播放；</p></li><li><p>喂数据</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void SDL_MixAudio(Uint8*    dst,</span><br><span class="line">               const Uint8* src,</span><br><span class="line">               Uint32       len,</span><br><span class="line">               int          volume)</span><br></pre></td></tr></table></figure><ul><li>dst: 目的缓冲区</li><li>src: 源缓冲区</li><li>len: 音频数据长度</li><li>volume: 音量大小，0-128 之间的数。SDL_MIX_MAXVOLUME代表最大音量。</li></ul></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>这个例子主要为大家展示了一下如何使用 SDL 的音频 API 来播放声音。其基本流程是，从 pcm 文件一块一块的读数据。然后通过 read_audio_data 这个回调函数给声卡喂数据。如果一次没用完，SDL会再次调用回调函数读数据。</p><p>如果audio_buf中的数据用完了，则再次从文件中读一块数据，直到读到文件尾。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;SDL.h&gt;</span><br><span class="line"></span><br><span class="line">#define BLOCK_SIZE 4096000</span><br><span class="line"></span><br><span class="line">static Uint8 *audio_buf &#x3D; NULL;</span><br><span class="line">static Uint8 *audio_pos &#x3D; NULL;</span><br><span class="line">static size_t buffer_len &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;callback function for audio devcie</span><br><span class="line">void read_audio_data(void *udata, Uint8 *stream, int len)&#123;</span><br><span class="line"></span><br><span class="line">    if(buffer_len &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDL_memset(stream, 0, len);</span><br><span class="line"></span><br><span class="line">    len &#x3D; (len &lt; buffer_len) ? len : buffer_len;</span><br><span class="line">    SDL_MixAudio(stream, audio_pos, len, SDL_MIX_MAXVOLUME);</span><br><span class="line"></span><br><span class="line">    audio_pos +&#x3D; len;</span><br><span class="line">    buffer_len -&#x3D; len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int ret &#x3D; -1;</span><br><span class="line"></span><br><span class="line">    FILE *audio_fd &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">    SDL_AudioSpec spec;</span><br><span class="line"></span><br><span class="line">    char *path &#x3D; &quot;.&#x2F;test.pcm&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;SDL initialize</span><br><span class="line">    if(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER))&#123;</span><br><span class="line">        fprintf(stderr, &quot;Could not initialize SDL - %s\n&quot;, SDL_GetError());</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;open pcm file</span><br><span class="line">    audio_fd &#x3D; fopen(path, &quot;r&quot;);</span><br><span class="line">    if(!audio_fd)&#123;</span><br><span class="line">        fprintf(stderr, &quot;Failed to open pcm file!\n&quot;);</span><br><span class="line">        goto __FAIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;SDL_AudioSpec</span><br><span class="line">    spec.freq &#x3D; 44100;;</span><br><span class="line">    spec.format &#x3D; AUDIO_S16SYS;</span><br><span class="line">    spec.channels &#x3D; 2;</span><br><span class="line">    spec.silence &#x3D; 0;</span><br><span class="line">    spec.samples &#x3D; 1024;;</span><br><span class="line">    spec.callback &#x3D; read_audio_data;;</span><br><span class="line">    spec.userdata &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;open audio devcie</span><br><span class="line">    if(SDL_OpenAudio(&amp;spec, NULL))&#123;</span><br><span class="line">        fprintf(stderr, &quot;Failed to open audio device, %s\n&quot;, SDL_GetError());</span><br><span class="line">        goto __FAIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;play audio</span><br><span class="line">    SDL_PauseAudio(0);</span><br><span class="line"></span><br><span class="line">    do&#123;</span><br><span class="line">        &#x2F;&#x2F;read data from pcm file</span><br><span class="line">        buffer_len &#x3D; fread(audio_buf, 1, BLOCK_SIZE, audio_fd);</span><br><span class="line">        fprintf(stderr, &quot;block size is %zu\n&quot;, buffer_len);</span><br><span class="line"></span><br><span class="line">        audio_pos &#x3D; audio_buf;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;the main thread wait for a moment</span><br><span class="line">        while(audio_pos &lt; (audio_buf + buffer_len)) &#123;</span><br><span class="line">            SDL_Delay(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;while(buffer_len !&#x3D;0);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;close audio device</span><br><span class="line">    SDL_CloseAudio();</span><br><span class="line"></span><br><span class="line">    ret &#x3D; 0;</span><br><span class="line"></span><br><span class="line">__FAIL:</span><br><span class="line">    &#x2F;&#x2F;release some resources</span><br><span class="line">    if(audio_buf)&#123;</span><br><span class="line">        free(audio_buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(audio_fd)&#123;</span><br><span class="line">        fclose(audio_fd);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;quit SDL</span><br><span class="line">    SDL_Quit();</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文向大家讲解了一下如何通过SDL库的音频处理 API 实现一个最简单的 PCM 播放器。通过个例子大家可以了解到，SDL的使用是如此简单。</p><p>当然这个播放器还是有点 Low,不过不要紧，随着后面文章的推出，你会逐渐看到一个完整的播放器是如何被打造出来的。</p><p>希望本文能对你有所帮助，谢谢！</p><h2 id="隆重推荐"><a href="#隆重推荐" class="headerlink" title="隆重推荐"></a>隆重推荐</h2><ul><li><a href="http://www.avdanchedu.com/56ef4bcb" target="_blank" rel="noopener">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab" target="_blank" rel="noopener">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8" target="_blank" rel="noopener">SDL基本图形绘制</a></li><li><a href="http://www.avdancedu.com/a0ec02a7" target="_blank" rel="noopener">SDL事件处事</a></li><li><a href="http://www.avdancedu.com/67189745" target="_blank" rel="noopener">彻底理解SDL纹理</a></li><li><a href="http://www.avdancedu.com/a6aca2fe" target="_blank" rel="noopener">SDL孙悟空与多线程</a></li><li><a href="http://www.avdancedu.com/f94132a0" target="_blank" rel="noopener">PCM音频播放器的实现</a></li><li><a href="https://coding.imooc.com/class/279.html" target="_blank" rel="noopener">ffmpeg精讲</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天向大家介绍一下如何通过 SDL 实现一个PCM音频播放器。这是一个最简单的播放器，它不涉及到音频的解复用，解码等工作。我们只需要将音频原始数据喂给 SDL 音频接口就可以听到悦耳的声音了。在下面的列子中我将向你演示，使用 SDL 做这样一个播放器是何等的简单。&lt;/p&gt;
&lt;p&gt;当然这个看似简单的播放器其实是由许多的理论基础在底层支持着的。如果在这方面没有什么基础的同学可以通过下面的链接去自行学习。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdanchedu.com/56ef4bcb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL 入门&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/287ad9ab&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL窗口渲染&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/24ee78a8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL基本图形绘制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/a0ec02a7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL事件处事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/67189745&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;彻底理解SDL纹理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/a6aca2fe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL孙悟空与多线程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/f94132a0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PCM音频播放器的实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SDL第四篇-事件处理</title>
    <link href="https://blog.avdancedu.com/a0ec02a7/"/>
    <id>https://blog.avdancedu.com/a0ec02a7/</id>
    <published>2021-09-04T09:07:40.881Z</published>
    <updated>2021-09-04T09:07:40.883Z</updated>
    
    <content type="html"><![CDATA[<p>前面我为大家介绍了 SDL 的三个主题：</p><ul><li><a href="http://www.avdanchedu.com/56ef4bcb" target="_blank" rel="noopener">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab" target="_blank" rel="noopener">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8" target="_blank" rel="noopener">SDL基本图形绘制</a></li></ul><p>今天我为大家介绍一下SDL的事件处理。这里所指的事件处理就是我们通常所说的，键盘事件，鼠标事件，窗口事件等。</p><p>SDL对这些事件都做了封装，提供了统一的API，下面我们就来详细的看一下。</p><a id="more"></a><h2 id="SDL中的事件处理"><a href="#SDL中的事件处理" class="headerlink" title="SDL中的事件处理"></a>SDL中的事件处理</h2><p>要想了解 SDL 的事件处理，我们必须要知道的一个原理是，SDL将所有事件都存放在一个队列中。所有对事件的操作，其实就是对队列的操作。了解了这个原理后，我们再来说SDL提供的 API 就很容易理解了。</p><ul><li>SDL_PollEvent: 将队列头中的事件抛出来。</li><li>SDL_WaitEvent: 当队列中有事件时，抛出事件。否则处于阻塞状态，释放 CPU。</li><li>SDL_WaitEventTimeout: 与SDL_WaitEvent的区别时，当到达超时时间后，退出阻塞状态。</li><li>SDL_PeekEvent: 从队列中取出事件，但该事件不从队列中删除。</li><li>SDL_PushEvent: 向队列中插入事件。</li></ul><p>SDL只提供了这样几个简单的API，下面们来介绍几个常见的事件：</p><ul><li>SDL_WindowEvent : Window窗口相关的事件。</li><li>SDL_KeyboardEvent : 键盘相关的事件。</li><li>SDL_MouseMotionEvent : 鼠标移动相关的事件。</li><li>SDL_QuitEvent : 退出事件。</li><li>SDL_UserEvent : 用户自定义事件。</li></ul><p>关于事件更加详的信息可以到 <a href="https://wiki.libsdl.org/SDL_Event" target="_blank" rel="noopener">SDL Wiki</a> 上进行查询。现在我们来看一个使用的例子吧。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>在我们之前文章的例子中，大家已经发现一个问题，那就是窗口只显示了 3 秒钟，之后就自动消失了。</p><p>有的同学可以会通过修改代码最后面的 SDL_Delay 函数，增加它的等待时间让窗口多活一段时间。</p><p>但这样的体验实在是太糟糕了。有没有一种好的办法可以解决这个问题呢？能不能窗口一直显示，直到检测到用户按了<code>ctrl+c</code> 或 使用鼠标点击关闭按钮后才关闭呢？</p><p>当然是可以的。我们只需要在之前的程序的末尾增加下面这段代码即可。它会一直检测用户是否按下了退出按钮。如果检测到了，则直接退出，否则保持显示状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">while(!quit)&#123;</span><br><span class="line">    SDL_Event event;</span><br><span class="line">    while(SDL_PollEvent(&amp;event))&#123;</span><br><span class="line">        switch(event.type)&#123;</span><br><span class="line">            case SDL_QUIT:</span><br><span class="line">               quit &#x3D; 1;</span><br><span class="line">               break;</span><br><span class="line">            default:</span><br><span class="line">               SDL_Log(&quot;.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SDL-PollEvent-与-SDL-WaitEvent"><a href="#SDL-PollEvent-与-SDL-WaitEvent" class="headerlink" title="SDL_PollEvent 与 SDL_WaitEvent"></a>SDL_PollEvent 与 SDL_WaitEvent</h2><p>增加了上面的代码，我们的实验程序似乎也显的很正规了。但有一个问题不知你发现没有<br>?当我们打开任务管理器时，发现我们的程序居然占了 100% 的 CPU。My GOD!这个的结果是决对不能接受的。</p><p>是什么原因造成的呢？我们来仔细看一下我们增加的代码吧。它由两层 while 循环组成，最里面的while循环的意思是，当队列中一直能取出事件，那就让他一直做下去，直到事件队列为空。外面的while循环的意思是，当队列为空的时候，重新执行内部的while循环。</p><p>也就是说，这段代码一直在工作，从不休息。所以导致cpu占到了100%。即然找到了问题的原因，我们就好处理了，只要在外层循环的最后 delay一下，让CPU休息一下就好了。</p><p>当然，SDL还为我们提供了 SDL_WaitEvent方法，使用这个API,你的CPU就不会跑到 100%了，因为当它发现队列为空时，它会阻塞在那里，并将CPU释放掉。</p><p>即然有 SDL_WaitEvent了，为什么还要有SDL_PollEvent呢？这主要是由于使用的场景不同。对于游戏来说，它要求事件的实时处理； 而对于一些其它实时性不高的case来说，则可以使用 SDL_WaitEvent了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到此，本文的内容就介绍完了。在本文中主要介绍了SDL是如何处理事件的，SDL为我们提供了非常简单的API，这大大减少了我们的开发成本。</p><p>另外，我在文章的最后，介绍了SDL_PollEvent 与 SDL_WaitEvent两个 API的区别。这也是使用 SDL 事件处理中最容易引起困惑的地方。</p><p>希望本文能对您有所帮助，谢谢！</p><h2 id="推荐阅读："><a href="#推荐阅读：" class="headerlink" title="推荐阅读："></a>推荐阅读：</h2><ul><li><a href="http://www.avdanchedu.com/56ef4bcb" target="_blank" rel="noopener">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab" target="_blank" rel="noopener">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8" target="_blank" rel="noopener">SDL基本图形绘制</a></li><li><a href="http://www.avdancedu.com/a0ec02a7" target="_blank" rel="noopener">SDL事件处事</a></li><li><a href="http://www.avdancedu.com/67189745" target="_blank" rel="noopener">彻底理解SDL纹理</a></li><li><a href="http://www.avdancedu.com/a6aca2fe" target="_blank" rel="noopener">SDL孙悟空与多线程</a></li><li><a href="http://www.avdancedu.com/f94132a0" target="_blank" rel="noopener">PCM音频播放器的实现</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面我为大家介绍了 SDL 的三个主题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdanchedu.com/56ef4bcb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL 入门&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/287ad9ab&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL窗口渲染&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/24ee78a8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL基本图形绘制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今天我为大家介绍一下SDL的事件处理。这里所指的事件处理就是我们通常所说的，键盘事件，鼠标事件，窗口事件等。&lt;/p&gt;
&lt;p&gt;SDL对这些事件都做了封装，提供了统一的API，下面我们就来详细的看一下。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SDL第五篇-彻底理解纹理</title>
    <link href="https://blog.avdancedu.com/67189745/"/>
    <id>https://blog.avdancedu.com/67189745/</id>
    <published>2021-09-04T09:07:30.599Z</published>
    <updated>2021-09-04T09:07:30.599Z</updated>
    
    <content type="html"><![CDATA[<p>这是SDL系列文章的第五篇，本文将彻底让你理解什么是纹理。并带你深入探讨SDL的几个重要概念SDL_Window、SDL_Render、SDL_Surface 与 SDL_Texture。在文章的最后向你展示SDL如何通过SDL_Texture进行渲染。</p><p>对于前面系列文章感兴趣的同学可以通过下面的链接查看：</p><ul><li><a href="http://www.avdanchedu.com/56ef4bcb" target="_blank" rel="noopener">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab" target="_blank" rel="noopener">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8" target="_blank" rel="noopener">SDL基本图形绘制</a></li><li><a href="http://www.avdancedu.com/a0ec02a7" target="_blank" rel="noopener">SDL事件处事</a></li><li><a href="http://www.avdancedu.com/67189745" target="_blank" rel="noopener">彻底理解SDL纹理</a></li><li><a href="http://www.avdancedu.com/a6aca2fe" target="_blank" rel="noopener">SDL孙悟空与多线程</a></li><li><a href="http://www.avdancedu.com/f94132a0" target="_blank" rel="noopener">PCM音频播放器的实现</a></li></ul><a id="more"></a><h2 id="SDL-Surface-vs-SDL-Texture"><a href="#SDL-Surface-vs-SDL-Texture" class="headerlink" title="SDL_Surface vs SDL_Texture"></a>SDL_Surface vs SDL_Texture</h2><p>在SDL系列文章的第二篇里，我详细的介绍了SDL 渲染的工作原理。即在SDL_Render对象中有一个视频缓冲区，该缓冲区我们称之为SDL_Surface，它是按照像素存放图像的。我们一般把真彩色的像素称为RGB24数据。也就是说，每一个像素由24位组成，每8位代表一种颜色，像素的最终颜色是由RGB三种颜色混合而成的。</p><p>SDL_Texture 与SDL_Surface相似，也是一种缓冲区。只不过它存放的不是真正的像素数据，而是存放的图像的描述信息。当渲染纹理时，SDL以这些描述信息为数据，底层通过OpenGL、D3D 或 Metal操作GPU，最终绘制出与SDL_Surface一样的图形，且效率更高（因为它是GPU硬件计算的）。</p><p>看了以上的介绍，是不是对纹理有了一个清楚的认识了？</p><p>介绍完 SDL_Surface 和 SDL_Texture后，我们再看下SDL_Window 与 SDL_Render。</p><h2 id="SDL-Window-与-SDL-Render"><a href="#SDL-Window-与-SDL-Render" class="headerlink" title="SDL_Window 与 SDL_Render"></a>SDL_Window 与 SDL_Render</h2><p>SDL_Window代表的是窗口的逻辑概念，它是存放在主内存中的一个对象。所以当我们调用SDL API 创建窗口后，它并不会被显示出来。</p><p>SDL_Render 是渲染器，它也是主存中的一个对象。对Render操作时实际上分为两个阶段：</p><p>一、渲染阶段。在该阶段，用户可以画各种图形渲染到SDL_Surface或SDL_Texture 中;</p><p>二、显示阶段。参SDL_Texture为数据，通过OpenGL操作GPU，最终将 SDL_Surfce 或SDL_Texture中的数据输出到显示器上。</p><p>通过上面的介绍，我们就将 SDL_Window、SDL_Render、SDL_Surface与 SDL_Texture之间的关系梳理清楚了，下面我们来看一下如何使用 SDL_Texture。</p><h2 id="使用SDL-Texture"><a href="#使用SDL-Texture" class="headerlink" title="使用SDL_Texture"></a>使用SDL_Texture</h2><p>SDL提供了非常好用的操作SDL_Texture的方法，下面我们来重点介绍一下使用SDL_Texute的基本步骤。</p><ul><li><p>创建一个 SDL_Texture。</p></li><li><p>渲染 Texture</p></li><li><p>Destory Texture</p></li></ul><h2 id="API详细介绍"><a href="#API详细介绍" class="headerlink" title="API详细介绍"></a>API详细介绍</h2><ul><li><p>创建 SDL_Texture</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SDL_Texture* SDL_CreateTexture(SDL_Renderer* renderer,</span><br><span class="line">                             Uint32        format,</span><br><span class="line">                             int           access,</span><br><span class="line">                             int           w,</span><br><span class="line">                             int           h)</span><br></pre></td></tr></table></figure><ul><li>format: 指明像素格式，可以是YUV，也可以是RGB</li><li>access: 指明Texture的类型。可以是 Stream(视频)，也可以是Target一般的类型。</li></ul></li><li><p>渲染</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int SDL_RenderCopy(SDL_Renderer*   renderer,</span><br><span class="line">                 SDL_Texture*    texture,</span><br><span class="line">                 const SDL_Rect* srcrect,</span><br><span class="line">                 const SDL_Rect* dstrect)</span><br></pre></td></tr></table></figure><ul><li>srcrect: 指定 Texture 中要渲染的一部分。如果将 Texture全部输出，可以设置它为 NULL。</li><li>dstrect: 指定输出的空间大小。</li></ul></li><li><p>销毁Texture</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void SDL_DestroyTexture(SDL_Texture* texture)</span><br></pre></td></tr></table></figure></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>下面这个例子非常简单，我这里就不做特别的说明了。对这个程序看不懂的同学可以看我之前的几篇 SDL 的相关文章。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;SDL.h&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;* Moving Rectangle *&#x2F;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">        SDL_Window *window;</span><br><span class="line">        SDL_Renderer *renderer;</span><br><span class="line">        SDL_Texture *texture;</span><br><span class="line">        SDL_Event event;</span><br><span class="line">        SDL_Rect r;</span><br><span class="line"></span><br><span class="line">        if (SDL_Init(SDL_INIT_VIDEO) &lt; 0) &#123;</span><br><span class="line">                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, &quot;Couldn&#39;t initialize SDL: %s&quot;, SDL_GetError());</span><br><span class="line">                return 3;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        window &#x3D; SDL_CreateWindow(&quot;SDL_CreateTexture&quot;,</span><br><span class="line">                        SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                        SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                        1024, 768,</span><br><span class="line">                        SDL_WINDOW_RESIZABLE);</span><br><span class="line"></span><br><span class="line">        r.w &#x3D; 100;</span><br><span class="line">        r.h &#x3D; 50;</span><br><span class="line"></span><br><span class="line">        renderer &#x3D; SDL_CreateRenderer(window, -1, 0);</span><br><span class="line"></span><br><span class="line">        texture &#x3D; SDL_CreateTexture(renderer, SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_TARGET, 1024, 768);</span><br><span class="line"></span><br><span class="line">        while (1) &#123;</span><br><span class="line">                SDL_PollEvent(&amp;event);</span><br><span class="line">                if(event.type &#x3D;&#x3D; SDL_QUIT)</span><br><span class="line">                        break;</span><br><span class="line">                r.x&#x3D;rand()%500;</span><br><span class="line">                r.y&#x3D;rand()%500;</span><br><span class="line"></span><br><span class="line">                SDL_SetRenderTarget(renderer, texture);</span><br><span class="line">                SDL_SetRenderDrawColor(renderer, 0x00, 0x00, 0x00, 0x00);</span><br><span class="line">                SDL_RenderClear(renderer);</span><br><span class="line">                SDL_RenderDrawRect(renderer,&amp;r);</span><br><span class="line">                SDL_SetRenderDrawColor(renderer, 0xFF, 0x00, 0x00, 0x00);</span><br><span class="line">                SDL_RenderFillRect(renderer, &amp;r);</span><br><span class="line">                SDL_SetRenderTarget(renderer, NULL);</span><br><span class="line">                SDL_RenderCopy(renderer, texture, NULL, NULL);</span><br><span class="line">                SDL_RenderPresent(renderer);</span><br><span class="line">        &#125;</span><br><span class="line">        SDL_DestroyRenderer(renderer);</span><br><span class="line">        SDL_Quit();</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文重点介绍了 SDL_Window、SDL_Render、SDL_Surface以及SDL_Texture之间的关系。搞清楚它们之前的关系对于理解 SDL 渲染起着至关重要的作用。</p><p>大家一定要仔细的理解文章中所讲的内容，在我后序的文章中，尤其是后面介绍 播放器 相关内容时，都要用到现在所讲的这些内容。</p><p>希望本文能对你有所帮助，谢谢！</p><h2 id="隆重推荐"><a href="#隆重推荐" class="headerlink" title="隆重推荐"></a>隆重推荐</h2><ul><li><a href="http://www.avdanchedu.com/56ef4bcb" target="_blank" rel="noopener">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab" target="_blank" rel="noopener">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8" target="_blank" rel="noopener">SDL基本图形绘制</a></li><li><a href="http://www.avdancedu.com/a0ec02a7" target="_blank" rel="noopener">SDL事件处事</a></li><li><a href="http://www.avdancedu.com/67189745" target="_blank" rel="noopener">彻底理解SDL纹理</a></li><li><a href="http://www.avdancedu.com/a6aca2fe" target="_blank" rel="noopener">SDL孙悟空与多线程</a></li><li><a href="http://www.avdancedu.com/f94132a0" target="_blank" rel="noopener">PCM音频播放器的实现</a></li><li><a href="https://coding.imooc.com/class/279.html" target="_blank" rel="noopener">ffmpeg精讲</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是SDL系列文章的第五篇，本文将彻底让你理解什么是纹理。并带你深入探讨SDL的几个重要概念SDL_Window、SDL_Render、SDL_Surface 与 SDL_Texture。在文章的最后向你展示SDL如何通过SDL_Texture进行渲染。&lt;/p&gt;
&lt;p&gt;对于前面系列文章感兴趣的同学可以通过下面的链接查看：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdanchedu.com/56ef4bcb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL 入门&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/287ad9ab&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL窗口渲染&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/24ee78a8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL基本图形绘制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/a0ec02a7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL事件处事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/67189745&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;彻底理解SDL纹理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/a6aca2fe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL孙悟空与多线程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/f94132a0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PCM音频播放器的实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SDL第六篇-孙悟空与多线程</title>
    <link href="https://blog.avdancedu.com/a6aca2fe/"/>
    <id>https://blog.avdancedu.com/a6aca2fe/</id>
    <published>2021-09-04T09:07:27.070Z</published>
    <updated>2021-09-04T09:07:27.070Z</updated>
    
    <content type="html"><![CDATA[<p>今天将向大家介绍一下SDL中的多线程的使用。通过下面对SDL 线程与锁相关的API介绍，你会发现，它与 Linux, Windows相关的API几乎是一模一样的。从这里可以推断出，其实SDL对于多线程的处理只是为大家提供了一套统一接口，并没有做其它太多的工作。</p><p>这是我们介绍 SDL 的第六篇文章。有兴趣的同学可以通过下面的链接查看其它几篇文章。</p><ul><li><a href="http://www.avdanchedu.com/56ef4bcb" target="_blank" rel="noopener">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab" target="_blank" rel="noopener">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8" target="_blank" rel="noopener">SDL基本图形绘制</a></li><li><a href="http://www.avdancedu.com/a0ec02a7" target="_blank" rel="noopener">SDL事件处事</a></li><li><a href="http://www.avdancedu.com/67189745" target="_blank" rel="noopener">彻底理解SDL纹理</a></li><li><a href="http://www.avdancedu.com/a6aca2fe" target="_blank" rel="noopener">SDL孙悟空与多线程</a></li><li><a href="http://www.avdancedu.com/f94132a0" target="_blank" rel="noopener">PCM音频播放器的实现</a></li><li><a href="https://coding.imooc.com/class/279.html" target="_blank" rel="noopener">ffmpeg精讲</a></li></ul><a id="more"></a><h2 id="为啥要用多线程？"><a href="#为啥要用多线程？" class="headerlink" title="为啥要用多线程？"></a>为啥要用多线程？</h2><p>我觉得这个小节的标题就是一个废话。不过为了文章的完整性，还是简单的说一说吧。多线程（多进程）是啥意思呢？做个不恰当的比喻，可以把CPU看成是孙悟空，它有一个能耐，从后脑揪几个猴毛就可以变出许多的小猴子。</p><p>多线程（多进程）就是这些小猴子。当干一件比较复杂的事儿时，可以孙悟空一个人干，这样自己比较累。它还有一种选择就是揪几根猴毛，让小猴子们一起帮着干。这样一件复杂的事件，分给许多猴子干，每只猴只干一部分，事情很快就被做完了，这样岂不是比一个人干要强的多？</p><p>当然，有好处也有坏外。猴子多了就需要管理，如果管理不好，就会闹翻天。比如，只有一块肉，该给哪个猴子吃呢？这真是一个另人头痛的问题。</p><p>实际上整个操作系统的演进，就是一部管理学的演进。如何才能让CPU，内存，磁盘I/O，各种设备之间高效的工作，一直是操作系统追求的目标。当然，这话有点扯远了。</p><p>今天我们要讲的就是多线程（多进程）之间该如何高效的工作。要想让多线程之间高效工作，就要给它们之间立点规矩，大家都要遵守的规矩。</p><h2 id="线程互斥与同步"><a href="#线程互斥与同步" class="headerlink" title="线程互斥与同步"></a>线程互斥与同步</h2><p>当僧多粥少时，就引入了互斥的概念。再举个我们生活中的例子吧，比如有一大家族住在同一个大屋子里，却只有一个厕所。早上起来大家都想去厕所，这时有谁先抢到了厕所，其它人就只能等他出来后再进入了，这就是<strong>互斥</strong>。</p><p>当仅有一份资源，大家都需要时，这就产生了管理问题。解决的办法就是通过互斥方法来解决。这种情况是在做多线程处理时要尽量避免的；如果资源足够呢？那当然是平均分配，人人有份了。这中情况是多线路程最希望的。</p><p>除了互斥之外，有些情况还需要更精细化的管理，比如说<strong>同步</strong>。例如车间里的流水线，每个人负责一块，每一块都是半成品，第一个人完成之后交给第二个人做下一步，而后面的人又必须依赖于前而人的结果，依次类推，最后一个人才能完成最终的产品。这就是线程间的精细化管理<strong>同步</strong>。</p><p>要想实现互斥和同步，就需要一种机制。在操作系统上提供了锁的概念来达到互斥与同步。</p><h2 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h2><p>在操作系统上有很种锁，有读写锁、自旋锁、可重入锁等。下面我简单的介绍一下它们之间的不同。</p><p>读写锁: 分为读锁与写锁。所谓读锁就是被访问的资源只要你不改变它的值，你就可以访问，但如果你想改变它，那么就需要等所有读它的线程都释放了它们的锁后，才可以进行修改；写锁是同一时刻只能有一个人访问，当资源被加锁后，其它人只能等待。</p><p>自旋锁: 偿试着给访问资源加锁，如果此时被访问资源已经上锁了，那就一直不停的偿试，直到加锁成功为止。由于它会非常消耗CPU资源，所以一般只锁今资源非常短的情况下才能使用它。</p><p>可重入锁: 同一个线程对被访问资源可以一直加锁。但如果被访问资源已经上锁了，那么其它线程则无法对其加锁。</p><p>锁是解决互斥的一种好办法，但同样有利必有弊。如果使用不善就会出现死锁。</p><h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h2><p>死锁顾名思意，就是打不开的锁。它是怎么产生的呢？举个例子，两个人需要一起完成一件事儿，A说他要等B做完了，他才能开始；而B说它要等A做完了，它才能开使。于时他们在相互等待中老去。</p><p>看类很简单的问题，但这类事情经常在我们的工作中出现。而在我们开发的多线程程序中更是频繁出现。别说人没遇到过哟！</p><p>如何解决？那就是考验你的管理能力了。共实很多情况是出现了死锁我们自己却不知道，否则的话，凭我们的聪名才智怎么能让他们一直锁在那儿呢。</p><h2 id="SDL多线程"><a href="#SDL多线程" class="headerlink" title="SDL多线程"></a>SDL多线程</h2><p>上面介绍了一大堆的理论，现在来看看 SDL 为我们都提供了那些API吧。</p><ul><li><p>创建线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDL_Thread* SDL_CreateThread(SDL_ThreadFunction fn,</span><br><span class="line">                           const char*        name,</span><br><span class="line">                           void*              data)</span><br></pre></td></tr></table></figure><ul><li>fn: 线程要运行的函数。</li><li>name: 线程名。</li><li>data: 函数参数。</li></ul></li><li><p>等待线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void SDL_WaitThread(SDL_Thread* thread,</span><br><span class="line">                  int*        status)</span><br></pre></td></tr></table></figure><p>等待线程结束。</p></li><li><p>创建互斥量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  SDL_mutex* SDL_CreateMutex(void)</span><br><span class="line">  &#96;&#96;&#96; </span><br><span class="line">  也就是创建一个稀有资源，这样大家就去抢这个资源。从而达到为真正资源加锁的目的。</span><br><span class="line">  </span><br><span class="line">- 销毁互斥量</span><br></pre></td></tr></table></figure><p>void SDL_DestroyMutex(SDL_mutex* mutex)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">- 加锁</span><br></pre></td></tr></table></figure><p>int SDL_LockMutex(SDL_mutex* mutex)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 解锁</span><br></pre></td></tr></table></figure><p>int SDL_UnlockMutex(SDL_mutex* mutex)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">常用的与线程和锁相关的 API 就以上几个，是不是非常简单？下面我们来看一个简单的例子吧。</span><br><span class="line"></span><br><span class="line">## 例子</span><br><span class="line"></span><br><span class="line">下面这个例子是在主线程中创建了一个子线程。然后主线程就一直等待子线程结束。等子线程结束后，主线程也随之结束。</span><br></pre></td></tr></table></figure><p>#include &lt;stdio.h&gt;<br>#include “SDL.h”</p></li></ul><p>/* Very simple thread - counts 0 to 9 delaying 50ms between increments */<br>static int TestThread(void *ptr)<br>{<br>    int cnt;</p><pre><code>for (cnt = 0; cnt &lt; 10; ++cnt) {    printf(&quot;\nThread counter: %d&quot;, cnt);    SDL_Delay(50);}return cnt;</code></pre><p>}</p><p>int main(int argc, char *argv[])<br>{<br>    SDL_Thread *thread;<br>    int         threadReturnValue;</p><pre><code>printf(&quot;\nSimple SDL_CreateThread test:&quot;);/* Simply create a thread */thread = SDL_CreateThread(TestThread, &quot;TestThread&quot;, (void *)NULL);if (NULL == thread) {    printf(&quot;\nSDL_CreateThread failed: %s\n&quot;, SDL_GetError());} else {    SDL_WaitThread(thread, &amp;threadReturnValue);    printf(&quot;\nThread returned value: %d&quot;, threadReturnValue);}return 0;</code></pre><p>}</p><pre><code>## 小结本文主要介绍了两方面的内容。一是对多线程理论做了一下简单的介绍；二是介绍了SDL中与线程和锁相关的API。最后通过一个例子显示了如何使用 SDL 中的多线程。希望本文能对你有所帮助，谢谢！## 隆重推荐* [SDL 入门](http://www.avdanchedu.com/56ef4bcb)* [SDL窗口渲染](http://www.avdancedu.com/287ad9ab)* [SDL基本图形绘制](http://www.avdancedu.com/24ee78a8)* [SDL事件处事](http://www.avdancedu.com/a0ec02a7)* [彻底理解SDL纹理](http://www.avdancedu.com/67189745)* [SDL孙悟空与多线程](http://www.avdancedu.com/a6aca2fe)* [PCM音频播放器的实现](http://www.avdancedu.com/f94132a0)* [ffmpeg精讲](https://coding.imooc.com/class/279.html)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天将向大家介绍一下SDL中的多线程的使用。通过下面对SDL 线程与锁相关的API介绍，你会发现，它与 Linux, Windows相关的API几乎是一模一样的。从这里可以推断出，其实SDL对于多线程的处理只是为大家提供了一套统一接口，并没有做其它太多的工作。&lt;/p&gt;
&lt;p&gt;这是我们介绍 SDL 的第六篇文章。有兴趣的同学可以通过下面的链接查看其它几篇文章。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdanchedu.com/56ef4bcb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL 入门&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/287ad9ab&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL窗口渲染&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/24ee78a8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL基本图形绘制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/a0ec02a7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL事件处事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/67189745&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;彻底理解SDL纹理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/a6aca2fe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL孙悟空与多线程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/f94132a0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PCM音频播放器的实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://coding.imooc.com/class/279.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ffmpeg精讲&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SDL第一篇-入门</title>
    <link href="https://blog.avdancedu.com/56ef4bcb/"/>
    <id>https://blog.avdancedu.com/56ef4bcb/</id>
    <published>2021-09-04T09:06:49.329Z</published>
    <updated>2021-09-04T09:06:49.330Z</updated>
    
    <content type="html"><![CDATA[<p>推荐阅读：</p><ul><li><a href="http://www.avdanchedu.com/56ef4bcb" target="_blank" rel="noopener">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab" target="_blank" rel="noopener">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8" target="_blank" rel="noopener">SDL基本图形绘制</a></li><li><a href="http://www.avdancedu.com/a0ec02a7" target="_blank" rel="noopener">SDL事件处事</a></li><li><a href="http://www.avdancedu.com/67189745" target="_blank" rel="noopener">彻底理解SDL纹理</a></li><li><a href="http://www.avdancedu.com/a6aca2fe" target="_blank" rel="noopener">SDL孙悟空与多线程</a></li><li><a href="http://www.avdancedu.com/f94132a0" target="_blank" rel="noopener">PCM音频播放器的实现</a></li></ul><p>SDL是 “Simple DirectMedia Layer”的缩写，它是一个开源的项目。其主要用于游戏开发中的多媒体处理，如视频渲染，音频播放，鼠标/键盘控制等操作。</p><p>并且它是一个跨平台的多媒体库。也就是说它对外接供了一套统一的接口，但在内部，它会根据不同平台调用不同的底层 API库。如在 Linux 系统下，它会使用 opengl 做渲染，而在 Window 下它会调用 D3D API进行渲染。</p><p>我之所以要介绍它，主要是因为我要在开发的多媒体播放器中使用它。</p><a id="more"></a><h2 id="SDL的编译与安装"><a href="#SDL的编译与安装" class="headerlink" title="SDL的编译与安装"></a>SDL的编译与安装</h2><p>目前 SDL 分为 SDL1 和 SDL2 两个主要版本。这两上版本差异非常大，无法相兼容。不过SDL1已经基本过时，主流产品都在使用的 SDL2，所以我们这里也使用SDL2作为例子进行讲解。</p><ul><li><p><a href="https://www.libsdl.org/download-2.0.php" target="_blank" rel="noopener">下载SDL源码</a>（<strong>可能需要翻墙才行</strong>）</p></li><li><p>编译与安装</p><ul><li><p>生成SDL的Makefile</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configure --prefix&#x3D;&#x2F;usr&#x2F;local</span><br></pre></td></tr></table></figure></code></pre></li><li><p>编译并安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="使用-SDL2-的其本流程"><a href="#使用-SDL2-的其本流程" class="headerlink" title="使用 SDL2 的其本流程"></a>使用 SDL2 的其本流程</h2><p>当我们通过源码编译并安装好 SDL2后，在我们的程序中使用 SDL2 就非常简单了，只要按照下面的步骤就可以绘制出一个窗口来。</p><ul><li><p>添加SDL头文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;SDL.h&gt;</span><br></pre></td></tr></table></figure></li><li><p>初始化SDL</p></li><li><p>创建窗口</p></li><li><p>销毁窗口</p></li><li><p>退出SDL</p></li></ul><p>当然，上面的步骤只是一个最基本的使用 SDL 的步骤，如果想了解更多的 SDL 的内容，静请期待我后面的文章。</p><h2 id="API详细介绍"><a href="#API详细介绍" class="headerlink" title="API详细介绍"></a>API详细介绍</h2><p>下面我们详细介绍一下上面用到的几个SDL API。</p><ul><li><p>初始化 SDL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int SDL_Init(Uint32 flags)</span><br></pre></td></tr></table></figure><table><thead><tr><th>flags</th><th>说明</th></tr></thead><tbody><tr><td>SDL_INIT_TIMER</td><td>timer subsystem</td></tr><tr><td>SDL_INIT_AUDIO</td><td>audio subsystem</td></tr><tr><td>SDL_INIT_VIDEO</td><td>video subsystem; automatically initializes the events subsystem</td></tr><tr><td>SDL_INIT_EVENTS</td><td>events subsystem</td></tr><tr><td>SDL_INIT_EVERYTHING</td><td>all of the above subsystems</td></tr></tbody></table><p>返回值：0, 成功。非0, 失败。</p></li><li><p>退出 SDL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void SDL_Quit(void)</span><br></pre></td></tr></table></figure></li><li><p>打印日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void SDL_Log(const char* fmt, ...)</span><br></pre></td></tr></table></figure><p>它与 C 语言中的 printf 格式相同。</p></li><li><p>创建窗口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SDL_Window* SDL_CreateWindow(const char* title,</span><br><span class="line">                           int         x,</span><br><span class="line">                           int         y,</span><br><span class="line">                           int         w,</span><br><span class="line">                           int         h,</span><br><span class="line">                           Uint32      flags)</span><br></pre></td></tr></table></figure><ul><li><p>title：窗口标题</p></li><li><p>x,y,w,h：窗口坐标</p></li><li><p>flag</p><table><thead><tr><th>flags</th><th>说明</th></tr></thead><tbody><tr><td>SDL_WINDOW_FULLSCREEN</td><td>fullscreen window</td></tr><tr><td>SDL_WINDOW_FULLSCREEN_DESKTOP</td><td>fullscreen window at the current desktop resolution</td></tr><tr><td>SDL_WINDOW_OPENGL</td><td>window usable with OpenGL context</td></tr><tr><td>SDL_WINDOW_HIDDEN</td><td>window is not visible</td></tr><tr><td>SDL_WINDOW_BORDERLESS</td><td>no window decoration</td></tr><tr><td>SDL_WINDOW_RESIZABLE</td><td>window can be resized</td></tr><tr><td>SDL_WINDOW_MINIMIZED</td><td>window is minimized</td></tr><tr><td>SDL_WINDOW_MAXIMIZED</td><td>window is maximized</td></tr><tr><td>SDL_WINDOW_SHOWN</td><td>show window</td></tr></tbody></table></li></ul></li><li><p>销毁窗口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void SDL_DestroyWindow(SDL_Window* window)</span><br></pre></td></tr></table></figure></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>下面是一个完整的使用SDL创建窗口的例子，你可以在 linux/mac环境下执行它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;SDL.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    int flag &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    SDL_Window *window;                    &#x2F;&#x2F; Declare a pointer</span><br><span class="line"></span><br><span class="line">    SDL_Init(SDL_INIT_VIDEO);              &#x2F;&#x2F; Initialize SDL2</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Create an application window with the following settings:</span><br><span class="line">    window &#x3D; SDL_CreateWindow(</span><br><span class="line">        &quot;An SDL2 window&quot;,                  &#x2F;&#x2F; window title</span><br><span class="line">        SDL_WINDOWPOS_UNDEFINED,           &#x2F;&#x2F; initial x position</span><br><span class="line">        SDL_WINDOWPOS_UNDEFINED,           &#x2F;&#x2F; initial y position</span><br><span class="line">        640,                               &#x2F;&#x2F; width, in pixels</span><br><span class="line">        480,                               &#x2F;&#x2F; height, in pixels</span><br><span class="line">        SDL_WINDOW_SHOWN | SDL_WINDOW_BORDERLESS&#x2F;&#x2F; flags - see below</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Check that the window was successfully created</span><br><span class="line">    if (window &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        &#x2F;&#x2F; In the case that the window could not be made...</span><br><span class="line">        printf(&quot;Could not create window: %s\n&quot;, SDL_GetError());</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The window is open: could enter program loop here (see SDL_PollEvent())</span><br><span class="line"></span><br><span class="line">    SDL_Delay(3000);  &#x2F;&#x2F; Pause execution for 3000 milliseconds, for example</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Close and destroy the window</span><br><span class="line">    SDL_DestroyWindow(window);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Clean up</span><br><span class="line">    SDL_Quit();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以使用下面的命令在linux/mac上编译上面的程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc&#x2F;clang -g -o sdl2_base 文件名.c &#96;pkg-config --cflags --libs sdl2&#96;</span><br></pre></td></tr></table></figure><p>编译出的程序名为 sdl2_base，执行下面的命令就可能看到运行的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;sdl2_base</span><br></pre></td></tr></table></figure><p><strong>需要注意的是，虽然上面的程序可以正常编译执行，但你会发现该程序创建的窗口并不能显示出来。我会在第二篇文章中介绍如何让窗口正常的显示出来</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过本文的介绍大家是不是觉得使用 SDL 非常简单易用呢？当然也许有人不太喜欢 SDL，认为直接使用 opengl 更高效。</p><p>但你要知道，SDL不只是对图像渲染做了封装，它还对其它媒体API做了封装，如对音频处理的封装等。这些封装大大减少了我们的开发工作量。</p><p>从另一方面讲，SDL 是一款非常优秀有多媒体库，除了使用它，其实我们还可以通过对其源码的分析，从中学到很多使用底层API的技巧。尤其是想学习播放器开发的同学，更是应该学好 SDL，因为著名的 ffplay 就是用的 SDL 做视频和音频的最终渲染与播放的。</p><p>最后，希望本文能帮你进行到 SDL 的世界。</p><h2 id="推荐阅读："><a href="#推荐阅读：" class="headerlink" title="推荐阅读："></a>推荐阅读：</h2><ul><li><a href="http://www.avdanchedu.com/56ef4bcb" target="_blank" rel="noopener">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab" target="_blank" rel="noopener">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8" target="_blank" rel="noopener">SDL基本图形绘制</a></li><li><a href="http://www.avdancedu.com/a0ec02a7" target="_blank" rel="noopener">SDL事件处事</a></li><li><a href="http://www.avdancedu.com/67189745" target="_blank" rel="noopener">彻底理解SDL纹理</a></li><li><a href="http://www.avdancedu.com/a6aca2fe" target="_blank" rel="noopener">SDL孙悟空与多线程</a></li><li><a href="http://www.avdancedu.com/f94132a0" target="_blank" rel="noopener">PCM音频播放器的实现</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdanchedu.com/56ef4bcb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL 入门&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/287ad9ab&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL窗口渲染&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/24ee78a8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL基本图形绘制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/a0ec02a7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL事件处事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/67189745&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;彻底理解SDL纹理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/a6aca2fe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL孙悟空与多线程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/f94132a0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PCM音频播放器的实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SDL是 “Simple DirectMedia Layer”的缩写，它是一个开源的项目。其主要用于游戏开发中的多媒体处理，如视频渲染，音频播放，鼠标/键盘控制等操作。&lt;/p&gt;
&lt;p&gt;并且它是一个跨平台的多媒体库。也就是说它对外接供了一套统一的接口，但在内部，它会根据不同平台调用不同的底层 API库。如在 Linux 系统下，它会使用 opengl 做渲染，而在 Window 下它会调用 D3D API进行渲染。&lt;/p&gt;
&lt;p&gt;我之所以要介绍它，主要是因为我要在开发的多媒体播放器中使用它。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SDL第三篇-绘制基本图形</title>
    <link href="https://blog.avdancedu.com/24ee78a8/"/>
    <id>https://blog.avdancedu.com/24ee78a8/</id>
    <published>2021-09-04T09:05:43.020Z</published>
    <updated>2021-09-04T09:05:43.020Z</updated>
    
    <content type="html"><![CDATA[<p>之前的SDL的两篇文章我向大家介绍了如何编译使用 SDL，以及如何才能让窗口显示出来。想了解相关内容的同学可以点击下面的链接查看相关内容。</p><ul><li><a href="http://www.avdanchedu.com/56ef4bcb" target="_blank" rel="noopener">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab" target="_blank" rel="noopener">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8" target="_blank" rel="noopener">SDL基本图形绘制</a></li><li><a href="http://www.avdancedu.com/a0ec02a7" target="_blank" rel="noopener">SDL事件处事</a></li><li><a href="http://www.avdancedu.com/67189745" target="_blank" rel="noopener">彻底理解SDL纹理</a></li><li><a href="http://www.avdancedu.com/a6aca2fe" target="_blank" rel="noopener">SDL孙悟空与多线程</a></li><li><a href="http://www.avdancedu.com/f94132a0" target="_blank" rel="noopener">PCM音频播放器的实现</a></li></ul><p>本文将向大家介绍一下，如何通过 SDL 绘制一些基本图形，如 点、线、矩形。了解了这些基本图形后，你就可以按照搭积木的方式，构造出其它更复杂的图形了。</p><a id="more"></a><h2 id="有哪些基本图形可以绘制"><a href="#有哪些基本图形可以绘制" class="headerlink" title="有哪些基本图形可以绘制"></a>有哪些基本图形可以绘制</h2><p>SDL中绘制基本图形的 API并不多，主要是 点、线、矩形。其它图形都可以通过 点、线、矩形组合出来。</p><ul><li>设置颜色：在绘制图形前，要设置一下画笔的色彩。这里需要注意的是，如果画笔与背景色相同了，那在窗口中是显示不出来图形的。</li><li>画点。</li><li>画线。</li><li>画矩形。</li><li>填充矩形。</li></ul><p>下面来详细介绍一下这几个API。</p><h2 id="API详细介绍"><a href="#API详细介绍" class="headerlink" title="API详细介绍"></a>API详细介绍</h2><ul><li><p>设置颜色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int SDL_SetRenderDrawColor(SDL_Renderer* renderer,</span><br><span class="line">                         Uint8         r,</span><br><span class="line">                         Uint8         g,</span><br><span class="line">                         Uint8         b,</span><br><span class="line">                         Uint8         a)</span><br></pre></td></tr></table></figure><p>该函数中的参数 a 指明了颜色的透明度。</p><p><strong>但该值我设置了一下没有起作用，应该需要和BlendMode一起才能起作用。这块有谁清楚可以指定一下</strong></p></li><li><p>画点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int SDL_RenderDrawPoint(SDL_Renderer* renderer,</span><br><span class="line">                      int           x, </span><br><span class="line">                      int           y)</span><br></pre></td></tr></table></figure></li><li><p>画多个点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int SDL_RenderDrawPoints(SDL_Renderer*    renderer,</span><br><span class="line">                       const SDL_Point* points,</span><br><span class="line">                       int              count)</span><br></pre></td></tr></table></figure><ul><li>points: 点数组。</li><li>count: 点的个数。</li></ul></li><li><p>画线</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int SDL_RenderDrawLine(SDL_Renderer* renderer,</span><br><span class="line">                     int           x1,</span><br><span class="line">                     int           y1,</span><br><span class="line">                     int           x2,</span><br><span class="line">                     int           y2)</span><br></pre></td></tr></table></figure></li><li><p>画多条线</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int SDL_RenderDrawLines(SDL_Renderer*    renderer,</span><br><span class="line">                      const SDL_Point* points,</span><br><span class="line">                      int              count)</span><br></pre></td></tr></table></figure><p>该函数会将使用两个相邻的点之间进行连线。最终画出你想画的图形。如画三角形，多边形或圆形。</p></li><li><p>绘制矩形</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int SDL_RenderDrawRect(SDL_Renderer*   renderer,</span><br><span class="line">                     const SDL_Rect* rect)</span><br></pre></td></tr></table></figure><p>rect: 是要绘制的一块区域。它包括，x,y,w,h这个元素。</p></li><li><p>填充矩形</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int SDL_RenderFillRect(SDL_Renderer*   renderer,</span><br><span class="line">                     const SDL_Rect* rect)</span><br></pre></td></tr></table></figure><p>使用指定的色彩填充一块矩形。</p></li><li><p>填充多块矩形</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int SDL_RenderDrawRects(SDL_Renderer*   renderer,</span><br><span class="line">                      const SDL_Rect* rects,</span><br><span class="line">                      int             count)</span><br></pre></td></tr></table></figure><ul><li>rects: 指定的矩形数组。</li><li>count: 指定矩形个数。</li></ul></li></ul><h2 id="我们来看看代码"><a href="#我们来看看代码" class="headerlink" title="我们来看看代码"></a>我们来看看代码</h2><p>下面的代码非常之简单，我们在上一篇文章代码的基础上增加了几个画线、画矩形的API就可以了。</p><p>这里唯一值得注意的地方是下面这个函数。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDL_SetRenderDrawColor(renderer, 0, 0, 255, 255);</span><br></pre></td></tr></table></figure><p>该函数是设置画笔颜色，也就是说我们想画出什么颜色的图形，只要用这个函数设置一下，再使用画点、画线的API就可以画出对应颜色的图形了。</p><p>原码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;SDL.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define POINTS_COUNT 4</span><br><span class="line"></span><br><span class="line">static SDL_Point points[POINTS_COUNT] &#x3D; &#123;</span><br><span class="line">    &#123;320, 200&#125;,</span><br><span class="line">    &#123;300, 240&#125;,</span><br><span class="line">    &#123;340, 240&#125;,</span><br><span class="line">    &#123;320, 200&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static SDL_Rect bigrect &#x3D; &#123;0,0,540, 380&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    int flag &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    SDL_Window *window;                    &#x2F;&#x2F; Declare a pointer</span><br><span class="line">    SDL_Renderer *renderer;</span><br><span class="line"></span><br><span class="line">    SDL_Init(SDL_INIT_VIDEO);              &#x2F;&#x2F; Initialize SDL2</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Create an application window with the following settings:</span><br><span class="line">    window &#x3D; SDL_CreateWindow(</span><br><span class="line">        &quot;An SDL2 window&quot;,                  &#x2F;&#x2F; window title</span><br><span class="line">        SDL_WINDOWPOS_UNDEFINED,           &#x2F;&#x2F; initial x position</span><br><span class="line">        SDL_WINDOWPOS_UNDEFINED,           &#x2F;&#x2F; initial y position</span><br><span class="line">        640,                               &#x2F;&#x2F; width, in pixels</span><br><span class="line">        480,                               &#x2F;&#x2F; height, in pixels</span><br><span class="line">        SDL_WINDOW_SHOWN | SDL_WINDOW_BORDERLESS&#x2F;&#x2F; flags - see below</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Check that the window was successfully created</span><br><span class="line">    if (window &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        &#x2F;&#x2F; In the case that the window could not be made...</span><br><span class="line">        printf(&quot;Could not create window: %s\n&quot;, SDL_GetError());</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;* We must call SDL_CreateRenderer in order for draw calls to affect this window. *&#x2F;</span><br><span class="line">    renderer &#x3D; SDL_CreateRenderer(window, -1, 0);</span><br><span class="line"></span><br><span class="line">    &#x2F;* Select the color for drawing. It is set to red here. *&#x2F;</span><br><span class="line">    SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);</span><br><span class="line"></span><br><span class="line">    &#x2F;* Clear the entire screen to our selected color. *&#x2F;</span><br><span class="line">    SDL_RenderClear(renderer);</span><br><span class="line"></span><br><span class="line">    SDL_SetRenderDrawColor(renderer, 255, 255, 255, SDL_ALPHA_OPAQUE);</span><br><span class="line">    &#x2F;&#x2F;SDL_RenderDrawLine(renderer, 100, 20, 500, 400);</span><br><span class="line">    SDL_RenderDrawLines(renderer, points, POINTS_COUNT);</span><br><span class="line"></span><br><span class="line">    SDL_Rect rect &#x3D; &#123;200, 300, 100, 100&#125;;</span><br><span class="line">    SDL_RenderDrawRect(renderer, &amp;rect);</span><br><span class="line"></span><br><span class="line">    SDL_SetRenderDrawColor(renderer, 0, 255, 255, 255);</span><br><span class="line">    SDL_RenderFillRect(renderer, &amp;rect);</span><br><span class="line"></span><br><span class="line">    SDL_SetRenderDrawColor(renderer, 0, 0, 255, 255);</span><br><span class="line">    SDL_RenderFillRect(renderer, &amp;bigrect);</span><br><span class="line"></span><br><span class="line">    &#x2F;* Up until now everything was drawn behind the scenes.</span><br><span class="line">       This will show the new, red contents of the window. *&#x2F;</span><br><span class="line">    SDL_RenderPresent(renderer);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The window is open: could enter program loop here (see SDL_PollEvent())</span><br><span class="line"></span><br><span class="line">    SDL_Delay(3000);  &#x2F;&#x2F; Pause execution for 3000 milliseconds, for example</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;destory renderer</span><br><span class="line">    if (renderer) &#123;</span><br><span class="line">        SDL_DestroyRenderer(renderer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Close and destroy the window</span><br><span class="line">    SDL_DestroyWindow(window);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Clean up</span><br><span class="line">    SDL_Quit();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文重点介绍了 SDL 绘制经常使用的几个基本图形API，通过这些API你可以构造出更加复杂的图形。</p><p>希望本文能对你所有帮助，谢谢！</p><h2 id="推荐阅读："><a href="#推荐阅读：" class="headerlink" title="推荐阅读："></a>推荐阅读：</h2><ul><li><a href="http://www.avdanchedu.com/56ef4bcb" target="_blank" rel="noopener">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab" target="_blank" rel="noopener">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8" target="_blank" rel="noopener">SDL基本图形绘制</a></li><li><a href="http://www.avdancedu.com/a0ec02a7" target="_blank" rel="noopener">SDL事件处事</a></li><li><a href="http://www.avdancedu.com/67189745" target="_blank" rel="noopener">彻底理解SDL纹理</a></li><li><a href="http://www.avdancedu.com/a6aca2fe" target="_blank" rel="noopener">SDL孙悟空与多线程</a></li><li><a href="http://www.avdancedu.com/f94132a0" target="_blank" rel="noopener">PCM音频播放器的实现</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前的SDL的两篇文章我向大家介绍了如何编译使用 SDL，以及如何才能让窗口显示出来。想了解相关内容的同学可以点击下面的链接查看相关内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdanchedu.com/56ef4bcb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL 入门&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/287ad9ab&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL窗口渲染&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/24ee78a8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL基本图形绘制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/a0ec02a7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL事件处事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/67189745&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;彻底理解SDL纹理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/a6aca2fe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL孙悟空与多线程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/f94132a0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PCM音频播放器的实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文将向大家介绍一下，如何通过 SDL 绘制一些基本图形，如 点、线、矩形。了解了这些基本图形后，你就可以按照搭积木的方式，构造出其它更复杂的图形了。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SDL第二篇-窗口渲染</title>
    <link href="https://blog.avdancedu.com/287ad9ab/"/>
    <id>https://blog.avdancedu.com/287ad9ab/</id>
    <published>2021-09-04T09:05:12.939Z</published>
    <updated>2021-09-04T09:05:12.939Z</updated>
    
    <content type="html"><![CDATA[<p>推荐阅读：</p><ul><li><a href="http://www.avdanchedu.com/56ef4bcb" target="_blank" rel="noopener">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab" target="_blank" rel="noopener">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8" target="_blank" rel="noopener">SDL基本图形绘制</a></li><li><a href="http://www.avdancedu.com/a0ec02a7" target="_blank" rel="noopener">SDL事件处事</a></li><li><a href="http://www.avdancedu.com/67189745" target="_blank" rel="noopener">彻底理解SDL纹理</a></li><li><a href="http://www.avdancedu.com/a6aca2fe" target="_blank" rel="noopener">SDL孙悟空与多线程</a></li><li><a href="http://www.avdancedu.com/f94132a0" target="_blank" rel="noopener">PCM音频播放器的实现</a></li></ul><p>上一篇文章中我们对SDL作了简单的介绍，重点介绍了如何编译SDL以及如何使用它。在文章的最后我们留下了一个疑问，即虽然我们创建了窗口，但窗口却并没有真正显示出来。</p><p>今天我们就来看一看，如何才能让创建的窗口真正的显示出来。</p><a id="more"></a><h2 id="渲染的基本流程"><a href="#渲染的基本流程" class="headerlink" title="渲染的基本流程"></a>渲染的基本流程</h2><p>为什么我们上一课中创建了窗口，但它却并没有显示出来呢？其原因是，我们创建的窗口只是逻辑上的窗口，要想让窗口显示出来，我们需要对窗口进行效果渲染，也就是要通过绘制像素的方法，将窗口中的像素全部点亮。</p><p>那么如何对窗口进行渲染呢？SDL为我们提供了方便是的API。不过在使用SDL对窗口进行渲染之前，我们要先了解渲染的基本原理。</p><p>其基本原理是，首先创建一个window窗口，它是我们要渲染的目标。然后，要有一个渲染上下文，该上下文中一方面存放着要渲染的目标，也就是windows窗口；另一方面是存放着一个缓冲区，该缓冲区用于存放渲染的内容。</p><p>渲染的内容可以是点、线、各种图形以及图片，视频的各种组合。这些组合后的内容首先被存放到缓冲区中，最终SDL将缓冲区中的内容渲染到窗口中。</p><p>所以渲染的基本流程如下：</p><ul><li>创建窗口</li><li>创建渲染器</li><li>清空缓冲区</li><li>绘制要显示的内容</li><li>最终将缓冲区内容渲染到window窗口上。</li></ul><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><ul><li><p>创建渲染上下文</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDL_Renderer* SDL_CreateRenderer(SDL_Window* window,</span><br><span class="line">                               int         index,</span><br><span class="line">                               Uint32      flags)</span><br></pre></td></tr></table></figure><p>window: 指明在哪个窗口里进行渲染<br>index: 指定渲染驱动的索引号。一般指定为 -1.<br>flags:</p><table><thead><tr><th>flags</th><th>说明</th></tr></thead><tbody><tr><td>SDL_RENDERER_SOFTWARE</td><td>the renderer is a software fallback</td></tr><tr><td>SDL_RENDERER_ACCELERATED</td><td>the renderer uses hardware acceleration</td></tr><tr><td>SDL_RENDERER_PRESENTVSYNC</td><td>present is synchronized with the refresh rate</td></tr><tr><td>SDL_RENDERER_TARGETTEXTURE</td><td>the renderer supports rendering to texture</td></tr></tbody></table></li><li><p>消毁渲染上下文</p><p>释放渲染上下文相关的资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void SDL_DestroyRenderer(SDL_Renderer* renderer)</span><br></pre></td></tr></table></figure></li><li><p>清空渲染目标</p><p>该函数的作用是用指定的颜色清空缓冲区。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int SDL_RenderClear(SDL_Renderer* renderer)</span><br></pre></td></tr></table></figure><p>renderer: 上面创建的渲染器上下文。</p></li><li><p>展示要渲染的内容</p><p>将缓冲区中的内容输出到目标上，也就是 windows 窗口上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void SDL_RenderPresent(SDL_Renderer* renderer)</span><br></pre></td></tr></table></figure><p>renderer: 上面创建的渲染器上下文</p></li></ul><h2 id="完整例子"><a href="#完整例子" class="headerlink" title="完整例子"></a>完整例子</h2><p>我在第一课的代码上，添加了上面几个函数之后，大家可以看到一个全红色的窗口可以显示在我们的面前了。</p><p>当然我们还可以在上面画一些图形，比如使用 SDL_RenderDrawLines() 函数在窗口中画一条直线。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;SDL.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    int flag &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    SDL_Window *window;                    &#x2F;&#x2F; Declare a pointer</span><br><span class="line">    SDL_Renderer *renderer;</span><br><span class="line"></span><br><span class="line">    SDL_Init(SDL_INIT_VIDEO);              &#x2F;&#x2F; Initialize SDL2</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Create an application window with the following settings:</span><br><span class="line">    window &#x3D; SDL_CreateWindow(</span><br><span class="line">        &quot;An SDL2 window&quot;,                  &#x2F;&#x2F; window title</span><br><span class="line">        SDL_WINDOWPOS_UNDEFINED,           &#x2F;&#x2F; initial x position</span><br><span class="line">        SDL_WINDOWPOS_UNDEFINED,           &#x2F;&#x2F; initial y position</span><br><span class="line">        640,                               &#x2F;&#x2F; width, in pixels</span><br><span class="line">        480,                               &#x2F;&#x2F; height, in pixels</span><br><span class="line">        SDL_WINDOW_SHOWN | SDL_WINDOW_BORDERLESS&#x2F;&#x2F; flags - see below</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Check that the window was successfully created</span><br><span class="line">    if (window &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        &#x2F;&#x2F; In the case that the window could not be made...</span><br><span class="line">        printf(&quot;Could not create window: %s\n&quot;, SDL_GetError());</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* We must call SDL_CreateRenderer in order for draw calls to affect this window. *&#x2F;</span><br><span class="line">    renderer &#x3D; SDL_CreateRenderer(window, -1, 0);</span><br><span class="line"></span><br><span class="line">    &#x2F;* Select the color for drawing. It is set to red here. *&#x2F;</span><br><span class="line">    SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);</span><br><span class="line"></span><br><span class="line">    &#x2F;* Clear the entire screen to our selected color. *&#x2F;</span><br><span class="line">    SDL_RenderClear(renderer);</span><br><span class="line"></span><br><span class="line">    &#x2F;* Up until now everything was drawn behind the scenes.</span><br><span class="line">       This will show the new, red contents of the window. *&#x2F;</span><br><span class="line">    SDL_RenderPresent(renderer);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The window is open: could enter program loop here (see SDL_PollEvent())</span><br><span class="line"></span><br><span class="line">    SDL_Delay(3000);  &#x2F;&#x2F; Pause execution for 3000 milliseconds, for example</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;destory renderer</span><br><span class="line">    if (renderer) &#123;</span><br><span class="line">        SDL_DestroyRenderer(renderer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Close and destroy the window</span><br><span class="line">    SDL_DestroyWindow(window);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Clean up</span><br><span class="line">    SDL_Quit();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我向大家介绍了如何将创建的窗口展示出来，并重点介绍了窗口渲染的基本原理以及使用的 SDL API。</p><p>后面的文章我将向大家重点介绍如何在窗口绘制一些常用图形。</p><p>谢谢！</p><h2 id="推荐阅读："><a href="#推荐阅读：" class="headerlink" title="推荐阅读："></a>推荐阅读：</h2><ul><li><a href="http://www.avdanchedu.com/56ef4bcb" target="_blank" rel="noopener">SDL 入门</a></li><li><a href="http://www.avdancedu.com/287ad9ab" target="_blank" rel="noopener">SDL窗口渲染</a></li><li><a href="http://www.avdancedu.com/24ee78a8" target="_blank" rel="noopener">SDL基本图形绘制</a></li><li><a href="http://www.avdancedu.com/a0ec02a7" target="_blank" rel="noopener">SDL事件处事</a></li><li><a href="http://www.avdancedu.com/67189745" target="_blank" rel="noopener">彻底理解SDL纹理</a></li><li><a href="http://www.avdancedu.com/a6aca2fe" target="_blank" rel="noopener">SDL孙悟空与多线程</a></li><li><a href="http://www.avdancedu.com/f94132a0" target="_blank" rel="noopener">PCM音频播放器的实现</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdanchedu.com/56ef4bcb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL 入门&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/287ad9ab&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL窗口渲染&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/24ee78a8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL基本图形绘制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/a0ec02a7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL事件处事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/67189745&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;彻底理解SDL纹理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/a6aca2fe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDL孙悟空与多线程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.avdancedu.com/f94132a0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PCM音频播放器的实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上一篇文章中我们对SDL作了简单的介绍，重点介绍了如何编译SDL以及如何使用它。在文章的最后我们留下了一个疑问，即虽然我们创建了窗口，但窗口却并没有真正显示出来。&lt;/p&gt;
&lt;p&gt;今天我们就来看一看，如何才能让创建的窗口真正的显示出来。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>《WebRTC音视频实时互动技术--原理、实战与源码分析》勘误表</title>
    <link href="https://blog.avdancedu.com/f2403a12/"/>
    <id>https://blog.avdancedu.com/f2403a12/</id>
    <published>2021-08-23T02:48:36.240Z</published>
    <updated>2021-08-23T02:48:36.240Z</updated>
    
    <content type="html"><![CDATA[<h2 id="勘误一"><a href="#勘误一" class="headerlink" title="勘误一"></a>勘误一</h2><p>a. P3, 1.2节，第三段中的 AVI 应为 AV1.<br>b. P11,  2.1.3节，第一段中的 AVI 应为 AV1<br>c. P22，3.2.2 节，第三段中的所有 AVI 应为 AV1<br>d. P261， 13.5节，第二段中的 AVI 应为 AV1</p><h2 id="勘误二"><a href="#勘误二" class="headerlink" title="勘误二"></a>勘误二</h2><p>P10, P11, P12 中的三张图，修改如下：</p><p><img data-src="https://cdn.avdancedu.com/image/article/webrtc_book_kw/AV_Archive2.png" alt=""></p><a id="more"></a><p><img data-src="https://cdn.avdancedu.com/image/article/webrtc_book_kw/AV_Archive3.png" alt=""><br><img data-src="https://cdn.avdancedu.com/image/article/webrtc_book_kw/AV_plugin.png" alt=""></p><h2 id="勘误三"><a href="#勘误三" class="headerlink" title="勘误三"></a>勘误三</h2><p>P15，第三段应为：</p><p>“从上面的描述中你可以看到，在 WebRTC 架构的四层中，最复杂、最核心的是第三层，即 引擎层，因此，这里我再对引擎层内部的关系做下简要介绍。引擎层包括三部分内容，分别是: 音频引擎、视频引擎以及网络传输。其中<strong>音频引擎</strong>和视频引擎是相对比较独立的。不过，它们 都需要与网络传输层(transport)打交道。也就是说，它们都需要将自己产生的数据通过网络 传输层发送出去;同时，也需要通过网络传输层接收其它端发过来的数据。此外，音频引擎与 视频引擎由于要进行音视频同步的原因，所以它们之间也存在着关联关系。”</p><h2 id="勘误四"><a href="#勘误四" class="headerlink" title="勘误四"></a>勘误四</h2><p>P34，代码4.4 修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.to(room).emit(&#39;cmd&#39;);</span><br></pre></td></tr></table></figure><h2 id="勘误五"><a href="#勘误五" class="headerlink" title="勘误五"></a>勘误五</h2><p>P43，第四段第一个单词<strong>groudId</strong>应为<strong>groupId</strong>。</p><h2 id="勘误六"><a href="#勘误六" class="headerlink" title="勘误六"></a>勘误六</h2><p>P98，表6.2各NAT之间可穿越表应为：<br><img data-src="https://cdn.avdancedu.com/image/article/webrtc_book_kw/NAT_table.png" alt=""></p><h2 id="勘误七"><a href="#勘误七" class="headerlink" title="勘误七"></a>勘误七</h2><p>P103，6.4.2小节倒数第二应为：<br><img data-src="https://cdn.avdancedu.com/image/article/webrtc_book_kw/turn_protocal.png" alt=""></p><p>“因为主机 A 拿到了主机 B 的 Relay 类型的 Candidate，即 RelayB，所以主机 A 可以直接将音视频数据发向 RelayB。TurnServer 从 RelayB 接收到数据后，会将数据 打包成 TURN 消息，经 3478 端口发往主机<strong>B</strong>。主机<strong>B</strong>收数据后，再利用 TurnClient 模块将数据从 TURN 消息中取出，交给其它模块做进一步处理; 同理，主机 B 与主机 A 的操作流程是一样的。TurnServer 从 RelayA 收到数据后，将其打包成 TURN 消息， 也要经过 3478 端口转发给主机<strong>A</strong>。”</p><h2 id="勘误八"><a href="#勘误八" class="headerlink" title="勘误八"></a>勘误八</h2><p>P114，第一段应为：</p><p>“程， 默认情况下 WebRTC 会将 VP8/H264 等编码器编码后的数据再交由 red 模块编码，生成带一些冗余信息的数据包，这样当传输中某个包丢了，就可以通过其他包将其恢复回来，而不用重传丢失的包。了解了上面这些内容后，第 <strong>16～18</strong> 行代码的含义应该就清楚了，即 PT 值为 124 表示需要使用 red 对之前编码好的数据再进行 red 处理，119 是 PT=124 重传数据 包的 PayloadType。如果用 Wireshark 等抓包工具抓取 WebRTC 媒体数据包时会发现它们都 是 red 包，而在 red 包里装的是 VP8/H264 编码的数据。”</p><h2 id="勘误九"><a href="#勘误九" class="headerlink" title="勘误九"></a>勘误九</h2><p>P124，代码行号69，内容应为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">69 使用Opus时，每个音频帧的最小间隔为10毫秒，使用带内FEC</span><br><span class="line">70 a&#x3D;fmtp:111 minptime&#x3D;10;useinbandfec&#x3D;1</span><br></pre></td></tr></table></figure><h2 id="勘误十"><a href="#勘误十" class="headerlink" title="勘误十"></a>勘误十</h2><p>P168，图9.10有误，正确的图如下所示：<br><img data-src="https://cdn.avdancedu.com/image/article/webrtc_book_kw/onebyeheader2.png" alt=""></p><h2 id="勘误十一"><a href="#勘误十一" class="headerlink" title="勘误十一"></a>勘误十一</h2><p>P175，10.1 节的第一段应为：</p><p>“在 WebRTC 中包含多种拥塞控制算法，有 GCC、BBR和 PCC。GCC 根据其实现又可细分为基于发送端的拥塞控制算法 Transport-CC4和基于<strong>接收端</strong>的拥塞控制算法 Goog-REMB。”</p><h2 id="勘误十二"><a href="#勘误十二" class="headerlink" title="勘误十二"></a>勘误十二</h2><p>P176，第一段中的<strong>QUICK</strong>应该为<strong>QUIC</strong>。此外，注脚中的<strong>QUICK</strong>，也应为<strong>QUIC</strong>。</p><h2 id="勘误十三"><a href="#勘误十三" class="headerlink" title="勘误十三"></a>勘误十三</h2><p>P183, 公式10.19 下面一段的第一句应为：</p><p>“在上述公式中，d(i) 表示当前包组到达时长与包组发送时长之差，<strong>参见公式10.4。</strong>正常情况下该值有正有负, ……”</p><h2 id="勘误十四"><a href="#勘误十四" class="headerlink" title="勘误十四"></a>勘误十四</h2><p>P271, 第一段应为：</p><p>“在上述代码中，如果对其再进行简化的话，可以发现 StartNextDecode() 方法中只调用了frame_buffer_对象的 NextFrame() 这个方法。由于该方法传入参数过于复杂，所以不太好理解，其实关键点是掌握其核心代码的第9～15行。”</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;勘误一&quot;&gt;&lt;a href=&quot;#勘误一&quot; class=&quot;headerlink&quot; title=&quot;勘误一&quot;&gt;&lt;/a&gt;勘误一&lt;/h2&gt;&lt;p&gt;a. P3, 1.2节，第三段中的 AVI 应为 AV1.&lt;br&gt;b. P11,  2.1.3节，第一段中的 AVI 应为 AV1&lt;br&gt;c. P22，3.2.2 节，第三段中的所有 AVI 应为 AV1&lt;br&gt;d. P261， 13.5节，第二段中的 AVI 应为 AV1&lt;/p&gt;
&lt;h2 id=&quot;勘误二&quot;&gt;&lt;a href=&quot;#勘误二&quot; class=&quot;headerlink&quot; title=&quot;勘误二&quot;&gt;&lt;/a&gt;勘误二&lt;/h2&gt;&lt;p&gt;P10, P11, P12 中的三张图，修改如下：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/webrtc_book_kw/AV_Archive2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Windows下编译WebRTC</title>
    <link href="https://blog.avdancedu.com/2bafd6cf/"/>
    <id>https://blog.avdancedu.com/2bafd6cf/</id>
    <published>2021-08-16T03:13:22.767Z</published>
    <updated>2021-08-16T03:13:22.768Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/webrtc_build/webrtc%E6%9E%B6%E6%9E%84.png" alt=""></p><p>随着音视频技术的不断普及，Google推出的 WebRTC 越来越受到大家的喜欢。现在很多直播产品都是基于WebRTC 进行二次开发做出来的。</p><p>WebRTC是提供了一整套处理实时音视频的开源库。它包括了音视频处理（采集，编解码，前处理，后处理，渲染），数据传输（实时传输，流控）和业务逻辑控制。可以说 WebRTC 的出现大大减少了做音视频开发的难度，所以熟练掌握好这个库对于做音视频相关的同学就显的特别重要了。</p><p>要想掌握 WebRTC 要过的头一关就是如何编译它。WebRTC库非常庞大，光源码就有几个G，所以它对开发主机的性能，网络带宽的要求都非常高。另外，在Windows平台下，它对Windows的系统版本，Visual Studio 版本也都有明确的要求，所以只要其中某一项出问题了，都可能导致失败。这就是为什么很多人在编译WebRTC经常失败的原因。</p><p>下面我们言归正传，介绍一下在如何在 Windows下成功编译WebRTC.</p><a id="more"></a><blockquote><p>注意：本文所有的操作的前提条件是，你可以访问外网</p></blockquote><h2 id="主机及系统配置"><a href="#主机及系统配置" class="headerlink" title="主机及系统配置"></a>主机及系统配置</h2><p>第一、WebRTC要求是 64位机器 8G 内存，最好超过16G内存。</p><blockquote><p>我实际的配置是 64位机器，4G内存，4核CPU也是没问题的。</p></blockquote><p>第二、至少 100G 磁盘空间，NTFS格式。</p><blockquote><p>FAT32格式是不能工作的，因为WebRTC中有的文件大于 4G。</p></blockquote><p>第三、Visual Studio 2019社区版即可。</p><blockquote><p>VS 不需要是英文版本</p></blockquote><p>第四、操作系统需要 Win10 系统。</p><h2 id="安装虚拟机（可选）"><a href="#安装虚拟机（可选）" class="headerlink" title="安装虚拟机（可选）"></a>安装虚拟机（可选）</h2><p>由于环境的问题经常会导致编译失败，所以为了方便设置环境，我使用了VirtualBox虚拟机（该虚拟机是免费的）。相较于VMware它虽然性能稍差，但完全够我们编译开发WebRTC使用。所以我们也不必在虚拟机这个环节上纠结。</p><p>安装虚拟机需要注意以下几点：</p><ol><li>为了更好的利用硬件，需要确认你机子的BOIS中是否打开了虚拟化选项，这对虚拟机的性能会产生很大影响。</li><li>在虚拟机上安装完系统后，一定要安装虚拟的<a href="https://jingyan.baidu.com/article/6525d4b13b7d0fac7d2e94ef.html" target="_blank" rel="noopener">增强驱动</a>，这样虚拟机要才能全屏显示。不会的可去问度娘。</li></ol><h2 id="安装-Visual-Stuido-注意事项"><a href="#安装-Visual-Stuido-注意事项" class="headerlink" title="安装 Visual Stuido 注意事项"></a>安装 Visual Stuido 注意事项</h2><p>安装 Visual Studio 2019 ，可以使用免费的 Community Edition 版本。在安装 VS 时选择定制（Custom Install）安装，并选择下面的模块:</p><ul><li>在安装VS2019之前先将Windows 10 SDK 安装好，<a href="https://developer.microsoft.com/zh-cn/windows/downloads/windows-10-sdk/" target="_blank" rel="noopener">下载地址</a></li><li><a href="https://visualstudio.microsoft.com/zh-hans/free-developer-offers/" target="_blank" rel="noopener">VS2019的下载地址</a></li><li>安装Win 10 SDK 时，要选择 “Debugging Tools For Windows” 这项，以便在你的开发环境中安装调试工具 windbg 和 cdb，这些工具会在后面测试和调试时使用。</li><li>安装SDK和VS2019时，要将它们安装到C盘</li><li>当VS2109下载好后，在命令行中执行下面的命令来安装：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ PATH_TO_INSTALLER.EXE ^</span><br><span class="line">--add Microsoft.VisualStudio.Workload.NativeDesktop ^</span><br><span class="line">--add Microsoft.VisualStudio.Component.VC.ATLMFC ^</span><br><span class="line">--includeRecommended</span><br></pre></td></tr></table></figure><blockquote><p>注意，如果 Windows SDK 是通过 Visual Studio 安装的, 则 调试 Tools 需要按下面步骤安装: </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Control Panel → Programs → Programs and Features → Select the “Windows Software Development Kit” v14393 → Change → Change → Check “Debugging Tools For Windows” → Change.</span><br></pre></td></tr></table></figure><h2 id="安装-depot-tools"><a href="#安装-depot-tools" class="headerlink" title="安装 depot_tools"></a>安装 depot_tools</h2><p>depot_tools就是一堆下载代码，编译等相关的工具，Google统一打包在 <a href="https://storage.googleapis.com/chrome-infra/depot_tools.zip" target="_blank" rel="noopener">depot_tools</a>中，你需将它下载到本地。</p><p><strong>首先</strong>，将 depot_tools.zip 文件解压。</p><p><strong>其次</strong>，将 depot_tools 目录地址添加到你机器的 <strong>系统环境变量 PATH</strong>  里，而不是用户级的环境变量里。具体操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Control Panel → System and Security → System → Advanced system settings</span><br></pre></td></tr></table></figure><blockquote><p>注意，必须将它放在PATH环境变量的开头。</p></blockquote><p><strong>然后</strong>，用同样的方法将 <strong>DEPOT_TOOLS_WIN_TOOLCHAIN</strong> 设置到你的系统环境变量里，并设置它的值为 0 ，该变量会告诉 depot_tools 使用你本地安装的 Visual Studio 版本。</p><blockquote><p>默认，depot_tools 使用 Google 内部版本。</p></blockquote><p><strong>最后</strong>，打开 cmd.exe, 运行 gclient 命令(不用带作何参数)。第一次运行时，gclient 将安装 Windows 下需要的工具, 包括 msysgit 和 python。gclient 执行完后，在命令行提示符下输入 python 将会显示 python.bat ，这就说明 depot_tools 安装好了。</p><h2 id="获取-WebRTC-代码"><a href="#获取-WebRTC-代码" class="headerlink" title="获取 WebRTC 代码"></a>获取 WebRTC 代码</h2><p>执行下面的命令就可以获取 WebRTC 的代码了，也只有用这种方式，后面才能编译通过。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. mkdir webrtc-checkout</span><br><span class="line">2. cd webrtc-checkout</span><br><span class="line">3. fetch --nohooks webrtc</span><br><span class="line">4. gclient sync</span><br></pre></td></tr></table></figure><blockquote><p>注意，由于 WebRTC 的代码量非常大，所以我一般都是在晚上让他去下载，第二天就可以用了。</p></blockquote><h2 id="编译及生成工程文件"><a href="#编译及生成工程文件" class="headerlink" title="编译及生成工程文件"></a>编译及生成工程文件</h2><p>执行下面的命令就可以编译WebRTC了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd src</span><br><span class="line">$ gn gen out&#x2F;Default</span><br><span class="line">$ ninja -C out&#x2F;Default</span><br></pre></td></tr></table></figure><p>编译成功后，执行下面的命令生成VS工程文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gn gen --ide&#x3D;vs out\Default</span><br></pre></td></tr></table></figure><p>这时，我们就可以在 src\out\Default\ 目录下找到 all.sln 这个工程文件，到这里我们就大功告成了。</p><h2 id="切换Branch"><a href="#切换Branch" class="headerlink" title="切换Branch"></a>切换Branch</h2><p>有时候我们需要切到WebRTC的某个分支，可以按下面的步聚操作：</p><ul><li>查看WebRTC远端有哪些分支</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure><ul><li>切换到某个具体的分支</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b my_branch refs&#x2F;remotes&#x2F;branch-heads&#x2F;xxxx</span><br><span class="line">gclient sync</span><br></pre></td></tr></table></figure><h2 id="指定VS-版本"><a href="#指定VS-版本" class="headerlink" title="指定VS 版本"></a>指定VS 版本</h2><p>有时间我们需要使用VS的老版本编译旧的WebRTC源码，此时除了需要在Windows上安装老版本VS外，还需要设置如下环境变量，这样WebRTC才会使用老的VS版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set GYP_MSVS_VERSION &#x3D; 2019</span><br><span class="line">set GYP_MSVS_OVERRIDE_PATH &#x3D; C:\Program Files (x86)\Microsoft Visual Studio\2019\Community</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们上面详细介绍了编译WebRTC的步骤，由于WebRTC本身的原因，大家在操作时一定要仔细阅读每一步，否则都有可能导致编译失败。</p><p>谢谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/webrtc_build/webrtc%E6%9E%B6%E6%9E%84.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;随着音视频技术的不断普及，Google推出的 WebRTC 越来越受到大家的喜欢。现在很多直播产品都是基于WebRTC 进行二次开发做出来的。&lt;/p&gt;
&lt;p&gt;WebRTC是提供了一整套处理实时音视频的开源库。它包括了音视频处理（采集，编解码，前处理，后处理，渲染），数据传输（实时传输，流控）和业务逻辑控制。可以说 WebRTC 的出现大大减少了做音视频开发的难度，所以熟练掌握好这个库对于做音视频相关的同学就显的特别重要了。&lt;/p&gt;
&lt;p&gt;要想掌握 WebRTC 要过的头一关就是如何编译它。WebRTC库非常庞大，光源码就有几个G，所以它对开发主机的性能，网络带宽的要求都非常高。另外，在Windows平台下，它对Windows的系统版本，Visual Studio 版本也都有明确的要求，所以只要其中某一项出问题了，都可能导致失败。这就是为什么很多人在编译WebRTC经常失败的原因。&lt;/p&gt;
&lt;p&gt;下面我们言归正传，介绍一下在如何在 Windows下成功编译WebRTC.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>非常棒的GDB与LLDB命令对照表</title>
    <link href="https://blog.avdancedu.com/2ffb45c8/"/>
    <id>https://blog.avdancedu.com/2ffb45c8/</id>
    <published>2021-08-15T13:27:20.284Z</published>
    <updated>2021-08-15T13:27:20.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GDB与LLDB命令对照表"><a href="#GDB与LLDB命令对照表" class="headerlink" title="GDB与LLDB命令对照表"></a>GDB与LLDB命令对照表</h2><hr><p><a href="https://lldb.llvm.org/lldb-gdb.html" target="_blank" rel="noopener">GDB 与 LLDB 命令对照表1</a><br><a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-command-examples.html" target="_blank" rel="noopener">GDB 与 LLDB 命令对照表2</a></p><hr><a id="more"></a><h2 id="设置观察点"><a href="#设置观察点" class="headerlink" title="设置观察点"></a>设置观察点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wa s v 变量名</span><br><span class="line">或 watchpoint set variable 变量名</span><br></pre></td></tr></table></figure><ul><li>观察点必须是独立的原始变量，而不能是类变量或结构体变量。</li></ul><h2 id="目前-LLDB-无法打印宏信息"><a href="#目前-LLDB-无法打印宏信息" class="headerlink" title="目前 LLDB 无法打印宏信息"></a>目前 LLDB 无法打印宏信息</h2><h2 id="查看内存内容"><a href="#查看内存内容" class="headerlink" title="查看内存内容"></a>查看内存内容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x -s4 -fx -c4 0xbffff3c0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;GDB与LLDB命令对照表&quot;&gt;&lt;a href=&quot;#GDB与LLDB命令对照表&quot; class=&quot;headerlink&quot; title=&quot;GDB与LLDB命令对照表&quot;&gt;&lt;/a&gt;GDB与LLDB命令对照表&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;https://lldb.llvm.org/lldb-gdb.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GDB 与 LLDB 命令对照表1&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-command-examples.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GDB 与 LLDB 命令对照表2&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>WebRTC传输与服务质量</title>
    <link href="https://blog.avdancedu.com/2763ac60/"/>
    <id>https://blog.avdancedu.com/2763ac60/</id>
    <published>2021-08-12T18:08:41.733Z</published>
    <updated>2021-08-12T18:08:41.734Z</updated>
    
    <content type="html"><![CDATA[<p>作者 | 李超<br>整理 | LiveVideoStack</p><p>非常高兴和大家一同探讨WebRTC传输是如何保证音视频服务质量的。</p><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_1.webp" alt=""></p><p>本次分享我将从四个方面向大家介绍一下WebRTC传输是如何保证音视频服务质量的。第一，实时通信的目标。我们首先需要确定实时通信的目标，才能够知道要将实时通信做成怎样的系统、保证怎样的实时性；第二，WebRTC如何保障数据传输的实时性；第三，进行实时传输时，想要满足实时性，网络与服务质量之间可能存在的矛盾；最后，就是WebRTC如何解决网络与服务质量之间的矛盾。</p><a id="more"></a><h2 id="实时通信的目标"><a href="#实时通信的目标" class="headerlink" title="实时通信的目标"></a>实时通信的目标</h2><h3 id="实时通信的目标是什么？"><a href="#实时通信的目标是什么？" class="headerlink" title="实时通信的目标是什么？"></a>实时通信的目标是什么？</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_2.webp" alt=""></p><p>首先提出两个问题：第一，开会时你是喜欢在办公室里，还是更喜欢在线上开？第二，如果有一场演唱会，你愿意去现场呢？还是愿意在线上听？</p><h3 id="线上与现在不同的原因"><a href="#线上与现在不同的原因" class="headerlink" title="线上与现在不同的原因"></a>线上与现在不同的原因</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_3.webp" alt=""></p><p>相信大家更多都会选择线下，理由是线上线下感觉不一样。其不同点在于：首先是摄像头与人眼看到的效果不一样，例如摄像头采集的角度过小、无法拍到某些角度的画面；其次是采集设备的质量参差不齐，一场会议中大家所使用的设备有的高清、有的模糊；最后，也是最关键的一点就是现场的气氛无法被摄像头采集到，每个人都有自己的气场，当大家聚集在一起时，现场氛围感非常热烈，但隔着屏幕无法感受到。</p><h3 id="实时通信的目标-1"><a href="#实时通信的目标-1" class="headerlink" title="实时通信的目标"></a>实时通信的目标</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_4.webp" alt=""></p><p>根据以上几点，我们可以总结出实时通信最终的目标是：尽可能逼近或达到面对面交流的效果。从目前的情况来看，超越面对面交流的效果是几乎不可能的。</p><h2 id="几个重要指标"><a href="#几个重要指标" class="headerlink" title="几个重要指标"></a>几个重要指标</h2><h3 id="几个重要指标-1"><a href="#几个重要指标-1" class="headerlink" title="几个重要指标"></a>几个重要指标</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_6.webp" alt=""></p><p>那么如何才能达到面对面交流的效果呢，这里涉及到几个重要指标。</p><p>最为关键的是实时通信的延迟指标，只有将延迟指标搞清楚，才能知道做实时通信时，达到怎样的延迟才算符合要求的，即接近面对面交流的效果。然后是音视频服务质量指标，延迟指标达到后，再根据这项指标判断音视频服务质量的好坏。</p><h3 id="实时通信延时指标"><a href="#实时通信延时指标" class="headerlink" title="实时通信延时指标"></a>实时通信延时指标</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_7.webp" alt=""></p><p>下面具体看一下延迟指标的分级标准。通过图中表格可以看到，如果端到端延迟在200ms以内，说明整个通话是优质的，通话效果就像大家在同一个房间里聊天一样；300ms以内，大多数人很满意，400ms以内，有小部分人可以感觉到延迟，但互动基本不受影响；500ms以上时，延迟会明显影响互动，大部分人都不满意。</p><p>所以最关键的一级是500ms，只有延迟低于500ms，才可以说是合格的实时互动系统。</p><h3 id="音频服务质量指标"><a href="#音频服务质量指标" class="headerlink" title="音频服务质量指标"></a>音频服务质量指标</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_8.webp" alt=""></p><p>接下来是音频服务质量指标，它根据MOS值来打分。4.0-5.0为“优”，评值标准是听得非常清楚，延时小，交流顺畅；3.5-4.0为“良”，音质稍差，听得清，延时小，有点杂音；3.0-3.5为“中”，音质较可，能听清，有一定时延，可以交流；1.5-3.0为“差”，勉强能够听清，交流时需要重复多次才能够表述清楚；0-1.5为“劣”，完全听不清，延时大，交流不畅。</p><h3 id="视频服务质量指标"><a href="#视频服务质量指标" class="headerlink" title="视频服务质量指标"></a>视频服务质量指标</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_9.png" alt=""></p><p>视频服务质量的评价标准有几个，它们也都是通过MOS值打分来判断质量好坏的，图中参考是以码流大小为标准评估指标。以640*480为例，如果想达到MOS值为4.5的优质效果，可以看到产生的码流的大小大概在3Mbps左右。这样的码流对于实时传输来说太大了，如果是640*480的视频占用3Mbps的带宽，那是一件非常奢侈的事儿。一般情况下，我们会选择MOS值为3.5（绿色线）的码流，其码流范围在600kbps左右。</p><p>从以上可以看到，在保证传输的实时性时，由于带宽是一定的，可能会牺牲一定的服务质量。</p><h2 id="主要矛盾"><a href="#主要矛盾" class="headerlink" title="主要矛盾"></a>主要矛盾</h2><h3 id="实时通信与服务质量的矛盾"><a href="#实时通信与服务质量的矛盾" class="headerlink" title="实时通信与服务质量的矛盾"></a>实时通信与服务质量的矛盾</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_10.webp" alt=""></p><p>通过了解上述三个指标，我们可以得到实时通信与服务质量的主要矛盾。</p><p>第一，码流与带宽之间的矛盾。要想达到好的质量，码流一般会比较大（当然，不能超过最大码流)，而带宽是有限的，于是码流和带宽之间就会产生矛盾；第二，实时性和服务质量之间的矛盾。通常为了保证好的实时性我们会选择UDP，而UDP不保证网络传输的可靠性，丢包、乱序是经常发生的。一旦出现丢包、乱序，网络传输质量就无法得到保证，最终会影响到音视频的质量。</p><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_11.webp" alt=""></p><p>这里我们就可以总结出实时通信的主要矛盾，即：音视频的质量与带宽大小、实时性和网络质量之间存在矛盾，其它包括3A问题都属于次要矛盾。</p><h2 id="解决矛盾方法"><a href="#解决矛盾方法" class="headerlink" title="解决矛盾方法"></a>解决矛盾方法</h2><h3 id="解决矛盾的方法"><a href="#解决矛盾的方法" class="headerlink" title="解决矛盾的方法"></a>解决矛盾的方法</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_12.webp" alt=""></p><p>下面来看下解决矛盾的方法。对于WebRTC来说，主要从以下几个方面解决主要矛盾：如何保障数据传输的实时性、如何提高网络质量、如何更准确的评估带宽、如何平衡码流与带宽。</p><h2 id="保障数据的实时性"><a href="#保障数据的实时性" class="headerlink" title="保障数据的实时性"></a>保障数据的实时性</h2><p>对于WebRTC来说，为了保障数据的实时性，提供了两种方法：一种是传输路径的选择，它首先会选择最佳的传输路径，使得端到端传输时采取最好、最短的传输路径从而保障数据传输的实时性；另一种是传输协议的选择，可以选择TCP或者UDP。下面咱们先看一下WebRTC是如何选择最佳传输路径的。</p><h3 id="选择一条最好的路径"><a href="#选择一条最好的路径" class="headerlink" title="选择一条最好的路径"></a>选择一条最好的路径</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_13.png" alt=""></p><p>图为WebRTC路径选择的架构图。图中包括三个端，A端、B端和C端，其中A和B在同一个局域网内，对于WebRTC来说，如果发现同一局域网内的两端需要通信时，会选择局域网内直连，从而保障网络路径最短最优；如果是A和C通信，它们不在同一局域网内，那么WebRTC会选择P2P直连，做NAT穿越，如果穿越成功，便可进行直连，这样路径相对服务器中转来说也比较短。只有在P2P不成功时，才会选择服务端中转。从图中可以看到，当一端通过TURN服务器将数据传输给另一端时，其传输路径明显长于P2P直连，所以对于WebRTC来说，它一定会选择最短、最优的路径，从而保障端到端的实时传输。</p><h3 id="使用TCP还是UDP？"><a href="#使用TCP还是UDP？" class="headerlink" title="使用TCP还是UDP？"></a>使用TCP还是UDP？</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_14.webp" alt=""></p><p>接下来看一下WebRTC对TCP/UDP协议的选择。在网络比较优质时，TCP/UDP都可以用于实时传输，但大多数情况下，我们首选UDP（后面会介绍UDP的优势）；弱网环境下不能使用TCP；而在进行网络穿越时，使用TCP又有较大的好处，在企业内可以使用TCP访问外网的80端口进行穿透。</p><h3 id="为什么极端网络环境下不能用TCP？"><a href="#为什么极端网络环境下不能用TCP？" class="headerlink" title="为什么极端网络环境下不能用TCP？"></a>为什么极端网络环境下不能用TCP？</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_15.webp" alt=""></p><p>为什么在弱网环境下不能用TCP？这是由于TCP的机制所造成的。TCP的机制是发送、确认、丢包、重传。正常情况下，数据从一端传输到另一端是没有任何问题的，但当出现丢包时就会有较大的麻烦。</p><p>图中显示了多次丢包时的延迟情况：从客户端向服务端发送数据包，服务端需要返回ACK消息进行确认; 客户端收到确认消息后, 才能继续发送后面的数据（有滑窗时也是类似的）。每次客户端发完数据后，都会启动一个定时器，定时器的最短超时时间是200ms。如果因某种原因，在200毫秒客户端没有收到返回的ACK包，客户端会重发上一个包。由于TCP有退避机制，以防止频繁发送丢失包，因此会将重发包的超时时间延长到400ms。如果重发包依然没有收到确认消息，则下一次重发的超时时间会延长到800ms。我们可以看到，连续几次丢包后，就会产生非常大的延迟，这就是TCP在弱网环境下不能使用的根本原因。</p><h3 id="选择UDP带来的问题"><a href="#选择UDP带来的问题" class="headerlink" title="选择UDP带来的问题"></a>选择UDP带来的问题</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_17.webp" alt=""></p><p>由于TCP的机制问题，因此通常我们会选择UDP来保障音视频传输的实时性。UDP在实时性方面有优势，但缺点同样明显。由于UDP是不可靠传输，它只能尽力送达，所以出现丢包、乱序是常见的事儿，但对于网络质量来说，丢包是非常严重的事情，这就需要我们自己处理这个问题。下面咱们就来看看WebRTC是如何解决这个问题的吧！</p><h2 id="如何提高网络质量"><a href="#如何提高网络质量" class="headerlink" title="如何提高网络质量"></a>如何提高网络质量</h2><h3 id="网络质量包含哪些指标"><a href="#网络质量包含哪些指标" class="headerlink" title="网络质量包含哪些指标"></a>网络质量包含哪些指标</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_18.webp" alt=""></p><p>那么，WebRTC是如何处理UDP的网络质量的呢？</p><p>要想解决网络质量，首先要知道影响网络质量的几个因素：它包括了丢包率、延迟时间、抖动、乱序。如果网络丢包率低、延迟时间小、不抖动、不乱序，这就是非常优质的网络啦。但如果丢包率很高，那么网络质量一定会很差。</p><h3 id="造成丢包的原因"><a href="#造成丢包的原因" class="headerlink" title="造成丢包的原因"></a>造成丢包的原因</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_19.webp" alt=""></p><p>图中是网络基本的拓扑，造成丢包的原因有很多，如链路质量差，当手机与基站连接时，由于信号不好会造成丢包，这就属于链路差，这种情况在移动端是经常发生的；第二是带宽满，比如一台机子上行发送码率比较大，而下行接收链路比较小，这时在上游的路由器会把数据缓存起来慢慢发送，但缓存是有限制的，一旦缓存被塞满，后面就会造成大量丢包；第三是主动丢包，比如路由是跨运营商的，在不同运营商之间传输数据时，可能由于运营商未知的原因造成丢包；第四是光线被挖断等偶然原因造成丢包。</p><h3 id="减少丢包的方法"><a href="#减少丢包的方法" class="headerlink" title="减少丢包的方法"></a>减少丢包的方法</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_20.webp" alt=""></p><p>WebRTC主要通过两种方式解决丢包：NACK和FEC。</p><h3 id="NACK"><a href="#NACK" class="headerlink" title="NACK"></a>NACK</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_21.webp" alt=""></p><p>NACK的作用是丢包重传。从图中你可以看到，WebRTC的发送端不停地向接收端发送RTP包，接收端每隔一小段时间，就对这段时间内的丢包情况进行统计。如果发现丢包，它会给发送端回一个NACK消息，NACK消息中记录了这一段时间内哪些包丢失了。发送端收到NACK后，会在之前的发送历史记录中找到丢失的包并重新发送。</p><h3 id="NACK适合使用的场景"><a href="#NACK适合使用的场景" class="headerlink" title="NACK适合使用的场景"></a>NACK适合使用的场景</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_22.webp" alt=""></p><p>当然，通过NACK重传，会产生一定的延时，该延时包括：等待发送NACK的时间（10或20ms），NACK经过网络的时延以及RTP的网络时延和重传RTP包的网络时延，即1.5RTT+10或20ms。通过这个公式我们可以知道，如果RTT时延比较大，比如200ms，那么1.5RTT就是300ms。通过前面讲述的实时传输延时指标我们可以知道，端到端实时传输的时延需要控制在500ms之内，如果仅数据的网络传输就占了300ms，那数据再经过采集、编码、解码、渲染等流程，这些处理时间加在一起很有可能就超过500ms。</p><p>所以可以得出结论，丢包重传仅适用于网络传输时延比较小的情况，如果RTT比较大时，就不适合使用丢包重传来保障网络质量了。</p><h3 id="FEC"><a href="#FEC" class="headerlink" title="FEC"></a>FEC</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_23.webp" alt=""></p><p>FEC的作用是通过冗余数据解决丢包。实际上，它就是一个异或操作。如图所示，假设传输的数据是Data1和Data2，这两个数据如果在传输的过程中没有FEC进行保护，其中一个数据丢失了，那只能通过NACK重新找回。那么，能否在传输过程中加一些冗余数据，以保证接收时，当某一个数据丢失后，不经过重传就可以将丢失的包找回来呢？这就是FEC。</p><p>在图中我们可以看到，Data1和Data2同时发送到对端，在发送时对它们做一下异或操作，即Data1的最后一位0与Data2的最后一位0异或为0，Data1的倒数第二位1与 Data2的倒数第二位1异或为0，依次类推，最后就产生了冗余数据R，同时将三个包从一端传输到另一端。传输过程中，如果Data1丢失，通过Data2和冗余包R就可以将Data1找回来。找回包的算法也是异或操作，即在接收端将Data2的每一位与冗余包中的相同位进行异或操作就算出了Data1。这就保证了不用重新请求，就将丢失包找回的作用。</p><p>而且异或具有传递性，A、B、C三个包可以同时异或得到D，如果其中任意一个包丢失，可以通过D和其它包找回丢失的包。</p><h3 id="ULPFEC"><a href="#ULPFEC" class="headerlink" title="ULPFEC"></a>ULPFEC</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_24.webp" alt=""></p><p>对于WebRTC来说，它默认使用的是ULPFEC。其原理是，将要传输的数据包先进行分组，如将三个包分为一组，然后为这一组包产生一个冗余包，如果这一组中某个包丢失了，就可以通过冗余包和其它包的异或操作将其找回。从图中第一行可以看到1和2到了，3丢了，通过R1可以找回3，第三行同样可以找回9。其缺点是，如果连续的两个包都丢失了，这种算法就失效了，比如第二行4和5丢失后，通过6和R2无法找回它们。</p><h3 id="FlexFEC"><a href="#FlexFEC" class="headerlink" title="FlexFEC"></a>FlexFEC</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_25.webp" alt=""></p><p>于是就有了改进的FlexFEC，它做了双向冗余处理，不仅横向做了冗余，而且纵向也做了冗余。</p><p>此时，当4和5同时丢失时，通过1、7和C1可以找到4，2、8和C2可以找到5，这样就可以找回连续的两个丢包。当然它也有弊端，其弊端是无法处理批量的连续丢包，例如连续丢失了10个包，FlexFEC对这种情况也无能为力。</p><p>以上就是WebRTC对于丢包的解决方法，通过“NACK+FEC”防止丢包。</p><h3 id="如何解决抖动和乱序"><a href="#如何解决抖动和乱序" class="headerlink" title="如何解决抖动和乱序"></a>如何解决抖动和乱序</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_26.webp" alt=""></p><p>下面来说说抖动和乱序。抖动的意思是，一会儿来了很多包，一会儿又一个没有，包是一波一波的来，包到达的时间很不平均；而乱序指的是先发的包后到了，后发的包先到了。</p><p>WebRTC处理抖动和乱序使用的是JitterBuffer和NetEQ。JitterBuffer用于处理视频包，NetEQ用于处理音频包。它们的原理大致相同（NetEQ更为复杂一些），都是通过一个队列（缓存区）对接收到的数据做下缓冲，然后再从队列的另一端将数据包一个个均匀的取出， 这样取出的数据就是平滑的了。</p><p>对于乱序的处理也比较好解决，如图中所示，每个RTP包进来的时候有一个序号（Sequence Number），在数据进入队列时，它会根据序号插到对应的位置上，比如图中104、107包已经到达，并且在对应的位置上，而103、105和106没来，位置就空着，等它们来了再插入对应的位置，这样就可以防止乱序，所以通过JitterBuffer和NetEQ就可以同时解决乱序和抖动了。</p><p>总结一下，NACK和FEC解决丢包问题，NACK会增加时延，FEC会占用带宽。JitterBuffer解决视频的乱序与抖动，NetEQ解决音频的乱序与抖动。</p><h3 id="网络延时产生的原因"><a href="#网络延时产生的原因" class="headerlink" title="网络延时产生的原因"></a>网络延时产生的原因</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_27.webp" alt=""></p><p>说到延时，实际上就与带宽评估有密切的关系了。延时的产生有两个原因：第一是链路问题，正常的网络上，数据包的传输都是时快时慢的；第二是发生了网络拥塞，当发生拥塞后，数据包会进行缓冲，就会造成延时，而当缓冲溢出时，就出现了丢包。</p><p>所以对于延时来说，我们需要解决的是因拥塞而造成的延时，链路问题无法解决。下面咱们就来看看WebRTC是如何防止拥塞的。</p><h2 id="准确的带宽评估方法"><a href="#准确的带宽评估方法" class="headerlink" title="准确的带宽评估方法"></a>准确的带宽评估方法</h2><h3 id="如何解决抖动和乱序-1"><a href="#如何解决抖动和乱序-1" class="headerlink" title="如何解决抖动和乱序"></a>如何解决抖动和乱序</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_28.webp" alt=""></p><p>WebRTC防止拥塞的根基是有准确的带宽评估方法。它提供了两种带宽评估方法，一种是基于丢包的带宽评估，另一种是基于延时的带宽评估。而基于延时的评估方法又分为接收端（Goog-REMB）和发送端（Goog-TCC）的带宽评估方法，目前默认采用的是Goog-TCC方法，因为其相对来说更为精准。</p><h3 id="基于丢包的带宽评估"><a href="#基于丢包的带宽评估" class="headerlink" title="基于丢包的带宽评估"></a>基于丢包的带宽评估</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_29.webp" alt=""></p><p>基于丢包的带宽评估方法比较简单，根据丢包率进行计算。实际上，正常带宽也有一定的丢包，如果丢包率&lt;2%，属于网络质量不错的正常丢包，说明带宽还没有达到上限，应该增加评估的带宽值。举个例子，比如你家里的带宽是8M，WebRTC最开始是不知道你家里的真实带宽的，它必须一点点测量，所以一开始它先给你的带宽设置一个假设值，即500K，当发现丢包率很低时，它再增加带宽的评估值，如从500K升到1兆，如果丢包率还是很低，就会加到1.5兆、2兆……，带宽评估值增加的速度是每次增加8%；如果丢包率&gt;10%，说明发生拥塞了，此时应该立即降低带宽，公式如图（loss&gt;0.1时）所示。如果丢包率&lt;10%，说明现在的带宽评估的比较准确，此时应该保持这个带宽，不增加也不减少；</p><h3 id="基于延时的带宽评估"><a href="#基于延时的带宽评估" class="headerlink" title="基于延时的带宽评估"></a>基于延时的带宽评估</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_30.webp" alt=""></p><p>基于延时的带宽评估方法比基于丢包的评估更好一些，因为它可以提前预估是否发生了拥塞。基于丢包的评估丢包率一旦超过10%就说明可能已经发生拥塞了，而网络一旦拥塞，再想恢复回原来的状态，需要花费一段时间，而这段时间就会影响音视频的服务质量。</p><p>而基于延时的带宽评估就不会产生这种情况。它的基本原理是，如果接收到的数据包的网络传输时延在持续增长，就说明网络变差了，当达到一定程度时，就要将评估的带宽值降下来，以防止发生网络拥塞。它的计算公式是根据状态机来的（状态机比较复杂，我这里就不讲了），当状态非常好时，需要增加带宽，同丢包增加带宽一样，每次增加8%；如果延时一直累加，则需要降低带宽，带宽降为原来85%，其它情况就保持当前带宽，无增无减。</p><h2 id="媒体数据与带宽的平衡"><a href="#媒体数据与带宽的平衡" class="headerlink" title="媒体数据与带宽的平衡"></a>媒体数据与带宽的平衡</h2><h3 id="媒体数据与带宽的平衡-1"><a href="#媒体数据与带宽的平衡-1" class="headerlink" title="媒体数据与带宽的平衡"></a>媒体数据与带宽的平衡</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_31.webp" alt=""></p><p>当带宽评估准确之后再进行控制就非常容易了。接下来，我们看一下WebRTC如何平衡媒体数据与带宽。</p><p>带宽评估方法和网络质量的提升在前面我已经介绍了。在有限的带宽下，如何才能提供更好的音视频服务质量，是人们一直孜孜不倦追求的目标。因此在同等条件下，可以将数据压缩的更小，一直是解决服务质量的一种关键方法。目前最常用的视频编码器还是H.264，不过新的编码器已经有了很大突破VP9/H265、AV1/H266提供了更高的压缩率，这使得我们在网络条件有限的情况下，可以传输更多的数据从而保障更好的服务质量。</p><p>另一方面，在带宽相同且码流无法压缩的情况下，还可以采用动态码率。通常，在使用动态码率时，我们可以直接从产品上看出来，你会发现视频一会儿清晰，一会儿模糊。即在带宽小时，编码器压缩码流，此时视频变得模糊；带宽大时，编码器放大了码流，所以视频变得清晰。以上就是通过减少数据量的方法来保障实时通信质量的。</p><h3 id="Simulcast与SVC"><a href="#Simulcast与SVC" class="headerlink" title="Simulcast与SVC"></a>Simulcast与SVC</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_32.png" alt=""></p><p>除此之外，还可以通过Simulcast或SVC解决质量问题。Simulcast和SVC解决问题的思路是类似的，它们会在发送端增大码流的发送，将数据先传给服务端，然后由服务端根据接收端带宽的不同，选择合适的码流下发。对于网络较差的用户，传输清晰度低的码流，对于网络较好的用户，传输高清晰度的码流。所以这两种技术对于发送方的带宽和质量有非常高的要求。</p><p>SVC与Simulcast最大的区别：SVC上传的是一路码流，但这一路码流是由多层构成的。服务端会按照不同接收端的带宽大小，选择传输不同的层。如上图所示，手机端带宽小，就传输小的一层数据，PC端带宽大，就将所有层全部传输过去；而Simulcast上传的是多路流，一般分为小、中、大三路。对手机端传输小的一路，对PC端传输最大的一路。Simulcast的好处在于，每一路流都是独立的，所以可以对每一路流使用硬件编解码器，而 SVC的分层方式目前没有硬件支持，所以无法通过硬件加速。</p><h3 id="流控"><a href="#流控" class="headerlink" title="流控"></a>流控</h3><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_33.png" alt=""></p><p>当带宽评估准确后，如果发送的的码流还是大于带宽大小，此时就需要通过流控来进行控制了。流控的作用是当输出码流大于带宽时，降低发送码率，以防止发生拥塞。当然它会导致时延的增加。实际上，对于流控来说，它需要控制两个点：第一个点是Pacer，降低发送码率。当然仅降低发送码率还不够，因为如果编码器仍然输出大量码流给Pacer，那么Pacer 的缓冲区迟早会被撑爆。所以在控制Pacer让它减少发送码率的同时，一定要降低音视频的编码器的输出码率，从而保持平衡，进而使数据平缓下行。</p><p>正如我前面所说的，流控虽然防止了网络拥塞的发生，但会增加一些延时，增加的延时最终会反应到实时通信的总指标里，总的延时必须控制在500ms以内。比如以前端到端时延是200ms，由于带宽不足，时延增加到300ms、400ms都是可以的，但一定不要超过500ms。</p><p>此外，对于编码器的输出码流来说，如果流控通过直接降低码流仍然不能与带宽适配时，还可以通过降低分辨率的方式来降低码流。总之，在带宽不足时，要想尽办法减少数据量。实在不行，也可以关掉视频只保留音频来保障网络的畅通。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_34.png" alt=""></p><p>总结一下，对于服务质量保障，首先提高网络质量，NACK和FEC解决丢包问题，JitterBuffer解决视频的乱序与抖动，NetEQ解决音频的乱序与抖动；带宽评估通过Goog-REMB和Goog-TCC，还有丢包的带宽评估；为了保障实时性，需要选择更优质的线路，比如客户端与服务端通信的时候选择更好的路线节点，保证云端网络带宽等等；从业务上，减少数据量可以用AV1、SVC、Simulcast、动态码率，减少业务；在防拥塞上，通过Pacer进行流控，只要能控制在500ms之内，适当增加时延也是可以接收的。</p><p>以上就是本次分享的全部内容，谢谢！</p><h2 id="Q-amp-A-部分"><a href="#Q-amp-A-部分" class="headerlink" title="Q&amp;A (部分)"></a>Q&amp;A (部分)</h2><p><strong>1. 路径的选择是WebRTC内部自动选择的吗？</strong></p><p>是自动选择的。WebRTC会自动判断通信的双方是否在同一个局域网内，如果是就直接在局域网内建立连接；如果不是，会通过STUN协议获取各自的外网地址，然后进行NAT穿越；如果还不成功的话，才会选择TURN服务进行数据中转。</p><p><strong>2. WebRTC网络传输质量衡量指标有什么？</strong><br>衡量任何一个实时传输系统时，首要看它的时延是否达到500ms以内。其实500ms对于实时通信而言，也是比较苛刻的标准了，因为网络的变化是非常大的， 所以要实现这个指标其实难度也是蛮大的。其次是丢包率，这是非常关键的指标，刚才说到2%的丢包率代表网络比较好；小于10%，对于WebRTC来说，代表目前的带宽是准确的；超过10%则代表发生了拥塞。有些厂商说它的产品可以抗xx%的丢包，这样的前提是不认为丢包是一个指标，但在真网络中，当路由的缓冲被撑爆后，必然会出现大量丢包，如果不把丢包当作指标的话，就缺少了一种判断网络拥塞发生的条件，这显然是不合理的。</p><p><strong>3. 视频JitterBuffer怎么具体控制平滑的？</strong><br>其实JitterBuffer平滑处理的难度并不像我们想像的那样复杂，之所以大家认为它复杂，可能是因为一些额外的因素，如还要处理音视频同步等问题。对于平滑处理，我们完全可以自己通过一个Buffer来实现。Buffer可以是动态大小或固定大小。为了简化，我们假设它是固定大小，比如定义一个可以存放 100 个元素的数组，在数组的一头每隔 10 毫秒取一个包，这就是一个最简单的平滑处理。当然更好的方式是可以根据网络的变化让这个平滑数组的大小也动态变化，这样就更高级一些。当然，如果Buffer是动态变化的，那在计算平滑数组的动态大小时，会稍难一些。</p><p><strong>4. WebRTC要和SIP客户端通讯有什么好的方案？</strong><br>一般与SIP通信最好借助流媒体服务器比如Janus，它既支持SIP协议也能支持WebRTC客户端。这样SIP终端就可以将数据传输流媒体服务器，然后再转发给WebRTC终端了，同理WebRTC终端也可以通过流媒体服务器与SIP终端通信了。</p><p><strong>5. FEC和NACK默认是不是都要开启？</strong><br>是的。对于WebRTC来说，FEC和NACK都是开启的，也可以控制它们的开关。</p><p><strong>6. 能说下为什么TCC比REMB准确吗？</strong><br>TCC和REMB主要有两个区别。第一是计算的端不同，REMB是在接收端计算的，接收端计算后再将结果返回给发送端进行控制，而在回传结果时，可能网络又发生了新的变化，这就造成了REMB的及时性不够；TCC是将所有数据都交给发送端做计算和控制，因此及时性和准确度会更高。第二是滤波器不同，REMB是卡尔曼滤波器（Kalman），TCC是最小二乘法滤波器（Trend line）。最小二乘法滤波器在网络延时评估这方面比卡尔曼滤波器效果更好一些。</p><p><strong>7. 在内网环境下p2p想让延时尽可能小，可以做哪些工作？实验室环境最小延时可以达到100ms以下吗？</strong><br>如果在同一个局域网内，实际只有几十毫秒的延迟。有同学可能会疑惑，有的产品在同一局域网内延迟非常小，为什么用WebRTC反而延迟增大了？这就是因为WebRTC为保障网络质量，在内部通过多种机制，各种缓冲，来做到的。所以它必然会产生一定的延迟，也就是拿延迟换质量。而在局域网内，网络基本没有延时，不丢包、不抖动、不乱序。这时什么策略都不采用，网络的传输才是最快的，因此在内网通信时，WebRTC的实时性一定不如什么策略都不加的产品好。</p><p><strong>8. ULPFEC和FLEXFEC区别是？</strong><br>ULPFEC只能进行单向冗余处理，而FLEXFEC可以进行双向冗余处理，即可以横向分组还可以纵向分组做冗余，所以它的抗丢包性要比ULPFEC好，同时占的带宽也比ULPFEC多。</p><p><strong>9. 可靠性这块，UDP上的WebRTC做ack是自己封装了seq吗？然后，一样需要ack重传的话，跟TCP SACK有什么区别呢？</strong><br>WebRTC使用的是RTP协议传输数据。RTP协议中有seq字段。此外，WebRTC用的NACK与TCP的ACK机制不同。TCP每一块数据都需要通过ACK进行确认，如果没收到ACK就重发，直到成功收到ACK或断连；而NACK允许丢包，当重传多次不行时，就不传了。且而即使重传了数据包，在接收端发现它已经过期时，也会将其丢掉。</p><p><strong>10. WebRTC后面会用QUIC协议吗？</strong><br>这个问题争论较大。WebRTC也在一直在尝试使用QUIC协议，从我的角度来看，QUIC协议最主要的是解决Http3，Http3解决的是TCP的问题，就要保证数据的可靠性，那么实时性就会受到影响，什么时候QUIC如果可以解决好实时性问题就可以用，反之则不能。</p><p>从我的角度看，一种协议最好只解决一件事儿，很难通过一套协议解决所有问题。</p><p><strong>阅读推荐</strong></p><p><img data-src="https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_35.webp" alt=""></p><p>《WebRTC音视频实时互动技术 — 原理、实战与源码分析》— 李超</p><p>书籍深入浅出的对WebRTC进行了系统讲解，既有原理，又有实战，从WebRTC是如何实现实时音视频通信的，到如何应用WebRTC库实现音视频通信，再到WebRTC源码的剖析，逐步展开讲解。此外，本书对WebRTC的传输系统进行了重点分析，相信读者通过本书可以一窥WebRTC传输的奥秘。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者 | 李超&lt;br&gt;整理 | LiveVideoStack&lt;/p&gt;
&lt;p&gt;非常高兴和大家一同探讨WebRTC传输是如何保证音视频服务质量的。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/WebRTC_QoS/webrtc_1.webp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本次分享我将从四个方面向大家介绍一下WebRTC传输是如何保证音视频服务质量的。第一，实时通信的目标。我们首先需要确定实时通信的目标，才能够知道要将实时通信做成怎样的系统、保证怎样的实时性；第二，WebRTC如何保障数据传输的实时性；第三，进行实时传输时，想要满足实时性，网络与服务质量之间可能存在的矛盾；最后，就是WebRTC如何解决网络与服务质量之间的矛盾。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>OpenCV课程资料</title>
    <link href="https://blog.avdancedu.com/65de593f/"/>
    <id>https://blog.avdancedu.com/65de593f/</id>
    <published>2021-08-07T04:21:07.513Z</published>
    <updated>2021-08-07T04:21:07.513Z</updated>
    
    <content type="html"><![CDATA[<p>这里是我OpenCV课程的相关资料，后面还会不断补充…</p><a id="more"></a><h2 id="Windows下编译OpenCV"><a href="#Windows下编译OpenCV" class="headerlink" title="Windows下编译OpenCV"></a>Windows下编译OpenCV</h2><h3 id="下载必要的工具和库"><a href="#下载必要的工具和库" class="headerlink" title="下载必要的工具和库"></a>下载必要的工具和库</h3><ol><li>安装python3和numpy库，下载地址:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;3.9.2&#x2F;python-3.9.2-amd64.exe</span><br></pre></td></tr></table></figure></li><li>安装 VS, 社区版即可，下载地址:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;visualstudio.microsoft.com&#x2F;zh-hans&#x2F;downloads&#x2F;</span><br></pre></td></tr></table></figure></li><li>安装 cmake，下载地址: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Kitware&#x2F;CMake&#x2F;releases&#x2F;download&#x2F;v3.20.0-rc1&#x2F;cmake-3.20.0-rc1-windows-x86_64.msi</span><br></pre></td></tr></table></figure></li><li>下载IPPICV<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;opencv&#x2F;opencv_3rdparty.git</span><br></pre></td></tr></table></figure><h3 id="下载opencv源码，下载地址："><a href="#下载opencv源码，下载地址：" class="headerlink" title="下载opencv源码，下载地址："></a>下载opencv源码，下载地址：</h3></li></ol><ul><li>opencv源码地址: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;opencv&#x2F;opencv.git</span><br></pre></td></tr></table></figure></li><li>opencv-contrib源码地址git: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone https:&#x2F;&#x2F;github.com&#x2F;opencv&#x2F;opencv_contrib.git</span><br></pre></td></tr></table></figure></li></ul><h3 id="编译方法："><a href="#编译方法：" class="headerlink" title="编译方法："></a>编译方法：</h3><ul><li>在存放opencv源码目录中创建build目录</li><li>运行cmake</li><li>选择opencv源码目录</li><li>选择编译目录</li><li>选择CPU架构</li><li>增加opencv-contrib选项, OPENCV_EXTRA_MODULES_PATH=../opencv_contrib/modules</li><li>检查编译选项<ul><li>勾选 opencv_world</li></ul></li><li>生成编译脚本</li></ul><h3 id="打开opencv工程文件"><a href="#打开opencv工程文件" class="headerlink" title="打开opencv工程文件"></a>打开opencv工程文件</h3><ol><li>选择输出版本类型</li><li>进行编译</li></ol><h2 id="Ubuntu下编译OpenCV4"><a href="#Ubuntu下编译OpenCV4" class="headerlink" title="Ubuntu下编译OpenCV4"></a>Ubuntu下编译OpenCV4</h2><ul><li><p>安装开发工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install build-essential cmake unzip pkg-config</span><br></pre></td></tr></table></figure></li><li><p>安装image and video I/O libraries</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libjpeg-dev libpng-dev libtiff-dev</span><br><span class="line">$ sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev</span><br><span class="line">$ sudo apt-get install libxvidcore-dev libx264-dev</span><br></pre></td></tr></table></figure></li><li><p>安装GUI</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libgtk-3-dev</span><br></pre></td></tr></table></figure></li><li><p>安装数据优化包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libatlas-base-dev gfortran</span><br></pre></td></tr></table></figure></li><li><p>安装 Python 3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install python3-dev</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里是我OpenCV课程的相关资料，后面还会不断补充…&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>我的新书《WebRTC音视频实时互动技术--原理、实战与源码分析》终于出版了</title>
    <link href="https://blog.avdancedu.com/bc71cb9a/"/>
    <id>https://blog.avdancedu.com/bc71cb9a/</id>
    <published>2021-07-22T13:22:03.373Z</published>
    <updated>2021-07-22T13:22:03.374Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://cdn.avdancedu.com/image/article/webrtc_qos/webrtc_book.png" alt=""></p><p>近年来，在音视频领域WebRTC越来越受到大家的追棒，它就像音视频技术的一顶“王冠”，上面嵌了大大小小、各种各样的“宝石”，如回音消除、降噪、自动增益、NetEQ、网络拥塞控制……不胜枚举！几乎所有的实时直播客户端都或多或少的使用了WebRTC的代码或借鉴了WebRTC的思想。</p><a id="more"></a><h2 id="WebRTC服务质量"><a href="#WebRTC服务质量" class="headerlink" title="WebRTC服务质量"></a>WebRTC服务质量</h2><p>为什么WebRTC会受到如此追棒呢？我想，究其原因是它有非常好的服务质量（网络服务质量、音视频服务质量）。</p><p>在众多的服务质量中，网络服务质量是最为关键的。你可以想像一下，如果网络是“畅通无阻”的：有无限的带宽，不丢包、不延时，那一切都变得美好了。但现实中，不可能每个用户都有如此好的网络，更多的是网络不佳，带宽受限。而让那些网络不佳、带宽受限的用户也能享受较好的服务，则是WebRTC一直孜孜不倦追求的目标。</p><p>为了达到这个目标，WebRTC发明了一种网控拥塞控制算法，称为GCC。该算法最厉害的地方是可以根据网络的丢包情况和延时趋势准确的判断出用户带宽的大小，并根据带宽的大小来控制发包的速度，从而避免网络拥塞的发生。</p><p>这项技术是十分关键的。大多数情况下，用户的带宽是动态变化的，如果我们不能实时的、有效的判断出带宽的大小，那么很有可能会因为发送音视频码流过大，导致网络拥塞，最终引起网络瘫痪。举个典型的例子，像长城宽带这种共享网络，假如你购买的是 100M 带宽，但实际使用时，分到的带宽并不是 100M，它的波动是非常大的。在早上人少的时候，带宽可以接近 100M；但晚上人多时，可能还 2M都达不到。如果没有拥塞控制算法，不能动态的判断出带宽的大小，我们发送大码流的时候，后果就可想而知了。</p><p>当然，能够准确的评估出带宽，只是“万里长征”的第一步，后面还有很多事情要做呢，如：如何进行发送码流的控制？只控制发送速度就可以了吗？如果不对“源”（产生音频与视频数据的地方）进行控制，就会导致内存爆长，从而引起系统崩溃。</p><p>此外，传输的实时性也是非常关键的。此时又涉及到传输协议的选择了，我们在传输音视频数据时，是应该选择TCP还是UDP？在极端网络情况下为什么要选择UDP？这些都是值得深入探讨的问题。</p><p>当传输协议选好后，端与端之间连接通路的选择对传输的实时性也起着至关重要的作用。如果通信的双方在同一个局域网内，那么它们应该首先选择局域网这条通路，而不是将包发向外网绕一圈再回来；如果不在同一个局域网内，则应该优先选择P2P直连；只有在直连不通的情况下，才应该考虑通过中继服务器进行数据中转，从而达到数据实时传输的目的。</p><p>总之，为了达到更好的服务质量，WebRTC想到了各种办法，可以说无所不用其极。这里我对其方法做了一下总结，分成五大类，如下图所示：</p><p><img data-src="https://cdn.avdancedu.com/image/article/webrtc_qos/webrtc_qos.png" alt=""></p><h2 id="我的新书"><a href="#我的新书" class="headerlink" title="我的新书"></a>我的新书</h2><p>实际上，上面这些内容，都在我的书《WebRTC音视频实时互动技术–原理、实战与源码分析》中做了详细介绍。</p><p>本书不仅对WebRTC的网络传输做了细致、大量的分析，而且还向你详细介绍了如何通过WebRTC实现Web端与Android和iOS端的互联互通；并且还在本书的最后三章对WebRTC的源码进行了剖析，以使你不但可以知道如何使用WebRTC实现音视频通信，还能让你了解其中的原理，并知道WebRTC具体是如何做的。</p><p>总体来说，本书是一本WebRTC入门到进阶的书籍，尤其适合对于WebRTC有一定了解，想进阶的同学来说，非常适合学习本书的内容。以下是本书的目录:</p><p><img data-src="https://cdn.avdancedu.com/image/article/webrtc_qos/webrtc_dir1.png" alt=""><br><img data-src="https://cdn.avdancedu.com/image/article/webrtc_qos/webrtc_dir2.png" alt=""><br><img data-src="https://cdn.avdancedu.com/image/article/webrtc_qos/webrtc_dir3.png" alt=""><br><img data-src="https://cdn.avdancedu.com/image/article/webrtc_qos/webrtc_dir4.png" alt=""></p><h2 id="购买地址"><a href="#购买地址" class="headerlink" title="购买地址"></a>购买地址</h2><p><a href="https://item.jd.com/10033954503352.html" target="_blank" rel="noopener">机械工业出版社(华章)</a></p><h2 id="沟通群"><a href="#沟通群" class="headerlink" title="沟通群"></a>沟通群</h2><p>对于图中的任何疑问可以到微信群中提问。</p><p><img data-src="https://cdn.avdancedu.com/image/article/webrtc_qos/webrtc_group.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/webrtc_qos/webrtc_book.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;近年来，在音视频领域WebRTC越来越受到大家的追棒，它就像音视频技术的一顶“王冠”，上面嵌了大大小小、各种各样的“宝石”，如回音消除、降噪、自动增益、NetEQ、网络拥塞控制……不胜枚举！几乎所有的实时直播客户端都或多或少的使用了WebRTC的代码或借鉴了WebRTC的思想。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Go的性能竟如何优秀？Go、C和RUST性能对比</title>
    <link href="https://blog.avdancedu.com/1ed22639/"/>
    <id>https://blog.avdancedu.com/1ed22639/</id>
    <published>2021-07-22T12:47:16.905Z</published>
    <updated>2021-07-22T12:47:16.905Z</updated>
    
    <content type="html"><![CDATA[<p>最近几年Go、RUST等新语言不断推陈出新，令人目不暇接。据说Go与RUST开发出的程序性能非常高，但对于我这种C/C++老鸟来说，对此并不感冒，“再快还能比C快？”这句话一直萦绕在我的心头。</p><p>但出于好奇，每次听到有人说Go性能多好多好时，难免都会追问一句“有没有与C进行过对比测试？”，这句并不是想“兑”谁，而是想确认一下网上的传言是否为真。</p><p>不幸的是，每当我问这句话时，从来没有得到一个明确答复，也搞不清是他们得出的“Go性能好”是道听途说，还是自己真实的测试结果。</p><p>近来时间充裕，一时兴起，心想不如做个简单的Go、C/C++、RUST的性能对比测试吧，验证一下Go的性能到底如何。</p><a id="more"></a><h2 id="简单的测试用例"><a href="#简单的测试用例" class="headerlink" title="简单的测试用例"></a>简单的测试用例</h2><p>由于我一直专注在音视频实时通信领域，因此对网络传输的性能特别关心，所以这次测试只验证一下不同语言在传输UDP包时的性能。</p><p>为了减少其它因素的影响，测试条件限制如下：</p><ul><li>在同一台机子上进行不同语言性能的测试，防止因硬件的不同影响测试结果</li><li>服务端只接收不回复，防止服务器干扰测试结果</li><li>客户端只发送不接收，每次只发送<code>Hello</code>几个字符</li><li>客户端循环发送 1000 0000次，看它的总时长是多少</li></ul><p>下面是不同语言编写的测试程序。</p><h3 id="C客户端代码"><a href="#C客户端代码" class="headerlink" title="C客户端代码"></a>C客户端代码</h3><p>下面是使用<code>C</code>语言实现的客户端代码的主要逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    gettimeofday(&amp;tv0, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> lastime = tv0.tv_sec * <span class="number">1000000000</span> + tv0.tv_usec; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"total: %lu, sec:%lu, nao:%u\n"</span>, lastime, tv0.tv_sec, tv0.tv_usec);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//循环 1000 0000 次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>; a&lt; <span class="number">10000000</span>; a++)&#123;</span><br><span class="line">        n = sendto(sock, </span><br><span class="line">                        buff_send, </span><br><span class="line">                        <span class="built_in">strlen</span>(buff_send), </span><br><span class="line">                        <span class="number">0</span>, (struct sockaddr *) &amp;addr, </span><br><span class="line">                        <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;tv1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> curtime = tv1.tv_sec * <span class="number">1000000000</span> + tv1.tv_usec; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"total:%lu, sec:%lu, nao:%u\n"</span>, curtime, tv1.tv_sec, tv1.tv_usec);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>从上述代码中可以看到，在<code>for</code>循环执行了 1000 0000 次，每次都调用 <code>sendto</code> 发送UDP数据。</p><h3 id="Go客户端代码"><a href="#Go客户端代码" class="headerlink" title="Go客户端代码"></a>Go客户端代码</h3><p>Go语言实现的逻辑与C客户端逻辑是类似的，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">var</span> lastime <span class="keyword">int64</span> = time.Now().UnixNano()</span><br><span class="line">    fmt.Printf(<span class="string">"lastime: %d\n"</span>, lastime)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> a:=<span class="number">0</span>; a &lt; <span class="number">10000000</span>; a++ &#123;</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        _, err = conn.Write([]<span class="keyword">byte</span>(<span class="string">"Hello"</span>))    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> curtime <span class="keyword">int64</span> = time.Now().UnixNano()</span><br><span class="line">    fmt.Printf(<span class="string">"curtime: %d"</span>, curtime)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Go的代码非常简单，它与C的区别是其使用Write来发送数据。</p><h3 id="RUST客户端代码"><a href="#RUST客户端代码" class="headerlink" title="RUST客户端代码"></a>RUST客户端代码</h3><p>RUST语言实现的逻辑也是类似的，代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">let</span> start = Instant::now();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> n = start.elapsed().as_nanos();</span><br><span class="line">    std::<span class="built_in">println!</span>(<span class="string">" elapsed: &#123;&#125;"</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//loop &#123;</span></span><br><span class="line">    <span class="keyword">for</span> _i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">100001</span> &#123;</span><br><span class="line">        socket.send_to(data.as_bytes(), <span class="string">"127.0.0.1:9998"</span>)?;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = start.elapsed().as_nanos();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"elapsed : &#123;&#125;"</span>, n);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><table><thead><tr><th align="left">系统</th><th align="left">硬件</th><th align="left">C</th><th align="left">Go</th><th align="left">RUST</th></tr></thead><tbody><tr><td align="left">Mac</td><td align="left">2.7 GHz Intel Core i5<br>8 GB DDR3</td><td align="left">150秒</td><td align="left">85秒</td><td align="left">150 秒</td></tr><tr><td align="left">Linux</td><td align="left">2.7GHz Inter 8 Core i7 <br> 8G</td><td align="left">17-18秒</td><td align="left">21-22秒</td><td align="left">22 秒</td></tr></tbody></table><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>刚看到这个结果时，我真是难以至信，Go和RUST的性能竟然与C如此接近。</p><p>通过上面的测试我们可以得出以下结论：</p><ul><li>新语言 Go 与 RUST 在性能上确实不错，基本上与 C 是接近的，应用层到系统接口之间的层级比较薄</li><li>不同的操作系统表现不一样，但通常情况下Go都是在Linux系统下运行，所以应该以Linux系统的测试为准</li><li>Go、RUST相较C/C++而言，开发效率高很多，如果性能差不多的情况下，采用Go或RUST做服务器开发更有优势</li></ul><p><strong>但这次只是一个简单的测试，只能说在发送UDP时，Go、RUST与C性能差别不大，但并不代表在整体性能上Go和RUST已经赶上C/C++性能了。如果想更好的了解Go、RUST与C/C++的差异，应该做更详尽的测试验证。</strong></p><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>代码地址：<a href="https://github.com/andancedu/go_rust_c.git" target="_blank" rel="noopener">https://github.com/andancedu/go_rust_c.git</a></p><h2 id="我的课程"><a href="#我的课程" class="headerlink" title="我的课程"></a>我的课程</h2><p>-<a href="https://coding.imooc.com/class/415.html" target="_blank" rel="noopener">音视频系统入门</a></p><p>-<a href="https://coding.imooc.com/class/279.html" target="_blank" rel="noopener">ffmpeg精讲</a></p><p>-<a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">WebRTC入门与实战</a></p><p>-<a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">WebRTC高并发流媒体服务器</a></p><p>-<a href="https://time.geekbang.org/column/article/111337" target="_blank" rel="noopener">从0开始构造直播系统</a></p><p>-<a href="https://coding.imooc.com/class/496.html" target="_blank" rel="noopener">OpenCV入门与实战</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近几年Go、RUST等新语言不断推陈出新，令人目不暇接。据说Go与RUST开发出的程序性能非常高，但对于我这种C/C++老鸟来说，对此并不感冒，“再快还能比C快？”这句话一直萦绕在我的心头。&lt;/p&gt;
&lt;p&gt;但出于好奇，每次听到有人说Go性能多好多好时，难免都会追问一句“有没有与C进行过对比测试？”，这句并不是想“兑”谁，而是想确认一下网上的传言是否为真。&lt;/p&gt;
&lt;p&gt;不幸的是，每当我问这句话时，从来没有得到一个明确答复，也搞不清是他们得出的“Go性能好”是道听途说，还是自己真实的测试结果。&lt;/p&gt;
&lt;p&gt;近来时间充裕，一时兴起，心想不如做个简单的Go、C/C++、RUST的性能对比测试吧，验证一下Go的性能到底如何。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>音频3A问题经验分享</title>
    <link href="https://blog.avdancedu.com/5756c48d/"/>
    <id>https://blog.avdancedu.com/5756c48d/</id>
    <published>2021-06-23T01:56:01.186Z</published>
    <updated>2021-06-23T01:56:01.187Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来音频的3A（回音消除、降噪、自动增益）问题都是音视频实时通信中特别关键，也特别难以解决的问题。尤其是回音消除问题，更是难上加难，它就好比你向水中倒了一些墨汁，现在又想将它从水中提取出来一样困难。</p><p>对于做音视频 PaaS (提供API接口服务）的公司而言，只有将3A问题处理好，才能在音视频实时通信市场上占有一席之地，否则就没法与声网、腾讯等这些老牌或巨头公司进行竞争。正是由于3A 问题是做音视频公司必须要解决好的问题，所以它们对能够解决这类问题的人才都求贤若渴，对于想进入音视频行业的同学来说，如果你能具有3A问题的解决能力，那你一定会成为各音视频大厂挣抢的“香饽饽”。</p><p>为了让大家学到更多的干货，这次我特意邀请到拍乐云合伙人&amp;音频专家 Ark，请他为大家详细介绍在商业应用中都会遇到哪些3A问题，遇到这类问题时该如何解决，对于初入门的同学又该如何学习音频技术。相信通过这次分享，一定会让大家会收获满满。</p><p>感兴趣的小伙伴请加入讨论群, 分享时间为2021年6月30 19:45。</p><p><img data-src="https://cdn.avdancedu.com/image/article/3A/dakashuo.png" alt="音频3A经验分享群"></p><a id="more"></a><h2 id="本次分享的大体题纲如下："><a href="#本次分享的大体题纲如下：" class="headerlink" title="本次分享的大体题纲如下："></a>本次分享的大体题纲如下：</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul><li>音频的一些基本知识，音量（响度），分贝，频率、振幅与音量的关系，为什么音量是负值？</li><li>增益是指什么？它与音量大小的区别是什么？如何进行自动增益？<h3 id="降噪相关"><a href="#降噪相关" class="headerlink" title="降噪相关"></a>降噪相关</h3></li><li>什么是噪音，算法是如何判断出噪音的？</li><li>噪音是有颜色的，这是什么意思？</li><li>降噪的难点是什么？什么样的噪音不好降？</li><li>我们是否应该优先使用硬件降噪？移动端与PC端有什么区别吗？</li><li>什么是舒适噪音？为什么要增加舒适噪音？<h3 id="回音相关"><a href="#回音相关" class="headerlink" title="回音相关"></a>回音相关</h3></li><li>回音消除的难点是什么？</li><li>是否可以简要的介绍一下回音产生的一个大体原理？</li><li>机端的回音消除是否比PC端的回音更好消除一些？其中的原理是否可以比大家介绍一下？</li><li>WebRTC在回音消除方法做了哪些工作，最新的AEC3 与以前的回音消除算法有什么显著的差别？<h3 id="学习相关"><a href="#学习相关" class="headerlink" title="学习相关"></a>学习相关</h3></li><li>在解决实际3A问题时，一定要用到数学吗？</li><li>未来的技术方向</li><li>学习音频的基本路径是什么？</li><li>能否给推荐几本好书？</li></ul><h2 id="分享嘉宾"><a href="#分享嘉宾" class="headerlink" title="分享嘉宾"></a>分享嘉宾</h2><p>Ark，拍乐云合伙人&amp;音频专家。中科大硕士毕业，多年音频开发经验，5年WebEx音频专家工作经验，精通音频3A算法，深入理解实时通信音频框架，主导设计了多套音频处理框架，对于音频算法、移动端设备适配、大屏远场算法优化、智能手表音频优化等都非常了解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直以来音频的3A（回音消除、降噪、自动增益）问题都是音视频实时通信中特别关键，也特别难以解决的问题。尤其是回音消除问题，更是难上加难，它就好比你向水中倒了一些墨汁，现在又想将它从水中提取出来一样困难。&lt;/p&gt;
&lt;p&gt;对于做音视频 PaaS (提供API接口服务）的公司而言，只有将3A问题处理好，才能在音视频实时通信市场上占有一席之地，否则就没法与声网、腾讯等这些老牌或巨头公司进行竞争。正是由于3A 问题是做音视频公司必须要解决好的问题，所以它们对能够解决这类问题的人才都求贤若渴，对于想进入音视频行业的同学来说，如果你能具有3A问题的解决能力，那你一定会成为各音视频大厂挣抢的“香饽饽”。&lt;/p&gt;
&lt;p&gt;为了让大家学到更多的干货，这次我特意邀请到拍乐云合伙人&amp;amp;音频专家 Ark，请他为大家详细介绍在商业应用中都会遇到哪些3A问题，遇到这类问题时该如何解决，对于初入门的同学又该如何学习音频技术。相信通过这次分享，一定会让大家会收获满满。&lt;/p&gt;
&lt;p&gt;感兴趣的小伙伴请加入讨论群, 分享时间为2021年6月30 19:45。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://cdn.avdancedu.com/image/article/3A/dakashuo.png&quot; alt=&quot;音频3A经验分享群&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>在Windows下使用VS编译OpenCV库</title>
    <link href="https://blog.avdancedu.com/d6343897/"/>
    <id>https://blog.avdancedu.com/d6343897/</id>
    <published>2021-06-06T08:29:01.643Z</published>
    <updated>2021-06-06T08:29:01.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近发现有很多同学在学习OpenCV时，不知道该如何在Windows下编译OpenCV源码，这里我整理了一份Windows编译OpenCV的具体步聚，希望可以帮助到大家。</p><p>Windows下编译OpenCV分为四步，即：</p><ul><li>一、下载安装必要的工具</li><li>二、下载OpenCV源码</li><li>三、生成编译脚本</li><li>四、使用VS工程编译OpenCV</li></ul><a id="more"></a><h2 id="下载必要的工具"><a href="#下载必要的工具" class="headerlink" title="下载必要的工具"></a>下载必要的工具</h2><ol><li>安装python3和numpy库，<a href="https://www.python.org/ftp/python/3.9.2/python-3.9.2-amd64.exe" target="_blank" rel="noopener">下载地址：https://www.python.org/ftp/python/3.9.2/python-3.9.2-amd64.exe</a></li><li>安装 VS, 下载社区版即可，<a href="https://visualstudio.microsoft.com/zh-hans/downloads/" target="_blank" rel="noopener">下载地址： https://visualstudio.microsoft.com/zh-hans/downloads/</a></li><li>安装 cmake，<a href="https://github.com/Kitware/CMake/releases/download/v3.20.0-rc1/cmake-3.20.0-rc1-windows-x86_64.msi" target="_blank" rel="noopener">下载地址：https://github.com/Kitware/CMake/releases/download/v3.20.0-rc1/cmake-3.20.0-rc1-windows-x86_64.msi</a></li><li>下载IPPICV，<a href="https://github.com/opencv/opencv_3rdparty.git" target="_blank" rel="noopener">下载地址：https://github.com/opencv/opencv_3rdparty.git</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;opencv&#x2F;opencv_3rdparty.git</span><br></pre></td></tr></table></figure></li></ol><h2 id="下载opencv源码"><a href="#下载opencv源码" class="headerlink" title="下载opencv源码"></a>下载opencv源码</h2><ol><li><p>下载opencv源码, 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;opencv&#x2F;opencv.git</span><br></pre></td></tr></table></figure></li><li><p>下载opencv-contrib源码, 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;opencv&#x2F;opencv_contrib.git</span><br></pre></td></tr></table></figure></li></ol><h2 id="生成编译脚本"><a href="#生成编译脚本" class="headerlink" title="生成编译脚本"></a>生成编译脚本</h2><ol><li>在存放opencv源码目录中创建build目录</li><li>运行cmake</li><li>选择opencv源码目录</li><li>选择编译目录</li><li>选择CPU架构</li><li>增加opencv-contrib选项, OPENCV_EXTRA_MODULES_PATH=../opencv_contrib/modules</li><li>检查编译选项，并<ol><li>勾选 opencv_world</li><li>勾选 ffmpeg</li><li>勾选 IPPICV，这步容易出错，如果你访问不了外网的话一般会出错。可以偿试手工下载IPPICV，进行设置。</li></ol></li><li>生成编译脚本</li></ol><h2 id="使用VS编译OpenCV"><a href="#使用VS编译OpenCV" class="headerlink" title="使用VS编译OpenCV"></a>使用VS编译OpenCV</h2><ol><li>选择输出版本类型</li><li>进行编译</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在上述步骤中，第三步<strong>生成编译脚本</strong>是最容易出错的，其中第7步是导致出错的最大原因，所以在生成编译脚本时一定要仔细检查这几项是否都是OK的。</p><h2 id="我的课程"><a href="#我的课程" class="headerlink" title="我的课程"></a>我的课程</h2><p>-<a href="https://coding.imooc.com/class/496.html" target="_blank" rel="noopener">OpenCV入门与实战</a></p><p>-<a href="https://coding.imooc.com/class/415.html" target="_blank" rel="noopener">音视频系统入门</a></p><p>-<a href="https://coding.imooc.com/class/279.html" target="_blank" rel="noopener">ffmpeg精讲</a></p><p>-<a href="https://coding.imooc.com/class/329.html" target="_blank" rel="noopener">WebRTC入门与实战</a></p><p>-<a href="https://coding.imooc.com/class/387.html" target="_blank" rel="noopener">WebRTC高并发流媒体服务器</a></p><p>-<a href="https://time.geekbang.org/column/article/111337" target="_blank" rel="noopener">从0开始构造直播系统</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近发现有很多同学在学习OpenCV时，不知道该如何在Windows下编译OpenCV源码，这里我整理了一份Windows编译OpenCV的具体步聚，希望可以帮助到大家。&lt;/p&gt;
&lt;p&gt;Windows下编译OpenCV分为四步，即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一、下载安装必要的工具&lt;/li&gt;
&lt;li&gt;二、下载OpenCV源码&lt;/li&gt;
&lt;li&gt;三、生成编译脚本&lt;/li&gt;
&lt;li&gt;四、使用VS工程编译OpenCV&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>《WebRTC实时互动技术原理实战与源码分析》一书的源码</title>
    <link href="https://blog.avdancedu.com/a0a831a3/"/>
    <id>https://blog.avdancedu.com/a0a831a3/</id>
    <published>2021-03-16T13:36:40.000Z</published>
    <updated>2021-03-17T04:33:32.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="源码下截地址"><a href="#源码下截地址" class="headerlink" title="源码下截地址"></a>源码下截地址</h1><p><a href="https://avdancedu.com/download/client.tar.gz" target="_blank" rel="noopener">客户端源码下载</a><br><a href="https://avdancedu.com/download/server.tar.gz" target="_blank" rel="noopener">服务端源码下载</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;源码下截地址&quot;&gt;&lt;a href=&quot;#源码下截地址&quot; class=&quot;headerlink&quot; title=&quot;源码下截地址&quot;&gt;&lt;/a&gt;源码下截地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://avdancedu.com/download/client.tar.gz&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>深入浅出C++的function</title>
    <link href="https://blog.avdancedu.com/dabab813/"/>
    <id>https://blog.avdancedu.com/dabab813/</id>
    <published>2020-07-16T14:05:23.000Z</published>
    <updated>2020-07-17T12:02:36.411Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来聊聊C++的function。std::function是从C++11开始支持的特性，它起什么作用?又有什么好处呢？</p><a id="more"></a><h2 id="C语言中的函数指针"><a href="#C语言中的函数指针" class="headerlink" title="C语言中的函数指针"></a>C语言中的函数指针</h2><p>对C语言熟悉的同学应该都知道，C语言中有一种高级技巧叫作函数指针，我们可以让函数指针指向参数类型相同、返回值类型也相同的函数。通过函数指针我们也可以实现C++中的多态。我们来看个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*func)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, print1 \n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, print2 \n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    func fp = print1;</span><br><span class="line">    fp();</span><br><span class="line"></span><br><span class="line">    fp = print2;</span><br><span class="line">    fp();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中定义了一个函数指针<code>func</code>，它可以指向无输入参数，返回值为整型的函数。因此在main函数中，我们可以用fp(这是func类型的指针）分别指向print1和print2并调用它们。</p><p>其运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello, print1</span><br><span class="line">hello, print2</span><br></pre></td></tr></table></figure><h2 id="function的作用"><a href="#function的作用" class="headerlink" title="function的作用"></a>function的作用</h2><p>从上面的C代码中我们可以看到C函数指针的作用，那在C++中是否也类似这样的功能呢？没错function就是完成这个任务的。但std::function比C的函数指针功能更强大些或者说更适合C++中使用。</p><p>下面我们来看一下如何在C++中使用std::function实现指向不同的函数吧。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello, print1"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello, print2"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::function&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">func</span><span class="params">(&amp;print1)</span></span>;</span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    func = &amp;print2;</span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码与C函数指针一样定义了两个全局函数print1和print2。在main函数中又定义了std::function 对象 func，然后将print1和print2分别赋值给func，这样就可以达到与C语言中指针同样的功能了。</p><p>其运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello, print1</span><br><span class="line">hello, print2</span><br></pre></td></tr></table></figure><p>可以看到std::function的结果与上面C函数指针的结果是一致的，因此std::function就是C++中用来代替C函数指针的。但如果std::function只是实现上面的功能也没啥好奇怪的对吧？实际上std::function还有一个特别有意思的用法，你可以将一个重载了<strong>()</strong>操作符的对象赋值给它，这样就可以像调用函数一样使用该对象了。下面咱们就对上面的代码做下简单修改，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"This is A Object"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    A a;</span><br><span class="line">    func = a;</span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，使用<code>struct</code>定义了一个结构体，而在该结构体中重载了<strong>()</strong>操作符，因此只要你将A的类对象赋值给func，它就可以像函数一样使用了。其结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">This is A Object</span><br></pre></td></tr></table></figure><h2 id="function的实现原理"><a href="#function的实现原理" class="headerlink" title="function的实现原理"></a>function的实现原理</h2><p>是不是觉得function做的事儿还挺神奇的？它是如何实现的呢？下面我们就来扒一扒它是如何实现的。</p><p>从实现上来说，有两种办法可以实现std::function：一种是通过类的多态，即通过虚表来达到多态；另一种方法是通过C语言的函数指针来实现。今天我们只介绍通过类多态的方式来实现function，对于通过函数指针实现的方式你可以自己去研究一下。</p><p>现在我们由浅入深的来分解一下function。通过观察我们可以发现function是一个包装类，它可以接收普通函数、<strong>函数类对象</strong>(也就是实现了（）操作符的类对象）等。它是如何做到的呢？</p><p>最简单的方式就是通过类模板。我们都知道function的类模板参数是可变的，但我们为了简单，所以只实现有一个参数的function类模板。这也符合我们的目标，只是扒一下实现原理，并不是想自己去实现它。</p><p>OK，下面我们来看看该如何定义这个类模板吧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> Arg0&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span>&lt;R(Arg0)&gt; &#123;</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(Arg0 arg0)</span></span>&#123;</span><br><span class="line">           <span class="keyword">return</span> ...;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个最简单的，只有一个参数的类模板。它是 <strong>function&lt;int(int)&gt;</strong> 或 <strong>function&lt;String(int)&gt;</strong> 等格式的类模板。这样我们在外型上与标准库中的std::function类似了。</p><p>接下来我们需要思考一下，如何让我们自己实现的function可以调用不同的函数呢？从其行为上可以推理出其内部应该有一个指针，而且这个指针具有多态性。想想C++中的多态是如何实现的？通过继承和虚表对吧。所以在function内部应该有一个基类指针，所有传入到function中的函数、类函数对象等都应该是继承于该类的子类成员。除此之外，还要在<strong>()</strong>操作符前加<code>virtual</code>关键字，让它创建虚表。</p><p>了解了上面的原理后，下面我们就在自己的function中增加基类及其类的指针。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> Arg0&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span>&lt;R(Arg0)&gt; <span class="title">function</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="class"><span class="keyword">class</span> __<span class="title">callbase</span> &#123;</span></span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                <span class="function"><span class="keyword">virtual</span> R <span class="title">operator</span><span class="params">()</span><span class="params">(Arg0 arg0)</span> </span>= <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">virtual</span> ~__callbase() &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        __callbase *base_;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(Arg0 arg0)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (*__callbase)(arg0); <span class="comment">//这里调用基类对象的()操作符</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面我们就将多态中的基类实现好了，在上面的代码中最关键是的<code>operator()</code>中增加了<strong>virtual</strong>关键字，这样该函数就被放到了vtable中，后面就可以在子类中实现该方法了。下面我们来实现子类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myfunction</span>&lt;R(Arg0)&gt; <span class="title">function</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> __<span class="title">callable</span>:</span> <span class="keyword">public</span> __callbase &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                callable(F functor)</span><br><span class="line">                    : functor(functor)&#123;&#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">virtual</span> R <span class="title">operator</span><span class="params">()</span><span class="params">(Arg0 arg0)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> functor(arg0);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span>:</span><br><span class="line">                F functor;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">        myfunction(F f): base_(<span class="keyword">new</span> __callable&lt;F&gt;(f))&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~myfunction()&#123;</span><br><span class="line">            <span class="keyword">if</span>(base_) &#123;</span><br><span class="line">                <span class="keyword">delete</span> base_;</span><br><span class="line">                base_ = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在子类的实现中，核心点是增加指向赋值给function类的函数指针或函数类对象，也就是上面<code>__callable</code>类中的<strong>F functor</strong> 成员。该成员的类型是通过模板<code>template&lt;typename F&gt;</code>推导出来的。如果我们在创建function时传入的是函数，那么functor就是一个函数指针，如果我们传入的是函数类对象，则functor就是类对象。</p><p>另外你可以发现，我分别在myfunction类的构造函数和<code>__callable</code>类前定义了模板<code>F</code>，这样当我们在main函数中创建myfunction对象时，通过类型推导就可以获到F的具体类型了。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">myfunction <span class="title">myfunc</span><span class="params">(<span class="built_in">print</span>)</span></span>; <span class="comment">//通过这句可以获得F类型为函数指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了functor成员后，还需要在构造<code>__callable</code>时给functor赋值，也就是让functor指向具体的函数或函数类对象。之后重载<strong>()</strong>操作符就可以直接调用具体的函数或函数类对象了。</p><p>通过以上讲解我想你应该已经知道标准库中的function实现的基本原理了。当然我们这里实现的比较简陋，真正的实现还要考虑很多性能的问题，所以实现的要比这个复杂得多。另外标准库中的实现是通过函数指针来实现的而非通过C++的多态。</p><p>不过我们今天实现的的myfunction虽然与标准库有很多不同，但原理都是类似的，对于我们理解function已经足够了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在本文中我首先向你介绍了std::function的作用以及如何使用它，之后又苞丁解牛的实现了一个最简陋的function，主要的目的是加深你对function的理解。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">C++高阶知识：深入分析移动构造函数及其原理</a><br><a href="https://avdancedu.com/360c1c76" target="_blank" rel="noopener">聊聊C++中的完美转发</a><br><a href="https://avdancedu.com/9683d88/" target="_blank" rel="noopener">细说智能指针</a><br><a href="https://avdancedu/670ef31f/" target="_blank" rel="noopener">聊聊C++中的类型转换</a><br><a href="https://avdancedu.com/5e7916e3/" target="_blank" rel="noopener">重学C/C++中的const</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们来聊聊C++的function。std::function是从C++11开始支持的特性，它起什么作用?又有什么好处呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://blog.avdancedu.com/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="https://blog.avdancedu.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>聊聊C++中的完美转发</title>
    <link href="https://blog.avdancedu.com/360c1c76/"/>
    <id>https://blog.avdancedu.com/360c1c76/</id>
    <published>2020-07-16T05:46:39.000Z</published>
    <updated>2020-07-16T10:47:13.621Z</updated>
    
    <content type="html"><![CDATA[<p>之前我已经向你介绍了<a href="http://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">C++中的std::move</a>，它的作用是无论你传给它的是左值还是右值，通过std::move之后都变成了右值。而今天我们要介绍的std::forward则与之不同，它的作用是什么呢？</p><a id="more"></a><h2 id="forward的作用"><a href="#forward的作用" class="headerlink" title="forward的作用"></a>forward的作用</h2><p>std::forward被称为<strong>完美转发</strong>，它的作用是保持原来的<code>值</code>属性不变。啥意思呢？通俗的讲就是，如果原来的值是左值，经std::forward处理后该值还是左值；如果原来的值是右值，经std::forward处理后它还是右值。</p><p>看看下面的例子，你应该就清楚上面这句话的含义了:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T &amp; t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lvalue"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T &amp;&amp; t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rvalue"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(v);</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">std</span>::forward&lt;T&gt;(v));</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">std</span>::<span class="built_in">move</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    testForward(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"======================"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    testFoward(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，定义了两个模板函数，一个接收左值，另一个接收右值。在<code>testForward</code>函数中向模板函数<code>print</code>传入不同的参数，这样我们就可以观察出forward与move的区别了。</p><p>上面代码执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lvalue</span><br><span class="line">rvalue</span><br><span class="line">rvalue</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">lvalue</span><br><span class="line">lvalue</span><br><span class="line">rvalue</span><br></pre></td></tr></table></figure><p>从上面第一组的结果我们可以看到，传入的1虽然是右值，但经过函数传参之后它变成了左值（在内存中分配了空间）；而第二行由于使用了std::forward函数，所以不会改变它的右值属性，因此会调用参数为右值引用的print模板函数；第三行，因为std::move会将传入的参数强制转成右值，所以结果一定是右值。</p><p>再来看看第二组结果。因为x变量是左值，所以第一行一定是左值；第二行使用forward处理，它依然会让其保持左值，所以第二也是左值；最后一行使用move函数，因此一定是右值。</p><p>通过上面的例子我想你应该已经清楚forward的作用是什么了吧？</p><h2 id="forward实现原理"><a href="#forward实现原理" class="headerlink" title="forward实现原理"></a>forward实现原理</h2><p>要分析forward实现原理，我们首先来看一下forward代码实现。由于我们之前已经有了<a href="http://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">分析std::move</a>的基础，所以再来看forward代码应该不会太困难。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>forward实现了两个模板函数，一个接收左值，另一个接收右值。在上面有代码中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type</span><br></pre></td></tr></table></figure><p>的含义我们在<a href="http://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">分析std::move</a>时已经向你做了说细的说明，其作用就是获得去掉引用后的参数类型。所以在上面的两上模板函数中，第一个是左值引用模板函数，第二个是右值引用模板函数。</p><p>紧接着forward模板函数对传入的参数进行强制转换，转换的目标类型符合引用折叠规则，因此左值参数最终转换后仍为左值，右值参数最终转成右值。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们首先通一个小例子向你介绍了std::forward的作用为“完美转发”，也就是不改变原值的属性。接着我带你分析了std::forward的原码实现，如果你看过我之前对std::move的分析文章，相信你在阅读std:forward的代码实现时不会遇到什么困难。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://avdancedu.com/a39d51f9/" target="_blank" rel="noopener">C++高阶知识：深入分析移动构造函数及其原理</a><br><a href="https://avdancedu.com/9683d88/" target="_blank" rel="noopener">细说智能指针</a><br><a href="https://avdancedu/670ef31f/" target="_blank" rel="noopener">聊聊C++中的类型转换</a><br><a href="https://avdancedu.com/5e7916e3/" target="_blank" rel="noopener">重学C/C++中的const</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前我已经向你介绍了&lt;a href=&quot;http://avdancedu.com/a39d51f9/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;C++中的std::move&lt;/a&gt;，它的作用是无论你传给它的是左值还是右值，通过std::move之后都变成了右值。而今天我们要介绍的std::forward则与之不同，它的作用是什么呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://blog.avdancedu.com/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="https://blog.avdancedu.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>[转]Mac配置中文man手册</title>
    <link href="https://blog.avdancedu.com/a77533/"/>
    <id>https://blog.avdancedu.com/a77533/</id>
    <published>2020-07-11T16:29:40.000Z</published>
    <updated>2020-07-13T09:00:53.517Z</updated>
    
    <content type="html"><![CDATA[<p>转自： <a href="http://www.jackaiup.com/index/detail?id=10234" target="_blank" rel="noopener">http://www.jackaiup.com/index/detail?id=10234</a></p><p>man手册对于我们在Mac或Linux系统下开发起着至关重要的作用，今天我们就来看一下如何在Mac系统下安装Man手册。</p><a id="more"></a><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li>安装软件依赖</li><li>编译安装man手册</li><li>修改配置文件</li><li>解决乱码问题</li></ul><h2 id="软件依赖"><a href="#软件依赖" class="headerlink" title="软件依赖"></a>软件依赖</h2><ul><li>autotools (autoconf, automake)</li><li>python3</li><li>opencc 1.x</li></ul><p>可以通过homebrew自行安装:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew install autotools</span><br><span class="line">brew install python3</span><br><span class="line">brew install opencc</span><br></pre></td></tr></table></figure><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><blockquote><p>git clone  <a href="https://github.com/man-pages-zh/manpages-zh" target="_blank" rel="noopener">https://github.com/man-pages-zh/manpages-zh</a>    #下载文件<br>cd manpages-zh<br>autoreconf –install –force     #构建configure文件<br>./configure<br>make<br>make install                     #需要超级用户权限</p></blockquote><h2 id="添加手册路径"><a href="#添加手册路径" class="headerlink" title="添加手册路径"></a>添加手册路径</h2><p>打开 man 手册配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;man.conf</span><br></pre></td></tr></table></figure><p>修改配置文件，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line">MANPATH &#x2F;usr&#x2F;local&#x2F;share&#x2F;man              #line 44</span><br><span class="line">MANPATH &#x2F;usr&#x2F;local&#x2F;share&#x2F;man&#x2F;zh_CN        #添加中文手册路径</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">:wq</span><br></pre></td></tr></table></figure><p>可以通过下面的命令查看是否中文文档已经加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man -aw</span><br></pre></td></tr></table></figure><p>如果出现下面的信息表示已加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;share&#x2F;man:&#x2F;usr&#x2F;share&#x2F;man:&#x2F;usr&#x2F;local&#x2F;share&#x2F;man&#x2F;zh_CN         #已经加载</span><br></pre></td></tr></table></figure><h2 id="查看中文文档"><a href="#查看中文文档" class="headerlink" title="查看中文文档"></a>查看中文文档</h2><p>执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man -aw ls            &lt;&#x3D; 查看有几个中文文档</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;share&#x2F;man&#x2F;man1&#x2F;ls.1                 &lt;&#x3D; 默认文档</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;share&#x2F;man&#x2F;zh_CN&#x2F;man1&#x2F;ls.1     &lt;&#x3D; 中文文档</span><br></pre></td></tr></table></figure><p>查看文档内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man -a ls             &lt;&#x3D; 查看文档内容</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">LS(1)                     BSD General Commands Manual                    LS(1)</span><br><span class="line">NAME</span><br><span class="line">     ls — list directory contents</span><br><span class="line">SYNOPSIS</span><br><span class="line">     ls [-ABCFGHLOPRSTUW@abcdefghiklmnopqrstuwx1] [file ...]</span><br><span class="line">DESCRIPTION</span><br><span class="line">     For each operand that names a file of a type other than directory, ls displays its name as</span><br><span class="line">     well as any requested, associated information.  For each operand that names a file of type</span><br><span class="line">     directory, ls displays the names of files contained within that directory, as well as any</span><br><span class="line">     requested, associated information.</span><br><span class="line">     If no operands are given, the contents of the current directory are displayed.  If more than</span><br><span class="line">     one operand is given, non-directory operands are displayed first; directory and non-direc‐</span><br><span class="line">     tory operands are sorted separately and in lexicographical order.</span><br><span class="line">     The following options are available:</span><br><span class="line">     -@      Display extended attribute keys and sizes in long (-l) output.</span><br><span class="line">     -1      (The numeric digit “one”.)  Force output to be one entry per line.  This is the</span><br><span class="line">     ...</span><br><span class="line">    按【q】进入中文文档</span><br><span class="line"></span><br><span class="line">LS(1)                                General Commands Manual                                LS(1)</span><br><span class="line">NAME</span><br><span class="line">       ls, dir, vdir - 列目录内容</span><br><span class="line">提要</span><br><span class="line">       ls [选项] [文件名...]</span><br><span class="line">       POSIX 标准选项: [-CFRacdilqrtu1]</span><br><span class="line">GNU 选项 (短格式):</span><br><span class="line">       [-1abcdfgiklmnopqrstuxABCDFGLNQRSUX]  [-w  cols]  [-T  cols]  [-I  pattern]  [--full-time]</span><br><span class="line">       [--format&#x3D;&#123;long,verbose,commas,across,vertical,single-column&#125;]</span><br><span class="line">       [--sort&#x3D;&#123;none,time,size,extension&#125;]               [--time&#x3D;&#123;atime,access,use,ctime,status&#125;]</span><br><span class="line">       [--color[&#x3D;&#123;none,auto,always&#125;]] [--help] [--version] [--]</span><br><span class="line">描述（ DESCRIPTION ）</span><br><span class="line">       程序ls先列出非目录的文件项，然后是每一个目录中的“可显示”文件。如果</span><br><span class="line">       没有选项之外的参数【译注：即文件名部分为空】出现，缺省为   &quot;.&quot;   （当前目录）。  选项“  -d</span><br><span class="line">       ”使得目录与非目录项同样对待。除非“ -a ” 选项出现，文 件名以“.”开始的文件不属“可显示”文件。</span><br><span class="line">       以当前目录为准，每一组文件（包括非目录文件项，以及每一内含文件的目录）分</span><br><span class="line">       别按文件名比较顺序排序。如果“-l”选项存在，每组文件前显示一摘要行:</span><br><span class="line">       ...</span><br><span class="line">【注】默认进入英文文档，按【q】可进入中文文档，再次按【q】则退出文档</span><br></pre></td></tr></table></figure><h2 id="解决乱码"><a href="#解决乱码" class="headerlink" title="解决乱码"></a>解决乱码</h2><p>如果系统的groff版本太低，文档可能出现乱码，可以将groff更新到最新版本（1.22.3，可能的话请使用尚未发布的 1.22.4）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install groff</span><br></pre></td></tr></table></figure><p>安装完成后，配置man.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;man.conf</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">#修改NROFF配置如下（将UTF8编码的MAN页面通过转码而被groff识别）</span><br><span class="line">#line 95</span><br><span class="line"></span><br><span class="line">NROFF preconv -e utf8 | &#x2F;usr&#x2F;local&#x2F;bin&#x2F;groff -Wall -mtty-char -Tutf8 -mandoc -c</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">#修改PAGER配置如下（这样可以避免MAN手册页面中的ANSI Escape字符序列干扰（用于控制显示粗体等格式））</span><br><span class="line">#line 106</span><br><span class="line"></span><br><span class="line">PAGER &#x2F;usr&#x2F;bin&#x2F;less -isR</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">:wq</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自： &lt;a href=&quot;http://www.jackaiup.com/index/detail?id=10234&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.jackaiup.com/index/detail?id=10234&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;man手册对于我们在Mac或Linux系统下开发起着至关重要的作用，今天我们就来看一下如何在Mac系统下安装Man手册。&lt;/p&gt;
    
    </summary>
    
    
      <category term="man" scheme="https://blog.avdancedu.com/categories/man/"/>
    
    
      <category term="man" scheme="https://blog.avdancedu.com/tags/man/"/>
    
  </entry>
  
</feed>
